{"TopicId":214762,"ForumId":136,"TopicTitle":"Performance Improvements","CreatedByName":"777aker","CreatedById":227579,"CreatedDateTime":"2023-03-08T23:38:06Z","PageNum":1,"Articles":[{"CreatedByName":"777aker","CreatedById":227579,"CreatedDateTime":"2023-03-08T23:38:06Z","Content":"\n\u003Cp\u003E\nI suggested performance improvements to kerbal space program support, and they requested I post it here because they thought it would greatly help the developers.\n\u003C/p\u003E\n\u003Cp\u003E\nFirst off, I love KSP2 and think it\u0027s a great game. Y\u0027all added a lot of features I really appreciate, like procedural wings, coloring (man do I love coloring), and the \u003Cabbr title=\u0022Stability Augmentation System\u0022\u003ESAS\u003C/abbr\u003E control and UI I like so much more. I\u0027m also really excited for all the features in the roadmap.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nSecondly, I\u0027ll say what I believe to be true and what you should do working off of those assumptions. I don\u0027t mean to sound pretentious, just writing this because I want to help if at all possible. I could also be completely wrong because I don\u0027t have that much experience.\u00A0 I believe if you knew all this though, you wouldn\u0027t be having the performance issues you\u0027re currently having, but I could be wrong. If my assumptions are wrong then my suggestions won\u0027t help much either.\n\u003C/p\u003E\n\u003Cp\u003E\nMy assumptions: KSP2 is currently built in Unity, which uses PhysX engine for its physics, which is really good for collision detection, but only that. Therefore, your structure is probably something along the lines of every part is a prefab, players then are basically dragging prefabs to build a ship that is then loaded into the world. These prefabs probably all inherit from some part class that handles gravity, joint force, and aerodynamics. Then fuel tanks and engines (where you\u0027re currently having performance issues when users add several) have additional scripts handling fuel and force application. This is probably all within FixedUpdate, which is called serially. This means that every single part is executing its script on the main thread sequentially, which is why some computers with good single CPUs instead of multicore CPUs are performing well. However, most modern CPUs are built with multiple cores and threading in mind because of how much more efficient it is. This doesn\u0027t matter though, because Unity\u0027s APIs aren\u0027t thread safe and prevent multithreading. Final assumption, you\u0027re not using the GPU for a lot of your calculations.\n\u003C/p\u003E\n\u003Cp\u003E\nWhere I believe you can go from here working off of those assumptions: It\u0027s kind of infeasible to just improve performance.\u00A0 Like sure, you can make your functions better, but only so much better, and there are some calculations you just have to perform. Once you get to colonization you also get ridiculously large structures and physics. Unity may not support multithreading (which honestly at a colony part level won\u0027t help too much), but it does support compute shaders which would allow you to perform a massive amount of calculations very quickly. For most of your parts you probably have the same function, just different inputs depending on the size and shapes. Then engines probably all have the same script that handles fuel consumption, just different thrust and ISPs, which is perfect for compute shaders, which are really good at performing the same function with different inputs in parallel. Unity even allows you to pass structs to the compute shader, which means each part could be simplified to a struct of its various variables, and then sent to the compute shader. Each block of the compute shader could be a different function / calculation, i.e. aerodynamics, gravity, fuel consumption, and each thread a different part (or be really fancy and use textures for input output through rgba values). Meaning most modern computers will be able to handle 1024 parts at the exact same rate as 1 part, because most have about 1024 threads. Worst case scenario you only get 512 parts, but even so Unity\u0027s compute shaders allow for a third dimension which means expanding beyond 1024/512 parts is simple. Or if you don\u0027t have a GPU, it will default to the fastest device which will be your CPU and now you\u0027ve threaded it since CPUs just simulate the GPU and thread if there isn\u0027t one. Basically, any where you have for loops, double for loops, or scripts on every part that perform the same calculation, you could probably offload to the GPU to increase performance.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nConcerns:\n\u003C/p\u003E\n\u003Cp\u003E\n- GPUs are slower. Yes. But if you have 1000 calculations and the CPU runs 3 times as fast (approximately maybe), the GPU does all 1000 calculations in 3 CPU time, because they are parallel. The CPU does 1000/3 = 333, which is a much bigger number than 3.\n\u003C/p\u003E\n\u003Cp\u003E\n- GPU answers are a large array you\u0027d have to loop through on the CPU anyway. Just do thread reduction.\n\u003C/p\u003E\n\u003Cp\u003E\n- It\u0027ll slow down rendering since we\u0027re using the GPU now. Well, rendering waits for the CPU calculations, and your structure would look something like this CPU (initial calculations and storage) -\u0026gt; GPU (parallel calculations) -\u0026gt; CPU (handle those calculations and store them for the next frame) -\u0026gt; GPU (render).\u00A0 Besides, slower rendering doesn\u0027t really matter if your calculations are the bottleneck.\n\u003C/p\u003E\n\u003Cp\u003E\n- You don\u0027t have that many parts. Yea, actually the GPU is worse for if you only have like 10 calculations. Best I\u0027d say is if you reach a threshold offload to GPU otherwise use CPU. But I imagine for colonization you will have to use the GPU.\n\u003C/p\u003E\n\u003Cp\u003E\nI have two examples, one using CUDA, the other a compute shader to prove how many calculations you can achieve. The compute shader performs collisions, collision reaction, and gravitational constants (which are bad for the GPU since there\u0027s a cube and a square root involved in the calculation)\u00A0 1.04 e10 (like 10 billion ish) times a second (10 blocks of 1024 threads that have a for loop going over all 10240 objects at an average of 100 fps - given, I took a lot of shortcuts to make it stupid efficient which you won\u0027t exactly be able to do in Unity.\u00A0 10 * 1024 * 10240 * 100). The CUDA program is the same principles as the compute shader wince it runs on a GPU, but the CUDA program has a reduction implementation that\u0027s quite simple since it\u0027s only thread reduction. It performs about 20,000,000 calculations in .3 seconds. If you partition each function onto a block you can do the block reduction on the CPU since block reduction is difficult and can be risky.\u00A0 You have to go back to the CPU anyway to store the information for later frames, and looping over blocks isn\u0027t going to be that long of a task. Both of these examples are using OpenGL and C, but Unity\u0027s compute shaders are pretty easy to use and comparable in principle, just use HLSL instead of GLSL.\n\u003C/p\u003E\n\u003Cp\u003E\nI have the repositories for the two examples but don\u0027t particularly won\u0027t to blast my personal information so if requested I\u0027ll send links to them (they have my name and some info and such).\n\u003C/p\u003E\n\u003Cp\u003E\nI hope this is helpful and you didn\u0027t already know all of this and I just sound like a jerk. I think that with great performance nobody cares as much about bugs since they can just immediately restart and not be waiting 10 minutes to see results again. I think performance is especially important since you want to make science accessible to everyone, and most people not properly exposed to science don\u0027t have modern hardware. I\u0027d also be happy to talk through some questions or concerns if you have any.\n\u003C/p\u003E\n\u003Cp\u003E\nThank you for your time.\n\u003C/p\u003E\n"},{"CreatedByName":"Cosmus","CreatedById":227070,"CreatedDateTime":"2023-03-09T23:47:07Z","Content":"\n\u003Cp\u003E\nI like your perspective. In your opinion, was Unity a good choice for a game like KSP?\n\u003C/p\u003E\n"},{"CreatedByName":"jaggaaff_","CreatedById":227435,"CreatedDateTime":"2023-03-10T04:20:53Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00224255841\u0022 data-ipsquote-contentid=\u0022214762\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221678405627\u0022 data-ipsquote-userid=\u0022227070\u0022 data-ipsquote-username=\u0022Cosmus\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n4 hours ago, Cosmus said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nI like your perspective. In your opinion, was Unity a good choice for a game like KSP?\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nI don\u0027t think Unity was a good choice for KSP2 or at least i think there were better choices for KSP2\n\u003C/p\u003E\n"},{"CreatedByName":"777aker","CreatedById":227579,"CreatedDateTime":"2023-03-11T08:42:43Z","Content":"\n\u003Cp\u003E\nHonestly, I think they shouldn\u0027t have used any game engine. The only nice thing about game engines is the built in tools that make development easier, but unity isn\u0027t built for a physics simulation. No game engine is really. They\u0027re just building something very unique so rather than helping them by providing them with nice tools a game engine is just holding them back. It means performance is worse and they have to do a lot of work arounds to get the systems they want in place.\n\u003C/p\u003E\n"}]}