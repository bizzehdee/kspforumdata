{"TopicId":8000,"ForumId":29,"TopicTitle":"Community Helm Control Management API Discussion","CreatedByName":"N3X15","CreatedById":12073,"CreatedDateTime":"2012-03-11T22:46:53Z","PageNum":1,"Articles":[{"CreatedByName":"N3X15","CreatedById":12073,"CreatedDateTime":"2012-03-11T22:46:53Z","Content":"\n\u003Cp\u003EWe\\\u0027re beginning to run into problems where guidance computers are interfering with each other and throwing the ship into wild spirals (see: dodADA \u002B MechJeb, Ascent Computer \u002B MechJeb, etc).\u003C/p\u003E\u003Cp\u003ESo, I propose we come together to find a common way to communicate that a Part has the helm, so to speak. This would need to operate on a Vessel-by-Vessel basis. Anything I mention here is just an idea I\\\u0027m throwing out for feedback, none of this is set in stone. This would also probably be a third-party library that all participating parts would reference and use.\u003C/p\u003E\u003Cp\u003EMy idea would be to have a class named HelmManager or something with the following public members:\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EMETHODS\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003E\u003Cbr\u003E[li]static boolean RequestHelm(Part yourPart) - Returns true and sets the part as the active helm handler if no other Parts are using the helm in the specified parent vessel (e.g. in Manual); also triggers HelmControlRequested event.[/li]\u003Cbr\u003E[li]static void ReleaseHelm(Part yourPart) - Releases helm control, triggers HelmReleased event.[/li]\u003Cbr\u003E[li]static void DemandHelm(Part yourPart) - Sets helm control to that part (should only be used if it\\\u0027s absolutely mission-critical, or on user input, such as pressing an on button). Triggers HelmControlDemanded event.[/li]\u003Cbr\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EEVENTS\u003C/strong\u003E (Listed as delegate method signatures)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003E\u003Cbr\u003E[li]boolean HelmControlRequested(Part requestingPart, Part currentPart) - return false to deny access to helm (e.g. when an a descent computer is in the middle of landing)[/li]\u003Cbr\u003E[li]void HelmControlReleased(Part releasingPart) - Might be used to re-request helm control for some parts.[/li]\u003Cbr\u003E[li]void HelmControlDemanded(Part demandingPart) - A courtesy note sent when an AI mutiny occurs and results in a helm control change.[/li]\u003Cbr\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe sequence would be to RequestHelm when your part is \u0027turned on\u0027. Then, when it\\\u0027s done, just ReleaseHelm. If another part wants access, you can either yield control (and turn off) or tell it to bugger off if you\\\u0027re in the middle of something important. \u003C/p\u003E\u003Cp\u003EWhat are your ideas?\u003C/p\u003E\n"},{"CreatedByName":"Warringer","CreatedById":328,"CreatedDateTime":"2012-03-11T22:56:20Z","Content":"\n\u003Cp\u003EI fully support this product and/or service.\u003C/p\u003E\u003Cp\u003EEDIT:\u003C/p\u003E\u003Cp\u003EA thought...\u003C/p\u003E\u003Cp\u003ESuch an API would be good to have with any plugin requesting the use of a key, as its perfectly possible that multiple plugins request the use of the same key.\u003C/p\u003E\u003Cp\u003EWould be bad if pressing one key activates the self destruct, while you just wanted to extend the solar panels.\u003C/p\u003E\n"},{"CreatedByName":"The_Duck","CreatedById":1156,"CreatedDateTime":"2012-03-12T01:39:59Z","Content":"\n\u003Cp\u003EI\\\u0027m happy to implement something like this in my ascent autopilot if it would be useful. I think in addition we need a method that will tell you which part has the helm, so that we can put an if(HelmManager.atHelm() == this) {} around our code that manipulates flight controls. Or is the idea that we just tell the HelmManager what our fly-by-wire function is and the HelmManager calls it each frame if we have the helm?\u003C/p\u003E\u003Cp\u003EI confess I haven\\\u0027t really tried out any of the other guidance computers so I\\\u0027m not sure when these problems are occurring. Under what circumstances are people trying to use multiple guidance computers at once?\u003C/p\u003E\n"},{"CreatedByName":"Quinton","CreatedById":18391,"CreatedDateTime":"2012-03-12T01:59:28Z","Content":"\n\u003Cp\u003EMaybe step back a level and associate a set of key/value pairs with each Vessel that Parts could use to coordinate state (this is probably a good feature request for the KSP developers for future versions, but could be mocked up now).\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-03-12T02:21:26Z","Content":"\n\u003Cp\u003EThis is just a particular example of a much larger problem that KSP is ill-suited to handle (in its current state): event priorities.\u003C/p\u003E\u003Cp\u003EIt\\\u0027s difficult to predict all the different types of input that parts might handle. Autopilots? Stabilizers? Some in-between? What happens when more than one part demands the helm? What if a stabilizer and an auto-lander both consider themselves to be more important than the other, and thus nobody gets helm control? Your proposed setup essentially defers the problem to a later place in the code, but the fundamental problem is still there.\u003C/p\u003E\u003Cp\u003EPerhaps a better way to solve this might be to stack modules when determining inputs. By default, there is always one entry: the player. Most plugins will probably want to give the player the last word, but some might act as stabilizers and \u0027soften\u0027 the player\\\u0027s input. This should be an option. An auto-lander will certainly want control, but some stabilizers might want to \u0027filter\u0027 its controls to soften the descent.\u003C/p\u003E\u003Cp\u003EThere\\\u0027s nothing we can do to prevent poorly-designed plugins from completely interfering with others, but you can at least establish a \u0027best practice\u0027 where each plugin is allowed to see the inputs of each plugin which came before it and adjust as necessary. Establish some categories where plugins can register themselves. Such a framework might even warn the user when multiple high-level autopilots are mounted on the ship.\u003C/p\u003E\n"},{"CreatedByName":"Quinton","CreatedById":18391,"CreatedDateTime":"2012-03-12T02:42:37Z","Content":"\n\u003Cp\u003EIn keeping with the finest Kerbal Engineering Practices, allowing three or five entirely different autopilots to vote (or perhaps argue) over the correct control inputs seems reasonable...\u003C/p\u003E\n"},{"CreatedByName":"nivvydaskrl","CreatedById":6789,"CreatedDateTime":"2012-03-12T13:16:45Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EThis is just a particular example of a much larger problem that KSP is ill-suited to handle (in its current state): event priorities.\u003Cp\u003EIt\\\u0027s difficult to predict all the different types of input that parts might handle. Autopilots? Stabilizers? Some in-between? What happens when more than one part demands the helm? What if a stabilizer and an auto-lander both consider themselves to be more important than the other, and thus nobody gets helm control? Your proposed setup essentially defers the problem to a later place in the code, but the fundamental problem is still there.\u003C/p\u003E\u003Cp\u003EPerhaps a better way to solve this might be to stack modules when determining inputs. By default, there is always one entry: the player. Most plugins will probably want to give the player the last word, but some might act as stabilizers and \u0027soften\u0027 the player\\\u0027s input. This should be an option. An auto-lander will certainly want control, but some stabilizers might want to \u0027filter\u0027 its controls to soften the descent.\u003C/p\u003E\u003Cp\u003EThere\\\u0027s nothing we can do to prevent poorly-designed plugins from completely interfering with others, but you can at least establish a \u0027best practice\u0027 where each plugin is allowed to see the inputs of each plugin which came before it and adjust as necessary. Establish some categories where plugins can register themselves. Such a framework might even warn the user when multiple high-level autopilots are mounted on the ship.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Ca href=\u0022https://en.wikipedia.org/wiki/Subsumption_architecture\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://en.wikipedia.org/wiki/Subsumption_architecture\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EMost of the autopilots currently in existance are reactive systems -- they follow very basic behaviors (in AI terms) based on various stimuli (user input and/or variables in the environment such as altitude, etc).\u003C/p\u003E\u003Cp\u003EI might recommend a plugin which allows the user to define which behaviors subsume, or take priority, over the others. It would identify all plugin-enabled parts on the rocket, and the user would check-mark which ones are actually autopilots. Then they\\\u0027d assign each autopilot a priority number and -- through some form of witchcraft (or by dropping in an overload which redirects the ship control interface to the autopilot subsumption manager [???]) -- only permits calls from lower-priority autopilots if a higher-priority autopilot hasn\\\u0027t issued a command to the rocket for some user-defined period of time.\u003C/p\u003E\n"},{"CreatedByName":"Drakomis","CreatedById":6549,"CreatedDateTime":"2012-03-12T15:20:26Z","Content":"\n\u003Cp\u003EYou know, just a thought, but perhaps you could implement a menu system for your parts that all has enable/disable features to \u003Cstrong\u003Enot\u003C/strong\u003E interfere until we get something to assist with part collaboration?\u003C/p\u003E\n"},{"CreatedByName":"dodrian","CreatedById":12564,"CreatedDateTime":"2012-03-12T17:56:30Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Drakomis\u0022 data-cite=\u0022Drakomis\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EYou know, just a thought, but perhaps you could implement a menu system for your parts that all has enable/disable features to \u003Cstrong\u003Enot\u003C/strong\u003E interfere until we get something to assist with part collaboration?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EMy part currently works only on user input (pressing a button, but I hope to add a GUI which makes it easier to turn off/on in the next version), and the user always have the option of overriding the helm control (by turning it off). When off, dodADA shouldn\\\u0027t interfere with other autopilots at all (if it does then there\\\u0027s a bug in my code somewhere, or I\\\u0027ve misunderstood how the whole system works).\u003C/p\u003E\u003Cp\u003EIf other developers felt we needed to add a helm-control system, I would implement it in my plugins, but I don\\\u0027t see it as necessary for what my part is designed to do (control the helm, but only when the user asks it to).\u003C/p\u003E\u003Cp\u003EMaybe this would become necessary for parts that are designed to fully-automate an entire mission, but at the moment that\\\u0027s not happening.\u003C/p\u003E\u003Cp\u003EA discussion I think maybe we should have though, is about namespaces, as I\\\u0027m pretty sure I\\\u0027m not the only one who will write a class called \\\u0027FlightComputer\\\u0027 \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E (I\\\u0027ll be calling it \\\u0027dodFlightComputer\\\u0027 in the next release).\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-03-12T18:02:06Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022dodrian\u0022 data-cite=\u0022dodrian\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EA discussion I think maybe we should have though, is about namespaces, as I\\\u0027m pretty sure I\\\u0027m not the only one who will write a class called \\\u0027FlightComputer\\\u0027 \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E (I\\\u0027ll be calling it \\\u0027dodFlightComputer\\\u0027 in the next release).\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou can do something like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E// reference this class in your part.cfg\u003Cbr\u003Epublic class DodrianFlightComputerPartClass : Dodrian.FlightComputer { }\u003Cbr\u003E\u003Cbr\u003Enamespace Dodrian {\u003Cbr\u003E  public class FlightComputer : global::Part {\u003Cbr\u003E    // put your class code here\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  // put other namespace classes here\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"Meatsauce","CreatedById":4499,"CreatedDateTime":"2012-03-19T14:54:07Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Quinton\u0022 data-cite=\u0022Quinton\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EIn keeping with the finest Kerbal Engineering Practices, allowing three or five entirely different autopilots to vote (or perhaps argue) over the correct control inputs seems reasonable...\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EOnly if the one determined to have priority overheats and explodes. \u003C/p\u003E\n"},{"CreatedByName":"thorfinn","CreatedById":8349,"CreatedDateTime":"2012-03-19T15:49:09Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Majiir\u0022 data-cite=\u0022Majiir\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EThere\\\u0027s nothing we can do to prevent poorly-designed plugins from completely interfering with others, but you can at least establish a \u0027best practice\u0027 where each plugin is allowed to see the inputs of each plugin which came before it and adjust as necessary. Establish some categories where plugins can register themselves. Such a framework might even warn the user when multiple high-level autopilots are mounted on the ship.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ESomething like the old TSR programs in DOS, and interrupt hooking? Seems like a good idea.\u003C/p\u003E\u003Cp\u003EIt would basically require a way to define the order of startup of the various plugins, and an interface to flight commands that is \u0027passed\u0027 (more or less literally) between them. Those who have delved into KSP internals have ideas about how to implement this?\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Quinton\u0022 data-cite=\u0022Quinton\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EIn keeping with the finest Kerbal Engineering Practices, allowing three or five entirely different autopilots to vote (or perhaps argue) over the correct control inputs seems reasonable...\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv style=\u0022text-align:center;\u0022\u003E\u003Cimg src=\u0022http://img171.imageshack.us/img171/4772/senzanomenl.png\u0022 alt=\u0022senzanomenl.png\u0022\u003E\u003C/div\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"comradephil","CreatedById":2791,"CreatedDateTime":"2012-03-19T23:06:46Z","Content":"\n\u003Cp\u003EBest idea I\\\u0027ve seen all day/\u003C/p\u003E\n"},{"CreatedByName":"gresrun","CreatedById":17883,"CreatedDateTime":"2012-03-19T23:21:29Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003ESomething like the old TSR programs in DOS, and interrupt hooking? Seems like a good idea.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EOr a more modern example of this pattern is Java\\\u0027s Servlet FilterChain: \u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cimg src=\u0022http://onjava.com/onjava/2003/11/19/graphics/tfessh-pic-1.gif\u0022 alt=\u0022tfessh-pic-1.gif\u0022\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EOr JavaScript\\\u0027s DOM event chain: \u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cimg src=\u0022http://www.guistuff.com/javascript/images/events_a.png\u0022 alt=\u0022events_a.png\u0022\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EEach Flight Controller would implement an interface:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Einterface FlightController {\u003Cbr\u003E\tprotected void handleEvent(Event e, FlightContollerChain chain);\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EFlight Controllers can then do whatever they need to do in handleEvent() and can optionally invoke FlightContollerChain.proceed(Event) to let downstream Flight Controllers have a chance to handle the event. E.g.:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Epublic class SharingFlightController : FlightController {\u003Cbr\u003E\tprotected void handleEvent(Event e, FlightContollerChain chain) {\u003Cbr\u003E\t\tConsole.WriteLine(\u0027Before downstream FlightContollers are invoked: event=\u0027 \u002B event);\u003Cbr\u003E\t\tchain.proceed(e);\u003Cbr\u003E\t\tConsole.WriteLine(\u0027After downstream FlightControllers are invoked because I like to share\u0027);\u003Cbr\u003E\t}\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Epublic class SelfishFlightController : FlightController {\u003Cbr\u003E\tprotected void handleEvent(Event e, EventChain chain) {\u003Cbr\u003E\t\tConsole.WriteLine(\u0027Before downstream FlightContollers: event=\u0027 \u002B event);\u003Cbr\u003E\t\t//chain.proceed(e);\u003Cbr\u003E\t\tConsole.WriteLine(\u0027Downstream FlightControllers never invoked because I got this...\u0027);\u003Cbr\u003E\t}\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe only trick is setting up the order of the Flight Controllers; do we let the user define/adjust the order?\u003C/p\u003E\n"},{"CreatedByName":"thorfinn","CreatedById":8349,"CreatedDateTime":"2012-03-19T23:47:45Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022gresrun\u0022 data-cite=\u0022gresrun\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EThe only trick is setting up the order of the Flight Controllers; do we let the user define/adjust the order?\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWell, I see two. Correct me if I\\\u0027m wrong.\u003C/p\u003E\u003Cp\u003ETrick 1: what builds the chain of handlers? Seems like a meta-plugin would be required (that reads a list of names off its cfg?)\u003C/p\u003E\u003Cp\u003ETrick 2: The chain nees to pass not just the event, but the command vectors calculated by the previous elements of the chain, and each handler should implement some sort of blending of its decisions with the previous ones. This isn\\\u0027t trivial, and it\\\u0027s a bit more complex than the way current autopilots work.\u003C/p\u003E\u003Cp\u003E(I suppose the state vectors are available to everything directly)\u003C/p\u003E\n"},{"CreatedByName":"togfox","CreatedById":17083,"CreatedDateTime":"2012-03-19T23:48:10Z","Content":"\n\u003Cp\u003EGreat topic. Can I suggest, as best practice, that helm components start or initialise in the OFF position. This will prevent half a dozen components all turning themselves on at the same time (upon vessel load) and then who actually has the helm becomes blurred. Avoid the deadlock, start off, and let the pilot determine priorities.\u003C/p\u003E\n"}]}