{"TopicId":16405,"ForumId":20,"TopicTitle":"MechJeb Autom8 Scripts Megathread","CreatedByName":"r4m0n","CreatedById":5404,"CreatedDateTime":"2012-08-08T23:57:23Z","PageNum":6,"Articles":[{"CreatedByName":"sal_vager","CreatedById":16426,"CreatedDateTime":"2012-09-09T17:20:29Z","Content":"\n\u003Cp\u003EIf your file extensions are hidden by default, then you should now have a filename.lua.txt\u003C/p\u003E\u003Cp\u003EEither disable hiding of common file extensions or try right clicking the file and selecting \u0022properties\u0022, you should then see the whole file name plus the extension and be able to change it.\u003C/p\u003E\u003Cp\u003EAlso, .lua is a text file in a sense, the code is in a human readable form, just formatted so the lua interpreter can read it, \u003Ca href=\u0022https://en.wikipedia.org/wiki/Lua_%28programming_language%29\u0022 rel=\u0022external nofollow\u0022\u003Esee here for details\u003C/a\u003E.\u003C/p\u003E\n"},{"CreatedByName":"TwiggyShip","CreatedById":46352,"CreatedDateTime":"2012-09-09T17:44:31Z","Content":"\n\u003Cp\u003EPretty sure that\u0027s fixed it. Thanks!\u003C/p\u003E\n"},{"CreatedByName":"Nadrek","CreatedById":25326,"CreatedDateTime":"2012-09-09T20:06:42Z","Content":"\n\u003Cp\u003EBased on further experimentation, here\u0027s additional information on the vector based mechjeb.attitudeTo, for those planning to terrify their kerbals during more complex orbital manuevers with Mechjeb\u0027s Autom8:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Emechjeb.attitudeTo({x,0,0},\u0022ORBIT\u0022)\u003Cbr\u003E  ?Where x \u0026lt; 0, NML\u002B\u003Cbr\u003E  ?Where x \u0026gt; 0, NML-\u003Cbr\u003Emechjeb.attitudeTo({0,x,0},\u0022ORBIT\u0022)\u003Cbr\u003E  ?Where x \u0026lt; 0, RAD- (to body)\u003Cbr\u003E  ?Where x \u0026gt; 0, RAD\u002B (Away from body)\u003Cbr\u003Emechjeb.attitudeTo({0,0,x},\u0022ORBIT\u0022)\u003Cbr\u003E  Where x \u0026lt; 0, RETROGRADE\u003Cbr\u003E  Where x \u0026gt; 0, DIRECT (PROGRADE)\u003Cbr\u003E\u003Cbr\u003Emechjeb.attitudeTo({x,0,0},\u0022INERTIAL\u0022)\u003Cbr\u003E  ?Where x \u0026lt; 0, ??\u003Cbr\u003E  ?Where x \u0026gt; 0, ??\u003Cbr\u003Emechjeb.attitudeTo({0,x,0},\u0022INERTIAL\u0022)\u003Cbr\u003E  ?Where x \u0026lt; 0, ??\u003Cbr\u003E  ?Where x \u0026gt; 0, ??\u003Cbr\u003Emechjeb.attitudeTo({0,0,x},\u0022INERTIAL\u0022)\u003Cbr\u003E  Where x \u0026lt; 0, ??\u003Cbr\u003E  Where x \u0026gt; 0, ??\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-12T05:08:01Z","Content":"\n\u003Cp\u003EAre all the functions required to automatically rendezvous with another craft available?\u003C/p\u003E\u003Cp\u003EOff the top of my head, you\u0027d need a way to do the following:\u003C/p\u003E\u003Cp\u003E- [launch or get into] a (preferably) lower orbit, preferably in the same plane, but if not...\u003C/p\u003E\u003Cp\u003E- Align planes (matching both LAN and inclination)\u003C/p\u003E\u003Cp\u003E- Align lines of apsides (make apoapsis and periapsis line up correctly)\u003C/p\u003E\u003Cp\u003E- Catch up (get the craft close enough, preferably \u0026lt; 1 km)\u003C/p\u003E\u003Cp\u003E- Transfer to target\u0027s orbit (aka match velocity aka insertion burn)\u003C/p\u003E\u003Cp\u003EI imagine the hard parts would be aligning planes and lining up the apsides (since I haven\u0027t noticed any mechjeb functions that do those automatically yet), but I don\u0027t know if those functions actually exist yet.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222012-09-12T10:16:14Z\u0022 title=\u002209/12/2012 10:16  AM\u0022 data-short=\u002211 yr\u0022\u003ESeptember 12, 2012\u003C/time\u003E by Peewee\u003C/strong\u003E\n\u003Cbr\u003Efigured out post #121, removed mention of manual param input\n\u003C/span\u003E\n"},{"CreatedByName":"togfox","CreatedById":17083,"CreatedDateTime":"2012-09-12T06:47:32Z","Content":"\n\u003Cp\u003EInteresting challenge. Ill look into this one as its somethig id use myself. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-12T10:51:04Z","Content":"\n\u003Cp\u003E\u003Cspan style=\u0022text-decoration:line-through;\u0022\u003EHm, I don\u0027t understand how mechjeb\u0027s Autom8 lua thing actually works. Is there a way to use \u0022FindAn(orbit, tgttorbit)\u0022 (in OrbitExtensions.cs when looking through the source) in a lua script, or would I have to do the math myself?\u003C/span\u003E\u003C/p\u003E\u003Cp\u003EDerp, figured out previous problem. Sorry for anyone trying to follow my problems, but make sure you have a target selected before trying to use \u0027mechjeb.core.targetVessel\u0027.\u003C/p\u003E\u003Cp\u003EAlso, the varying interfaces for mechjeb.core.target* and vessel.* are driving me nuts. \u003C/p\u003E\u003Cp\u003Eexample:\u003C/p\u003E\u003Cp\u003Emechjeb.core.targetVessel.orbit.inclination\u003C/p\u003E\u003Cp\u003Evs\u003C/p\u003E\u003Cp\u003Evessel.orbitInclination\u003C/p\u003E\u003Cp\u003EAlso, put a space between while and ( due to LuaSharp being buggy.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222012-09-13T13:05:08Z\u0022 title=\u002209/13/2012 01:05  PM\u0022 data-short=\u002211 yr\u0022\u003ESeptember 13, 2012\u003C/time\u003E by Peewee\u003C/strong\u003E\n\u003Cbr\u003EAdding an also every time I get stuck learning lua and figure it out\n\u003C/span\u003E\n"},{"CreatedByName":"Nadrek","CreatedById":25326,"CreatedDateTime":"2012-09-15T03:10:03Z","Content":"\n\u003Cp\u003EDo not despair! It appears that\u003C/p\u003E\u003Cp\u003Emechjeb.core.targetVessel\u003C/p\u003E\u003Cp\u003Emechjeb.core.targetBody\u003C/p\u003E\u003Cp\u003Emechjeb.core.part.vessel\u003C/p\u003E\u003Cp\u003E .orbit\u003C/p\u003E\u003Cp\u003E .referenceBody\u003C/p\u003E\u003Cp\u003Elocal Orbits = script.call(\u0022Planetarium.Orbits\u0022)\u003C/p\u003E\u003Cp\u003E Orbits\u003Cem\u003E.\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003Eare all direct interfaces to the KSP mod system, while\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003Evessel.\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003E is an abstraction layer/interface/wrapper that the Mechjeb team wrote for the Autom8 module. Thus, there is choice inherent in the system - choose the Autom8 abstraction, which is more limited but which is, I suspect, more likely to remain consistent version to version, or choose the more direct KSP interface, which is fuller featured, but more likely to change (and, apparently, nearly completely undocumented as far as I can tell - I\u0027m adding what I find to the SimpleKSPOrbitalOperations.lua file, and to this thread).\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003EAlso, what was the answer to FindAn(orbit, tgttorbit) - can you post sample code, please, so we can all learn more?\u003C/em\u003E\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-15T06:27:29Z","Content":"\n\u003Cp\u003EAs far as I can tell, you have to do the math yourself.\u003C/p\u003E\u003Cp\u003EFrom OrbitExtensions.cs:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E        /// \u0026lt;summary\u0026gt;\u003Cbr\u003E        /// Finds the coordinates of a state vector.\u003Cbr\u003E        /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E        /// \u0026lt;returns\u0026gt;\u003Cbr\u003E        /// Double[] {lattitude, longitude}\u003Cbr\u003E        /// \u0026lt;/returns\u0026gt;\u003Cbr\u003E        /// \u0026lt;param name=\u0027vinput\u0027\u0026gt;\u003Cbr\u003E        /// State vector\u003Cbr\u003E        /// \u0026lt;/param\u0026gt;\u003Cbr\u003E        public static double[] LatLonofVector(Vector3d vinput)\u003Cbr\u003E        {\u003Cbr\u003E            //get the geocentric latitude and longitude of a orbital element vector\u003Cbr\u003E            double rad = Math.PI/180;\u003Cbr\u003E            double c1 = vinput.x;\u003Cbr\u003E            double c2 = vinput.y;\u003Cbr\u003E            double c3 = vinput.z;\u003Cbr\u003E            double lon = 0;\u003Cbr\u003E\u003Cbr\u003E            double lat = Math.Atan(c3/Math.Pow((c1*c1) \u002B (c2*c2), .5))/rad;\u003Cbr\u003E            if (c1 \u0026lt; 0)\u003Cbr\u003E            {\u003Cbr\u003E                lon = (Math.Atan(c2/c1)/rad) \u002B 90;\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                lon = (Math.Atan(c2/c1)/rad) \u002B 270;\u003Cbr\u003E            }\u003Cbr\u003E            var coord = new[] {lat, lon};\u003Cbr\u003E            return coord;\u003Cbr\u003E        }\u003Cbr\u003E        /// \u0026lt;summary\u0026gt;\u003Cbr\u003E        /// Orbit foo, this finds the nodes of two orbits\u003Cbr\u003E        /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E        /// \u0026lt;returns\u0026gt;\u003Cbr\u003E        /// The true anomaly of the ascending node(descing node is 180degrees off)\u003Cbr\u003E        /// \u0026lt;/returns\u0026gt;\u003Cbr\u003E        /// \u0026lt;param name=\u0027orbit\u0027\u0026gt;\u003Cbr\u003E        /// Orbit.\u003Cbr\u003E        /// \u0026lt;/param\u0026gt;\u003Cbr\u003E        /// \u0026lt;param name=\u0027tgtorbit\u0027\u0026gt;\u003Cbr\u003E        /// Target Orbit\u003Cbr\u003E        /// \u0026lt;/param\u0026gt;\u003Cbr\u003E        public static double FindAN(Orbit orbit, Orbit tgtorbit)\u003Cbr\u003E        {\u003Cbr\u003E            double rad = Math.PI/180;\u003Cbr\u003E            double Lan1 = orbit.LAN;\u003Cbr\u003E            double inc1 = orbit.inclination;\u003Cbr\u003E            double Lan2 = tgtorbit.LAN;\u003Cbr\u003E            double inc2 = tgtorbit.inclination;\u003Cbr\u003E\u003Cbr\u003E            //see braeunig.us/space... cross product of two orbital planes gives the node location\u003Cbr\u003E            var a = new Vector3d(Math.Sin(inc1*rad)*Math.Cos(Lan1*rad), Math.Sin(inc1*rad)*Math.Sin(Lan1*rad),\u003Cbr\u003E                                 Math.Cos(inc1*rad));\u003Cbr\u003E            var b = new Vector3d(Math.Sin(inc2*rad)*Math.Cos(Lan2*rad), Math.Sin(inc2*rad)*Math.Sin(Lan2*rad),\u003Cbr\u003E                                 Math.Cos(inc2*rad));\u003Cbr\u003E            var c = new Vector3d(0, 0, 0);\u003Cbr\u003E            c = Vector3d.Cross(a, ;\u003Cbr\u003E            var coord = new double[] {0, 0};\u003Cbr\u003E            coord = LatLonofVector(c); //get the coordinates lat/lon of the ascending node\u003Cbr\u003E            double lat = coord[0];\u003Cbr\u003E            double lon = coord[1];\u003Cbr\u003E\u003Cbr\u003E            //go look at the diagrams at braeunig.us/space\u003Cbr\u003E            double \u00C3\u017D\u00C2\u00B1 = lon - Lan1; //its all greek to me\u003Cbr\u003E            if (\u00C3\u017D\u00C2\u00B1 \u0026lt; 0) \u00C3\u017D\u00C2\u00B1 \u002B= 360;\u003Cbr\u003E            double \u00C3\u017D\u00C2\u00BB = Math.Atan(Math.Tan(\u00C3\u017D\u00C2\u00B1*rad)/Math.Cos(inc1*rad))/rad;\u003Cbr\u003E            double x = 180 \u002B (\u00C3\u017D\u00C2\u00BB - orbit.argumentOfPeriapsis);\u003Cbr\u003E            if (x \u0026gt; 360) return 360 - x;\u003Cbr\u003E            else return x;\u003Cbr\u003E        }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EMy current (completely untested) lua port:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E-- takes (vector{x,y,z}) (?), returns coordinates{lat, lon}\u003Cbr\u003Efunction LatLonofVector(vinput)\u003Cbr\u003E\t-- get the geocentric latitude and longitude of a orbital element vector\u003Cbr\u003E\trads = math.pi/180\u003Cbr\u003E\tlocal c1 = vinput[1]\u003Cbr\u003E\tlocal c2 = vinput[2]\u003Cbr\u003E\tlocal c3 = vinput[3]\u003Cbr\u003E\tlocal lon = 0\u003Cbr\u003E\u003Cbr\u003E\tlocal lat = math.atan(c3/math.sqrt((c1*c1) \u002B (c2*c2)))/rads;\u003Cbr\u003E\tif (c1 \u0026lt; 0) then\u003Cbr\u003E\t\tlon = (math.atan(c2/c1)/rads) \u002B 90;\u003Cbr\u003E\telse\u003Cbr\u003E\t\tlon = (math.atan(c2/c1)/rads) \u002B 270;\u003Cbr\u003E\tend\u003Cbr\u003E\tlocal coord = {lat, lon}\u003Cbr\u003E\treturn coord;\u003Cbr\u003Eend\u003Cbr\u003E--takes (vessel, mechjeb.core.targetVessel), returns true anomaly of ascending node\u003Cbr\u003Efunction FindAN(subj, tgt)\u003Cbr\u003E\trads = math.pi/180\u003Cbr\u003E\tlocal Lan1 = subj.orbitLAN\u003Cbr\u003E\tlocal inc1 = subj.orbitInclination\u003Cbr\u003E\tlocal Lan2 = tgt.orbit.LAN\u003Cbr\u003E\tlocal inc2 = tgt.orbit.inclination\u003Cbr\u003E\t-- see braeunig.us/space... cross product of two orbital planes gives the node location\u003Cbr\u003E\tlocal a = {math.sin(inc1*rads)*math.cos(Lan1*rads), math.sin(inc1*rads)*math.sin(Lan1*rads), math.cos(inc1*rads)}\u003Cbr\u003E\tlocal b = {math.sin(inc2*rads)*math.cos(Lan2*rads), math.sin(inc2*rads)*math.sin(Lan2*rads), math.cos(inc2*rads)}\u003Cbr\u003E\tlocal c = {0, 0, 0}\u003Cbr\u003E\tc = VectorCross(a,  --easy enough to define yourself\u003Cbr\u003E\tlocal coord = {0,0,0}\u003Cbr\u003E\tcoord = LatLonofVector(c) --get the coordinates lat/lon of the ascending node\u003Cbr\u003E\tlocal lat = coord[1]\u003Cbr\u003E\tlocal lon = coord[2]\u003Cbr\u003E\u003Cbr\u003E\t-- go look at the diagrams at braeunig.us/space\u003Cbr\u003E\tlocal d = lon - Lan1; -- its all greek to me\u003Cbr\u003E\tif (d \u0026lt; 0) then\u003Cbr\u003E\t\td = d \u002B 360 \u003Cbr\u003E\tend\u003Cbr\u003E\tlocal e = math.atan(math.tan(d*rads)/math.cos(inc1*rads))/rads\u003Cbr\u003E\tlocal x = 180 \u002B (e - subj.orbitArgumentOfPeriapsis)\u003Cbr\u003E\tif (x \u0026gt; 360) then\u003Cbr\u003E\t\treturn 360 - x\u003Cbr\u003E\telse \u003Cbr\u003E\t\treturn x\u003Cbr\u003E\tend\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EYesterday, I decided to split off most of the math into a different script for calculating true/mean/eccentric anomalies, from a table of orbital parameters. That should make it easier to keep up to date; should just need to update the way the getParameters(ship) function works when KSP/MechJebLib updates and everything breaks. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"Grand Lander","CreatedById":31521,"CreatedDateTime":"2012-09-15T06:45:26Z","Content":"\n\u003Cp\u003EI cant even use Autm8 LoL\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-15T20:56:38Z","Content":"\n\u003Cp\u003EAlright, 319 lines in (including whitespace and comments) and I \u0026gt;think\u0026lt; I have a ship that matches planes with its target. More testing/debugging is required though. I found some interesting time equations at \u003Ca href=\u0022http://braeunig.us/space/\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://braeunig.us/space/\u003C/a\u003E , and I think this script could be (on paper anyway) capable of making a combined transfer/minor plane change burn to intercept with the target, then simply kill relative velocity to synchronize orbits, but that\u0027s not very likely in the first version.\u003C/p\u003E\n"},{"CreatedByName":"Nadrek","CreatedById":25326,"CreatedDateTime":"2012-09-16T00:03:14Z","Content":"\n\u003Cp\u003EExcellent work, Peewee - you\u0027re definitely ahead of me for this area; I\u0027ll catch up at some point, though I have a lot of other functions to write first.\u003C/p\u003E\u003Cp\u003EFor everyone that\u0027s interested, below is a newer lua/Autom8 function from my SimpleKSPOrbitalMechanics script that will print out a large portion of the information available to us from any of the Orbit classes (the vessel.orbit* references still exist, but if you like, you can replace vessel.orbit with \u0026lt;your orbital object\u0026gt;, which I\u0027m going to do myself for my report* function, because then you can use it for your own vessel (as this does), or any target vessel or body, or even a specific body or vessel not being targetted.\u003C/p\u003E\u003Cp\u003EGrand Lander, the basic steps in simply using Autom8 are easy. If you want to see basic vessel control, the FlyMeToTheMun script from the first page of this thread is an excellent, simple starting point. Start KSP, and get a Mun lander with Mechjeb ready on the launchpad.\u003C/p\u003E\u003Cp\u003EEither copy and paste the contents of that script into the Autom8 window\u0027s bottom text bar, or save it in %KSP%\\PluginData\\mumechlib as \u0022FlyMeToTheMun.lua\u0022 and then type in that same bottom Autom8 text bar:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Erequire \u0022FlyMeToTheMun\u0022\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThen type in that bottom Autom8 text bar:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003EFlyMeToTheMun(30,30)\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EAnd read through the \u0022print()\u0022 statements in the script as it runs; you can then start to figure out the code controlling your rocket.\u003C/p\u003E\u003Cp\u003EIf you want something more detailed and to learn more about lua, some of the other scripts in this thread are better - you can start with SimpleOrbitalMechanics for pure Autom8 math, or SimpleOrbitalOperations for pure operational use (Molniya style orbits, for example). That\u0027s post #53 in this thread (\u003Ca href=\u0022http://kerbalspaceprogram.com/forum/showthread.php/16503-MechJeb-Autom8-Scripts-Megathread?p=238962\u0026amp;viewfull=1#post238962\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://kerbalspaceprogram.com/forum/showthread.php/16503-MechJeb-Autom8-Scripts-Megathread?p=238962\u0026amp;viewfull=1#post238962\u003C/a\u003E)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Efunction printSkomKSPCurrentOrbitalElements()\u003Cbr\u003E  -- returns nothing.\u003Cbr\u003E  --[[ Ex.\u003Cbr\u003E    printSkomKSPCurrentOrbitalElements()\u003Cbr\u003E  ]]\u003Cbr\u003E  print(\u0022name string \u0022 .. mechjeb.core.part.vessel.name)\u003Cbr\u003E  print(\u0022orbitApA meters \u0022 .. vessel.orbitApA)\u003Cbr\u003E  print(\u0022orbitApR meters \u0022 .. mechjeb.core.part.orbit.ApR)\u003Cbr\u003E  print(\u0022orbitPeA meters \u0022 .. vessel.orbitPeA)\u003Cbr\u003E  print(\u0022orbitPeR meters \u0022 .. mechjeb.core.part.orbit.PeR)\u003Cbr\u003E  print(\u0022orbitPeriod seconds \u0022 .. vessel.orbitPeriod)\u003Cbr\u003E  print(\u0022orbitTimeToAp seconds \u0022 .. vessel.orbitTimeToAp)\u003Cbr\u003E  print(\u0022orbitTimeToPe seconds \u0022 .. vessel.orbitTimeToPe)\u003Cbr\u003E  print(\u0022orbitLAN (RA/Long of Ascending Node) degrees \u0022 .. vessel.orbitLAN)\u003Cbr\u003E  print(\u0022LAN degrees \u0022 .. mechjeb.core.part.orbit.LAN)\u003Cbr\u003E  print(\u0022orbitArgumentOfPeriapsis (APe) degrees \u0022 .. vessel.orbitArgumentOfPeriapsis)\u003Cbr\u003E  print(\u0022orbitLongitudeOfPeriapsis (LPe) degrees \u0022 .. calcSomLpeFromLanApe(vessel.orbitLAN, vessel.orbitArgumentOfPeriapsis))\u003Cbr\u003E  print(\u0022orbitInclination degrees \u0022 .. vessel.orbitInclination)\u003Cbr\u003E  print(\u0022orbitEccentricity (e) \u0022 .. vessel.orbitEccentricity)\u003Cbr\u003E  print(\u0022orbitSemiMajorAxis (a) meters \u0022 .. vessel.orbitSemiMajorAxis)\u003Cbr\u003E  print(\u0022meanAnomaly radians 0 to 2pi \u0022 .. mechjeb.core.part.vessel.orbit.meanAnomaly)\u003Cbr\u003E  print(\u0022meanAnomalyAtEpoch radians (KSP 0.16 BUGGED == meanAnomaly) 0 to 2pi \u0022 .. mechjeb.core.part.vessel.orbit.meanAnomalyAtEpoch)\u003Cbr\u003E  print(\u0022epoch seconds \u0022 .. mechjeb.core.part.orbit.epoch)\u003Cbr\u003E  print(\u0022time seconds \u0022 .. vessel.time)\u003Cbr\u003E  print(\u0022StartUT seconds \u0022 .. mechjeb.core.part.orbit.StartUT)\u003Cbr\u003E  print(\u0022GetUniversalTime seconds \u0022 .. script.call(\u0022Planetarium.GetUniversalTime\u0022))\u003Cbr\u003E  print(\u0022trueAnomaly degrees 0 to 360 \u0022 .. mechjeb.core.part.orbit.trueAnomaly)\u003Cbr\u003E  print(\u0022eccentricAnomaly radians 0 to 2pi \u0022 .. mechjeb.core.part.orbit.eccentricAnomaly)\u003Cbr\u003E  print(\u0022pos[1] position vector ?x? ?? \u0022 .. mechjeb.core.part.orbit.pos[1])\u003Cbr\u003E  print(\u0022pos[2] position vector ?x? ?? \u0022 .. mechjeb.core.part.orbit.pos[2])\u003Cbr\u003E  print(\u0022pos[3] position vector ?x? ?? \u0022 .. mechjeb.core.part.orbit.pos[3])\u003Cbr\u003E  print(\u0022vel[1] velocity vector ?x? ?? \u0022 .. mechjeb.core.part.orbit.vel[1])\u003Cbr\u003E  print(\u0022vel[2] velocity vector ?x? ?? \u0022 .. mechjeb.core.part.orbit.vel[2])\u003Cbr\u003E  print(\u0022vel[3] velocity vector ?x? ?? \u0022 .. mechjeb.core.part.orbit.vel[3])\u003Cbr\u003E  print(\u0022semiMinorAxis meters \u0022 .. mechjeb.core.part.vessel.orbit.semiMinorAxis)\u003Cbr\u003E  print(\u0022semiLatusRectum meters \u0022 .. mechjeb.core.part.vessel.orbit.semiLatusRectum)\u003Cbr\u003E  print(\u0022speedOrbital m/s \u0022 .. vessel.speedOrbital)\u003Cbr\u003E  print(\u0022orbitalSpeed ?? not the same as vessel.speedOrbital \u0022 .. mechjeb.core.part.orbit.orbitalSpeed)\u003Cbr\u003E  print(\u0022orbitalEnergy \u0022 .. mechjeb.core.part.orbit.orbitalEnergy)  \u003Cbr\u003E  print(\u0022speedSurface m/s \u0022 .. vessel.speedSurface)\u003Cbr\u003E  print(\u0022speedVertical m/s \u0022 .. vessel.speedVertical)\u003Cbr\u003E  print(\u0022speedHorizontal m/s \u0022 .. vessel.speedHorizontal)\u003Cbr\u003E  print(\u0022vesselHeading degrees \u0022 .. vessel.vesselHeading)\u003Cbr\u003E  print(\u0022vesselPitch degrees \u0022 .. vessel.vesselPitch)\u003Cbr\u003E  print(\u0022vesselRoll degrees \u0022 .. vessel.vesselRoll)\u003Cbr\u003E  print(\u0022altitudeASL meters \u0022 .. vessel.altitudeASL)\u003Cbr\u003E  print(\u0022altitudeTrue meters \u0022 .. vessel.altitudeTrue)\u003Cbr\u003E  print(\u0022altitudeBottom meters \u0022 .. vessel.altitudeBottom)\u003Cbr\u003E  print(\u0022core altitude meters \u0022 .. mechjeb.core.part.vessel.altitude)\u003Cbr\u003E  print(\u0022latitude degrees \u0022 .. vessel.latitude)\u003Cbr\u003E  print(\u0022longitude degrees \u0022 .. vessel.longitude)\u003Cbr\u003E  print(\u0022vessel orbit radius meters \u0022 .. vessel.radius)\u003Cbr\u003E  print(\u0022core orbit radius meters \u0022 .. mechjeb.core.part.orbit.radius)\u003Cbr\u003E  print(\u0022localg m/s \u0022 .. vessel.localg)\u003Cbr\u003E  print(\u0022atmosphericDensity \u0022 .. vessel.atmosphericDensity)\u003Cbr\u003E  print(\u0022ObT ?? \u0022 .. mechjeb.core.part.vessel.orbit.ObT)\u003Cbr\u003E  print(\u0022ObTAtEpoch ?? \u0022 .. mechjeb.core.part.vessel.orbit.ObTAtEpoch)\u003Cbr\u003E  print(\u0022SEVp ?? \u0022 .. mechjeb.core.part.orbit.SEVp)\u003Cbr\u003E  print(\u0022SEVs ?? \u0022 .. mechjeb.core.part.orbit.SEVs)\u003Cbr\u003E  print(\u0022fromE ?? \u0022 .. mechjeb.core.part.orbit.fromE)\u003Cbr\u003E  print(\u0022fromV ?? \u0022 .. mechjeb.core.part.orbit.fromV)\u003Cbr\u003E  print(\u0022E ?? \u0022 .. mechjeb.core.part.orbit.E)\u003Cbr\u003E  print(\u0022V ?? \u0022 .. mechjeb.core.part.orbit.V)\u003Cbr\u003E  print(\u0022toE ?? \u0022 .. mechjeb.core.part.orbit.toE)\u003Cbr\u003E  print(\u0022toV ?? \u0022 .. mechjeb.core.part.orbit.toV)\u003Cbr\u003E  print(\u0022UTappr ?? \u0022 .. mechjeb.core.part.orbit.UTappr)\u003Cbr\u003E  print(\u0022UTsoi ?? \u0022 .. mechjeb.core.part.orbit.UTsoi)\u003Cbr\u003E  print(\u0022referenceBody.name string \u0022 .. mechjeb.core.part.orbit.referenceBody.name)\u003Cbr\u003E  if mechjeb.core.part.orbit.referenceBody.name == \u0022Kerbin\u0022 then\u003Cbr\u003E    print(\u0022referenceBody full name string KSP_Galaxy1_Kerbol_Kerbin\u0022)\u003Cbr\u003E  elseif mechjeb.core.part.orbit.referenceBody.name == \u0022Mun\u0022 then\u003Cbr\u003E    print(\u0022referenceBody full name string KSP_Galaxy1_Kerbol_Kerbin_Mun\u0022)\u003Cbr\u003E  elseif mechjeb.core.part.orbit.referenceBody.name == \u0022Minmus\u0022 then\u003Cbr\u003E    print(\u0022referenceBody full name string KSP_Galaxy1_Kerbol_Kerbin_Minmus\u0022)\u003Cbr\u003E  elseif mechjeb.core.part.orbit.referenceBody.name == \u0022Sun\u0022 then\u003Cbr\u003E    print(\u0022referenceBody full name string KSP_Galaxy1_Kerbol\u0022)\u003Cbr\u003E  end\u003Cbr\u003E  print(\u0022ClAppr ?? only nonzero when closestEncounterBody ~= nil \u0022 .. mechjeb.core.part.orbit.ClAppr)\u003Cbr\u003E  print(\u0022ClEctr1 ?? only nonzero when closestEncounterBody ~= nil \u0022 .. mechjeb.core.part.orbit.ClEctr1)\u003Cbr\u003E  print(\u0022ClEctr2 ?? only nonzero when closestEncounterBody ~= nil \u0022 .. mechjeb.core.part.orbit.ClEctr2)\u003Cbr\u003E  print(\u0022CrAppr ?? only nonzero when closestEncounterBody ~= nil \u0022 .. mechjeb.core.part.orbit.CrAppr)\u003Cbr\u003E  print(\u0022EndUT \u0022 .. mechjeb.core.part.orbit.EndUT)\u003Cbr\u003E  print(\u0022eccVec[1] eccentricity vector ?x? ?? \u0022 .. mechjeb.core.part.orbit.eccVec[1])\u003Cbr\u003E  print(\u0022eccVec[2] eccentricity vector ?y? ?? \u0022 .. mechjeb.core.part.orbit.eccVec[2])\u003Cbr\u003E  print(\u0022eccVec[3] eccentricity vector ?z? ?? \u0022 .. mechjeb.core.part.orbit.eccVec[3])\u003Cbr\u003E  print(\u0022FEVp ?? \u0022 .. mechjeb.core.part.orbit.FEVp)\u003Cbr\u003E  print(\u0022FEVs ?? \u0022 .. mechjeb.core.part.orbit.FEVs)\u003Cbr\u003E  print(\u0022h[1] ?? \u0022 .. mechjeb.core.part.orbit.h[1])\u003Cbr\u003E  print(\u0022h[2] ?? \u0022 .. mechjeb.core.part.orbit.h[2])\u003Cbr\u003E  print(\u0022h[3] ?? \u0022 .. mechjeb.core.part.orbit.h[3])\u003Cbr\u003E  print(\u0022mag ?? \u0022 .. mechjeb.core.part.orbit.mag)\u003Cbr\u003E  if mechjeb.core.part.vessel.orbit.closestEncounterBody ~= nil then\u003Cbr\u003E    print(\u0022closestEncounterBody.name \u0022 .. mechjeb.core.part.vessel.orbit.closestEncounterBody.name)\u003Cbr\u003E  end\u003Cbr\u003E  print(\u0022orbitPercent \u0022 .. mechjeb.core.part.orbit.orbitPercent)\u003Cbr\u003E  if mechjeb.core.part.orbit.previousPatch ~= nil then\u003Cbr\u003E    -- Orbit class\u003Cbr\u003E    print(\u0022previousPatch.semiMajorAxis (a) meters \u0022 .. mechjeb.core.part.orbit.previousPatch.semiMajorAxis)\u003Cbr\u003E    print(\u0022previousPatch.inclination degrees \u0022 .. mechjeb.core.part.orbit.previousPatch.inclination)\u003Cbr\u003E  end\u003Cbr\u003E  if mechjeb.core.part.orbit.nextPatch ~= nil then\u003Cbr\u003E    -- Orbit class\u003Cbr\u003E    print(\u0022nextPatch.semiMajorAxis (a) meters \u0022 .. mechjeb.core.part.orbit.nextPatch.semiMajorAxis)\u003Cbr\u003E    print(\u0022nextPatch.inclination degrees \u0022 .. mechjeb.core.part.orbit.nextPatch.inclination)\u003Cbr\u003E  end\u003Cbr\u003E  print(\u0022nearestTT ?? \u0022 .. mechjeb.core.part.orbit.nearestTT)\u003Cbr\u003E  print(\u0022nextTT ?? \u0022 .. mechjeb.core.part.orbit.nextTT)\u003Cbr\u003E  print(\u0022objectType string \u0022 .. mechjeb.core.part.orbit.objectType)\u003Cbr\u003E  print(\u0022sampleInterval ?? \u0022 .. mechjeb.core.part.orbit.sampleInterval)\u003Cbr\u003E  print(\u0022timeToTransition1 ?? \u0022 .. mechjeb.core.part.orbit.timeToTransition1)\u003Cbr\u003E  print(\u0022timeToTransition2 ?? \u0022 .. mechjeb.core.part.orbit.timeToTransition2)\u003Cbr\u003E-- ?? FUTURE ADD TimeSincePeriapsis, angular momentum,\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"Nadrek","CreatedById":25326,"CreatedDateTime":"2012-09-16T00:08:55Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022togfox\u0022 data-cite=\u0022togfox\u0022\u003E\u003Cdiv\u003EI\u0027ve no experience with github. What do others think?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI\u0027ve used SVN to a small extent; if a reference for basic check in/out, making copies, and doing so based on label name (not tip) in git is linked to, I\u0027d be more than happy to use it as well as pastebin. I don\u0027t have any real preference between source control repositories - for a selection of individual scripts like these, with one or maybe two authors apiece, there\u0027s no compelling reason to choose one modern source control method over another.\u003C/p\u003E\u003Cp\u003EI would say make sure there are Windows, Mac, and Linux instructions.\u003C/p\u003E\n"},{"CreatedByName":"dAkshEN3","CreatedById":9408,"CreatedDateTime":"2012-09-17T19:31:27Z","Content":"\n\u003Cp\u003EHow would I use the wait() command to wait until the ship is above/below a certain altitude, it doesn\u0027t seem to like anything I\u0027ve tried.\u003C/p\u003E\u003Cp\u003EWhat I\u0027ve tried so far:\u003C/p\u003E\u003Cp\u003E\u0026lt;code\u0026gt;\u003C/p\u003E\u003Cp\u003Ewait(altAbove1k)\u003C/p\u003E\u003Cp\u003E...\u003C/p\u003E\u003Cp\u003Efunction altAbove1k()\u003C/p\u003E\u003Cp\u003E return vessel.altitudeASL \u0026gt; 1000\u003C/p\u003E\u003Cp\u003Eend\u003C/p\u003E\u003Cp\u003E\u0026lt;/code\u0026gt;\u003C/p\u003E\u003Cp\u003Eand\u003C/p\u003E\u003Cp\u003E\u0026lt;code\u0026gt;\u003C/p\u003E\u003Cp\u003Ewhile vessel.altitudeASL \u0026lt; 1000 do\u003C/p\u003E\u003Cp\u003E wait(1)\u003C/p\u003E\u003Cp\u003Eend\u003C/p\u003E\u003Cp\u003E\u0026lt;/code\u0026gt;\u003C/p\u003E\u003Cp\u003EBoth cause KSP to freeze and crash.\u003C/p\u003E\u003Cp\u003EIs this a problem with \u0027vessel\u0027 or am I missing something?\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-17T22:57:03Z","Content":"\n\u003Cp\u003EYou need to run it in a coroutine. See kerbin2mun.lua in the OP for an example.\u003C/p\u003E\u003Cp\u003EAfter thorough testing, I\u0027ve determined that my FindAN() function doesn\u0027t work as expected.\u003C/p\u003E\u003Cp\u003EIf anyone has a working algorithm to get the true anomaly of the ascending node between two orbital planes, I\u0027d be much obliged. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EWhat I\u0027ve got so far (significant portions ported over from MuMechLib):\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E-- TAKES: orbital position vector (3d vector)\u003Cbr\u003E-- RETURNS: geocentric latitude and longitude? (2d vector) at given orbital element vector\u003Cbr\u003Efunction LatLongofVector(vinput)\u003Cbr\u003E\t-- get the geocentric latitude and longitude of a orbital element vector\u003Cbr\u003E\tlocal rads = math.pi/180\u003Cbr\u003E\tlocal c1 = vinput[1]\u003Cbr\u003E\tlocal c2 = vinput[2]\u003Cbr\u003E\tlocal c3 = vinput[3]\u003Cbr\u003E\tlocal lat = math.atan(c3 / math.sqrt(c1*c1 \u002B c2*c2))/rads\u003Cbr\u003E\tlocal long = math.atan2(c2, c1)/rads\u003Cbr\u003E\tif (c1 \u0026lt; 0) then\u003Cbr\u003E\t\tlong = long \u002B 90\u003Cbr\u003E\telseif (c1 \u0026gt; 0) then\u003Cbr\u003E\t\tlong = long \u002B 270\u003Cbr\u003E\tend\u003Cbr\u003E\tlocal coord = {lat, long}\u003Cbr\u003E\treturn coord;\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003E-- TAKES: geocentric coordinates (latitude, longitude)\u003Cbr\u003E-- RETURNS: true anomaly (radians) when orbit is over coordinates\u003Cbr\u003E-- note: May or may not actually work right now...\u003Cbr\u003Efunction GetTrueAnomalyAtGeoCoordinates(orbitParams, coords)\u003Cbr\u003E\tlocal temp2 = math.deg(math.atan(math.tan(math.rad(coords[2]))/math.cos(math.rad(orbitParams.I))))\u003Cbr\u003E--\tprint(\u0022temp2: \u0022 .. temp2)\u003Cbr\u003E\tlocal truAnomaly = 180 \u002B (temp2 - orbitParams.AoP)\u003Cbr\u003E\tif (truAnomaly \u0026gt; 360) then truAnomaly = truAnomaly - 360 end\u003Cbr\u003E\treturn math.rad(truAnomaly)\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003E-- TAKES: target orbital parameters\u003Cbr\u003E-- RETURNS: (radians) true anomaly of ascending node\u003Cbr\u003E-- note: does not work yet.\u003Cbr\u003Efunction FindAN(orbitParams, targetParams)\u003Cbr\u003E\tprint(\u0022finding AN\u0022)\u003Cbr\u003E\tlocal vA = math.sin(math.rad(orbitParams.I))*math.cos(math.rad(orbitParams.LAN))\u003Cbr\u003E\tlocal vB = math.sin(math.rad(orbitParams.I))*math.sin(math.rad(orbitParams.LAN))\u003Cbr\u003E\tlocal vC = math.cos(math.rad(orbitParams.I))\u003Cbr\u003E\tlocal tA = math.sin(math.rad(targetParams.I))*math.cos(math.rad(targetParams.LAN))\u003Cbr\u003E\tlocal tB = math.sin(math.rad(targetParams.I))*math.sin(math.rad(targetParams.LAN))\u003Cbr\u003E\tlocal tC = math.cos(math.rad(targetParams.I))\u003Cbr\u003E\t-- vector3D.cross(v, t) inline here\u003Cbr\u003E\tlocal c = {}\u003Cbr\u003E\tc[1] = vB*tC - vC*tB\u003Cbr\u003E\tc[2] = vC*tA - vA*tC\u003Cbr\u003E\tc[3] = vA*tB - vB*tA\u003Cbr\u003E--\tprint(\u0022end vector stuff C\u0022)\u003Cbr\u003E\u003Cbr\u003E\tlocal coordsA = LatLongofVector(c)\u003Cbr\u003E\tcoordsA[2] = coordsA[2] - orbitParams.LAN --don\u0027t ask me.\u003Cbr\u003E\tif (coordsA[2] \u0026lt; 0) then\u003Cbr\u003E\t\tcoordsA[2] = coordsA[2] \u002B 360\u003Cbr\u003E\tend\u003Cbr\u003E\tprint(\u0022AN coords?: \u0022.. coordsA[1], coordsA[2])\u003Cbr\u003E\t-- Got latitude/longitude of node A\u003Cbr\u003E--\tlocal latB = coordsA[1] * (-1)\u003Cbr\u003E--\tlocal longB = coordsA[2] \u002B 180\u003Cbr\u003E--\tif (longB \u0026gt; 360) then\u003Cbr\u003E--\t\tlongB = longB - 360\u003Cbr\u003E--\tend\u003Cbr\u003E--\tlocal coordsB = {latB, longB}\u003Cbr\u003E\t-- Got latitude/longitude of node B\u003Cbr\u003E--\tprint(\u0022end coordinate stuff C\u0022)\u003Cbr\u003E\u003Cbr\u003E\tlocal nodeA = GetTrueAnomalyAtGeoCoordinates(orbitParams, coordsA)\u003Cbr\u003E--\tlocal nodeB = GetTrueAnomalyAtGeoCoordinates(orbitParams, coordsB)\u003Cbr\u003E--\tprint(\u0022end node stuff A\u0022)\u003Cbr\u003E\t-- TODO: figure out a way to distinguish ascending and descending nodes.\u003Cbr\u003E--\tif (GetRadiusAtTruAnomaly(orbitParams, nodeA) \u0026gt; GetRadiusAtTruAnomaly(orbitParams, nodeB)) then\u003Cbr\u003E\t\treturn nodeA\u003Cbr\u003E--\telse\u003Cbr\u003E--\t\treturn nodeB\u003Cbr\u003E--\tend\u003Cbr\u003Eend\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI also have true anomaly -\u0026gt; eccentric anomaly -\u0026gt; mean anomaly conversions.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222012-09-17T23:14:53Z\u0022 title=\u002209/17/2012 11:14  PM\u0022 data-short=\u002211 yr\u0022\u003ESeptember 17, 2012\u003C/time\u003E by Peewee\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Nadrek","CreatedById":25326,"CreatedDateTime":"2012-09-18T00:41:19Z","Content":"\n\u003Cp\u003ETo expand a little on Peewee\u0027s absolutely correct \u0022run it in a coroutine\u0022 message (and do look at the example he provided! \u003C/p\u003E\u003Cp\u003ECoroutines in lua are essentially a separate execution thread - they\u0027re a routine (function) that, in the simplest form, you tell to go off and start asynchronously, and it does whatever it wants while you continue to do whatever you want - you don\u0027t wait for it (much like starting a program in *nix with \u0026amp; afterwards - it runs in a separate process). So, if you want a constantly updated gauge or meter, a coroutine is great. If you want to have a light blink on and off forever, or based on something, a coroutine is great. If you want to interact with the code in the coroutine bidirectionally... not so simple.\u003C/p\u003E\u003Cp\u003ENow, when you get your Autom8 lua window, whatever you do there is done _in the main game process_. So if you say \u0022wait()\u0022, then the entire game waits. If you put the wait() in a coroutine, then that coroutine spawns a new process/thread, and that thread waits... but since you didn\u0027t wait for the coroutine, you don\u0027t see any wait.\u003C/p\u003E\u003Cp\u003ETherefore, whatever you\u0027re waiting for needs to wait for the wait() (i.e. be synchronous with it, be in the same process/thread)... and to not stall out the game, that _entire package_ needs to be executed asynchronously with the game, i.e. in a coroutine.\u003C/p\u003E\u003Cp\u003ESo, we have:\u003C/p\u003E\u003Cp\u003Efunction DoStuffDriver\u003C/p\u003E\u003Cp\u003E stuff\u003C/p\u003E\u003Cp\u003E wait()\u003C/p\u003E\u003Cp\u003E stuff\u003C/p\u003E\u003Cp\u003Eend\u003C/p\u003E\u003Cp\u003Efunction coDoStuff\u003C/p\u003E\u003Cp\u003E ..\u003C/p\u003E\u003Cp\u003Eend\u003C/p\u003E\u003Cp\u003EAnd in the main Autom8 window, you\u0027ll call coDoStuff(), and you\u0027ll see the results of any print() statements, but you can\u0027t really control it anymore without a lot more work - you kick it off and let it run. If it goes wild, get out to the main Start Game screen and go back in.\u003C/p\u003E\u003Cp\u003ENote that my SimpleSKPOrbitalOperations Isp finding coroutine is also an example, but less clear.\u003C/p\u003E\n"},{"CreatedByName":"Nadrek","CreatedById":25326,"CreatedDateTime":"2012-09-18T02:48:29Z","Content":"\n\u003Cp\u003EPeewee, what license or licenses are you releasing your code under? If you\u0027re willing to go the user\u0027s choice of GPLv2, GPLv3, or CC-BY-SA 3.0 or a license compatible with all three of them (MIT, etc.), then I\u0027d love to get my grubby little hands on your (working) code (particularly the anomaly conversions) to include in the SimpleOrbitalMechanics and related libraries with attribution to you as the original author. It\u0027d save me some time writing abd documenting exactly the same mathematics, though since they\u0027re pure math, I\u0027ll need to write some assert() statements for the test harness.\u003C/p\u003E\u003Cp\u003E dAkshEN3, you\u0027re in luck - I just finished the second of my major \u0022waiting\u0022 general functions, and had to test it. I assume a test based on altitude would be of interest to you? \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E That\u0027s the very last function below.\u003C/p\u003E\u003Cp\u003EIf anything\u0027s confusing (or wrong) please ask - this is the rough draft, copied from another function that waits for a set of two variables to quit changing too much per timeslice (i.e. wait until the pitch and heading settle down after a mechjeb.attitudeTo() call before firing engines), and I may well have some comments from the previous version in there. It\u0027s also a little chatty still, but that may help you visualize what\u0027s happening.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E-- Original Work Copyright 2012, Nadrek, insofar as any elements that aren\u0027t obvious, trivial, or mathematics are concerned (none of which are copyrightable)\u003Cbr\u003E-- licensed under your choice of GPLv2, GPLv3, or Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)  http://www.gnu.org/licenses/gpl-2.0.html  or  http://www.gnu.org/licenses/gpl.html  or  http://creativecommons.org/licenses/by-sa/3.0/\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Efunction waitSkomForMinimumToPassFn1TmbtwnMnot(Function1, TimeBetween, MaxNumberOfTries)\u003Cbr\u003E  -- added in v0.004\u003Cbr\u003E  --   NOTE: Because this has wait() statements, it must be run synchronously with whatever uses the data it returns\u003Cbr\u003E  --   NOTE: Because this has wait() statements, it must be run asynchronously with the main game and any control processes!\u003Cbr\u003E  -- Function1 is a function that takes no arguments, and returns one numeric values that will be tested\u003Cbr\u003E  --   to see if the return value is greater than or equal to the previous return value.\u003Cbr\u003E  -- TimeBetween is the time in seconds between initial and final measurements for each test\u003Cbr\u003E  -- MaxNumberOfTries is how many times we should wait for TimeBetween to elapse and test\u003Cbr\u003E  --   This is so we don\u0027t get into an infinite loop with an ever increasing value\u003Cbr\u003E  -- returns 0 if we timed out (got to MaxNumberOfTries without ever passing a minimum point\u003Cbr\u003E  --   and 1 if we successfully ended up just past than the minimum.\u003Cbr\u003E  -- For example, this is very useful to wait for some measurement to reach a minimum, i.e.\u003Cbr\u003E  --   one use is to use this to wait until the Mean Anomaly, or the Longitude, or the Altitude is at its lowest.\u003Cbr\u003E  --   Alternately, wait for math.abs(MeanAnomaly-2.3) to wait until the MA is just past 2.3\u003Cbr\u003E  --   quit moving \u0022too much\u0022, using that to determine when the vessel is indeed no longer oscillating too much.\u003Cbr\u003E  -- Ex. USE WITHIN ANOTHER COROUTINE function!!!\u003Cbr\u003E  --   waitSkomForMinimumToPassFn1TmbtwnMnot(reportSkomKSPLatitude, 30, 725)\u003Cbr\u003E  -- Ex. see SimpleKSPOrbitalOperations, function ???\u003Cbr\u003E  -- locals would be ideal; however, in one other test locals didn\u0027t update in the while loop, so uniquely named globals were used.  This was as of SharpLua 1.1\u003Cbr\u003E  globalFuncPrevi_waitSkomForMinimumToPassFn1TmbtwnMnot = 1\u003Cbr\u003E  -- now for some _really_ stupid local/global kludges.  local variables get a 1:1 replacement, but don\u0027t work in a prior while loop try.\u003Cbr\u003E  --   global variables, however, get an index out of range exception on the timeout, but do work in the while loop.\u003Cbr\u003E  local localFuncPrev1_waitSkomForMinimumToPassFn1TmbtwnMnot = Function1()\u003Cbr\u003E  globalFuncPrev1_waitSkomForMinimumToPassFn1TmbtwnMnot = localFuncPrev1_waitSkomForMinimumToPassFn1TmbtwnMnot\u003Cbr\u003E  -- First, wait a time unit after the initial \u0022previous\u0022\u003Cbr\u003E  wait(TimeBetween)\u003Cbr\u003E  -- now for some _really_ stupid local/global kludges.  local variables get a 1:1 replacement, but don\u0027t work in a prior while loop try.\u003Cbr\u003E  --   global variables, however, get an index out of range exception on the timeout, but do work in the while loop.\u003Cbr\u003E  local localFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot = Function1()\u003Cbr\u003E  globalFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot = localFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot\u003Cbr\u003E  -- Now we can enter our \u0022checking\u0022 while loop.\u003Cbr\u003E  -- If the return value is over our threshold and we aren\u0027t finished, let\u0027s keep waiting.\u003Cbr\u003E  globalFuncDiff = (globalFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot - globalFuncPrev1_waitSkomForMinimumToPassFn1TmbtwnMnot)\u003Cbr\u003E  print(globalFuncDiff .. \u0022 loop \u0022 .. globalFuncPrevi_waitSkomForMinimumToPassFn1TmbtwnMnot)\u003Cbr\u003E  -- The difference will be negative while the values are decreasing over time.\u003Cbr\u003E  while (globalFuncDiff \u0026lt;= 0) and (globalFuncPrevi_waitSkomForMinimumToPassFn1TmbtwnMnot \u0026lt;= MaxNumberOfTries) do\u003Cbr\u003E    -- the \u0022Cur\u0022 we\u0027ve currently got is now \u0022Prev\u0022 - make it so.\u003Cbr\u003E    globalFuncPrev1_waitSkomForMinimumToPassFn1TmbtwnMnot = globalFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot\u003Cbr\u003E    wait(TimeBetween)\u003Cbr\u003E    -- Gather a new \u0022Cur\u0022 with our kludgy local/global tricks.\u003Cbr\u003E    local localFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot = Function1()\u003Cbr\u003E    globalFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot = localFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot\u003Cbr\u003E    -- increment the loop counter so we can exit if it\u0027s taking too many tries.\u003Cbr\u003E    globalFuncPrevi_waitSkomForMinimumToPassFn1TmbtwnMnot = globalFuncPrevi_waitSkomForMinimumToPassFn1TmbtwnMnot \u002B 1\u003Cbr\u003E    globalFuncDiff = (globalFuncCur1_waitSkomForMinimumToPassFn1TmbtwnMnot - globalFuncPrev1_waitSkomForMinimumToPassFn1TmbtwnMnot)\u003Cbr\u003E    print(globalFuncDiff .. \u0022 loop \u0022 .. globalFuncPrevi_waitSkomForMinimumToPassFn1TmbtwnMnot)\u003Cbr\u003E  end \u003Cbr\u003E  if globalFuncPrevi_waitSkomForMinimumToPassFn1TmbtwnMnot \u0026gt;= MaxNumberOfTries then\u003Cbr\u003E    print \u0022Wait for minimum timed out\u0022\u003Cbr\u003E    return 0\u003Cbr\u003E  else\u003Cbr\u003E    print \u0022Successful Minimum passage\u0022\u003Cbr\u003E    return 1\u003Cbr\u003E  end\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Efunction testSkomKSPWaitForMinAltitudeDriver()\u003Cbr\u003E-- added in v0.004\u003Cbr\u003E-- purely a test function to verify that waitSkomForMinimumToPassFn1TmbtwnMnot works\u003Cbr\u003E--   and to demonstrate that functions can be created on the fly, as it were.\u003Cbr\u003E  local Function1_testSkomKSPWaitForMinAltitudeDriver = function() return mechjeb.core.part.vessel.orbit.altitude end\u003Cbr\u003E  local retval = waitSkomForMinimumToPassFn1TmbtwnMnot(Function1_testSkomKSPWaitForMinAltitudeDriver, 5, 20)\u003Cbr\u003E  if retval == 0 then\u003Cbr\u003E    print \u0022Did not ever pass Periapsis (the minimum altitude)\u0022\u003Cbr\u003E  else\u003Cbr\u003E    print(\u0022Either was already ascending, or just passed minimum altitude of \u0022 .. mechjeb.core.part.vessel.orbit.altitude .. \u0022  no more than 10 seconds before time \u0022 .. mechjeb.core.part.vessel.orbit.epoch)\u003Cbr\u003E  end\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Efunction cotestSkomKSPWaitForMinAltitude()\u003Cbr\u003E  -- added in v0.004\u003Cbr\u003E  --[[ ex.\u003Cbr\u003E    Warp to less than 100 seconds before periapsis, then run:\u003Cbr\u003E    cotestSkomKSPWaitForMinAltitude()\u003Cbr\u003E  ]]\u003Cbr\u003E\u003Cbr\u003E  local coTest = coroutine.create(testSkomKSPWaitForMinAltitudeDriver)\u003Cbr\u003E  coroutine.resume(coTest)\u003Cbr\u003Eend\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENote that in Mechjeb 1.9.1, there\u0027s still some synchronization errors with the wait() statement - if you get one, just re-run it. At this time, I don\u0027t know if they\u0027re correlated with number of wait()s or time spent wait()ing, but since r4m0n is aware of the issue already, I\u0027m hoping Mechjeb 1.9.2 transparently resets the wait() when they happen, which would render further investigation from the lua side pointless.\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-18T12:26:28Z","Content":"\n\u003Cp\u003EI\u0027m using code from MuMechLib, so I\u0027m obligated to release those parts under GPL. To keep everything tidy, I\u0027m releasing it all under GPL.\u003C/p\u003E\u003Cp\u003EHere\u0027s my script as-is. (still obviously a work in progress)\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Cspan style=\u0022font-size:12px;\u0022\u003E------NON-FUNCTIONAL CODE------\u003C/span\u003E\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://pastebin.com/uxCZJgjT\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://pastebin.com/uxCZJgjT\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://pastebin.com/X8qgZGdE\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://pastebin.com/X8qgZGdE\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Cspan style=\u0022font-size:12px;\u0022\u003E------FOR SCRIPT WRITERS ONLY------\u003C/span\u003E\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Cspan style=\u0022font-size:12px;\u0022\u003E------DON\u0027T BOTHER DOWNLOADING IF YOU JUST WANT IT TO WORK------\u003C/span\u003E\u003C/strong\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222012-09-18T16:53:50Z\u0022 title=\u002209/18/2012 04:53  PM\u0022 data-short=\u002211 yr\u0022\u003ESeptember 18, 2012\u003C/time\u003E by Peewee\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"BlueSubstance","CreatedById":40362,"CreatedDateTime":"2012-09-18T14:23:23Z","Content":"\n\u003Cp\u003EIs it okay if the script is a .txt file?\u003C/p\u003E\u003Cp\u003EIf i donwload one of your scripts it is a text file. \u003C/p\u003E\u003Cp\u003E-Blue\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-18T16:50:33Z","Content":"\n\u003Cp\u003EIt\u0027s fine if you\u0027re just checking out the code, but if you want to execute anything in-game, you\u0027ll need to get rid of the .txt on the end. Once again, it\u0027s a work in progress, and doesn\u0027t actually do anything useful yet. As it is now, Rendezvous() will just spam some debugging text to the console then throw an error about trying to do math on a nil value (AN is not currently returned because it was inaccurate). I\u0027ll edit that post before it causes any more confusion.\u003C/p\u003E\n"},{"CreatedByName":"r4m0n","CreatedById":5404,"CreatedDateTime":"2012-09-19T03:11:28Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022BlueSubstance\u0022 data-cite=\u0022BlueSubstance\u0022\u003E\u003Cdiv\u003EIs it okay if the script is a .txt file?\u003Cp\u003EIf i donwload one of your scripts it is a text file. \u003C/p\u003E\u003Cp\u003E-Blue\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Cstrong\u003Edofile(\u0022somefile.txt\u0022)\u003C/strong\u003E should work if you want to keep the extension, but beware of mixing real text files with Lua code. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022:wink:\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"crusaderuk","CreatedById":41603,"CreatedDateTime":"2012-09-19T12:33:19Z","Content":"\n\u003Cp\u003EWithout seeming critical or troll(ish), the math is all very impressive, but it would be nice to see some actual .lua script files that we (the humble kerbalites) could use in Autom8, it would also be great to have a script library thread (which is what I thought this was) where scripts can be listed with a simple explanation of what they do.\u003C/p\u003E\u003Cp\u003EJust my thoughts - not intended to offend anyone.\u003C/p\u003E\n"},{"CreatedByName":"Peewee","CreatedById":5338,"CreatedDateTime":"2012-09-19T12:40:58Z","Content":"\n\u003Cp\u003EYes, that\u0027s what I\u0027m working towards. The math has to be done before any simple \u0027run it and it just works\u0027 scripts can be made, and it just so happens that rendezvous scripts take a significant amount of annoyingly hard to debug math, which hasn\u0027t already been given to us by MuMechLib.\u003C/p\u003E\u003Cp\u003EIn the meantime, have a simple script I whipped up in an hour: \u003Ca href=\u0022http://pastebin.com/ZZ0VGU6N\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://pastebin.com/ZZ0VGU6N\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EIt will take you on a quick spin around the Kerbin neighborhood and land. (Kerbin -\u0026gt; Mun -\u0026gt; Minmus -\u0026gt; Kerbin)\u003C/p\u003E\n"},{"CreatedByName":"crusaderuk","CreatedById":41603,"CreatedDateTime":"2012-09-20T23:21:03Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Peewee\u0022 data-cite=\u0022Peewee\u0022\u003E\u003Cdiv\u003EYes, that\u0027s what I\u0027m working towards. The math has to be done before any simple \u0027run it and it just works\u0027 scripts can be made, and it just so happens that rendezvous scripts take a significant amount of annoyingly hard to debug math, which hasn\u0027t already been given to us by MuMechLib.\u003Cp\u003EIn the meantime, have a simple script I whipped up in an hour: \u003Ca href=\u0022http://pastebin.com/ZZ0VGU6N\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://pastebin.com/ZZ0VGU6N\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EIt will take you on a quick spin around the Kerbin neighborhood and land. (Kerbin -\u0026gt; Mun -\u0026gt; Minmus -\u0026gt; Kerbin)\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThanks for this\u003C/p\u003E\n"},{"CreatedByName":"Nadrek","CreatedById":25326,"CreatedDateTime":"2012-09-21T00:16:19Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022crusaderuk\u0022 data-cite=\u0022crusaderuk\u0022\u003E\u003Cdiv\u003EWithout seeming critical or troll(ish), the math is all very impressive, but it would be nice to see some actual .lua script files that we (the humble kerbalites) could use in Autom8, it would also be great to have a script library thread (which is what I thought this was) where scripts can be listed with a simple explanation of what they do.\u003Cp\u003EJust my thoughts - not intended to offend anyone.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAs Peewee said, to do neat things, we have to work out the neat math first, and then code it, and then test it, and then go back to the math, and then change the design, and so on. The neat stuff isn\u0027t quite as trivial as it appears - it is, in fact, rocket science*. Once we have a really good, solid foundation, then all Autom8 using Kerbal engineers and scientists will have more building blocks to work with. \u003C/p\u003E\u003Cp\u003EAlso, don\u0027t sell yourself short - look at Peewee\u0027s tour script; I bet you can spend less than ten minutes, and modify it so that it goes on the tour in reverse order. You could also take FlyMeToTheMun, and alter it to be FlyMeToTheMinmus. All it takes is a little trial and error, and a few brave Kerbals.\u003C/p\u003E\u003Cp\u003E*: Two body simplification thereof.\u003C/p\u003E\n"},{"CreatedByName":"crusaderuk","CreatedById":41603,"CreatedDateTime":"2012-09-21T01:03:03Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Peewee\u0022 data-cite=\u0022Peewee\u0022\u003E\u003Cdiv\u003EYes, that\u0027s what I\u0027m working towards. The math has to be done before any simple \u0027run it and it just works\u0027 scripts can be made, and it just so happens that rendezvous scripts take a significant amount of annoyingly hard to debug math, which hasn\u0027t already been given to us by MuMechLib.\u003Cp\u003EIn the meantime, have a simple script I whipped up in an hour: \u003Ca href=\u0022http://pastebin.com/ZZ0VGU6N\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://pastebin.com/ZZ0VGU6N\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EIt will take you on a quick spin around the Kerbin neighborhood and land. (Kerbin -\u0026gt; Mun -\u0026gt; Minmus -\u0026gt; Kerbin)\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EUmm I cant get this to work .. I\u0027m typing ... dofile(\u0022tour\u0022) \u003C/p\u003E\u003Cp\u003Eand it says...\u003C/p\u003E\u003Cp\u003EParseException: Code has syntax errors:\u003C/p\u003E\u003Cp\u003ELine 1, Col 1 \u0027f\u0027: Failed to parse Name of VarName.\u003C/p\u003E\u003Cp\u003ELine 1, Col 20 \u0027(\u0027: Failed to parse \u00270\u0027..\u003C/p\u003E\u003Cp\u003EI\u0027ve named the file tour.lua \u003C/p\u003E\u003Cp\u003Eand I\u0027ve looked over the code but cant see anything that\u0027s obvious .........HELP lol\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222012-09-21T18:00:25Z\u0022 title=\u002209/21/2012 06:00  PM\u0022 data-short=\u002211 yr\u0022\u003ESeptember 21, 2012\u003C/time\u003E by crusaderuk\u003C/strong\u003E\n\u003C/span\u003E\n"}]}