{"TopicId":55798,"ForumId":36,"TopicTitle":"[1.0] XT Landertron - Smart Retrorockets for Landers and Spaceplanes v0.08 Oct 10","CreatedByName":"XanderTek","CreatedById":92553,"CreatedDateTime":"2013-12-11T09:27:57Z","PageNum":7,"Articles":[{"CreatedByName":"ManuxKerb","CreatedById":139441,"CreatedDateTime":"2015-04-27T22:30:57Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022XanderTek\u0022 data-cite=\u0022XanderTek\u0022\u003E\u003Cdiv\u003EAll Landertrons assigned to a stage will be taken into account when figuring out when to fire. So 2 sets of 4 Landertrons will work just fine so long as they\u0027re all activated at once.\u003Cp\u003EHow big would you like to see them get? I was thinking about adding tweakscale compatibility.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EHi\u003C/p\u003E\u003Cp\u003ETweakscale sounds good :-)\u003C/p\u003E\u003Cp\u003EI\u0027m just in the process of testing the landertrons, when i activate them, 20 km above the mun (already in landing trajectory, horizontal m/s nearly 0), then they start firering right away. 18 km above the mun and my ms/ is just 20 m/s or so. Why do they not wait for the suicide burn ? Of course they run out before the surface any my Kerbals die.... Also they have so many thrust that they actually lift the lander again and my ap gets higher.....\u003C/p\u003E\u003Cp\u003EBreaking Distance says: ca 200 m but it starts before that (yellow color)\u003C/p\u003E\u003Cp\u003EAlso: What does Endspeed in the menu mean ? is it the final landing speed after fireing the landertrons ?\u003C/p\u003E\u003Cp\u003EThanks for clearing that up :-D\u003C/p\u003E\n"},{"CreatedByName":"XanderTek","CreatedById":92553,"CreatedDateTime":"2015-04-28T20:32:55Z","Content":"\n\u003Cp\u003ECorrect, Endspeed is the speed you\u0027ll be going when you contact the ground. Most of the time you can just leave that at zero.\u003C/p\u003E\u003Cp\u003EThere\u0027s a bug that currently results in the landertrons getting confused if you build the lander in a different orientation than you end up landing it in. This often happens if you build the lander in the spaceplane hanger. Is it possible that\u0027s what you experienced? I\u0027m working on a solution, but its been slow going. Or maybe something broke in 1.0. I haven\u0027t had a chance to check yet.\u003C/p\u003E\n"},{"CreatedByName":"ManuxKerb","CreatedById":139441,"CreatedDateTime":"2015-04-28T20:39:42Z","Content":"\n\u003Cp\u003EHi XanderTek,\u003C/p\u003E\u003Cp\u003EWell i build the lander normal in the VAB, it is possible that i turned it clokwise but not upside down or anything. I did play in 0.9 (will wait till most of my mods are ported \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EThe thing is, the engies did not turn blue, they just got straight to yellow and started firering 18km up but suicide burn point was at 10 km or so...\u003C/p\u003E\u003Cp\u003EThanks for looking into this, in the end i laded the lander with my backup engine :-) But Landertrons would be much cooler :-D\u003C/p\u003E\n"},{"CreatedByName":"Gobur","CreatedById":106365,"CreatedDateTime":"2015-05-02T10:36:05Z","Content":"\n\u003Cp\u003EI try this in 1.0.2 swith Arm menu or staging set in on, wo waiting for ground :-(\u003C/p\u003E\n"},{"CreatedByName":"TheDog","CreatedById":137239,"CreatedDateTime":"2015-05-03T12:07:23Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022XanderTek\u0022 data-cite=\u0022XanderTek\u0022\u003E\u003Cdiv\u003ECorrect, Endspeed is the speed you\u0027ll be going when you contact the ground. Most of the time you can just leave that at zero.\u003Cp\u003EThere\u0027s a bug that currently results in the landertrons getting confused if you build the lander in a different orientation than you end up landing it in. This often happens if you build the lander in the spaceplane hanger. Is it possible that\u0027s what you experienced? I\u0027m working on a solution, but its been slow going. Or maybe something broke in 1.0. I haven\u0027t had a chance to check yet.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EHi XanderTek,\u003C/p\u003E\u003Cp\u003Eindeed for me it didnt work in 1.0 (1.0.2).\u003C/p\u003E\u003Cp\u003EI took the freedom to look at your source, and I *believe* I have fixed all instances where 1.0 changed something.\u003C/p\u003E\u003Cp\u003E(most important was \u003Cem\u003Evessel.staticPressure\u003C/em\u003E no longer exists, thus my landertrons could not figure out when to fire).\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EUpdated source landertron.cs\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Epublic class Landertron : PartModule\u003Cbr\u003E{\u003Cbr\u003E    //[KSPField(guiActive = true, guiActiveEditor=true ,isPersistant=true),UI_FloatRange(maxValue=1.5f,minValue=0.5f,stepIncrement=0.05f)]\u003Cbr\u003E    //public float heightmultiplier = 1;\u003Cbr\u003E    //[KSPField(guiActive = true, guiActiveEditor = true, isPersistant = true), UI_FloatRange(maxValue = 3, minValue = -3f, stepIncrement = 0.1f)]\u003Cbr\u003E    //public float offset = 0;\u003Cbr\u003E    //[KSPField(guiActive = false)]\u003Cbr\u003E    //public float endheight = 0;\u003Cbr\u003E    [KSPField(guiActive = false, guiActiveEditor = true, isPersistant = true), UI_FloatRange(maxValue = 10, minValue = 0, stepIncrement = 0.5f)]\u003Cbr\u003E    public float endspeed = 0;\u003Cbr\u003E    [KSPField(guiActive = false)]\u003Cbr\u003E    public bool boom = false;\u003Cbr\u003E    [KSPField(guiActive = false)]\u003Cbr\u003E    public bool showgui = true;\u003Cbr\u003E    [KSPField(guiActive = false)]\u003Cbr\u003E    public bool refuelable = true;\u003Cbr\u003E    //[KSPField(guiActive = false)]\u003Cbr\u003E    //public bool engineShutdown = true;\u003Cbr\u003E    [KSPField(guiActive = false)]\u003Cbr\u003E    public float electricrate = 0.05f;\u003Cbr\u003E    [KSPField(guiActive = false, guiActiveEditor=false ,isPersistant=true)]\u003Cbr\u003E    public int mode = 0;\u003Cbr\u003E    public float thrust = 0;\u003Cbr\u003E    [KSPField(isPersistant = false, guiActiveEditor = false, guiActive = false)]\u003Cbr\u003E    public string Status = \u0022Idle\u0022;\u003Cbr\u003E    [KSPField(isPersistant = false, guiActiveEditor = true, guiActive = true)]\u003Cbr\u003E    public string ModeName = \u0022 \u0022;\u003Cbr\u003E    //[KSPField(isPersistant = false, guiActiveEditor = false, guiActive = true)]\u003Cbr\u003E    public double deltaV = 0;\u003Cbr\u003E    public float m = 0;\u003Cbr\u003E    public float elec_dem = 0;\u003Cbr\u003E    public float elec_rec = 0;\u003Cbr\u003E    public float totalfuelmass = 0;\u003Cbr\u003E    public double totalthrust = 0;\u003Cbr\u003E    public double partanglethrust = 0;\u003Cbr\u003E    public double vesselanglethrust = 0;\u003Cbr\u003E    public double localg;\u003Cbr\u003E    public double gee = 0;\u003Cbr\u003E    public double vaccel = 0;\u003Cbr\u003E    public double backgroundaccel = 0;\u003Cbr\u003E    public double vh_prev = 1000;\u003Cbr\u003E    public double v = 0;\u003Cbr\u003E    [KSPField(isPersistant = false, guiActive = true, guiName = \u0022Braking Distance\u0022, guiUnits = \u0022m\u0022)]\u003Cbr\u003E    public float displayd = 0;\u003Cbr\u003E    public double dfinal = 0;\u003Cbr\u003E    public double dmin = 0;\u003Cbr\u003E    public bool fire = false;\u003Cbr\u003E    public bool arm = false;\u003Cbr\u003E    public bool end = false;\u003Cbr\u003E    public bool firing = false;\u003Cbr\u003E    public bool warning = false;\u003Cbr\u003E    public bool prevland = true;\u003Cbr\u003E    public static bool globaljustrefueled = false;\u003Cbr\u003E    public bool justrefueled = false;\u003Cbr\u003E    protected ModuleEngines engine;\u003Cbr\u003E    protected PartResource sf;\u003Cbr\u003E    protected Landertron ltron;\u003Cbr\u003E    public Vector3d pos;\u003Cbr\u003E    public Vector3d up;\u003Cbr\u003E    public Vector3d acc;\u003Cbr\u003E    public Vector3d vel;\u003Cbr\u003E    [KSPField(guiActive=false)]\u003Cbr\u003E    public int lcount = 0;\u003Cbr\u003E    public RaycastHit craft;\u003Cbr\u003E    public Part mpart;\u003Cbr\u003E    public float isp;\u003Cbr\u003E    public float burntime;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    [KSPField(isPersistant = false)]\u003Cbr\u003E    public string AnimationName;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    private AnimationState[] animStates;\u003Cbr\u003E    private bool animdeployed=false;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public override void OnAwake()\u003Cbr\u003E    {\u003Cbr\u003E        lcount = 0;\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E    public override void OnStart(PartModule.StartState state)\u003Cbr\u003E    {\u003Cbr\u003E        engine = this.part.Modules[\u0022ModuleEngines\u0022] as ModuleEngines;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        sf = this.part.Resources[\u0022SolidFuel\u0022];\u003Cbr\u003E        if (HighLogic.LoadedScene == GameScenes.EDITOR \u0026amp;\u0026amp; mode == 0)\u003Cbr\u003E        { mode = 2; }\u003Cbr\u003E        else if (HighLogic.LoadedScene == GameScenes.EDITOR \u0026amp;\u0026amp; mode == 0)\u003Cbr\u003E        { mode = 1; }\u003Cbr\u003E        switch(mode)\u003Cbr\u003E        {\u003Cbr\u003E            case 1:\u003Cbr\u003E                ModeName = \u0022Soft Landing\u0022;\u003Cbr\u003E                break;\u003Cbr\u003E            case 2:\u003Cbr\u003E                ModeName = \u0022Short Landing\u0022;\u003Cbr\u003E                break;\u003Cbr\u003E            case 3:\u003Cbr\u003E                ModeName = \u0022StayPut\u0022;\u003Cbr\u003E                break;\u003Cbr\u003E        }\u003Cbr\u003E        guifixer();\u003Cbr\u003E        animStates = SetUpAnimation(AnimationName, this.part);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        //GameEvents.onJointBreak.Add(onJointBreak);\u003Cbr\u003E    }\u003Cbr\u003E    //private void onJointBreak(EventReport eventreport)\u003Cbr\u003E    //{ print(\u0022Something detatched! \u0022);}\u003Cbr\u003E    /*[KSPEvent(guiName = \u0022Refuel\u0022,guiActive=false ,externalToEVAOnly = true, guiActiveUnfocused = true, unfocusedRange = 3.0f)]\u003Cbr\u003E    public void Refuel()\u003Cbr\u003E    {\u003Cbr\u003E        double sf_available = 0;\u003Cbr\u003E        int containercount=0;\u003Cbr\u003E        foreach (Part p in vessel.parts)\u003Cbr\u003E        {\u003Cbr\u003E            if (!p.Modules.Contains(\u0022Landertron\u0022) \u0026amp;\u0026amp; p.Resources.Contains(\u0022SolidFuel\u0022))\u003Cbr\u003E            {\u003Cbr\u003E                PartResource sfp = p.Resources[\u0022SolidFuel\u0022];\u003Cbr\u003E                sf_available \u002B= sfp.amount;\u003Cbr\u003E                containercount\u002B\u002B;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E                //print(\u0022avail: \u0022 \u002B sf_available);\u003Cbr\u003E        double sf_needed = sf.maxAmount - sf.amount;\u003Cbr\u003E        double sf_added = Math.Min(sf_available, sf_needed);\u003Cbr\u003E        sf.amount \u002B= sf_added;\u003Cbr\u003E        foreach (Part p in vessel.parts)\u003Cbr\u003E        {\u003Cbr\u003E            if (!p.Modules.Contains(\u0022Landertron\u0022) \u0026amp;\u0026amp; p.Resources.Contains(\u0022SolidFuel\u0022))\u003Cbr\u003E            {\u003Cbr\u003E                PartResource sfp = p.Resources[\u0022SolidFuel\u0022];\u003Cbr\u003E                sfp.amount -= sf_added/containercount;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E        justrefueled = true;\u003Cbr\u003E        animdeployed = false;\u003Cbr\u003E    }*/\u003Cbr\u003E    public void Refuel()\u003Cbr\u003E    {\u003Cbr\u003E        /*int ccount = 0;\u003Cbr\u003E        foreach (Part p in this.part.children)\u003Cbr\u003E        {\u003Cbr\u003E            print(\u0022name: \u0022\u002Bp.name);\u003Cbr\u003E            p.Die();\u003Cbr\u003E            //p.explosionPotential = 0;\u003Cbr\u003E            //p.explode();\u003Cbr\u003E            //ccount\u002B\u002B;\u003Cbr\u003E        }*/\u003Cbr\u003E        for (int i = 0; i \u0026lt; this.part.children.Count; )\u003Cbr\u003E        {\u003Cbr\u003E            Part p = this.part.children[i];\u003Cbr\u003E            if (p.Resources.Contains(\u0022SolidFuel\u0022) \u0026amp;\u0026amp; sf.amount \u0026lt; sf.maxAmount)\u003Cbr\u003E            {\u003Cbr\u003E\u003Cbr\u003E                PartResource sfp = p.Resources[\u0022SolidFuel\u0022];\u003Cbr\u003E                sf.amount = Math.Min(sf.amount \u002B sfp.amount, sf.maxAmount);\u003Cbr\u003E                //print(\u0022name: \u0022 \u002B p.name);\u003Cbr\u003E                p.Die();\u003Cbr\u003E                justrefueled = true;\u003Cbr\u003E                animdeployed = false;\u003Cbr\u003E            }\u003Cbr\u003E            else \u002B\u002Bi;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        /*if (ccount \u0026gt; 0)\u003Cbr\u003E        {\u003Cbr\u003E            for (int i = 0; i \u0026lt; ccount; i\u002B\u002B)\u003Cbr\u003E            {\u003Cbr\u003E                print(\u0022name: \u0022 \u002B this.part.children   (i).name);\u003Cbr\u003E            }\u003Cbr\u003E        }*/\u003Cbr\u003E    }\u003Cbr\u003E    [KSPEvent(guiName = \u0022Soft Landing\u0022, guiActiveEditor = true, guiActiveUnfocused = false, guiActive = false)]\u003Cbr\u003E    public void ClassicMode()\u003Cbr\u003E    {\u003Cbr\u003E        mode = 1;\u003Cbr\u003E        ModeName = \u0022Soft Landing\u0022;\u003Cbr\u003E        forAllSym();        \u003Cbr\u003E    }\u003Cbr\u003E    [KSPEvent(guiName = \u0022Short Landing\u0022, guiActiveEditor = true, guiActiveUnfocused = false, guiActive = false)]\u003Cbr\u003E    public void VSL()\u003Cbr\u003E    {\u003Cbr\u003E        mode = 2;\u003Cbr\u003E        ModeName = \u0022Short Landing\u0022;\u003Cbr\u003E        forAllSym();        \u003Cbr\u003E    }\u003Cbr\u003E    [KSPEvent(guiName = \u0022StayPut\u0022, guiActiveEditor = true, guiActiveUnfocused = false, guiActive = false)]\u003Cbr\u003E    public void SP()\u003Cbr\u003E    {\u003Cbr\u003E        mode = 3;\u003Cbr\u003E        ModeName = \u0022StayPut\u0022;\u003Cbr\u003E        forAllSym();\u003Cbr\u003E    }\u003Cbr\u003E    [KSPEvent(guiName = \u0022Decouple\u0022, guiActive = false, externalToEVAOnly = true, guiActiveUnfocused = true, unfocusedRange = 3.0f)]\u003Cbr\u003E    public void decoup()\u003Cbr\u003E    {\u003Cbr\u003E        this.part.decouple(2000);\u003Cbr\u003E    }\u003Cbr\u003E    /*[KSPEvent(guiName = \u0022Escape!\u0022, guiActiveEditor = true, guiActiveUnfocused = false, guiActive = true)]\u003Cbr\u003E    public void escape()\u003Cbr\u003E    {\u003Cbr\u003E        mode = 4;\u003Cbr\u003E        ModeName = \u0022Escape!\u0022;\u003Cbr\u003E        forAllSym();\u003Cbr\u003E    }*/\u003Cbr\u003E    [KSPAction(\u0022Arm\u0022)]\u003Cbr\u003E    public void armaction(KSPActionParam param)\u003Cbr\u003E    {\u003Cbr\u003E        this.part.force_activate();\u003Cbr\u003E    }\u003Cbr\u003E    [KSPAction(\u0022Decouple\u0022)]\u003Cbr\u003E    public void decoupleaction(KSPActionParam param)\u003Cbr\u003E    {\u003Cbr\u003E        this.part.decouple(2000);\u003Cbr\u003E    }\u003Cbr\u003E    /*[KSPAction(\u0022Abort\u0022, KSPActionGroup.Abort)]\u003Cbr\u003E    public void abort()\u003Cbr\u003E    {\u003Cbr\u003E        if (mode==4)\u003Cbr\u003E        {\u003Cbr\u003E            foreach (Part p in vessel.parts)\u003Cbr\u003E            {\u003Cbr\u003E                if (p.Modules.Contains(\u0022ModuleDecouple\u0022))\u003Cbr\u003E                {\u003Cbr\u003E                    ModuleDecouple dec=p.Modules[\u0022ModuleDecouple\u0022] as ModuleDecouple;\u003Cbr\u003E                    dec.Decouple();\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E        engine.Activate();\u003Cbr\u003E        }\u003Cbr\u003E    }*/\u003Cbr\u003E    public void Update()\u003Cbr\u003E    {\u003Cbr\u003E        if (HighLogic.LoadedSceneIsEditor)\u003Cbr\u003E        {\u003Cbr\u003E            guifixer();\u003Cbr\u003E\u003Cbr\u003E            /*totalmass = 0;\u003Cbr\u003E            totalfuelmass = 0;\u003Cbr\u003E            foreach (Part p in EditorLogic.SortedShipList)\u003Cbr\u003E            {\u003Cbr\u003E                if (p.Modules.Contains(\u0022Landertron\u0022) \u0026amp;\u0026amp; p.inverseStage == this.part.inverseStage)\u003Cbr\u003E                {\u003Cbr\u003E                    ltron = p.Modules[\u0022Landertron\u0022] as Landertron;\u003Cbr\u003E                    if (ltron.mode == mode)\u003Cbr\u003E                    {\u003Cbr\u003E                        totalfuelmass = totalfuelmass\u002Bp.GetResourceMass();\u003Cbr\u003E\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E                totalmass = totalmass\u002Bp.GetResourceMass()\u002Bp.mass;\u003Cbr\u003E            }\u003Cbr\u003E            //print(\u0022fuel: \u0022 \u002B totalfuelmass);\u003Cbr\u003E            //print(\u0022ln: \u0022 \u002B Mathf.Log(totalmass / (totalmass - totalfuelmass)));\u003Cbr\u003E            deltaV = engine.atmosphereCurve.Evaluate(1) * 9.81f * Mathf.Log(totalmass / (totalmass - totalfuelmass));*/\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E    public override void OnActive()\u003Cbr\u003E    {\u003Cbr\u003E        lcount = 0;\u003Cbr\u003E        foreach (Part p in vessel.parts)\u003Cbr\u003E        {\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            if (p.Modules.Contains(\u0022Landertron\u0022) \u0026amp;\u0026amp; p.inverseStage==this.part.inverseStage \u0026amp;\u0026amp; p.GetResourceMass()\u0026gt;0)\u003Cbr\u003E            {\u003Cbr\u003E\u003Cbr\u003E                ltron=p.Modules[\u0022Landertron\u0022] as Landertron;\u003Cbr\u003E                if (ltron.mode == mode)\u003Cbr\u003E                {\u003Cbr\u003E                    lcount = lcount \u002B 1;\u003Cbr\u003E\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E        }\u003Cbr\u003E        //partanglethrust = Vector3d.Dot(this.part.transform.up.normalized, this.vessel.transform.up.normalized);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        animdeployed = true;\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E    public override void OnUpdate()\u003Cbr\u003E    {\u003Cbr\u003E        guifixer();\u003Cbr\u003E        if (justrefueled \u0026amp;\u0026amp; this.vessel == FlightGlobals.ActiveVessel)\u003Cbr\u003E        {\u003Cbr\u003E            //if (globaljustrefueled)\u003Cbr\u003E            //{ \u003Cbr\u003E            //    Staging.AddStageAt(0);\u003Cbr\u003E            //    globaljustrefueled = false;\u003Cbr\u003E            //}\u003Cbr\u003E            //int c = 0;\u003Cbr\u003E            //int stg = Staging.CurrentStage;\u003Cbr\u003E            //if (stg == c)\u003Cbr\u003E            //{ Staging.AddStageAt(0); }\u003Cbr\u003E\u003Cbr\u003E            //this.part.stackIcon.SetIconColor(XKCDColors.White);\u003Cbr\u003E            Status = \u0022Idle\u0022;\u003Cbr\u003E            this.part.deactivate();\u003Cbr\u003E            //print(\u0022deact\u0022);\u003Cbr\u003E            this.part.inverseStage = 0;\u003Cbr\u003E            //Staging.AddStageAt(Staging.CurrentStage\u002B1);\u003Cbr\u003E            //Staging.AddStageAt(Staging.CurrentStage \u002B 1);\u003Cbr\u003E            //print(\u0022stage: \u0022 \u002B Staging.CurrentStage);\u003Cbr\u003E            //Staging.RecalculateVesselStaging(this.vessel);\u003Cbr\u003E            justrefueled = false;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        }\u003Cbr\u003E        if (refuelable)\u003Cbr\u003E        {\u003Cbr\u003E            Refuel();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        foreach (AnimationState anim in animStates)\u003Cbr\u003E        {\u003Cbr\u003E            if (animdeployed \u0026amp;\u0026amp; anim.normalizedTime \u0026lt; 1) { anim.speed = 1; }\u003Cbr\u003E            if (animdeployed \u0026amp;\u0026amp; anim.normalizedTime \u0026gt;= 1)\u003Cbr\u003E            {\u003Cbr\u003E                anim.speed = 0;\u003Cbr\u003E                anim.normalizedTime = 1;\u003Cbr\u003E            }\u003Cbr\u003E            if (!animdeployed \u0026amp;\u0026amp; anim.normalizedTime \u0026gt; 0) { anim.speed = -1; }\u003Cbr\u003E            if (!animdeployed \u0026amp;\u0026amp; anim.normalizedTime \u0026lt;= 0)\u003Cbr\u003E            {\u003Cbr\u003E                anim.speed = 0;\u003Cbr\u003E                anim.normalizedTime = 0;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E    public override void OnFixedUpdate()\u003Cbr\u003E    {\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        //if (engine.maxThrust != 0 \u0026amp;\u0026amp; engine.maxThrust != thrust)\u003Cbr\u003E        //{ thrust = engine.maxThrust; }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        m = this.vessel.GetTotalMass();\u003Cbr\u003E        v = this.vessel.verticalSpeed;\u003Cbr\u003E        //gee = FlightGlobals.getGeeForceAtPosition(this.vessel.mainBody.position).magnitude;\u003Cbr\u003E        pos = this.vessel.findWorldCenterOfMass();\u003Cbr\u003E        up = (pos - this.vessel.mainBody.position).normalized;\u003Cbr\u003E        vesselanglethrust = Vector3d.Dot(this.vessel.transform.up.normalized, up);\u003Cbr\u003E        Vector3 thrustp = Vector3d.zero;\u003Cbr\u003E        foreach (var t in engine.thrustTransforms)\u003Cbr\u003E        { thrustp -= t.forward / engine.thrustTransforms.Count; }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\t\t//--TheDog: 03.05.2015: FIXED: KSP 1.0.2 has no more GameScenes.SPH--\u003Cbr\u003E\t\tVector3 fwd = HighLogic.LoadedScene == GameScenes.EDITOR ? Vector3d.up : (Vector3d)engine.part.vessel.GetTransform().up;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        partanglethrust = Vector3.Dot(fwd, thrustp);\u003Cbr\u003E        acc = this.vessel.acceleration;\u003Cbr\u003E        vaccel = Vector3d.Dot(acc, up);\u003Cbr\u003E        totalthrust = engine.maxThrust * partanglethrust * vesselanglethrust * lcount * (engine.thrustPercentage / 100);\u003Cbr\u003E        //print(totalthrust);\u003Cbr\u003E        totalfuelmass = lcount * (float)sf.amount * 0.0075f; //this.part.GetResourceMass();\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\t\t//--TheDog: 03.05.2015: FIXED: KSP 1.0.2 has no more staticPressure--\u003Cbr\u003E        //isp = engine.atmosphereCurve.Evaluate((float)this.vessel.staticPressure);\u003Cbr\u003E\t\tisp = engine.atmosphereCurve.Evaluate((float)this.vessel.mainBody.GetPressure(this.height())); \u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\t\tdeltaV = isp * 9.81f * Mathf.Log(this.vessel.GetTotalMass() / (this.vessel.GetTotalMass() - totalfuelmass)) * partanglethrust;\u003Cbr\u003E        //burntime = this.part.GetResourceMass() / (engine.maxThrust / isp);\u003Cbr\u003E        burntime = (float)sf.amount *0.0075f / (engine.maxThrust*(engine.thrustPercentage/100) / (isp*9.81f));\u003Cbr\u003E\u003Cbr\u003E        elec_dem = electricrate * TimeWarp.fixedDeltaTime;\u003Cbr\u003E        elec_rec = elec_dem;\u003Cbr\u003E        if (sf.amount \u0026gt; 0.1)\u003Cbr\u003E        { elec_rec = this.part.RequestResource(\u0022ElectricCharge\u0022, elec_dem); }\u003Cbr\u003E        modeconfig();\u003Cbr\u003E        if (elec_rec \u0026lt; elec_dem)\u003Cbr\u003E        {\u003Cbr\u003E            this.part.stackIcon.SetIconColor(XKCDColors.BrightYellow);\u003Cbr\u003E            Status = \u0022No Power\u0022;\u003Cbr\u003E        }\u003Cbr\u003E        else if (sf.amount == 0 \u0026amp;\u0026amp; engine.getIgnitionState)\u003Cbr\u003E        {\u003Cbr\u003E            engine.allowShutdown = true;\u003Cbr\u003E            engine.Shutdown();\u003Cbr\u003E            engine.allowShutdown = false;\u003Cbr\u003E            this.part.stackIcon.SetIconColor(XKCDColors.White);\u003Cbr\u003E            Status = \u0022Idle\u0022;\u003Cbr\u003E            this.part.deactivate();\u003Cbr\u003E        }\u003Cbr\u003E        else if (end)\u003Cbr\u003E        {\u003Cbr\u003E            if (boom)\u003Cbr\u003E            { this.part.explode(); }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                //print(\u0022venting \u0022 \u002B sf.amount \u002B \u0022 fuel\u0022);\u003Cbr\u003E                sf.amount = 0; \u003Cbr\u003E            }\u003Cbr\u003E            firing = false;\u003Cbr\u003E        }\u003Cbr\u003E        else if (fire)\u003Cbr\u003E        {\u003Cbr\u003E            Status = \u0022Firing!\u0022;\u003Cbr\u003E            engine.Activate();\u003Cbr\u003E            firing = true;\u003Cbr\u003E            this.part.stackIcon.SetIconColor(XKCDColors.RadioactiveGreen);\u003Cbr\u003E        }\u003Cbr\u003E        else if (arm)\u003Cbr\u003E        {\u003Cbr\u003E            if (engine.getIgnitionState)\u003Cbr\u003E            {\u003Cbr\u003E                engine.allowShutdown = true;\u003Cbr\u003E                engine.Shutdown();\u003Cbr\u003E                engine.allowShutdown = false;\u003Cbr\u003E            }\u003Cbr\u003E            if (sf.amount \u0026gt; 0)\u003Cbr\u003E            {\u003Cbr\u003E                if (warning)\u003Cbr\u003E                {\u003Cbr\u003E                    this.part.stackIcon.SetIconColor(XKCDColors.Red);\u003Cbr\u003E                    Status = \u0022Warning! Too Fast!\u0022;\u003Cbr\u003E                }\u003Cbr\u003E                else\u003Cbr\u003E                {\u003Cbr\u003E                    this.part.stackIcon.SetIconColor(XKCDColors.LightCyan);\u003Cbr\u003E                    Status = \u0022Armed\u0022;\u003Cbr\u003E                }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                this.part.stackIcon.SetIconColor(XKCDColors.White);\u003Cbr\u003E                Status = \u0022Idle\u0022;\u003Cbr\u003E                this.part.deactivate();\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E        prevland = this.vessel.Landed;\u003Cbr\u003E    }\u003Cbr\u003E    protected void modeconfig()\u003Cbr\u003E    {\u003Cbr\u003E        switch (mode)\u003Cbr\u003E        {\u003Cbr\u003E            case 1:\u003Cbr\u003E                //Classic\u003Cbr\u003E                warning = -v - endspeed \u0026gt; deltaV * vesselanglethrust;\u003Cbr\u003E                if (vesselanglethrust \u0026lt; 0.2)\u003Cbr\u003E                {\u003Cbr\u003E                    dmin = 0;\u003Cbr\u003E                }\u003Cbr\u003E                //else if (warning)\u003Cbr\u003E                //{\u003Cbr\u003E                    //double realend = v \u002B deltaV * vesselanglethrust;\u003Cbr\u003E                    //dmin = -1* (realend * realend - v * v) / (2 * (totalthrust / m \u002B vaccel));\u003Cbr\u003E                    //dmin = -(v * burntime \u002B 0.5 * (totalthrust / m \u002B vaccel) * burntime * burntime);\u003Cbr\u003E                    //dmin = -v * burntime;\u003Cbr\u003E                //}\u003Cbr\u003E                else if (v \u002B (totalthrust / m \u002B vaccel) * burntime \u0026gt; -endspeed)\u003Cbr\u003E                {\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                    dmin = -1 * (endspeed * endspeed - v * v) / (2 * (totalthrust * 0.90 / m \u002B vaccel));\u003Cbr\u003E                }\u003Cbr\u003E                else\u003Cbr\u003E                {\u003Cbr\u003E                    dmin = -(v * burntime \u002B 0.5 * (totalthrust / m \u002B vaccel) * burntime * burntime);\u003Cbr\u003E                }\u003Cbr\u003E                //double dfullburn = -(v \u002B Math.Max(v \u002B (totalthrust / m \u002B vaccel) * burntime,0)) * burntime / 2;\u003Cbr\u003E                //double dfullburn = -(v * burntime \u002B Math.Max(0.5 * (totalthrust / m \u002B vaccel) * burntime * burntime,0));\u003Cbr\u003E                if (!firing)\u003Cbr\u003E                { backgroundaccel = vaccel; }\u003Cbr\u003E                dfinal = dmin; //* heightmultiplier \u002B offset;\u003Cbr\u003E                //dfinal = Math.Min(dmin, dfullburn);\u003Cbr\u003E                displayd = (float)dfinal;\u003Cbr\u003E                arm = !firing;\u003Cbr\u003E                float h = height();\u003Cbr\u003E                fire = h \u0026lt; dfinal \u0026amp;\u0026amp; v \u0026lt; -1 \u0026amp;\u0026amp; !this.vessel.Landed \u0026amp;\u0026amp; sf.amount \u0026gt; 0;// \u0026amp;\u0026amp; (h/v)\u0026lt;burntime;\u003Cbr\u003E                //end = (h \u0026lt; endheight || v \u0026gt; -1 * endspeed || sf.amount == 0) \u0026amp;\u0026amp; firing;\u003Cbr\u003E                if (!firing)\u003Cbr\u003E                {\u003Cbr\u003E                    //print(\u0022w: \u0022 \u002B warning \u002B \u0022 dmin: \u0022 \u002B dmin \u002B \u0022 vf: \u0022 \u002B (v \u002B (totalthrust / m \u002B vaccel) * burntime));\u003Cbr\u003E                }\u003Cbr\u003E                end = (h \u0026lt; 0.1 || v \u0026gt; -1 * endspeed || sf.amount == 0) \u0026amp;\u0026amp; firing;\u003Cbr\u003E\u003Cbr\u003E                double areq = endspeed * endspeed -v * v / (2 * -1 * h) - backgroundaccel;\u003Cbr\u003E                double adiff = areq - vaccel;\u003Cbr\u003E                //float throt=areq * m / totalthrust;\u003Cbr\u003E                if (firing)\u003Cbr\u003E                {\u003Cbr\u003E                    engine.throttleLocked = false;\u003Cbr\u003E                    engine.useEngineResponseTime = true;\u003Cbr\u003E                    engine.engineAccelerationSpeed = 0.0f;\u003Cbr\u003E                    engine.engineDecelerationSpeed = 0.0f;\u003Cbr\u003E                    //engine.currentThrottle = Mathf.Min((float)(areq * m / totalthrust), 0);\u003Cbr\u003E                    //engine.currentThrottle = Mathf.Clamp(engine.currentThrottle \u002B (float)(adiff * m / (vesselanglethrust * partanglethrust * engine.maxThrust)), 0, 1);\u003Cbr\u003E                    //engine.currentThrottle = Mathf.Clamp(engine.currentThrottle \u002B (float)(adiff * m / totalthrust), 0, 1);\u003Cbr\u003E                    engine.currentThrottle = Mathf.Clamp((float)(areq * m *(engine.thrustPercentage/100) / totalthrust), 0, 1);\u003Cbr\u003E                    //print(engine.requestedThrust);\u003Cbr\u003E                    //print(\u0022areq: \u0022 \u002B areq \u002B \u0022 adiff: \u0022 \u002B adiff);\u003Cbr\u003E                    //print(\u0022v: \u0022 \u002B v \u002B \u0022 h: \u0022 \u002B h \u002B \u0022 rthrot: \u0022 \u002B (areq * m / totalthrust));\u003Cbr\u003E                    //print(\u0022Fuel: \u0022\u002Bsf.amount\u002B\u0022 v: \u0022 \u002Bv);\u003Cbr\u003E                    //engine.throttleLocked = true;\u003Cbr\u003E                }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                break;\u003Cbr\u003E            case 2:\u003Cbr\u003E                //Space Plane\u003Cbr\u003E                double vh = this.vessel.srf_velocity.magnitude;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                arm = !firing;\u003Cbr\u003E                fire = this.vessel.Landed \u0026amp;\u0026amp; !prevland \u0026amp;\u0026amp; sf.amount \u0026gt; 0;\u003Cbr\u003E                end = (vh \u0026lt; endspeed || vh_prev\u0026lt;vh ||sf.amount \u0026lt;= 0) \u0026amp;\u0026amp; firing;\u003Cbr\u003E                warning = vh \u0026gt; -deltaV;\u003Cbr\u003E                //if (firing)\u003Cbr\u003E                //{ print(\u0022vh: \u0022 \u002B vh); }\u003Cbr\u003E                vh_prev = vh;\u003Cbr\u003E                break;\u003Cbr\u003E            case 3:\u003Cbr\u003E                //StayPut\u003Cbr\u003E                double staydir = vesselanglethrust;// Vector3d.Dot(this.part.transform.up.normalized, up);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                arm = !firing;\u003Cbr\u003E                fire = this.vessel.Landed  \u0026amp;\u0026amp; sf.amount \u0026gt; 0; //\u0026amp;\u0026amp; v \u0026gt; 0.1\u003Cbr\u003E                end = (staydir\u0026lt;0.1 || sf.amount \u0026lt; 0.1) \u0026amp;\u0026amp; firing;\u003Cbr\u003E                warning = false;\u003Cbr\u003E\u003Cbr\u003E                break;\u003Cbr\u003E            default:\u003Cbr\u003E                break;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E    protected float height()\u003Cbr\u003E    {\u003Cbr\u003E        float dsea = (float)FlightGlobals.getAltitudeAtPos(pos);\u003Cbr\u003E        float d = dsea;\u003Cbr\u003E        if (Physics.Raycast(pos, -up, out craft, dsea \u002B 10000f, 1 \u0026lt;\u0026lt; 15))\u003Cbr\u003E        { d = Mathf.Min(dsea, craft.distance); }\u003Cbr\u003E        //else { d = dsea; }\u003Cbr\u003E        float surfheight = dsea - d;\u003Cbr\u003E        float lowestd = d;\u003Cbr\u003E        foreach (Part p in vessel.parts)\u003Cbr\u003E        {\u003Cbr\u003E            if (p.collider != null) //Makes sure the part actually has a collider to touch ground\u003Cbr\u003E            {\u003Cbr\u003E                Vector3 bottom = p.collider.ClosestPointOnBounds(vessel.mainBody.position); //Gets the bottom point\u003Cbr\u003E                float partAlt = FlightGlobals.getAltitudeAtPos(bottom) - surfheight;  //Gets the looped part alt\u003Cbr\u003E                lowestd = Mathf.Max(0, Mathf.Min(lowestd, partAlt));  //Stores the smallest value in all the parts\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E        d = lowestd;\u003Cbr\u003E        return d;\u003Cbr\u003E    }\u003Cbr\u003E    protected void forAllSym()\u003Cbr\u003E    {\u003Cbr\u003E        foreach (Part p in this.part.symmetryCounterparts)\u003Cbr\u003E        {\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            ltron = p.Modules[\u0022Landertron\u0022] as Landertron;\u003Cbr\u003E            ltron.mode = mode;\u003Cbr\u003E            ltron.ModeName = ModeName;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E    protected void guifixer()\u003Cbr\u003E    {\u003Cbr\u003E        //engine.Events[\u0022Activate Engine\u0022].guiActive = false;\u003Cbr\u003E        //engine.Actions[\u0022toggle\u0022].active = false;\u003Cbr\u003E        if (!showgui)\u003Cbr\u003E        {\u003Cbr\u003E            ltron = this.part.Modules[\u0022Landertron\u0022] as Landertron;\u003Cbr\u003E            Fields[\u0022endspeed\u0022].guiActive = false;\u003Cbr\u003E            Fields[\u0022endspeed\u0022].guiActiveEditor = false;\u003Cbr\u003E            Events[\u0022ClassicMode\u0022].guiActiveEditor = false;\u003Cbr\u003E            Events[\u0022Decouple\u0022].guiActiveUnfocused = false;\u003Cbr\u003E            Events[\u0022VSL\u0022].guiActiveEditor = false;\u003Cbr\u003E            Events[\u0022SP\u0022].guiActiveEditor = false;\u003Cbr\u003E            Fields[\u0022ModeName\u0022].guiActive = false;\u003Cbr\u003E            Fields[\u0022ModeName\u0022].guiActiveEditor = false;\u003Cbr\u003E            Fields[\u0022Status\u0022].guiActive = false;\u003Cbr\u003E            Fields[\u0022displayd\u0022].guiActive = false;\u003Cbr\u003E\u003Cbr\u003E        }\u003Cbr\u003E        else if (mode == 1 || mode==2)\u003Cbr\u003E        {\u003Cbr\u003E            //Fields[\u0022heightmultiplier\u0022].guiActive = true;\u003Cbr\u003E            //Fields[\u0022heightmultiplier\u0022].guiActiveEditor = true;\u003Cbr\u003E            //Fields[\u0022offset\u0022].guiActive = true;\u003Cbr\u003E            //Fields[\u0022offset\u0022].guiActiveEditor = true;\u003Cbr\u003E            Fields[\u0022endspeed\u0022].guiActive = true;\u003Cbr\u003E            Fields[\u0022endspeed\u0022].guiActiveEditor = true;\u003Cbr\u003E        }\u003Cbr\u003E        else\u003Cbr\u003E        {\u003Cbr\u003E            //Fields[\u0022heightmultiplier\u0022].guiActive = false;\u003Cbr\u003E            //Fields[\u0022heightmultiplier\u0022].guiActiveEditor = false;\u003Cbr\u003E            //Fields[\u0022offset\u0022].guiActive = false;\u003Cbr\u003E            //Fields[\u0022offset\u0022].guiActiveEditor = false;\u003Cbr\u003E            Fields[\u0022endspeed\u0022].guiActive = false;\u003Cbr\u003E            Fields[\u0022endspeed\u0022].guiActiveEditor = false;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E    public static AnimationState[] SetUpAnimation(string animationName, Part part)  //Thanks Majiir!\u003Cbr\u003E    {\u003Cbr\u003E        var states = new List\u0026lt;AnimationState\u0026gt;();\u003Cbr\u003E        foreach (var animation in part.FindModelAnimators(animationName))\u003Cbr\u003E        {\u003Cbr\u003E            var animationState = animation[animationName];\u003Cbr\u003E            animationState.speed = 0;\u003Cbr\u003E            animationState.enabled = true;\u003Cbr\u003E            animationState.wrapMode = WrapMode.ClampForever;\u003Cbr\u003E            animation.Blend(animationName);\u003Cbr\u003E            states.Add(animationState);\u003Cbr\u003E        }\u003Cbr\u003E        return states.ToArray();\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENow my landertrons are firing as expected.\u003C/p\u003E\u003Cp\u003EI can also send you the updated file (source and dll), if you want.\u003C/p\u003E\u003Cp\u003ECheers,\u003C/p\u003E\u003Cp\u003ETheDog\u003C/p\u003E\n"},{"CreatedByName":"ManuxKerb","CreatedById":139441,"CreatedDateTime":"2015-05-03T19:36:21Z","Content":"\n\u003Cp\u003EHi\u003C/p\u003E\u003Cp\u003EI hope to see this updated and bugfixed soon \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E I really like the idea, but could never test it, as it did not work properly \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EThanks!\u003C/p\u003E\n"},{"CreatedByName":"TheDog","CreatedById":137239,"CreatedDateTime":"2015-05-04T19:56:34Z","Content":"\n\u003Cp\u003EI had a request to share my updated DLL, and I thought of this solution:\u003C/p\u003E\u003Cp\u003EI have a temporary, unofficial patch release of my updates here:\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022https://github.com/TheDogKSP/XanderTek_XTLandertron/releases\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://github.com/TheDogKSP/XanderTek_XTLandertron/releases\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E(\u003Cspan style=\u0022color:#ff0000;\u0022\u003Epatched DLL and source only - you still need to download from the front page here first, then replace the DLL!\u003C/span\u003E)\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E**This will get pulled once XanderTek updates his release, so his release (and this thread) remains the \u0022single version of the truth\u0022**\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EThis will also get pulled should XanderTek disapprove of this unofficial patch distribution.\u003C/p\u003E\n"},{"CreatedByName":"XanderTek","CreatedById":92553,"CreatedDateTime":"2015-05-09T16:51:01Z","Content":"\n\u003Cp\u003EI totally approve of the patch TheDog, and I appreciate the help. That\u0027s the beauty of open source! I\u0027ll have the official download updated with your fixes shortly.\u003C/p\u003E\n"},{"CreatedByName":"Wuwuk","CreatedById":138928,"CreatedDateTime":"2015-05-16T10:57:37Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022XanderTek\u0022 data-cite=\u0022XanderTek\u0022\u003E\u003Cdiv\u003EI totally approve of the patch TheDog, and I appreciate the help. That\u0027s the beauty of open source! I\u0027ll have the official download updated with your fixes shortly.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EVersion \u0022v0.08\u0022 download from front page, include TheDog patched DLL?\u003C/p\u003E\n"},{"CreatedByName":"Kerbas_ad_astra","CreatedById":126593,"CreatedDateTime":"2015-05-17T00:04:40Z","Content":"\n\u003Cp\u003EFYI, KASModuleGrab is deprecated and will need to be updated to \u003Ca href=\u0022https://github.com/KospY/KIS/wiki/ModuleKISItem\u0022 rel=\u0022external nofollow\u0022\u003EModuleKISItem\u003C/a\u003E.\u003C/p\u003E\n"},{"CreatedByName":"ManuxKerb","CreatedById":139441,"CreatedDateTime":"2015-05-17T15:23:18Z","Content":"\n\u003Cp\u003EHi\u003C/p\u003E\u003Cp\u003EI made a texture so you can see that is \u0022up\u0022 on one of the landertrons as i crashed Jeb and Val because i attached them the wrong side....\u003C/p\u003E\u003Cp\u003EHere you go. Just override the texture for the trrEngine.\u003C/p\u003E\u003Cp\u003EScreenshot: \u003Ca href=\u0022http://postimg.org/image/u6sz6xx6j\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://postimg.org/image/u6sz6xx6j\u003C/a\u003E\u003C/p\u003E\u003Cp\u003ETex: \u003Ca href=\u0022http://postimg.org/image/40efhblvn/\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://postimg.org/image/40efhblvn/\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EHave fun\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-05-17T15:28:24Z\u0022 title=\u002205/17/2015 03:28  PM\u0022 data-short=\u00229 yr\u0022\u003EMay 17, 2015\u003C/time\u003E by ManuxKerb\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"ManuxKerb","CreatedById":139441,"CreatedDateTime":"2015-05-17T19:44:29Z","Content":"\n\u003Cp\u003EHi\u003C/p\u003E\u003Cp\u003EOk i just tried the landertrons again and they fiered much too early. They went straight to yellow and then after burning out to blue. \u003C/p\u003E\u003Cp\u003EThe only thing i did was rotate them 90\u00C3\u201A\u00C2\u00B0 down as the where 45 before. Could this cause this ?\u003C/p\u003E\u003Cp\u003EThanks\u003C/p\u003E\n"},{"CreatedByName":"Kerbas_ad_astra","CreatedById":126593,"CreatedDateTime":"2015-05-23T18:21:50Z","Content":"\n\u003Cp\u003EI\u0027ve made this patch that brings the specific impulses and maximum temperatures in line with stock parts, as well as overriding the volume of the hexcan to a more reasonable value. (Remember, only Engineers can attach stuff with KIS, so bring Bill and his screwdriver!)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[HexCanSF]\u003Cbr\u003E{\u003Cbr\u003E    bulkheadProfiles = srf\u003Cbr\u003E    @maxTemp = 2000\u003Cbr\u003E    -MODULE[KASModuleGrab]{}\u003Cbr\u003E\u003Cbr\u003E    MODULE\u003Cbr\u003E    {\u003Cbr\u003E        name = ModuleKISItem\u003Cbr\u003E        volumeOverride = 60\u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E@PART[XTL*]\u003Cbr\u003E{\u003Cbr\u003E    @maxTemp = 2000\u003Cbr\u003E    bulkheadProfiles = srf\u003Cbr\u003E\u003Cbr\u003E    @MODULE[ModuleEngines]\u003Cbr\u003E    {\u003Cbr\u003E        -atmosphereCurve,*{}\u003Cbr\u003E\u003Cbr\u003E        atmosphereCurve //the one from the advanced SRB\u003Cbr\u003E        {\u003Cbr\u003E            key = 0 190\u003Cbr\u003E            key = 1 170\u003Cbr\u003E            key = 7 0.001\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EHowever, the arming and firing logic needs work. Performing an elementary test with a modified Kerbal 2, the landertrons fire as soon as they are armed and don\u0027t seem to disarm -- Bill got the scare of his life when the landertron fired again as soon as he loaded it with solid fuel, tossing the capsule end over end and tossing him from the ladder. (Jeb loved it, of course, and Bob was okay with it because I\u0027d attached airbags in case the landertrons behaved oddly.)\u003C/p\u003E\n"},{"CreatedByName":"gendalf","CreatedById":17407,"CreatedDateTime":"2015-05-25T11:24:45Z","Content":"\n\u003Cp\u003Ehow to install it? \u003C/p\u003E\u003Cp\u003Edo I just move XTLandertron08 folder to the gamedata? \u003C/p\u003E\u003Cp\u003EOr \u003C/p\u003E\u003Cp\u003EXanderTek, HexCans, Landertron.cs should be separate in the gamedata?\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-05-25T11:27:26Z\u0022 title=\u002205/25/2015 11:27  AM\u0022 data-short=\u00229 yr\u0022\u003EMay 25, 2015\u003C/time\u003E by gendalf\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Thermospore","CreatedById":141603,"CreatedDateTime":"2015-06-05T23:56:33Z","Content":"\n\u003Cp\u003EAnyone else having a problem with the Landertrons just firing immediately instead of waiting for a suicide burn?\u003C/p\u003E\n"},{"CreatedByName":"Capt. Hunt","CreatedById":97860,"CreatedDateTime":"2015-06-07T18:23:50Z","Content":"\n\u003Cp\u003Eyeah, I\u0027ve got that too. They fire as soon as armed. Also, I\u0027m not sure they\u0027re stopping when your speed is zeroed, because they tend to just cause my landers to spin uncontrollably.\u003C/p\u003E\n"},{"CreatedByName":"ManuxKerb","CreatedById":139441,"CreatedDateTime":"2015-06-07T20:00:51Z","Content":"\n\u003Cp\u003EHi\u003C/p\u003E\u003Cp\u003EI got the same behaviour as you too. This is definitely a bug. I suspect it happens if you rotate the landertrons in any direction. Even just a touch. If you just attach them and dont do anything like Offset or rotate they worked in my (very quick test).\u003C/p\u003E\u003Cp\u003EDid you also rotate/offseted them ?\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-06-07T20:03:34Z\u0022 title=\u002206/07/2015 08:03  PM\u0022 data-short=\u00229 yr\u0022\u003EJune 7, 2015\u003C/time\u003E by ManuxKerb\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Thermospore","CreatedById":141603,"CreatedDateTime":"2015-06-07T20:57:01Z","Content":"\n\u003Cp\u003EHuh I tried that but they still fired immediately :/ Thanks for the response though! At least I\u0027m not the only one with this problem haha\u003C/p\u003E\n"},{"CreatedByName":"XanderTek","CreatedById":92553,"CreatedDateTime":"2015-06-23T14:45:41Z","Content":"\n\u003Cp\u003ESorry guys, something is clearly broken. It\u0027s been a while since I\u0027ve had a chance to dive back into the code, but I should be able to this weekend. I\u0027ll let you know when I have an update!\u003C/p\u003E\n"},{"CreatedByName":"AndrewB","CreatedById":146561,"CreatedDateTime":"2015-06-25T08:27:01Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022XanderTek\u0022 data-cite=\u0022XanderTek\u0022\u003E\u003Cdiv\u003ESorry guys, something is clearly broken. It\u0027s been a while since I\u0027ve had a chance to dive back into the code, but I should be able to this weekend. I\u0027ll let you know when I have an update!\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EGreat news - I\u0027m still making use of the other engines that come with this mod - they really help dealing with aerobraking, but there was a brief period where I had the landertron retrorockets working with remote tech and it was beautiful!\u003C/p\u003E\n"},{"CreatedByName":"rottielover","CreatedById":73403,"CreatedDateTime":"2015-07-11T14:00:13Z","Content":"\n\u003Cp\u003EI was just curious if you\u0027ve had a chant to take a look at the code. Love me the HGR parts and miss the functionality your plugin provides. Thank you for your efforts and time spend on this mod. Love it!\u003C/p\u003E\n"},{"CreatedByName":"Dale.s","CreatedById":101982,"CreatedDateTime":"2015-08-03T20:12:08Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022XanderTek\u0022 data-cite=\u0022XanderTek\u0022\u003E\u003Cdiv\u003ESorry guys, something is clearly broken. It\u0027s been a while since I\u0027ve had a chance to dive back into the code, but I should be able to this weekend. I\u0027ll let you know when I have an update!\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EJust a little bump to see if you made any progress with this? So many fond memory\u00C3\u00A2\u00E2\u201A\u00AC\u00E2\u201E\u00A2s of this mod (sort landing space planes, escape pods from KO) would love to get this going again!\u003C/p\u003E\n"},{"CreatedByName":"Jargon","CreatedById":149485,"CreatedDateTime":"2015-08-08T12:56:08Z","Content":"\n\u003Cp\u003EJust discovered this bug the hard way upon approaching the Mun with Jeb. I really thought I\u0027d have to sacrifice him as he was suborbital with no fuel left, except 4 landertrons which just fired him back into space.\u003C/p\u003E\u003Cp\u003EOnly just managed to put the craft down after separating the landertrons into 2 pairs. First set killed horizontal as well as accelerated him \u003Cem\u003Etowards \u003C/em\u003Ethe Mun so that the second set intended for killing off the vertical descent didn\u0027t send him into deep space. Managed to \u003Cem\u003Esafely \u003C/em\u003Eland the Kerbal way doing ~55m/s and using the poodle engine as a crumple zone \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif\u0022 alt=\u0022:D\u0022\u003E\u003C/p\u003E\u003Cp\u003ETL;DR Please fix this! Would love to see it working with RemoteTech as someone else has mentioned \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"Kerbas_ad_astra","CreatedById":126593,"CreatedDateTime":"2015-08-28T06:18:16Z","Content":"\n\u003Cp\u003EApparently, I never properly installed TheDog\u0027s recompile, since I was fiddling with XTL recently and found \u0022staticPressure\u0022 errors in my log. So, if any of you are finding your landertrons activating immediately upon arming, that might be the problem -- be sure you\u0027re grabbing his recompile (or recompiling his source, as I did when I thought he\u0027d goofed somehow and uploaded the wrong DLL, before I realized that I hadn\u0027t actually installed his to begin with).\u003C/p\u003E\u003Cp\u003EUnfortunately, while the landertrons in my testing are no longer firing prematurely, they\u0027re still finicky at best. The upper \u0022safe\u0022 limit for landing (using a testing spacecraft similar to the one in the video in the OP) seems to be about 30-40 m/s -- certainly not survivable without them, so it\u0027s an improvement, but not nearly using the full delta-V that they\u0027re capable of producing. I think that part of the issue may be framerate limits -- if a vehicle is traveling at the full 200 m/s that the landertron can theoretically compensate, it moves 3.3 meters per frame, which may not be enough time/space to properly run the engines and actually zero that velocity (braking distances measured in millimeters, according to the part context menu). Probably also involved is the more realistic atmosphere, which results in higher terminal velocity.\u003C/p\u003E\u003Cp\u003EReducing the thrust on the landertron (i.e. forcing it to start firing earlier and longer) seems to help some, and I\u0027ll continue testing (there are also some height multiplier and offset variables in the code that might help), but in the meantime, I don\u0027t think these guys are going to be the same \u0022disregard parachutes, deploy rockets\u0022 kind of solution they were before.\u003C/p\u003E\u003Cp\u003EAlso, something doesn\u0027t seem quite right with the short landing mode -- in testing, KER says they should have more than enough delta-V to get the job done, but they seem to just give up after a fraction of a second (much less than their predicted burn time). I\u0027m going to dive into the math when I get the time.\u003C/p\u003E\n"},{"CreatedByName":"Kerbas_ad_astra","CreatedById":126593,"CreatedDateTime":"2015-09-06T22:29:28Z","Content":"\n\u003Cp\u003EGood news! I\u0027ve figured out what the problems are and how to fix them.\u003C/p\u003E\u003Cp\u003EThe issue with soft-landing was that they weren\u0027t properly calculating their own Isp (with the stockalike atmosphere curve I patched them to have, they were getting stuck at 0.001 seconds), which was causing them to severely underestimate their actual delta-V, thrust, required firing distance, and everything. That\u0027s fixed now.\u003C/p\u003E\u003Cp\u003EThe giving-up short-landing rockets are caused by jitter, I think. They stop firing if the current velocity is greater than the one from the previous frame. The intent is that this detects when the ship has come to a stop and begun to accelerate backwards., but landing with a bit of a bounce can also trip that condition. I\u0027ve added some tolerance to stop that from happening further. It works in testing with the Aeris 3A, but I worry that it may be somewhat sensitive to TWR, so be careful.\u003C/p\u003E\u003Cp\u003EI\u0027ve put up the DLL as \u003Ca href=\u0022https://github.com/Kerbas-ad-astra/XanderTek_XTLandertron/releases/tag/v0.09-beta.KAA\u0022 rel=\u0022external nofollow\u0022\u003E\u003Cstrong\u003Ea release\u003C/strong\u003E\u003C/a\u003E, but if you grab the GameData folder from \u003Ca href=\u0022https://github.com/Kerbas-ad-astra/XanderTek_XTLandertron\u0022 rel=\u0022external nofollow\u0022\u003E\u003Cstrong\u003Ethe repo itself\u003C/strong\u003E\u003C/a\u003E, I\u0027ve made some changes to the part configs and such that I\u0027m happy to let XanderTek package up and release. In particular, the parts have had their Isp and thermal properties rebalanced to be in line with stock parts and gotten some scale-factor updates to work well with KIS.\u003C/p\u003E\u003Cp\u003EFinally, if anyone knows a way to tell if we\u0027re in the SPH or VAB, that would be great -- since the scene names are the same now (\u0022GameScenes.EDITOR\u0022), the code defaults everything to be in short-landing mode, even though I would probably rather use soft-landing mode if I\u0027m building something in the VAB. That\u0027s the only outstanding issue that comes to mind.\u003C/p\u003E\n"}]}