{"TopicId":33991,"ForumId":29,"TopicTitle":"Mark a landing spot on a celestial body","CreatedByName":"nobody44","CreatedById":66369,"CreatedDateTime":"2013-06-20T18:05:26Z","PageNum":1,"Articles":[{"CreatedByName":"nobody44","CreatedById":66369,"CreatedDateTime":"2013-06-20T18:05:26Z","Content":"\n\u003Cp\u003EHello,\u003C/p\u003E\u003Cp\u003EI try to mark a certain landing spot on a celestial body. I use OpenGL quads for that for now, but unfortunately this is slow. So I would like to change that, but I don\u0027t know how.\u003C/p\u003E\u003Cp\u003EMy current code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        public static void drawLandingArea (CelestialBody body, double minLatitude, double maxLatitude, \u003Cbr\u003E                                            double minLongitude, double maxLongitude, \u003Cbr\u003E                                            Color c, double rotation = 0)\u003Cbr\u003E        {\u003Cbr\u003E            double dlat = (maxLatitude - minLatitude) / 10.0;\u003Cbr\u003E            double dlog = (maxLongitude - minLongitude) / 10.0;\u003Cbr\u003E\u003Cbr\u003E            List\u0026lt;Vector3d[]\u0026gt; quads = new List\u0026lt;Vector3d[]\u0026gt; ();\u003Cbr\u003E\u003Cbr\u003E            for (double lat = minLatitude; lat \u002B dlat \u0026lt; maxLatitude; lat \u002B= dlat) {\u003Cbr\u003E                for (double log = minLongitude; log \u002B dlog \u0026lt; maxLongitude; log \u002B= dlog) {\u003Cbr\u003E                    Vector3d up1 = body.GetSurfaceNVector (lat, log);\u003Cbr\u003E                    Vector3d center1 = body.position \u002B body.Radius * up1;\u003Cbr\u003E\u003Cbr\u003E                    Vector3d up2 = body.GetSurfaceNVector (lat, log \u002B dlog);\u003Cbr\u003E                    Vector3d center2 = body.position \u002B body.Radius * up2;\u003Cbr\u003E\u003Cbr\u003E                    Vector3d up3 = body.GetSurfaceNVector (lat \u002B dlat, log \u002B dlog);\u003Cbr\u003E                    Vector3d center3 = body.position \u002B body.Radius * up3;\u003Cbr\u003E\u003Cbr\u003E                    Vector3d up4 = body.GetSurfaceNVector (lat \u002B dlat, log);\u003Cbr\u003E                    Vector3d center4 = body.position \u002B body.Radius * up4;\u003Cbr\u003E\u003Cbr\u003E                    if (!IsOccluded (center1, body)) { // this function makes sure that the quad is visible\u003Cbr\u003E                        quads.Add (new Vector3d[] { center1, center2, center3, center4});\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            GLQuadMap (quads, c);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public static void GLQuadMap (List\u0026lt;Vector3d[]\u0026gt; list, Color c)\u003Cbr\u003E        {\u003Cbr\u003E            GL.PushMatrix ();\u003Cbr\u003E            material.SetPass (0);\u003Cbr\u003E            GL.LoadOrtho ();\u003Cbr\u003E            GL.Begin (GL.QUADS);\u003Cbr\u003E            GL.Color (c);\u003Cbr\u003E            foreach(Vector3d[] vertices in list) {\u003Cbr\u003E                GLVertexMap (vertices[0]);\u003Cbr\u003E                GLVertexMap (vertices[1]);\u003Cbr\u003E                GLVertexMap (vertices[2]);\u003Cbr\u003E                GLVertexMap (vertices[3]);\u003Cbr\u003E            }\u003Cbr\u003E            GL.End ();\u003Cbr\u003E            GL.PopMatrix ();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public static void GLVertexMap (Vector3d worldPosition)\u003Cbr\u003E        {\u003Cbr\u003E            Vector3 screenPoint = PlanetariumCamera.Camera.WorldToScreenPoint (ScaledSpace.LocalToScaledSpace(worldPosition));\u003Cbr\u003E            GL.Vertex3 (screenPoint.x / Camera.main.pixelWidth, screenPoint.y / Camera.main.pixelHeight, 0);\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe result is basically what I want:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/46HrI9L.png\u0022 alt=\u002246HrI9L.png\u0022\u003E\u003C/p\u003E\u003Cp\u003EBut as I said, it is slow. So I would like to try the Unity way and create a game object with a mesh. But actually, I have *no* clue how to do that. *Any* advice is appreciated.\u003C/p\u003E\u003Cp\u003Enobody44\u003C/p\u003E\n"},{"CreatedByName":"Tex_NL","CreatedById":58254,"CreatedDateTime":"2013-06-20T18:07:23Z","Content":"\n\u003Cp\u003EMechJeb supports landing predictions. You could ask how they did it.\u003C/p\u003E\n"},{"CreatedByName":"nobody44","CreatedById":66369,"CreatedDateTime":"2013-06-21T00:30:06Z","Content":"\n\u003Cp\u003EThey use a similar code as mine. In fact I copied their stuff and adjusted it to my needs. And they mark a single landing spot, i need to mark a landing area.\u003C/p\u003E\n"},{"CreatedByName":"jheriko","CreatedById":67666,"CreatedDateTime":"2013-06-24T22:23:32Z","Content":"\n\u003Cp\u003Egl quads should be as fast as anything in game if done right... try using a vertex buffer instead of uploading the vertices to the gpu each frame, also cache the divisions by screen dimensions and multiply by the same constant. you can evaluate it once per frame instead of for every vertex. can you use a static fixed array in memory instead of the expensive list? have you tried using a triangle list instead? how about a triangle strip using pairs of degenerate triangles to connect the quads?\u003C/p\u003E\u003Cp\u003Ethis all means nothing if you are drawing, e.g. 4 quads though.\u003C/p\u003E\n"}]}