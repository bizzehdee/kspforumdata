{"TopicId":153036,"ForumId":44,"TopicTitle":"Time from periapsis is always positive","CreatedByName":"Stef Morojna","CreatedById":169585,"CreatedDateTime":"2016-12-05T12:05:44Z","PageNum":1,"Articles":[{"CreatedByName":"Stef Morojna","CreatedById":169585,"CreatedDateTime":"2016-12-05T12:05:44Z","Content":"\n\u003Cp\u003E\nI\u0027m calculating the time from periapsis, but for some reason it always returns me a positive number.\n\u003C/p\u003E\n\u003Cdiv data-role=\u0022contentPage\u0022\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022tQNZgap.png\u0022 src=\u0022http://i.imgur.com/tQNZgap.png\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nSo in this case, the calculation results correct, it gives me 5 seconds since rocket passed periapsis.\n\u003C/p\u003E\n\u003Cp\u003E\nHowever here:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u00226c3zLJM.png\u0022 src=\u0022http://i.imgur.com/6c3zLJM.png\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nAnd in this case it also gives me 5 s since we passed periapsis, it should be -5 s ( or orbital period - 5), but no it gives me the absolute value.\n\u003C/p\u003E\n\u003Cp\u003E\nHere is the code ( C#)\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode\u0022\u003E\n            GetStaticProperties(); // Calculates all the static parameters, like eccentricity semiMajoraAxis etc\n            \n            double e = _eccentricity;\n\n\t\t\t// works fine till here\n\n\t\t\ttrueAnomalyAtStart = -Math.Acos( Double3.Dot(_eccV, posIn) / (e * Double3.Magnitude(posIn)) );\n\n\t\t\tprint ( (Double3.Dot(_eccV, posIn)) / (e * Double3.Magnitude(posIn) ) );\n\n\t\t\teccentricAnomalyAtStart =  2d * Math.Atan(Math.Tan(trueAnomalyAtStart / 2d) / Math.Sqrt( (1d \u002B e) / (1d - e) ));\n\n\t\t\tanomalyToPeriapsis = (eccentricAnomalyAtStart - e * Math.Sin (eccentricAnomalyAtStart));\n\t\t\t// ^ this is the anomaly to periapsis, this is what I actually use in the orbit math\n\n\t\t\ttimeToPeriapsis = anomalyToPeriapsis / meanMotion; // this is used just to show player time to periapsis\u003C/pre\u003E\n\u003Cp\u003E\nIf anyone know what the problem is, I would really apreciate it.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-12-05T13:33:36Z\u0022 title=\u002212/05/2016 01:33  PM\u0022 data-short=\u00227 yr\u0022\u003EDecember 5, 2016\u003C/time\u003E by Stef Morojna\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Bill Phil","CreatedById":127797,"CreatedDateTime":"2016-12-05T13:43:32Z","Content":"\n\u003Cp\u003E\nI think it\u0027s because you\u0027re solving for anomaly to Periapsis in such a way that it gives you a positive angle. Periapsis is usually angle 0, and so, if\u00A0you\u0027re behind it you want a negative\u00A0angle. Adding an if statement that checks the starting anomaly with respect to the Periapsis might help.\u00A0I\u0027m not familiar with C#, though. However, I don\u0027t think you need a double for eccentricity, since it\u0027s from 0 to 1 for most conics, only with hyperbolas being greater than 1. But I\u0027m not familiar wity C#, so...\n\u003C/p\u003E\n"},{"CreatedByName":"LN400","CreatedById":140595,"CreatedDateTime":"2016-12-05T14:00:15Z","Content":"\n\u003Cp\u003E\nSeeing you use trigonometric functions, and me not knowing that programming language or the functions, have you accounted for these functions (mathematically speaking) being defined only over a 180* (pi in radians) interval?\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-12-05T14:00:55Z\u0022 title=\u002212/05/2016 02:00  PM\u0022 data-short=\u00227 yr\u0022\u003EDecember 5, 2016\u003C/time\u003E by LN400\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2016-12-05T14:19:30Z","Content":"\n\u003Cp\u003E\nAs LN400 hints, your problem starts with true anomaly computation. Cos(\u002Bx) = Cos(-x), and Acos function always returns the positive result. So your true anomaly will always fall in the [0, pi] range.\n\u003C/p\u003E\n\u003Cp\u003E\nThis isn\u0027t a mistake, either. Based on position alone, it\u0027s impossible to tell which way the object is orbiting. Which means it\u0027s impossible to tell the difference between positive and negative anomaly. You need one more piece of information that will tell you direction of motion.\n\u003C/p\u003E\n"},{"CreatedByName":"Stef Morojna","CreatedById":169585,"CreatedDateTime":"2016-12-05T19:42:57Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222875923\u0022 data-ipsquote-contentid=\u0022153036\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221480947570\u0022 data-ipsquote-userid=\u002257710\u0022 data-ipsquote-username=\u0022K^2\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n10 hours ago, K^2 said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nAs LN400 hints, your problem starts with true anomaly computation. Cos(\u002Bx) = Cos(-x), and Acos function always returns the positive result. So your true anomaly will always fall in the [0, pi] range.\n\u003C/p\u003E\n\u003Cp\u003E\nThis isn\u0027t a mistake, either. Based on position alone, it\u0027s impossible to tell which way the object is orbiting. Which means it\u0027s impossible to tell the difference between positive and negative anomaly. You need one more piece of information that will tell you direction of motion.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nI compute all the orbital parameters from position and velocity, so I should probably start by calculating what direction the orbit is going?\n\u003C/p\u003E\n\u003Cp\u003E\nEdit: I have found out that making the \u0022Mean Motion\u0022 positive or negative changes the direction the object orbits.\n\u003C/p\u003E\n\u003Cp\u003E\nEdit2: \u00A0So aparently doing this: \u00A0 MeanMotion\u00A0* Math.Sign(angularMomentum.z); \u00A0solves most of the problems ( I\u0027m not sure if this would work in 3d orbits, but it works fine for 2d)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222875883\u0022 data-ipsquote-contentid=\u0022153036\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221480945412\u0022 data-ipsquote-userid=\u0022127797\u0022 data-ipsquote-username=\u0022Bill Phil\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n10 hours ago, Bill Phil said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0However, I don\u0027t think you need a double for eccentricity, since it\u0027s from 0 to 1 for most conics, only with hyperbolas being greater than 1. But I\u0027m not familiar wity C#, so...\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nIts honestly just simpler to have all the parameters in doubles, also some extra precision never hurts.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-12-06T00:40:32Z\u0022 title=\u002212/06/2016 12:40  AM\u0022 data-short=\u00227 yr\u0022\u003EDecember 6, 2016\u003C/time\u003E by Stef Morojna\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2016-12-06T09:02:19Z","Content":"\n\u003Cp\u003E\nThere is absolutely zero reason not to use double on modern CPUs, unless you are dealing with massive arrays of numbers, where you\u0027ll be hurting for cache performance otherwise.\n\u003C/p\u003E\n\u003Cp\u003E\nAbsolutely always use double precision for intermediate results. It costs you nothing in performance, and can help you avoid nasty, unforeseen rounding errors. This includes trig operations and square roots, since modern compilers are good at replacing these with SIMD intrinsics, meaning you can compute these in double precision just as fast as single. The few rare exceptions on somewhat older CPUs where this can cost you an extra tick are not worth optimizing for at cost of precision.\n\u003C/p\u003E\n\u003Cp\u003E\nThis goes for C# as well, since JIT will convert all these trig operations to SIMD.\n\u003C/p\u003E\n"}]}