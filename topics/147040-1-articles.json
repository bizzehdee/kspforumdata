{"TopicId":147040,"ForumId":21,"TopicTitle":"Experiments in long-distance Junos","CreatedByName":"numerobis","CreatedById":62016,"CreatedDateTime":"2016-09-04T02:12:44Z","PageNum":1,"Articles":[{"CreatedByName":"numerobis","CreatedById":62016,"CreatedDateTime":"2016-09-04T02:12:44Z","Content":"\n\u003Cp\u003E\nThis post is for aircraft lovers only! I\u0027m trying to push the limits of what planes can do in KSP.\n\u003C/p\u003E\n\u003Cp\u003E\nI had a pair of contracts in early career mode that required me crew reports below X meters in six or seven far-away locations. I had the first planes, so I inspired myself from the\u00A0\u003Ca href=\u0022https://en.wikipedia.org/wiki/Rutan_Voyager\u0022 rel=\u0022external nofollow\u0022\u003ERutan Voyager\u003C/a\u003E:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022p3URk7l.png\u0022 class=\u0022ipsImage\u0022 height=\u0022590\u0022 src=\u0022http://i.imgur.com/p3URk7l.png\u0022 width=\u00221000\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nI had done a first contract with the pair of Junos on small pods, with big control surfaces for elevators and a rudder. From that success, I extrapolated that if I put on a lot more fuel on the pods a bit more wing, and then saved some weight on the tail by cutting it down to a tail fin - no rudder - and a single elevon, I\u0027d be OK. Then I noticed that three rocket fins were lighter but had the same area as one tail fin (in retrospect, I really only needed one tail fin). That plane, flown manually, made it a bit over 5,000 km. This plane is nearly half fuel on liftoff.\n\u003C/p\u003E\n\u003Cp\u003E\nNext I decided to see what I could do in sandbox with the Juno. This plane has nearly the same amount of fuel (just 10 units more):\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u00228D00KDB.png\u0022 class=\u0022ipsImage\u0022 height=\u0022590\u0022 src=\u0022http://i.imgur.com/8D00KDB.png\u0022 width=\u00221000\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nI chose to make it a single-engine plane. It still has 2t of fuel -- actually, 2.05t -- so it\u0027s supposed to take off with half the thrust and almost all the weight. I cut all the dry mass I could, and some of the drag:\n\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003E\nReplace the cockpit (1.25t) with an inline cockpit (1t), save 250kg and also allow placing an intake up front.\n\u003C/li\u003E\n\u003Cli\u003E\nReplace the tail connector with front and back adapters. Same mass (200kg) but they\u00A0carry 160\u00A0fuel between them and allow putting an intake in front and juno in back. That fuel means we can spare three Mk0 tanks, saving 75kg -- and still have extra fuel on board.\n\u003C/li\u003E\n\u003Cli\u003E\nDrop down to just one juno and intake from two, saving 109\u00A0kg and reducing drag substantially.\n\u003C/li\u003E\n\u003Cli\u003E\nReplace two pairs of structural wing E with a pair of Big-S strakes. Same mass, but they carry 200\u00A0fuel between them, so we can remove four Mk0 tanks, saving 100kg.\n\u003C/li\u003E\n\u003Cli\u003E\nReplace the fixed wheels with retractable wheels. Lower drag, just 20kg extra mass.\n\u003C/li\u003E\n\u003Cli\u003E\nRemove two of the tail pieces, leaving just one rocket fin as my vertical stabilizer. Save 20kg mass, offsetting the wheels exactly, and reducing drag.\n\u003C/li\u003E\n\u003C/ul\u003E\u003Cp\u003E\nAll in all I saved 250 \u002B 75 \u002B 109\u00A0\u002B 100\u00A0= 534kg on my airframe, and was able to carry an extra 50kg fuel with that, so my launch mass is 484kg lighter. Bonus, it looks like some scifi movie fighter. But how did I do?\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022AeWQtSH.png\u0022 class=\u0022ipsImage\u0022 height=\u0022590\u0022 src=\u0022http://i.imgur.com/AeWQtSH.png\u0022 width=\u00221000\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nWay better than a mere 5,000km! This little thing is only a bit lighter, but has half the thrust of the Voyager-styled plane, so I was surprised to even see it take off, and I was worried I wouldn\u0027t be able to climb efficiently.\n\u003C/p\u003E\n\u003Cp\u003E\nFor both planes, the flight plan\u00A0is simple: fly prograde, but don\u0027t let yourself pitch up so high that you slow down, and don\u0027t let yourself pitch down. That way you\u0027ll climb nicely out of the airport, then when your lift is only barely sufficient, you will naturally level out. As you burn fuel, you\u0027ll slowly climb, naturally, because you\u0027re lighter but have the same lift. And you\u0027ll speed up a bit, and burn less fuel per time unit -- which is a double-whammy for fuel per distance unit.\n\u003C/p\u003E\n\u003Cp\u003E\nFor my single-engine plane I wrote a kOS script. I\u0027ve since improved it, so that it can glide much further and splash\u00A0the plane down without losing the intake. The tiny single-engine plane is remarkable: I was able to splash down nearly with full fuel, then lift off from the water. I\u0027m testing it now on the twin-engine Voyager-style plane. Feel free to copy it for your own purposes:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cpre class=\u0022ipsCode\u0022\u003E\n\nprint \u0022Level-flight is active, waiting...\u0022.\nwait until ship:altitude \u0026gt; 100.\n\nparameter glideAngle is 5.\n\nlocal state is \u0022climbing\u0022.\n\nlocal targetPitch is glideAngle.\nlock steering to heading(90, targetPitch).\n\nlocal speed0 is ship:velocity:surface:mag.\n\nuntil false {\n  local flightPathAngle is 90 - vang(ship:up:vector, ship:velocity:surface).\n  local speed1 is ship:velocity:surface:mag.\n\n  local frameTime is 0.1.\n  if state = \u0022climbing\u0022 {\n    set targetPitch to max(0, flightPathAngle).\n    if speed1 \u0026lt; speed0 { set state to \u0022topping\u0022. }\n    if flightPathAngle \u0026lt; 0 { set state to \u0022falling\u0022. }\n    if ship:availableThrust = 0 { set state to \u0022gliding\u0022. }\n  } else if state = \u0022topping\u0022 {\n    // don\u0027t change targetPitch.\n    if flightPathAngle \u0026lt; targetPitch { set state to \u0022climbing\u0022. }\n  } else if state = \u0022falling\u0022 {    set targetPitch to min(0, flightPathAngle \u002B glideAngle).\n    if flightPathAngle \u0026gt; 0 { set state to \u0022climbing\u0022. }\n    if ship:availableThrust = 0 { set state to \u0022gliding\u0022. }\n  } else if state = \u0022gliding\u0022 {\n    set frameTime to 1. // save power!\n    if flightPathAngle \u0026gt; -glideAngle { set targetPitch to flightPathAngle. }\n    else { set targetPitch to min(-glideAngle, flightPathAngle \u002B glideAngle). }\n    if ship:availableThrust \u0026gt; 0 { set state to \u0022falling\u0022. }\n  }\n\n  set speed0 to speed1.\n  print state \u002B \u0022 / pitch \u0022 \u002B round(targetPitch, 2) \u002B \u0022 / path \u0022 \u002B round(flightPathAngle, 2).\n  wait frameTime.\n}\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n"},{"CreatedByName":"numerobis","CreatedById":62016,"CreatedDateTime":"2016-09-06T02:20:30Z","Content":"\n\u003Cp\u003E\nI have improved on the autopilot. Now it takes off automatically, throttles back to avoid flying too fast (about 200 m/s is just about right), and can pretty much land automatically (if I lower the gear manually). Bit of a rough landing, but hey, nothing broke. 11,263km -- nearly 3,000 km farther on the same amount of fuel, just with a better autopilot.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022NFXgTXM.png\u0022 class=\u0022ipsImage\u0022 height=\u0022750\u0022 src=\u0022http://i.imgur.com/NFXgTXM.png\u0022 width=\u00221000\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nAlso, here\u0027s a better picture of the bird, gliding at dawn, with Minmus in the background:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022A5ULSEg.png\u0022 class=\u0022ipsImage\u0022 height=\u0022750\u0022 src=\u0022http://i.imgur.com/A5ULSEg.png\u0022 width=\u00221000\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nThe code to go with that flight:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\n\u003Cspan class=\u0022pln\u0022\u003E// m/s. How fast should we go at rollback (on liftoff)?\nparameter rollbackSpeed is 35.\n\n// Degrees. When we rollback, how far should we pull up?\n// Don\u0027t set it so high we get a tail strike.\nparameter rollbackAngle is 10.\n\n// Degrees. How far below the horizon should we point when gliding?\n// Also: what\u0027s our max \u003Cabbr title=\u0022Angle of Attack\u0022\u003EAoA\u003C/abbr\u003E when we can\u0027t keep our altitude?\nparameter glideAngle is 5.\n\n// Degrees. What \u003Cabbr title=\u0022Angle of Attack\u0022\u003EAoA\u003C/abbr\u003E should we keep when in level flight?\n// Strongly recommended you build a plane that works at 0 \u003Cabbr title=\u0022Angle of Attack\u0022\u003EAoA\u003C/abbr\u003E!\nparameter levelAngle is 0.\n\n// m/s. How fast should we target? We\u0027ll be at full throttle until we reach\n// this speed; then we\u0027ll throttle back to match it.\nparameter levelSpeed is 200.\n\n// (0,1]. What\u0027s the minimum throttle we should use?\n// We internally enforce that the minThrottle is at least 1e-3 because\n// otherwise the math goes wonky and even the physics explodes.\nparameter minThrottle is 0.1.\n\nprint \u0022Level-flight is active.\u0022.\nprint \u0022Glide angle: \u0022 \u002B glideAngle.\nprint \u0022Level angle: \u0022 \u002B levelAngle.\nprint \u0022Level speed: \u0022 \u002B levelSpeed.\nprint \u0022Min throttle:\u0022 \u002B minThrottle * 100 \u002B \u0022 %\u0022.\n\nlocal state is \u0022\u0022.\nlocal speed0 is 0.\n\n// Update targetPitch and targetHeading to change the cooked steering.\n// If you don\u0027t update them, we use last frame\u0027s version.\n// We don\u0027t do anything smart about using roll to turn.\nlocal targetPitch is glideAngle.\nlocal targetHeading is 90.\n\n// In phases other than gliding, we lock throttle to the targetThrottle.\n// In gliding we save power and unlock the throttle since we can\u0027t thrust anyway\nlocal targetThrottle is 1.\n\n// If min throttle falls to 1e-15, sometimes, somehow, we break physics and\n// get runaway phantom forces. So don\u0027t let that happen.\nset minThrottle to max(1e-3, minThrottle).\n// Normally we refresh at 10 Hz (0.1s) but when gliding we go into power-saving\n// mode at 1 Hz.\nlocal refreshTime is 0.1.\n\nfunction horizontalSpeed2 {\n  local y2 is ship:velocity:surface:y ^ 2.\n  local v2 is ship:velocity:surface:sqrmagnitude.\n  return v2 - y2.\n}\nfunction horizontalSpeed {\n  return sqrt(horizontalSpeed2).\n}\nfunction controlThrottle {\n  local v2 is horizontalSpeed2().\n  local v_desired2 is levelSpeed ^ 2.\n  local throttle_desired is targetThrottle * v_desired2 / v2.\n  local throttle_diff is throttle_desired - targetThrottle.\n  local throttle_diff_per_refresh is (throttle_diff / 10.0) * refreshTime.\n  local new_throttle is targetThrottle \u002B throttle_diff_per_refresh.\n  set targetThrottle to max(min(new_throttle, 1), minThrottle).\n}\n\nfunction switchToGliding {\n  set state to \u0022gliding\u0022.\n  set refreshTime to 1.\n  unlock throttle.\n}\n\n// function gliding() { inlined below }\n\nfunction switchToClimbing {\n  set state to \u0022climbing\u0022.\n  set refreshTime to 0.1.\n  set speed0 to horizontalSpeed().\n  lock throttle to targetThrottle.\n}\n\nfunction execClimbing {\n  parameter flightPathAngle.\n  set targetPitch to max(levelAngle, flightPathAngle).\n  controlThrottle().\n  printPoweredState(flightPathAngle).\n\n  local speed1 is horizontalSpeed().\n  if ship:availableThrust = 0 {\n    switchToGliding().\n  } else if flightPathAngle \u0026lt; levelAngle {\n    switchToFalling().\n  } else if targetThrottle \u0026gt; 0.99 and speed1 \u0026lt; speed0 {\n    switchToToppingOut().\n  }\n  set speed0 to speed1.\n}\n\nfunction switchToToppingOut {\n  set state to \u0022topping-out\u0022.\n  set refreshTime to 0.1.\n  lock throttle to targetThrottle.\n}\nfunction execToppingOut {\n  parameter flightPathAngle.\n  // don\u0027t set targetPitch.\n  controlThrottle().\n  printPoweredState(flightPathAngle).\n\n  if ship:availableThrust = 0 {\n    switchToGliding().\n  } else if flightPathAngle \u0026lt; targetPitch {\n    switchToClimbing().\n  }\n}\n\nfunction switchToFalling {\n  set state to \u0022falling\u0022.\n  set refreshTime to 0.05.\n  lock throttle to targetThrottle.\n}\n\nfunction execFalling {\n  parameter flightPathAngle.\n  set targetPitch to min(levelAngle, flightPathAngle \u002B glideAngle).\n  controlThrottle().\n  printPoweredState(flightPathAngle).\n\n  if ship:availableThrust = 0 {\n    switchToGliding().\n  } else if flightPathAngle \u0026gt; 0 {\n    switchToClimbing().\n  }\n}\n\nfunction printPoweredState {\n  parameter flightPathAngle.\n  print state \u002B \u0022 / pitch \u0022 \u002B round(targetPitch, 2) \u002B \u0022 / path \u0022 \u002B round(flightPathAngle, 2) \u002B \u0022 / T \u0022 \u002B round(targetThrottle*100) \u002B \u0022%\u0022.\n}\n///////////////////////////////////////////////////////////////////////////\n// Implementing the autopilot.\n\n// Time for liftoff!\nif ship:status = \u0022LANDED\u0022 or ship:status = \u0022SPLASHED\u0022 or ship:status = \u0022PRELAUNCH\u0022 {\n  print \u0022lifting off; takeoff speed \u0022 \u002B rollbackSpeed \u002B \u0022 at pitch \u0022 \u002B rollbackAngle.\n  \u003Cabbr title=\u0022Stability Augmentation System\u0022\u003Esas\u003C/abbr\u003E on.\n  lock throttle to 1.\n  stage.\n  wait until horizontalSpeed() \u0026gt; rollbackSpeed.\n  print \u0022rolling back to \u0022 \u002B rollbackAngle.\n  \u003Cabbr title=\u0022Stability Augmentation System\u0022\u003Esas\u003C/abbr\u003E off.\n  set targetPitch to rollbackAngle.\n  lock steering to heading(90, targetPitch).\n  wait until ship:verticalspeed \u0026gt; 1 or ship:altitude \u0026gt; 100.\n  print \u0022liftoff!\u0022.\n  gear off.\n  wait until ship:altitude \u0026gt; 100.\n}\n\n\u003Cabbr title=\u0022Stability Augmentation System\u0022\u003Esas\u003C/abbr\u003E off.\nlock steering to heading(targetHeading, targetPitch).\n\nswitchToClimbing().\nuntil false {\n  local flightPathAngle is 90 - vang(ship:up:vector, ship:velocity:surface).\n\n  if state = \u0022gliding\u0022 {\n    // If flightpathangle \u0026gt; -glideAngle then flightPathAngle,\n    // else if flightPathAngle \u002B glideAngle \u0026gt; -glideAngle then -glideAngle,\n    // else flightPathAngle \u002B glideAngle\n    set targetPitch to min(max(flightPathAngle, -glideAngle), flightPathAngle \u002B glideAngle).\n    print \u0022gliding pitch \u0022 \u002B round(targetPitch, 2).\n    if ship:availableThrust \u0026gt; 0 { switchToFalling(). }\n  }\n  else if state = \u0022climbing\u0022 { execClimbing(flightPathAngle). }\n  else if state = \u0022topping-out\u0022 { execToppingOut(flightPathAngle). }\n  else if state = \u0022falling\u0022 { execFalling(flightPathAngle). }\n\n  wait refreshTime.\n}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"}]}