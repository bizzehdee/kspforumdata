{"TopicId":103118,"ForumId":29,"TopicTitle":"What is Vessel.verticalSpeed actually measuring","CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T07:15:40Z","PageNum":1,"Articles":[{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T07:15:40Z","Content":"In the course of tracking down an issue today, I found that the value returned by vessel.verticalSpeed does not match that of a manually calculated \u0022rate of change of altitude\u0022. The difference between the two values is tiny (probably inconsequential for any mod other than Pilot Assistant) but it has me questioning where the number comes from.\n\nThis is my manual calculation which has resolved the offset that kept appearing when using my altitude hold. It is simply the rate of change in altitude over the previous frame\n\n    [COLOR=#008000]// run every physics frame[/COLOR]vertSpeed = (thisVessel.altitude - lastAltitude) / TimeWarp.fixedDeltaTime;lastAltitude = thisVessel.altitude;\n\nLogging the difference between ^^ and vessel.verticalSpeed results in a noticeable difference, particularly at high speed (a half meter offset that won\u0027t go away is very noticeable when altitude is being precisely controlled)\n\n- At 20km and 1300m/s surface velocity, the highest measured diff was 0.1175m/s and an offset of 0.03-0.04m/s was consistently present\n- Squad\u0027s value is always greater than mine at a constant altitude\n\nSo if Squad isn\u0027t measuring the rate of change of altitude, what are they measuring? ([Answered](https://forum.kerbalspaceprogram.com/threads/114476-What-is-Vessel-verticalSpeed-actually-measuring?p=1817208\u0026viewfull=1#post1817208))\n\n**Edited \u003Ctime datetime=\u00222015-04-02T19:51:18Z\u0022 title=\u002204/02/2015 07:51  PM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm**"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-01T07:50:20Z","Content":"That\u0027s because Squad\u0027s value measures instantaneous velocity. You are mesuring average velocity over a period of (short) time. This is why yours will nearly always be inferior. Your method also implies a bunch of potential floating point imprecisions.\n\nBasically, vertical velocity is the magnitude of the projection of the velocity vector on the vertical vector. That\u0027s all. In code, that would be something like:\n\n    Vector3d vertical = (this.vessel.GetWorldPos3D() - this.vessel.mainBody.position).normalized; //alternatively this.vessel.upAxis should workVector3d velocity = this.vessel.rootPart.Rigidbody.velocity \u002B Krakensbane.GetFrameVelocity(); //That\u0027s basically also this.vessel.obt_velocitydouble vertSpeed = Vector3d.Dot(velocity, vertical) //Instantaneous vertical speed\n\nNote: I\u0027m \\*guessing\\* this is what squad does, because that would be the most sane way to calculate instantaneous vertical velocity when you know the velocity vector.\n\nEDIT: cleaned the code a bit. Realized I didn\u0027t need to project on the vertical axis and then get the magnitude if the vector is normalized.\n\n**Edited \u003Ctime datetime=\u00222015-04-01T08:14:07Z\u0022 title=\u002204/01/2015 08:14  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 1, 2015\u003C/time\u003E by stupid\\_chris**"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T08:35:05Z","Content":"\u003E \n\u003E This is why yours will nearly always be inferior.\n\nMy method **should** be inferior for stated reasons (\\*duh\\* on the instantaneous vs. averaging...) but is still giving results that are within acceptable margins. \n\nOn the other hand, Squad\u0027s vertical speed says the vessel has a vertical velocity of 0.05m/s even when the altitude is slowly decreasing for 10\u002B frames before and after that value is recorded (offset is consistent, not a spike)\n\nI\u0027ll check out the difference between the velocity vector and the two values shortly..."},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-01T08:39:54Z","Content":"\u003E \n\u003E My method **should** be inferior for stated reasons (\\*duh\\* on the instantaneous vs. averaging...) but is still giving results that are within acceptable margins. \n\u003E On the other hand, Squad\u0027s vertical speed says the vessel has a vertical velocity of 0.05m/s even when the altitude is slowly decreasing for 10\u002B frames before and after that value is recorded (offset is consistent, not a spike)\n\u003E \n\u003E I\u0027ll check out the difference between the velocity vector and the two values shortly...\n\nThen Squad screwed something up. Apply the code I wrote above (I\u0027d calculate everything manually as I did), it should give you the real value."},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T09:43:59Z","Content":"\u003E \n\u003E Apply the code I wrote above (I\u0027d calculate everything manually as I did), it should give you the real value.\n\nThe result from your code is a small improvement on Squad\u0027s value, but it still displays a consistent slight offset of about 0.02m/s compared to the expected value based on changes in altitude. Using the surface relative velocity was significantly worse (0.07-0.08m/s) for some reason. Both tests were run with a very consistent altitude and speed and only my original test method is consistently giving results that match the altitude data.\n\n[Raw data can be found here](https://docs.google.com/spreadsheets/d/1JNK6z7ghyeGwkS0vUi5GNKbhXX79udCC6PAzawbXspo/edit?usp=sharing) (18km tab is the comparison of the three data sets and has the most consistent altitude, 15km was testing the effects of velocity on the error, 20km uses static conditions but doesn\u0027t include the suggested method and the altitude hold was not particularly well tuned)\n\n**Edited \u003Ctime datetime=\u00222015-04-01T09:47:16Z\u0022 title=\u002204/01/2015 09:47  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 1, 2015\u003C/time\u003E by Crzyrndm**"},{"CreatedByName":"sarbian","CreatedById":57146,"CreatedDateTime":"2015-04-01T12:45:05Z","Content":"I\u0027ll copy paste a comment line I added in Mechjeb to not forget about it\n\n\u0022egg found out that vessel.pos is actually 1 frame in the future while vessel.obt\\_vel is not\u0022\n\nI have a feeling this is relevant here."},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-01T19:29:25Z","Content":"I dont know what your reference is for the \\*right\\* vertical speed, but the method you first used is flawed, because you\u0027re averaging. Regardless, I think the problem is because of floating point imprecision, and because the velocity vector is not \\*stable\\*. I think the solution is to do like Mechjeb: you need a moving average. If you need that much precision, then thatd probably the best solution."},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T20:13:03Z","Content":"\u003E \n\u003E I\u0027ll copy paste a comment line I added in Mechjeb to not forget about it\n\u003E \u0022egg found out that vessel.pos is actually 1 frame in the future while vessel.obt\\_vel is not\u0022\n\u003E \n\u003E I have a feeling this is relevant here.\n\nIf that\u0027s true, it\u0027s probably the root cause (pending testing for confirmation). It would angle the up vector very slightly forwards and add a tiny amount of horizontal velocity to the measurement. Fits with my observations of increasing error with increasing speed.\n\nEDIT\n\nUsing the last up Vector produces a negative offset of similar magnitude to the value squad reports. The average of the two \\*might\\* be the value I need, but I don\u0027t feel like using two wrong values to make one that might be right ![:D](//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif)\n\n\u003E \n\u003E I dont know what your reference is for the \\*right\\* vertical speed, but the method you first used is flawed, because you\u0027re averaging. Regardless, I think the problem is because of floating point imprecision, and because the velocity vector is not \\*stable\\*. I think the solution is to do like Mechjeb: you need a moving average. If you need that much precision, then thatd probably the best solution.\n\nIn my case, no, any calculation from velocity vectors is not going to work because they do not go to zero when the rate of change in altitude goes to zero (I can guarantee that value is \u003C10mm/s over a period of several minutes.). That particular behaviour is an absolute neccesity for the altitude control system used by Pilot Assistant to produce expected behaviour.\n\nI could maybe store the last upVector and see if that works (E: It doesn\u0027t), but failing that I will be sticking with the method that is accurate if a little less precise.\n\nEDIT\n\nStatistics comparing results from my last test (35500 samples) for anyone interested (control system using \u0022Avg VS\u0022 input)\n\n![rhkrE2Z.png](http://i.imgur.com/rhkrE2Z.png)\n\n**Edited \u003Ctime datetime=\u00222015-04-01T22:02:09Z\u0022 title=\u002204/01/2015 10:02  PM\u0022 data-short=\u00229 yr\u0022\u003EApril 1, 2015\u003C/time\u003E by Crzyrndm**"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-02T06:26:11Z","Content":"Well potato. I think I figured out where the error comes from. The velocity vector is calculated from the root part of the vessel, but the up vector is calculated from the CoM of the vessel. What that does is that in the cases where the root part is in front CoM (i.e. planes as in your tests, the up vector is not actually the right up vector. The tiny longitudinal differencr betwern both positions will cause the orthogonal prohprojection to have a value greater than 0 even when not climbing, because the up vector is actually drawn backwards. This will nearly always cause a superior value At all times. Thats the problem. Im on my phone rn but ill write a snippet of code later that should work. All in all, \\*always\\* trust vectors. If vectors are not giving you the right answer, you did something wrong. Using an averaged speed would potentially give unexpected results you definitely do not want if precision is this important."},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-02T06:56:27Z","Content":"Precision isn\u0027t amazingly important, accuracy is. Any constant offset just cannot be tolerated\n\nDon\u0027t worry about writing the code, with a possible cause identified I can handle the logic ![:P](//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_tongue.gif)\n\n**Edited \u003Ctime datetime=\u00222015-04-02T08:02:23Z\u0022 title=\u002204/02/2015 08:02  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm**"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-02T07:43:04Z","Content":"Meh, not like it\u0027s hard. If If it doesn\u0027t mind for it to be based on the root part, something like:\n\n    Vector3d vertical = (this.vessel.rootPart.transform.position - this.vessel.mainBody.position).normalized;Vector3d velocity = this.vessel.rootPart.Rigidbody.velocity \u002B Krakensbane.GetFrameVelocity();verticalSpeed = Vector3d.Dot(vertical, velocity);\n\nShould do the job."},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-02T08:02:27Z","Content":"Well, I know where Squad\u0027s number came from now. vertSpeed3 exactly matches that of vessel.verticalSpeed (calculating the up vector through the root part, offset by one frame). Neither calculation meets the requirement of zero vertical speed with a constant altitude.\n\n    lastVertical = vertical;vertical = (thisVessel.rootPart.rigidbody.position - thisVessel.mainBody.position).normalized;velocity = thisVessel.obt_velocity;vertSpeed2 = Vector3d.Dot(velocity, vertical); // worst offset yet, \u002B0.1m/svertSpeed3 = Vector3d.Dot(velocity, lastVertical); // same as vessel.verticalSpeed\n\nI wonder if this is all down to a constant altitude not being a straight line?\n\n**Edited \u003Ctime datetime=\u00222015-04-02T08:17:07Z\u0022 title=\u002204/02/2015 08:17  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm**"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-02T09:20:01Z","Content":"\u003E \n\u003E Well, I know where Squad\u0027s number came from now. vertSpeed3 exactly matches that of vessel.verticalSpeed (calculating the up vector through the root part, offset by one frame). Neither calculation meets the requirement of zero vertical speed with a constant altitude.\n\u003E \n\u003E \n\u003E \n\u003E \n\u003E \n\u003E     lastVertical = vertical;vertical = (thisVessel.rootPart.rigidbody.position - thisVessel.mainBody.position).normalized;velocity = thisVessel.obt_velocity;vertSpeed2 = Vector3d.Dot(velocity, vertical); // worst offset yet, \u002B0.1m/svertSpeed3 = Vector3d.Dot(velocity, lastVertical); // same as vessel.verticalSpeed\n\u003E \n\u003E \n\u003E \n\u003E \n\u003E I wonder if this is all down to a constant altitude not being a straight line?\n\nFirst off, you used vessel.orbital\\_velocity, which will give the same result. you need the velocity and vertical having the same origin, which is a part. Use the velocity I wrote above and it should work correctly. And yes, vertical speed being zero is about having zero altitude climb, and since Kerbin is round, that means going in a circle arc, not a straight line."},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-02T09:48:13Z","Content":"Improved by using the part velocity (herp derp), still offset.\n\nI realise that zero vertical speed == a circular path in KSP. My comment was aimed at whether the fact it is a circular path is throwing off whatever calculation is used for rigidbody.velocity (or possibly something to do with Krackensbane). For example, if the direction is determined from the last position to the current position, that would be rotated slightly upwards. That would make the correct upVec exactly halfway between the current and the previous one.\n\nEDIT\n\nInitial testing is giving very good indications that the ^^ was exactly the issue.\n\n    lastUp = vertical;vertical = (thisVessel.rootPart.transform.position - thisVessel.mainBody.position).normalized;velocity = thisVessel.rootPart.Rigidbody.velocity \u002B Krakensbane.GetFrameVelocity();vertSpeed = Vector3d.Dot((vertical \u002B lastUp) / 2, velocity); // VS calculated from upvec bisecting current and last upVec\n\nEDIT2\n\nUnless any other suggestions come up, I\u0027m going to call this solved. The ^^ calculation matches the changes in altitude with no notable offset (9um/s over 3500 samples), and Squad\u0027s calculation was already identified as this\n\n    lastVertical = vertical;vertical = (thisVessel.rootPart.rigidbody.position - thisVessel.mainBody.position).normalized;vertSpeed = Vector3d.Dot(vessel.obt_velocity, lastVertical);\n\n**Edited \u003Ctime datetime=\u00222015-04-02T10:36:41Z\u0022 title=\u002204/02/2015 10:36  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm**"}]}