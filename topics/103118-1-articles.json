{"TopicId":103118,"ForumId":29,"TopicTitle":"What is Vessel.verticalSpeed actually measuring","CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T07:15:40Z","PageNum":1,"Articles":[{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T07:15:40Z","Content":"\n\u003Cp\u003EIn the course of tracking down an issue today, I found that the value returned by vessel.verticalSpeed does not match that of a manually calculated \u0022rate of change of altitude\u0022. The difference between the two values is tiny (probably inconsequential for any mod other than Pilot Assistant) but it has me questioning where the number comes from.\u003C/p\u003E\u003Cp\u003EThis is my manual calculation which has resolved the offset that kept appearing when using my altitude hold. It is simply the rate of change in altitude over the previous frame\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E[COLOR=#008000]// run every physics frame[/COLOR]\u003Cbr\u003EvertSpeed = (thisVessel.altitude - lastAltitude) / TimeWarp.fixedDeltaTime;\u003Cbr\u003ElastAltitude = thisVessel.altitude;\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ELogging the difference between ^^ and vessel.verticalSpeed results in a noticeable difference, particularly at high speed (a half meter offset that won\u0027t go away is very noticeable when altitude is being precisely controlled)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003EAt 20km and 1300m/s surface velocity, the highest measured diff was 0.1175m/s and an offset of 0.03-0.04m/s was consistently present\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003ESquad\u0027s value is always greater than mine at a constant altitude\u003Cbr\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ESo if Squad isn\u0027t measuring the rate of change of altitude, what are they measuring? (\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/threads/114476-What-is-Vessel-verticalSpeed-actually-measuring?p=1817208\u0026amp;viewfull=1#post1817208\u0022 rel=\u0022external nofollow\u0022\u003EAnswered\u003C/a\u003E)\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-02T19:51:18Z\u0022 title=\u002204/02/2015 07:51  PM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-01T07:50:20Z","Content":"\n\u003Cp\u003EThat\u0027s because Squad\u0027s value measures instantaneous velocity. You are mesuring average velocity over a period of (short) time. This is why yours will nearly always be inferior. Your method also implies a bunch of potential floating point imprecisions.\u003C/p\u003E\u003Cp\u003EBasically, vertical velocity is the magnitude of the projection of the velocity vector on the vertical vector. That\u0027s all. In code, that would be something like:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EVector3d vertical = (this.vessel.GetWorldPos3D() - this.vessel.mainBody.position).normalized; //alternatively this.vessel.upAxis should work\u003Cbr\u003EVector3d velocity = this.vessel.rootPart.Rigidbody.velocity \u002B Krakensbane.GetFrameVelocity(); //That\u0027s basically also this.vessel.obt_velocity\u003Cbr\u003Edouble vertSpeed = Vector3d.Dot(velocity, vertical) //Instantaneous vertical speed\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENote: I\u0027m *guessing* this is what squad does, because that would be the most sane way to calculate instantaneous vertical velocity when you know the velocity vector.\u003C/p\u003E\u003Cp\u003EEDIT: cleaned the code a bit. Realized I didn\u0027t need to project on the vertical axis and then get the magnitude if the vector is normalized.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-01T08:14:07Z\u0022 title=\u002204/01/2015 08:14  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 1, 2015\u003C/time\u003E by stupid_chris\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T08:35:05Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022stupid_chris\u0022 data-cite=\u0022stupid_chris\u0022\u003E\u003Cdiv\u003EThis is why yours will nearly always be inferior.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EMy method \u003Cstrong\u003Eshould\u003C/strong\u003E be inferior for stated reasons (*duh* on the instantaneous vs. averaging...) but is still giving results that are within acceptable margins. \u003C/p\u003E\u003Cp\u003EOn the other hand, Squad\u0027s vertical speed says the vessel has a vertical velocity of 0.05m/s even when the altitude is slowly decreasing for 10\u002B frames before and after that value is recorded (offset is consistent, not a spike)\u003C/p\u003E\u003Cp\u003EI\u0027ll check out the difference between the velocity vector and the two values shortly...\u003C/p\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-01T08:39:54Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Crzyrndm\u0022 data-cite=\u0022Crzyrndm\u0022\u003E\u003Cdiv\u003EMy method \u003Cstrong\u003Eshould\u003C/strong\u003E be inferior for stated reasons (*duh* on the instantaneous vs. averaging...) but is still giving results that are within acceptable margins. \u003Cp\u003EOn the other hand, Squad\u0027s vertical speed says the vessel has a vertical velocity of 0.05m/s even when the altitude is slowly decreasing for 10\u002B frames before and after that value is recorded (offset is consistent, not a spike)\u003C/p\u003E\u003Cp\u003EI\u0027ll check out the difference between the velocity vector and the two values shortly...\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThen Squad screwed something up. Apply the code I wrote above (I\u0027d calculate everything manually as I did), it should give you the real value.\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T09:43:59Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022stupid_chris\u0022 data-cite=\u0022stupid_chris\u0022\u003E\u003Cdiv\u003EApply the code I wrote above (I\u0027d calculate everything manually as I did), it should give you the real value.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe result from your code is a small improvement on Squad\u0027s value, but it still displays a consistent slight offset of about 0.02m/s compared to the expected value based on changes in altitude. Using the surface relative velocity was significantly worse (0.07-0.08m/s) for some reason. Both tests were run with a very consistent altitude and speed and only my original test method is consistently giving results that match the altitude data.\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022https://docs.google.com/spreadsheets/d/1JNK6z7ghyeGwkS0vUi5GNKbhXX79udCC6PAzawbXspo/edit?usp=sharing\u0022 rel=\u0022external nofollow\u0022\u003ERaw data can be found here\u003C/a\u003E (18km tab is the comparison of the three data sets and has the most consistent altitude, 15km was testing the effects of velocity on the error, 20km uses static conditions but doesn\u0027t include the suggested method and the altitude hold was not particularly well tuned)\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-01T09:47:16Z\u0022 title=\u002204/01/2015 09:47  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 1, 2015\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"sarbian","CreatedById":57146,"CreatedDateTime":"2015-04-01T12:45:05Z","Content":"\n\u003Cp\u003EI\u0027ll copy paste a comment line I added in Mechjeb to not forget about it\u003C/p\u003E\u003Cp\u003E\u0022egg found out that vessel.pos is actually 1 frame in the future while vessel.obt_vel is not\u0022\u003C/p\u003E\u003Cp\u003EI have a feeling this is relevant here.\u003C/p\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-01T19:29:25Z","Content":"\n\u003Cp\u003EI dont know what your reference is for the *right* vertical speed, but the method you first used is flawed, because you\u0027re averaging. Regardless, I think the problem is because of floating point imprecision, and because the velocity vector is not *stable*. I think the solution is to do like Mechjeb: you need a moving average. If you need that much precision, then thatd probably the best solution.\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-01T20:13:03Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022sarbian\u0022 data-cite=\u0022sarbian\u0022\u003E\u003Cdiv\u003EI\u0027ll copy paste a comment line I added in Mechjeb to not forget about it\u003Cp\u003E\u0022egg found out that vessel.pos is actually 1 frame in the future while vessel.obt_vel is not\u0022\u003C/p\u003E\u003Cp\u003EI have a feeling this is relevant here.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIf that\u0027s true, it\u0027s probably the root cause (pending testing for confirmation). It would angle the up vector very slightly forwards and add a tiny amount of horizontal velocity to the measurement. Fits with my observations of increasing error with increasing speed.\u003C/p\u003E\u003Cp\u003EEDIT\u003C/p\u003E\u003Cp\u003EUsing the last up Vector produces a negative offset of similar magnitude to the value squad reports. The average of the two *might* be the value I need, but I don\u0027t feel like using two wrong values to make one that might be right \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif\u0022 alt=\u0022:D\u0022\u003E\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022stupid_chris\u0022 data-cite=\u0022stupid_chris\u0022\u003E\u003Cdiv\u003EI dont know what your reference is for the *right* vertical speed, but the method you first used is flawed, because you\u0027re averaging. Regardless, I think the problem is because of floating point imprecision, and because the velocity vector is not *stable*. I think the solution is to do like Mechjeb: you need a moving average. If you need that much precision, then thatd probably the best solution.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIn my case, no, any calculation from velocity vectors is not going to work because they do not go to zero when the rate of change in altitude goes to zero (I can guarantee that value is \u0026lt;10mm/s over a period of several minutes.). That particular behaviour is an absolute neccesity for the altitude control system used by Pilot Assistant to produce expected behaviour.\u003C/p\u003E\u003Cp\u003EI could maybe store the last upVector and see if that works (E: It doesn\u0027t), but failing that I will be sticking with the method that is accurate if a little less precise.\u003C/p\u003E\u003Cp\u003EEDIT\u003C/p\u003E\u003Cp\u003EStatistics comparing results from my last test (35500 samples) for anyone interested (control system using \u0022Avg VS\u0022 input)\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/rhkrE2Z.png\u0022 alt=\u0022rhkrE2Z.png\u0022\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-01T22:02:09Z\u0022 title=\u002204/01/2015 10:02  PM\u0022 data-short=\u00229 yr\u0022\u003EApril 1, 2015\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-02T06:26:11Z","Content":"\n\u003Cp\u003EWell potato. I think I figured out where the error comes from. The velocity vector is calculated from the root part of the vessel, but the up vector is calculated from the CoM of the vessel. What that does is that in the cases where the root part is in front CoM (i.e. planes as in your tests, the up vector is not actually the right up vector. The tiny longitudinal differencr betwern both positions will cause the orthogonal prohprojection to have a value greater than 0 even when not climbing, because the up vector is actually drawn backwards. This will nearly always cause a superior value At all times. Thats the problem. Im on my phone rn but ill write a snippet of code later that should work. All in all, *always* trust vectors. If vectors are not giving you the right answer, you did something wrong. Using an averaged speed would potentially give unexpected results you definitely do not want if precision is this important.\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-02T06:56:27Z","Content":"\n\u003Cp\u003EPrecision isn\u0027t amazingly important, accuracy is. Any constant offset just cannot be tolerated\u003C/p\u003E\u003Cp\u003EDon\u0027t worry about writing the code, with a possible cause identified I can handle the logic \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_tongue.gif\u0022 alt=\u0022:P\u0022\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-02T08:02:23Z\u0022 title=\u002204/02/2015 08:02  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-02T07:43:04Z","Content":"\n\u003Cp\u003EMeh, not like it\u0027s hard. If If it doesn\u0027t mind for it to be based on the root part, something like:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EVector3d vertical = (this.vessel.rootPart.transform.position - this.vessel.mainBody.position).normalized;\u003Cbr\u003EVector3d velocity = this.vessel.rootPart.Rigidbody.velocity \u002B Krakensbane.GetFrameVelocity();\u003Cbr\u003EverticalSpeed = Vector3d.Dot(vertical, velocity);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EShould do the job.\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-02T08:02:27Z","Content":"\n\u003Cp\u003EWell, I know where Squad\u0027s number came from now. vertSpeed3 exactly matches that of vessel.verticalSpeed (calculating the up vector through the root part, offset by one frame). Neither calculation meets the requirement of zero vertical speed with a constant altitude.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003ElastVertical = vertical;\u003Cbr\u003Evertical = (thisVessel.rootPart.rigidbody.position - thisVessel.mainBody.position).normalized;\u003Cbr\u003Evelocity = thisVessel.obt_velocity;\u003Cbr\u003EvertSpeed2 = Vector3d.Dot(velocity, vertical); // worst offset yet, \u002B0.1m/s\u003Cbr\u003EvertSpeed3 = Vector3d.Dot(velocity, lastVertical); // same as vessel.verticalSpeed\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI wonder if this is all down to a constant altitude not being a straight line?\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-02T08:17:07Z\u0022 title=\u002204/02/2015 08:17  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-04-02T09:20:01Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Crzyrndm\u0022 data-cite=\u0022Crzyrndm\u0022\u003E\u003Cdiv\u003EWell, I know where Squad\u0027s number came from now. vertSpeed3 exactly matches that of vessel.verticalSpeed (calculating the up vector through the root part, offset by one frame). Neither calculation meets the requirement of zero vertical speed with a constant altitude.\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003ElastVertical = vertical;\u003Cbr\u003Evertical = (thisVessel.rootPart.rigidbody.position - thisVessel.mainBody.position).normalized;\u003Cbr\u003Evelocity = thisVessel.obt_velocity;\u003Cbr\u003EvertSpeed2 = Vector3d.Dot(velocity, vertical); // worst offset yet, \u002B0.1m/s\u003Cbr\u003EvertSpeed3 = Vector3d.Dot(velocity, lastVertical); // same as vessel.verticalSpeed\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI wonder if this is all down to a constant altitude not being a straight line?\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EFirst off, you used vessel.orbital_velocity, which will give the same result. you need the velocity and vertical having the same origin, which is a part. Use the velocity I wrote above and it should work correctly. And yes, vertical speed being zero is about having zero altitude climb, and since Kerbin is round, that means going in a circle arc, not a straight line.\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-04-02T09:48:13Z","Content":"\n\u003Cp\u003EImproved by using the part velocity (herp derp), still offset.\u003C/p\u003E\u003Cp\u003EI realise that zero vertical speed == a circular path in KSP. My comment was aimed at whether the fact it is a circular path is throwing off whatever calculation is used for rigidbody.velocity (or possibly something to do with Krackensbane). For example, if the direction is determined from the last position to the current position, that would be rotated slightly upwards. That would make the correct upVec exactly halfway between the current and the previous one.\u003C/p\u003E\u003Cp\u003EEDIT\u003C/p\u003E\u003Cp\u003EInitial testing is giving very good indications that the ^^ was exactly the issue.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003ElastUp = vertical;\u003Cbr\u003Evertical = (thisVessel.rootPart.transform.position - thisVessel.mainBody.position).normalized;\u003Cbr\u003Evelocity = thisVessel.rootPart.Rigidbody.velocity \u002B Krakensbane.GetFrameVelocity();\u003Cbr\u003EvertSpeed = Vector3d.Dot((vertical \u002B lastUp) / 2, velocity); // VS calculated from upvec bisecting current and last upVec\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EEDIT2\u003C/p\u003E\u003Cp\u003EUnless any other suggestions come up, I\u0027m going to call this solved. The ^^ calculation matches the changes in altitude with no notable offset (9um/s over 3500 samples), and Squad\u0027s calculation was already identified as this\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003ElastVertical = vertical;\u003Cbr\u003Evertical = (thisVessel.rootPart.rigidbody.position - thisVessel.mainBody.position).normalized;\u003Cbr\u003EvertSpeed = Vector3d.Dot(vessel.obt_velocity, lastVertical);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-02T10:36:41Z\u0022 title=\u002204/02/2015 10:36  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 2, 2015\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"}]}