{"TopicId":119681,"ForumId":44,"TopicTitle":"Stupid calculators","CreatedByName":"Shpaget","CreatedById":45577,"CreatedDateTime":"2015-08-29T19:00:02Z","PageNum":1,"Articles":[{"CreatedByName":"Shpaget","CreatedById":45577,"CreatedDateTime":"2015-08-29T19:00:02Z","Content":"\n\u003Cp\u003EWe\u0027ve come to rely on our pocket calculators, however, I\u0027ve come across this little gem. My Citizen SR-270X is a bit of a special needs case.\u003C/p\u003E\u003Cp\u003EWhen asking for the result of 2\u003Csup\u003E255\u003C/sup\u003E, one would expect to be presented with some huge number.\u003C/p\u003E\u003Cp\u003EThis Citizen, on the other hand, is quite firm in stating the result is 0.5.\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/03kr40e.jpg\u0022 alt=\u002203kr40e.jpg\u0022\u003E\u003C/p\u003E\u003Cp\u003EInterestingly, 255 is 11111111 in binary, which happens to be 8-bit two\u0027s-complement -1, which would mean that the calculator actually calculates 2\u003Csup\u003E-1\u003C/sup\u003E.\u003C/p\u003E\u003Cp\u003EHowever, it correctly calculates 2\u003Csup\u003E254\u003C/sup\u003E, 2\u003Csup\u003E256\u003C/sup\u003E and all the way up to 2\u003Csup\u003E332\u003C/sup\u003E. Weird.\u003C/p\u003E\n"},{"CreatedByName":"steve_v","CreatedById":69272,"CreatedDateTime":"2015-08-29T19:04:31Z","Content":"\n\u003Cp\u003EI call bug \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"Bill Phil","CreatedById":127797,"CreatedDateTime":"2015-08-29T19:36:08Z","Content":"\n\u003Cp\u003EAre you in a weird mode? The mode a calculator is in could cause some weird things to happen...\u003C/p\u003E\n"},{"CreatedByName":"Shpaget","CreatedById":45577,"CreatedDateTime":"2015-08-29T20:11:01Z","Content":"\n\u003Cp\u003ENah, just regular math stuff.\u003C/p\u003E\n"},{"CreatedByName":"peadar1987","CreatedById":81207,"CreatedDateTime":"2015-08-29T20:16:51Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022steve_v\u0022 data-cite=\u0022steve_v\u0022\u003E\u003Cdiv\u003EI call bug \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYup, obvious bug. Sort it out Squad! Jeez!\u003C/p\u003E\n"},{"CreatedByName":"SciMan","CreatedById":12748,"CreatedDateTime":"2015-08-30T01:13:46Z","Content":"\n\u003Cp\u003EI\u0027m almost certain that you\u0027re in a fixed decimal places mode. In other words, the Citizen calculator gets the same answer as the Casio, but it\u0027s truncating the answer to only show one digit after the decimal.\u003C/p\u003E\u003Cp\u003EThat, or they chose a really really odd place to save a few transistors.\u003C/p\u003E\u003Cp\u003EOf course, I\u0027m sure my TI-89 titanium would spit out the right number, but then again it\u0027s hardly fair to compare a graphing calculator to a scientific calculator.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-08-30T01:20:53Z\u0022 title=\u002208/30/2015 01:20  AM\u0022 data-short=\u00228 yr\u0022\u003EAugust 30, 2015\u003C/time\u003E by SciMan\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Camacha","CreatedById":59088,"CreatedDateTime":"2015-08-30T01:24:12Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022SciMan\u0022 data-cite=\u0022SciMan\u0022\u003E\u003Cdiv\u003EI\u0027m almost certain that you\u0027re in a fixed decimal places mode. In other words, the Citizen calculator gets the same answer as the Casio, but it\u0027s truncating the answer to only show one digit after the decimal.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou might be right there, it makes a lot of sense. Only if similar queries yield very different results, something else might be going on.\u003C/p\u003E\u003Cp\u003EEdit: the bit about similar queries is in the OP. I guess that is what you get for posting while doing other things.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-08-30T03:59:49Z\u0022 title=\u002208/30/2015 03:59  AM\u0022 data-short=\u00228 yr\u0022\u003EAugust 30, 2015\u003C/time\u003E by Camacha\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-08-30T03:05:32Z","Content":"\n\u003Cp\u003EThat\u0027s because it uses IEE floating point. 255 \u002B 127 = 382 = 0x17E. But it only has room for 2 hex digits. So the 1 is lost. It becomes just 0x7E. As an actual floating point number, it\u0027s 0x3F000000 = 0.5. Easy.\u003C/p\u003E\n"},{"CreatedByName":"Camacha","CreatedById":59088,"CreatedDateTime":"2015-08-30T04:08:13Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EThat\u0027s because it uses IEE floating point. 255 \u002B 127 = 382 = 0x17E. But it only has room for 2 hex digits. So the 1 is lost. It becomes just 0x7E. As an actual floating point number, it\u0027s 0x3F000000 = 0.5. Easy.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EHow does the 255 \u002B 127 in your explanation correspond to 2\u003Csup\u003E255\u003C/sup\u003E? How is 255 as an exponent different than 254 and 256 from the perspective of the calculator?\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-08-30T04:20:08Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Camacha\u0022 data-cite=\u0022Camacha\u0022\u003E\u003Cdiv\u003EHow does the 255 \u002B 127 in your explanation correspond to 2\u003Csup\u003E255\u003C/sup\u003E? How is 255 as an exponent different than 254 and 256 from the perspective of the calculator?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe format stores a number as sign * 2^exponent * (1 \u002B mantissa). The sign is stored as a single bit. Exponent is stored as a number between -127 and \u002B127. To achieve that, it adds 127 to the actual exponent and stores that. So number 1.0 is 2^0 * (1 \u002B 0). And so the exponent it\u0027s actually going to store is 0 \u002B 127. Since it\u0027s positive, sign bit is zero, hence 0x3F800000. Likewise, 0x3F000000 = 0.5, because now the exponent stored is just 126. 126 - 127 = -1, and 2^(-1) = 0.5.\u003C/p\u003E\u003Cp\u003EI don\u0027t see why it would work differently with 2^254. You should get 0.25 as an answer. I can imagine 2^256 not working because of some other limitation. But it\u0027s hard to tell. If it works the same, the answer should be 1.0.\u003C/p\u003E\u003Cp\u003EIn general, with this simple exponentiation algorithm, instead of 2^n, you should get 2^(((n \u002B 127)%256) - 127), where % denotes modulus operator.\u003C/p\u003E\u003Cp\u003EEdit: Many systems use double-precision instead. So the limit is 2^1023 instead of 2^127. But I haven\u0027t been able to find one that would give the same mistake on 2^2047. Everything I\u0027ve tried so far has correctly identified an overflow and displayed result as \u002BInf. (Impressively enough, Ti-89 managed to actually compute a value even for 2^2048)\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-08-30T04:33:21Z\u0022 title=\u002208/30/2015 04:33  AM\u0022 data-short=\u00228 yr\u0022\u003EAugust 30, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"SciMan","CreatedById":12748,"CreatedDateTime":"2015-08-30T04:34:02Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Camacha\u0022 data-cite=\u0022Camacha\u0022\u003E\u003Cdiv\u003EYou might be right there, it makes a lot of sense. Only if similar queries yield very different results, something else might be going on.\u003Cp\u003EEdit: the bit about similar queries is in the OP. I guess that is what you get for posting while doing other things.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWell, I guess that settles it. They chose a very odd place to save a few transistors.\u003C/p\u003E\u003Cp\u003ENow that I know it\u0027s not fixed decimal places, this looks a lot like a buffer truncation error. In other words, the last N bits of data just get chopped off the end and thrown away.\u003C/p\u003E\u003Cp\u003EThis is different from a buffer overflow error, where a buffer wraps around to 0 if it gets incremented by one while at a value of 2^N-1 where N = buffer width in bits.\u003C/p\u003E\u003Cp\u003EEx. 0xFF \u002B\u002B 0x01 = 0x00 is a buffer overflow for an 8-bit buffer, because 0x100 doesn\u0027t fit.\u003C/p\u003E\u003Cp\u003EWhatever it is, something very strange is going on here.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-08-30T04:40:07Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022SciMan\u0022 data-cite=\u0022SciMan\u0022\u003E\u003Cdiv\u003EThis is different from a buffer overflow error, where a buffer wraps around to 0 if it gets incremented by one while at a value of 2^N-1 where N = buffer width in bits.\u003Cp\u003EEx. 0xFF \u002B\u002B 0x01 = 0x00 is a buffer overflow for an 8-bit buffer, because 0x100 doesn\u0027t fit.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENo, this is precisely an overflow error, as I have explained.\u003C/p\u003E\n"},{"CreatedByName":"magnemoe","CreatedById":57801,"CreatedDateTime":"2015-08-30T04:57:10Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022SciMan\u0022 data-cite=\u0022SciMan\u0022\u003E\u003Cdiv\u003EWell, I guess that settles it. They chose a very odd place to save a few transistors.\u003Cp\u003ENow that I know it\u0027s not fixed decimal places, this looks a lot like a buffer truncation error. In other words, the last N bits of data just get chopped off the end and thrown away.\u003C/p\u003E\u003Cp\u003EThis is different from a buffer overflow error, where a buffer wraps around to 0 if it gets incremented by one while at a value of 2^N-1 where N = buffer width in bits.\u003C/p\u003E\u003Cp\u003EEx. 0xFF \u002B\u002B 0x01 = 0x00 is a buffer overflow for an 8-bit buffer, because 0x100 doesn\u0027t fit.\u003C/p\u003E\u003Cp\u003EWhatever it is, something very strange is going on here.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENormal standard is to give an error if overrun, other weird thing is that it did not switch to negative numbers but I guess sign is not first digit as in computers.\u003C/p\u003E\u003Cp\u003EI however can top this, then I was an kid I had an Commodore 64, programing in basic it insisted that 7*7=49.0001, not sure about number of zeros but it was three or more.\u003C/p\u003E\n"},{"CreatedByName":"Shpaget","CreatedById":45577,"CreatedDateTime":"2015-08-30T06:01:15Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EThe format stores a number as sign * 2^exponent * (1 \u002B mantissa). The sign is stored as a single bit. Exponent is stored as a number between -127 and \u002B127. To achieve that, it adds 127 to the actual exponent and stores that. So number 1.0 is 2^0 * (1 \u002B 0). And so the exponent it\u0027s actually going to store is 0 \u002B 127. Since it\u0027s positive, sign bit is zero, hence 0x3F800000. Likewise, 0x3F000000 = 0.5, because now the exponent stored is just 126. 126 - 127 = -1, and 2^(-1) = 0.5.\u003Cp\u003EI don\u0027t see why it would work differently with 2^254. You should get 0.25 as an answer. I can imagine 2^256 not working because of some other limitation. But it\u0027s hard to tell. If it works the same, the answer should be 1.0.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYeah, that\u0027s two\u0027s complement.\u003C/p\u003E\u003Cp\u003EIt gives correct answers for 2^254, 2^256 and everything I tested up until 2^332, after which it Gives Math Error (I suppose 9.999 x 10^99 is as high as I can go) so if it was an overflow, that shouldn\u0027t happen. It seems that that was intended to be a spot where it switches from working with 8 bits to something else, but the transition was poorly done.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-08-30T06:01:56Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022magnemoe\u0022 data-cite=\u0022magnemoe\u0022\u003E\u003Cdiv\u003ENormal standard is to give an error if overrun, other weird thing is that it did not switch to negative numbers but I guess sign is not first digit as in computers.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EPlease, read the thread. I have explained exactly what happens. Sign IS the first bit, but it\u0027s the exponent that\u0027s overflowing. It does not overflow the same way as it does in integer math.\u003C/p\u003E\u003Cp\u003EAnd by the way, all errors on over/underflows are always optional, even on PC. By default, neither integer nor floating point over/underflows generate an error. You have to set some flags to get them to trigger an exception.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Shpaget\u0022 data-cite=\u0022Shpaget\u0022\u003E\u003Cdiv\u003EYeah, that\u0027s two\u0027s complement.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENo, it is not. In two\u0027s complement, zero is zero. In IEEE exponent, zero is 127. It has the same modulus property as two\u0027s complement, but the number is shifted by a fixed offset.\u003C/p\u003E\n"},{"CreatedByName":"Shpaget","CreatedById":45577,"CreatedDateTime":"2015-08-30T06:10:53Z","Content":"\n\u003Cp\u003EYou\u0027re right.\u003C/p\u003E\u003Cp\u003ESo, any guesses why this one particular fails the rest of calculations work fine?\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-08-30T06:24:30Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Shpaget\u0022 data-cite=\u0022Shpaget\u0022\u003E\u003Cdiv\u003ESo, any guesses why this one particular fails the rest of calculations work fine?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ESeveral. For starters, as I\u0027ve indicated, a bunch of calculators use double precision. That has a larger range of exponents, -1023 to \u002B1023. Next, there could be hardware difference. Particular chip might respond to over/underflow differences. Finally, there are usually flags that specify what should happen on floating point error. Typical responses are to do nothing, to replace result with Inf/NaN as appropriate, or to throw exceptions. It\u0027s possible that this is normal \u0022do nothing\u0022 behavior for this calculator, while others tend to treat it as an error.\u003C/p\u003E\n"},{"CreatedByName":"Nuke","CreatedById":10883,"CreatedDateTime":"2015-08-30T20:38:32Z","Content":"\n\u003Cp\u003Ei wonder what 2^(254\u002B1) or 2^(256-1) would do. it might allow you to do the calculation without being totally wrong.\u003C/p\u003E\n"},{"CreatedByName":"Shpaget","CreatedById":45577,"CreatedDateTime":"2015-08-30T20:42:50Z","Content":"\n\u003Cp\u003EBoth return 0.5.\u003C/p\u003E\u003Cp\u003E2^254 x 2 and 2^256 / 2 return the correct value, though.\u003C/p\u003E\n"},{"CreatedByName":"Nuke","CreatedById":10883,"CreatedDateTime":"2015-08-31T09:43:32Z","Content":"\n\u003Cp\u003Ei thought it might cause the calculator to use a different instruction if there was an accumulation before an exponent. guess i was wrong.\u003C/p\u003E\n"},{"CreatedByName":"lugge","CreatedById":143343,"CreatedDateTime":"2015-08-31T10:31:07Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Shpaget\u0022 data-cite=\u0022Shpaget\u0022\u003E\u003Cdiv\u003ESo, any guesses why this one particular fails the rest of calculations work fine?\u003C/div\u003E\u003C/blockquote\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003ESeveral. For starters, as I\u0027ve indicated, a bunch of calculators use double precision. That has a larger range of exponents, -1023 to \u002B1023. Next, there could be hardware difference. Particular chip might respond to over/underflow differences. Finally, there are usually flags that specify what should happen on floating point error. Typical responses are to do nothing, to replace result with Inf/NaN as appropriate, or to throw exceptions. It\u0027s possible that this is normal \u0022do nothing\u0022 behavior for this calculator, while others tend to treat it as an error.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EPlease read the question from Shpaget carefully.\u003C/p\u003E\u003Cp\u003EHe asked for the the rest of calculations, not rest of calculators.\u003C/p\u003E\u003Cp\u003EYour answer still doesn\u0027t explain why 2^254 nd 2^256 seems to work correct.\u003C/p\u003E\u003Cp\u003EFor these exponents, the overrun issue (yes, FP overrun, not integer) should also occure.\u003C/p\u003E\u003Cp\u003EThis fact is it what makes the behaviour so weird.\u003C/p\u003E\n"},{"CreatedByName":"rtxoff","CreatedById":107622,"CreatedDateTime":"2015-08-31T10:38:09Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022magnemoe\u0022 data-cite=\u0022magnemoe\u0022\u003E\u003Cdiv\u003E*snip*\u003Cp\u003EI however can top this, then I was an kid I had an Commodore 64, programing in basic it insisted that 7*7=49.0001, not sure about number of zeros but it was three or more.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EDoesn\u0027t look like this:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/lVmU3QZ.png\u0022 alt=\u0022lVmU3QZ.png\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-08-31T11:20:50Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022lugge\u0022 data-cite=\u0022lugge\u0022\u003E\u003Cdiv\u003EYour answer still doesn\u0027t explain why 2^254 nd 2^256 seems to work correct.\u003Cp\u003EFor these exponents, the overrun issue (yes, FP overrun, not integer) should also occure.\u003C/p\u003E\u003Cp\u003EThis fact is it what makes the behaviour so weird.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAh, I missed the part where 254/256 work. That is, indeed, extra weird. But it\u0027s hard to say why these two are special without knowing some details on the algorithm used.\u003C/p\u003E\u003Cp\u003EI was picturing this with a^b = 2^(b ln\u003Csub\u003E2\u003C/sub\u003E(a)). This makes the exponent really fast to compute using FPU arithmetic. The ln\u003Csub\u003E2\u003C/sub\u003E can also be computed very efficiently by using FPU to get integer part, and iterating from there. But if that was the case, ln\u003Csub\u003E2\u003C/sub\u003E wourld return strictly 1.0, which would allow the rest of the algorithm to procede exactly the same for 2^254 and 2^256. I suppose, there could be some sort of a check in there that fails for some odd reason, but it\u0027s also possible that it\u0027s actually a completely different algorithm.\u003C/p\u003E\u003Cp\u003EEdit: What would the result of 2^253 be? Does it still give you correct value?\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-08-31T11:28:56Z\u0022 title=\u002208/31/2015 11:28  AM\u0022 data-short=\u00228 yr\u0022\u003EAugust 31, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Shpaget","CreatedById":45577,"CreatedDateTime":"2015-08-31T16:26:07Z","Content":"\n\u003Cp\u003E1,447401115 x 10^76\u003C/p\u003E\u003Cp\u003EMy Casio and Wolfram Alpha agree, so I suppose it\u0027s correct.\u003C/p\u003E\n"}]}