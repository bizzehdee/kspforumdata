{"TopicId":188305,"ForumId":44,"TopicTitle":"Combine risc and cisc?","CreatedByName":"Arugela","CreatedById":133381,"CreatedDateTime":"2019-09-17T07:46:17Z","PageNum":1,"Articles":[{"CreatedByName":"Arugela","CreatedById":133381,"CreatedDateTime":"2019-09-17T07:46:17Z","Content":"\n\u003Cp\u003E\n\u003Ca href=\u0022https://ieeexplore.ieee.org/document/182090\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://ieeexplore.ieee.org/document/182090\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Ca href=\u0022https://renesasrulz.com/doctor_micro/rx_blog/b/weblog/posts/cisc-and-risc-debate-continues-hybrid-wins\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://renesasrulz.com/doctor_micro/rx_blog/b/weblog/posts/cisc-and-risc-debate-continues-hybrid-wins\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nWould this benefit KSP?\n\u003C/p\u003E\n\u003Cp\u003E\nSomething was mentioning they thought macs may go risc. I was wondering if you couldn\u0027t combine them.\n\u003C/p\u003E\n\u003Cp\u003E\nOr can it be combined in more ways to get more for things like physics? Maybe more low key code for programmers.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Ca href=\u0022https://www.quora.com/Is-the-Intel-Pentium-really-a-hybrid-between-RISC-and-CISC\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://www.quora.com/Is-the-Intel-Pentium-really-a-hybrid-between-RISC-and-CISC\u003C/a\u003E\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nQuote\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cdiv\u003E\n\u003Cdiv\u003E\n\u003Cp\u003E\n\u003Cspan\u003ENo.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EIt is a CISC.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EAlso, One of the features of many RISC processors is that all the instructions could be executed in a single clock cycle. No CISC CPU can do this.\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222019-09-17T07:53:32Z\u0022 title=\u002209/17/2019 07:53  AM\u0022 data-short=\u00224 yr\u0022\u003ESeptember 17, 2019\u003C/time\u003E by Arugela\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"magnemoe","CreatedById":57801,"CreatedDateTime":"2019-09-17T12:20:29Z","Content":"\n\u003Cp\u003E\nPretty outdated information for multiple reasons.\u00A0\u003Cbr\u003E\nFirst of all back in early 90s we had just past one millions\u00A0transistors nowdays we have billions, 90% is used for cache,\u00A0branch prediction and prefetch, yes cisc uses some hundred thousands more transistors \u003Cspan\u003E\u003Cimg alt=\u0022:)\u0022 data-emoticon=\u0022\u0022 src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 title=\u0022:)\u0022\u003E\u00A0\u003C/span\u003E\u00A0\u003Cbr\u003E\nSecond lately as in last 10 years simple instructions has been hardwired risk style on x86, only more complex instructions uses microcode.\u003Cbr\u003E\nLast\u00A0cpu uses pipelines so they process one instruction in pipe each clock cycle but instruction uses multiple to pass the pipe, yes the one instruction each clock cycle was true with 1-200 MHz, not with multiple GHz\u003Cbr\u003E\u003Cbr\u003E\nNow for small\u00A0low power use cpu\u0027s risc is better, this is why they are used in cell phones and lots of embedded systems. Granted mobile cpu are not small anymore but as they uses risc its no point in switching.\u00A0\u003Cbr\u003E\nAndroid and IOS require them to run.\u00A0\u003Cbr\u003E\nOn the other hand microsoft dropped their risc versions of surface tablet as it could not run standard windows programs.\u00A0\u003Cbr\u003E\nXbox and playstation switched to x86 this generation and will continue using it for the next version.\u00A0\u003Cbr\u003E\nThis has more to do with being able to use pc hardware rather than having to design their own systems.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"wumpus","CreatedById":133850,"CreatedDateTime":"2019-09-17T14:53:16Z","Content":"\n\u003Cp\u003E\n[Warning: this is detailed and probably too long.\u00A0 I was into this type of thing back in the day]\n\u003C/p\u003E\n\u003Cp\u003E\nfurther \u0022prescript\u0022: if you want real performance increases, look at GPU architectures.\u00A0 Unfortunately, they are pretty hostile to programmers and not very compatible with nearly all algorithms and programming methods, but anything that can be made to fit their model can get extreme performance (and even bitcoin mining wasn\u0027t a great fit, but makes a good example of CPU vs. GPU power)\n\u003C/p\u003E\n\u003Cp\u003E\nCISC vs. RISC really belongs in the 1990s.\u00A0 I think there is a quote (from early editions) in Hennessy and Patterson (once \u0022The Book\u0022 on computer architecture, especially when this debate was still going on) that any architecture made after 1984 or so was called \u0022RISC\u0022.\n\u003C/p\u003E\n\u003Cp\u003E\nA quick post defining \u0022RISC\u0022 (or at least where to place real processors on a RISC-CISC continuum by a then leading name in the field). \u003Ca href=\u0022https://www.yarchive.net/comp/risc_definition.html\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://www.yarchive.net/comp/risc_definition.html\u003C/a\u003E\u003Cbr\u003E\n[tl:dr Indirect addressing was the big problem with CISC.\u00A0 Any complexity in computation is a non-issue to RISC, they just want to avoid any addressing complexity.]\n\u003C/p\u003E\n\u003Cp\u003E\nAs magnemoe mentioned, early CPUs had limited transistor budgets (modern cores have power budgets - most of the chip isn\u0027t the CPU \u0022core\u0022).\n\u003C/p\u003E\n\u003Cp\u003E\nCISC really wasn\u0027t a \u0022thing\u0022, just the old way of doing things that RISC revolted against.\u00A0\u00A0 Even so, I think the defining thing about CISC was the used of microcode.\u00A0 Microcode is basically a bit of software that turns a bundle of transistors and gates into a computer, and you pretty much have to learn how to make it to understand what it is.\u00A0 It also made designing computers, and especially much more complex computer wildly easier, so was pretty much universally adopted for CPU design.\n\u003C/p\u003E\n\u003Cp\u003E\nOnce CPU designers accepted microcode, they really weren\u0027t limited in the complexity of their instructions: the instructions were now coded as software instead of separate circuits.\u00A0 This also lead to a movement trying to \u0022close the semantic gap\u0022 by making a CPU\u0027s internal instructions (i.e. assembly language) effectively a high level language that would be easy to program.\u00A0 The Intel 432 might be seen as the high point of this idea of CISC design, while the VAX minicomputer and the 68k (especially after the 68020 \u0022improvements\u0022) are examples of success with extreme CISCyness.\n\u003C/p\u003E\n\u003Cp\u003E\nThe initial inspiration for RISC was the five step pipeline.\u00A0 Instructions wouldn\u0027t be completed in a single clock, but spread over a \u0022fetch/decode/execute/memory access/write back\u0022 pipeline with each instruction being processes on essentially an assembly line.\u00A0 So not only could they execute an instruction per cycle, the clock speed could be (theoretically) five times faster.\u00A0 Not only did RISC have the room for such things (missing all the microcode ROM and whatnot), it was also often difficult to pipeline CISC instructions.\u00A0 Another idea was to have one memory operation per instruction, any more made single cycle execution impossible (this made memory indirect access impossible, something that would make out-of-order much more viable). [Note that modern x86 CPUs have 20-30 cycle pipelines and break instructions down to \u0022load/store\u0022 levels, there isn\u0027t much difference here between CISC/RISC]\n\u003C/p\u003E\n\u003Cp\u003E\n\u0022\u003Cspan\u003EAlso, One of the features of many RISC processors is that all the instructions could be executed in a single clock cycle. No CISC CPU can do this.\u0022\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EThis is quite wrong.\u00A0 First, RISC architectures did this by simply throwing out all instructions they could that would have these issues and thus have to use multiple instructions to do the same thing (and don\u0027t underestimate just how valuable the storage space for all those instructions were when RISC (and especially CISC) were defined).\u00A0 Early RISCs couldn\u0027t execute jump or branch instructions in a single cycle as well, look up \u0022branch delay slots\u0022 for their kludge around this.\u00A0 Finally, I really think you want to include things like a \u0022divide\u0022 instruction: divide really doesn\u0027t pipeline well but you don\u0027t want to stop an emulate it with instructions (especially with an early tiny instruction cache).\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nOnce pipelining was effectively utilized, RISC designers included superscale processors (executing two instructions at once) and Out-of-order CPUs.\u00A0 These were hard to do with the simple RISC instruction sets and absolutely brutal for CISC.\u003Cbr\u003E\nVAX made two pipelined machines: one tried to pipeline instructions, the other pipelined microcode.\u00A0 The \u0022pipeline microcode\u0022 was successful but still ran 1/5 the speed of DEC\u0027s new ALPHA RISC CPU.\u003Cbr\u003E\nMotorola managed pipelining with the 68040 and superscaler execution with the 68060.\u00A0 That ended the Motorola line.\u00A0 *NOTE* anybody who had to program x86 assembler always wished that IBM had chosen Motorola instead of Intel.\u00A0 The kludginess of early x86 is hard to believe in retrospect.\u003Cbr\u003E\nIntel managed pipelining with the i486, superscaler execution with the Pentium, and Out-of-order (plus 3-way superscaler) with the Pentium Pro (at 200MHz, no less).\u00A0 It was clear that at least one CISC could run with the RISCs in performance while taking advantage of the massive infrastructure it had built over the years.\n\u003C/p\u003E\n\u003Cp\u003E\nOnce Intel broke the out-of-order barrier with the Pentium Pro not to mention the AMD Athlon hot on its heels, the RISC chips had a hard time competing on performance against chips nearly as powerful, plenty cheaper, and with infinitely more software available.\u00A0 From a design standpoint, the two biggest differences between RISC and x86 were that decoding x86 was a real pain (lots of tricks have been used, and currently a microcode cache is used by both Intel and Ryzen) and the x86 didn\u0027t have enough integer registers (floating point was worse).\u00A0 This was fixed with the AMD64 instruction set that now has 16 integer instructions (same as ARM).\u00A0 The CISC-RISC division was dead and the RISCs could only retreat back to proprietary lockin and other means to keep customers.\n\u003C/p\u003E\n\u003Cp\u003E\nWhile that all sounds straightforward, pretty much every CISC chip made after the 386/68020 era was called a \u0022RISC core executing CISC instructions\u0022.\u00A0 Curiously enough, the chips this was really true tended to fail the hardest.\u00A0 AMD\u0027s K5 chip was basically a 29k (a real RISC) based chip that translated x86 in microcode: it was a disaster (and lead to AMD buying Nexgen who made the K6).\u00A0 IBM\u0027s 605 (a PowerPC that could run x86 or PowerPC code) never made it out of the lab, although this might be from IBM already being burned by the \u0022OS/2 problem\u0022 (emulating your competition only helps increase their marketshare).\n\u003C/p\u003E\n\u003Cp\u003E\nThere really isn\u0027t a way you\u0027d want to combine \u0022RISC and CISC\u0022 anymore, RISC chips are perfectly happy including things like vector floating point multiply, and crypto instructions.\u00A0 The only CISCy thing they don\u0027t want is anything like indirect addressing (something not hard to code with separate instructions that can be then run out-of-order and tracked).\n\u003C/p\u003E\n\u003Cp\u003E\nHere\u0027s an example of how to build \u0022CISCy\u0022 instructions out of RISC ones and wildly increase the power/complexity ratio.\u00A0 To me it is more a matter of making an out-of-order much more in-order, but you might see it in RISC/CISC terms: \u003Ca href=\u0022https://repositories.lib.utexas.edu/bitstream/handle/2152/3710/tsengf71786.pdf\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://repositories.lib.utexas.edu/bitstream/handle/2152/3710/tsengf71786.pdf\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027d also like to point out that if you really wanted to make a fast chip between a 6502 and an ARM1, a stack-based architecture might have been strongly tempting.\u00A0 The ARM1 spend half the transitor/space budget on 16 32bit registers alone, and I\u0027d think that doing that with DRAM might have worked at the time (later DRAM and Logic process wouldn\u0027t be compatible, but I don\u0027t think this was true at the time).\u00A0 One catch with using a DRAM array for registers is that you could only access one operand at a time, which would work fine for a stack.\u00A0 Instructions typically take two operands and write to a third operand.\u00A0 The oldest architecture were accumulators (the 6502 was also an accumulator architecture) and would have a single operand either combined with the accumulator (single register) and the output would replace the accumulator or the accumulator would be written to memory.\u00A0 A stack[ish] would be an improvement on that with the accumulator being replaced with a \u0022top of stack\u0022.\u00A0 CISC machines would allow both inputs to come from registers (or memory) and write to a register (or memory) [with the exception that the output would be the same as one of the inputs].\u00A0 One of the defining characteristics of RISC was that they were load store: instructions either worked on 2 registers and outputed to another register (without the CISC requirement that one be the same) or load or store from memory to/from a register.\n\u003C/p\u003E\n\u003Cp\u003E\nThe point of all this \u0022single instruction operand\u0022 business would be that it would be compatible with the DRAM array (which then could fit whatever registers you needed into an early CPU).\u00A0 The downside would be that it would barely tolerate pipelining, and completely fail to go either superscaler or out-of-order (dying with the CISCs).\u00A0 But for a brief window it should really fly (much like the 6502).\n\u003C/p\u003E\n"}]}