{"TopicId":121888,"ForumId":44,"TopicTitle":"C, C\u002B\u002B, C# Programming - what is the sense in this","CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-09-28T14:21:11Z","PageNum":7,"Articles":[{"CreatedByName":"Yourself","CreatedById":4465,"CreatedDateTime":"2015-10-25T14:59:16Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003EThis may seem like a completely random injection into \u003Cem\u003Ethis\u003C/em\u003E thread, but given the tread is about the sense of the C programming language \u003Cem\u003Ethis\u003C/em\u003E should be completely appropriate. \u003Cp\u003EI was trying to write a file grabbing routine and was cloning code from the net and testing it when I ran across \u003Cem\u003Ethis\u003C/em\u003E:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E       int width, height;\u003Cbr\u003E        this.GetDefaultSize( out width, out height );\u003Cbr\u003E        this.Resize( width, height );\u003Cbr\u003E        FileChooserDialog chooser = new FileChooserDialog(\u0022Please select a File to Open\u0022, this, FileChooserAction.Open, \u003Cbr\u003E            \u0022Cancel\u0022, ResponseType.Cancel,\u0022Open\u0022, ResponseType.Accept );\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI went looking through my C/C\u002B\u002B books(5) there is nothing about \u003Cstrong\u003Ethis\u003C/strong\u003E anywhere, the object is not designed or mentioned, and surprisingly the code compiles. There was something breifly mention about this\u003C/p\u003E\u003Cp\u003Ethis-\u0026gt;month = mn;\u003C/p\u003E\u003Cp\u003EWhat da hail is \u003Cstrong\u003Ethis\u003C/strong\u003E, is there some supersecret C club in which these out-of-the-blue object handlers are passed. :^).\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe code sample there is C#, which is related to the C family of languages in name only. C\u002B\u002B has \u0060this\u0060 as a keyword, but C does not. Within a class method, \u0060this\u0060 is a pointer to the class instance that the method is currently executing on. Most of the time you don\u0027t need to use it since it\u0027s implicitly added for you. Some exceptions to this are situations where you\u0027ve named a method parameter the same as a member variable and you need to disambiguate them. Generally I prefer to name member variables with a prefix indicating that they are, in fact, member variables so that this isn\u0027t a problem.\u003C/p\u003E\u003Cp\u003EThere are other situations where the \u0060this\u0060 pointer actually does come up that are more useful. For example, methods that return a reference to the current object:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Estruct Foo\u003Cbr\u003E{\u003Cbr\u003E    Foo\u0026amp; SomeMethod( int x )\u003Cbr\u003E    {\u003Cbr\u003E        // do something with \u0027x\u0027\u003Cbr\u003E        return *this;\u003Cbr\u003E    }\u003Cbr\u003E};\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EIn a sense, all member methods really have an extra implicit parameter and that extra implicit parameter is called \u0060this\u0060 and is a pointer to the instance to operate on. So really you could imagine the above struct could also be implemented like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Estruct Foo\u003Cbr\u003E{\u003Cbr\u003E    static Foo\u0026amp; SomeMethod( Foo* this, int x )\u003Cbr\u003E    {\u003Cbr\u003E        // do something with \u0027x\u0027\u003Cbr\u003E        return *this;\u003Cbr\u003E    }\u003Cbr\u003E};\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EOf course this might prevent the compiler from being a little more clever about optimizing method calls (who knows, C\u002B\u002B compilers are absurdly complicated), but semantically it\u0027s similar to the previous situation.\u003C/p\u003E\u003Cp\u003EIn C# the semantics are a bit different since C# doesn\u0027t expose pointers (unless you\u0027re working with unsafe code, which you should rarely be doing). In C# the \u0027this\u0027 keyword is a variable containing the value of the instance that the called method is currently operating on. Like in the C\u002B\u002B case it can also be thought of as an implicit method parameter (and, in fact, the IL code emitted by the compiler treats it as such; in non-static methods the \u0060ldarg.0\u0060 instruction is always \u0060this\u0060).\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-25T15:11:45Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003EDespite being 64GB, Sandy Bridge and Ivy Bridge chipsets only allows maximum of 32GB memory when the chipset first came out. Now there are some 64 and even some 128 out there. Most everything else is in the Xeon range.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EXeons are x86-64 processors, just like the i3/i5/i7 family. They\u0027re just intended for the server/workstation market instead of the desktop/laptop market. In general, computers using Xeon processors have more memory and more CPU cores, while computers using a desktop-grade i5/i7 processor have better single-threaded performance.\u003C/p\u003E\n"},{"CreatedByName":"Kerbart","CreatedById":78303,"CreatedDateTime":"2015-10-25T15:17:38Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003E(...)the answer is that I want to create an array based on values of 2^48 bits, so it would be highly advantageous to have a method on-the-fly that reversed order and \u0027Not\u0027ed the bits, and alternative is to carve it into 2 @ 24 bits or 3 @ 16 bits(which I could use a table for). \u003Cp\u003EIn order to divide into 3 16 bit parts the QW first has to be copied rightshifted 16 copied, and rightshifted again\u003C/p\u003E\u003Cp\u003Eand copied. All bits higher than 16 need to be removed, to do this take the register, create a dummy register, rightshift 16, leftshift 16, xor with the source register, then lookup. Once the lookup is done IMul register 1 by 4,294,967,296 and add to register 3, register 2 by 65536 and add to register 3. Done.\u003C/p\u003E\u003Cp\u003ENext issue is that each needs a lookup value, since 2^48 is too large for memory it will have to be disked, by doing this I can greatly compact the array, and in doing that I don\u0027t need to process trillions of values at once. \u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Cem\u003EEach\u003C/em\u003E of them needs a lookup value? You\u0027re working with an array that actually holds 281 trillion different values? Because if you\u0027re not, wouldn\u0027t using a sparse array be a much saner solution?\u003C/p\u003E\n"},{"CreatedByName":"magnemoe","CreatedById":57801,"CreatedDateTime":"2015-10-25T15:38:33Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003EDespite being 64GB, Sandy Bridge and Ivy Bridge chipsets only allows maximum of 32GB memory when the chipset first came out. Now there are some 64 and even some 128 out there. Most everything else is in the Xeon range. In most cases this is dependent on module size each module is typically no more than 8 GB and dimms are 16, the manufactures limit this to 2 sets, as memory size increases or slots increase this goes to 8. Increasing the number of dimms slots apparently lowers memory transfer rates. Now there are a few at 64 and even 128.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThis is an motherboard limit mostly, they did not bother adding more memory support than is practical with four of the larges dimm modules. \u003C/p\u003E\u003Cp\u003EBack then I bought my 2011 socket system I did this in part because of the 32 GB limit. \u003C/p\u003E\u003Cp\u003EAs you say currently its 64 and moving over to 128 GB. \u003C/p\u003E\u003Cp\u003EI also have an strong feeling that they could easy increase the address span from 40 bit if needed. \u003C/p\u003E\u003Cp\u003EAs Jouni says this will require 40 times more memory than on the largest servers before becoming an serious issue\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-25T15:58:09Z","Content":"\n\u003Cp\u003EI think there are limits in addressing in 64 bit mode, I remember reading about these modes in the 3603 page manual. Once a 64 bit OS is installed the OS accesses memory in only using the base pointer.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E\u003Cspan style=\u0022color:#C0C0C0;\u0022\u003E- - - Updated - - -\u003C/span\u003E\u003C/span\u003E\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Kerbart\u0022 data-cite=\u0022Kerbart\u0022\u003E\u003Cdiv\u003E\u003Cem\u003EEach\u003C/em\u003E of them needs a lookup value? You\u0027re working with an array that actually holds 281 trillion different values? Because if you\u0027re not, wouldn\u0027t using a sparse array be a much saner solution?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou didn\u0027t read what I wrote. What I said was that at the asembler level or a very good c compiler you can right shift a copied 48biter by 0, 16, 32 crossreference the word in each of the three registers them sum (shift them left by 32, 16, 0, respectively). The problem is effectively building a table each and justifying and assembler call.\u003C/p\u003E\n"},{"CreatedByName":"Camacha","CreatedById":59088,"CreatedDateTime":"2015-10-25T16:32:03Z","Content":"\n\u003Cp\u003EWhat a great thread \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E It just so happens that I recently started toying with QBasic/QB64 again. I quickly found it to be a fun exercise, but a rather futile one if you want to do anything useful without also doing massive amounts of work. I switched to Visual Basic 2015 and after a good day of initial frustration, things are coming along. Many things are different, but plenty are also the same. In my younger years the programs were mostly glued together with enthusiasm, nowadays a little more structure really does help.\u003C/p\u003E\u003Cp\u003EThe Visual Basic versus C discussion is an interesting one. There is no doubt about it that C and C\u002B\u002B are seen as the standard. I am happy to say, however, that learning about VB is also allowing me to read C/C\u002B\u002B more easily. Before I could not really make much of it, now I can often at least understand the intention of the code. I have also found many API\u0027s exist for VB for programs and applications I use or am interested in, which is a definite plus if you want to dive right in.\u003C/p\u003E\u003Cp\u003EWhether I will make the switch to C/C\u002B\u002B later on depends on both the need and usefulness it will have for me. I guess I will need to dive in when I finally want to make work of those Arduinos, where every. cycle. counts. Or OpenCL, which is available for Visual Basic, but is not very well documented as compared to C.\u003C/p\u003E\u003Cp\u003EAt least I can say I am now versed in \u003Cem\u003Etwo\u003C/em\u003E useless programming languages \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif\u0022 alt=\u0022:D\u0022\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-25T16:49:05Z\u0022 title=\u002210/25/2015 04:49  PM\u0022 data-short=\u00228 yr\u0022\u003EOctober 25, 2015\u003C/time\u003E by Camacha\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Yourself","CreatedById":4465,"CreatedDateTime":"2015-10-25T16:57:22Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003Ethe answer given online was make a table, by numerous people. \u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ESure, use a small lookup table, like one that can reverse the bits of a single 8-bit byte. Then the problem reduces to just reversing the bytes in a structure and passing each of them through the lookup table (the code sample I provided had an example of this for 64-bit integers). If you try to make a lookup table for reversing every possible 48-bit value, the whole thing is going to end up being even slower because of all the memory shenanigans it\u0027ll cause. Even if you had that kind of memory available, you\u0027re basically just going to take a dump all over your cache locality and that can be a very big deal for speed.\u003C/p\u003E\u003Cp\u003EIn fact, I was curious exactly to what extent that will impact performance, so I wrote a quick little app in C# to test this out. I have 3 methods for reversing the bits in a 64-bit integer. Each one reverses it either 8-bits, 16-bits, or 24-bits at a time. I first profile generating a random 64-bit integer and xor-ing it into a result variable (to make sure nothing optimizes out the function calls, I always make sure to use the result). I then profile each of the 3 methods and subtract out the overhead from the first run.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eusing System;\u003Cbr\u003Eusing System.Diagnostics;\u003Cbr\u003E\u003Cbr\u003Enamespace ReverseProfile\u003Cbr\u003E{\u003Cbr\u003E    static class Program\u003Cbr\u003E    {\u003Cbr\u003E        const int Samples = 100000000;\u003Cbr\u003E\u003Cbr\u003E        static void Main()\u003Cbr\u003E        {\u003Cbr\u003E            var rand = new Random( 0 );\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Testing...\u0022 );\u003Cbr\u003E\u003Cbr\u003E            for( int i = 0; i \u0026lt; Samples; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                ulong x = rand.Next64();\u003Cbr\u003E\u003Cbr\u003E                if( Reverse8( x ) != Reverse16( x ) )\u003Cbr\u003E                {\u003Cbr\u003E                    Console.WriteLine( \u0022Failed: Reverse8 != Reverse16 @ 0x{0:X16}\u0022, x );\u003Cbr\u003E                    return;\u003Cbr\u003E                }\u003Cbr\u003E\u003Cbr\u003E                if( Reverse16( x ) != Reverse24( x ) )\u003Cbr\u003E                {\u003Cbr\u003E                    Console.WriteLine( \u0022Failed: Reverse16 != Reverse24 @ 0x{0:X16}\u0022, x );\u003Cbr\u003E                    return;\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Tests passed.\\n\u0022 );\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Profiling Random...\u0022 );\u003Cbr\u003E\u003Cbr\u003E            ulong r = 0;\u003Cbr\u003E            rand = new Random( 0 );\u003Cbr\u003E\u003Cbr\u003E            var sw = Stopwatch.StartNew();\u003Cbr\u003E            for( int i = 0; i \u0026lt; Samples; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                r ^= rand.Next64();\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            sw.Stop();\u003Cbr\u003E\u003Cbr\u003E            var baseTime = sw.Elapsed;\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E            Console.WriteLine( \u0022Base time: {0}/call\\n\u0022, FormatTime( baseTime ) );\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Profiling Reverse8...\u0022 );\u003Cbr\u003E            rand = new Random( 0 );\u003Cbr\u003E\u003Cbr\u003E            r = 0;\u003Cbr\u003E            sw.Restart();\u003Cbr\u003E            for( int i = 0; i \u0026lt; Samples; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                r ^= Reverse8( rand.Next64() );\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            sw.Stop();\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E            Console.WriteLine( \u0022Reverse8: {0}/call\\n\u0022, FormatTime( sw.Elapsed - baseTime ) );\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Profiling Reverse16...\u0022 );\u003Cbr\u003E            rand = new Random( 0 );\u003Cbr\u003E\u003Cbr\u003E            r = 0;\u003Cbr\u003E            sw.Restart();\u003Cbr\u003E            for( int i = 0; i \u0026lt; Samples; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                r ^= Reverse16( rand.Next64() );\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            sw.Stop();\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E            Console.WriteLine( \u0022Reverse16: {0}/call\\n\u0022, FormatTime( sw.Elapsed - baseTime ) );\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Profiling Reverse24...\u0022 );\u003Cbr\u003E            rand = new Random( 0 );\u003Cbr\u003E\u003Cbr\u003E            r = 0;\u003Cbr\u003E            sw.Restart();\u003Cbr\u003E            for( int i = 0; i \u0026lt; Samples; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                r ^= Reverse24( rand.Next64() );\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            sw.Stop();\u003Cbr\u003E\u003Cbr\u003E            Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E            Console.WriteLine( \u0022Reverse24: {0}/call\\n\u0022, FormatTime( sw.Elapsed - baseTime ) );\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        static Program()\u003Cbr\u003E        {\u003Cbr\u003E            Console.WriteLine( \u0022Initializing...\u0022 );\u003Cbr\u003E            byte[] reverse4 = { 0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE, 0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF };\u003Cbr\u003E\u003Cbr\u003E            smReverse8 = new byte[1 \u0026lt;\u0026lt; 8];\u003Cbr\u003E            for( int i = 0; i \u0026lt; smReverse8.Length; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                smReverse8[i] = (byte) ( ( reverse4[i \u0026amp; 0xF] \u0026lt;\u0026lt; 4 ) | reverse4[i \u0026gt;\u0026gt; 4] );\u003Cbr\u003E            }\u003Cbr\u003E            Console.WriteLine( \u00228-bit table built.\u0022 );\u003Cbr\u003E\u003Cbr\u003E            smReverse16 = new ushort[1 \u0026lt;\u0026lt; 16];\u003Cbr\u003E            for( int i = 0; i \u0026lt; smReverse16.Length; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                smReverse16[i] = (ushort) ( ( smReverse8[i \u0026amp; 0xFF] \u0026lt;\u0026lt; 8 ) | smReverse8[i \u0026gt;\u0026gt; 8] );\u003Cbr\u003E            }\u003Cbr\u003E            Console.WriteLine( \u002216-bit table built.\u0022 );\u003Cbr\u003E\u003Cbr\u003E            smReverse24 = new uint[1 \u0026lt;\u0026lt; 24];\u003Cbr\u003E            for( int i = 0; i \u0026lt; smReverse24.Length; \u002B\u002Bi )\u003Cbr\u003E            {\u003Cbr\u003E                smReverse24[i] =\u003Cbr\u003E                    (uint) ( ( smReverse8[i \u0026amp; 0xFF] \u0026lt;\u0026lt; 16 ) | ( smReverse8[( i \u0026gt;\u0026gt; 8 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 8 ) | smReverse8[i \u0026gt;\u0026gt; 16] );\u003Cbr\u003E            }\u003Cbr\u003E            Console.WriteLine( \u002224-bit table built.\u0022 );\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private static ulong Reverse8( ulong n )\u003Cbr\u003E        {\u003Cbr\u003E            return ( (ulong) smReverse8[n \u0026amp; 0xFF] \u0026lt;\u0026lt; 56\u003Cbr\u003E                    | (ulong) smReverse8[( n \u0026gt;\u0026gt; 8 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 48\u003Cbr\u003E                    | (ulong) smReverse8[( n \u0026gt;\u0026gt; 16 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 40\u003Cbr\u003E                    | (ulong) smReverse8[( n \u0026gt;\u0026gt; 24 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 32\u003Cbr\u003E                    | (ulong) smReverse8[( n \u0026gt;\u0026gt; 32 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 24\u003Cbr\u003E                    | (ulong) smReverse8[( n \u0026gt;\u0026gt; 40 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 16\u003Cbr\u003E                    | (ulong) smReverse8[( n \u0026gt;\u0026gt; 48 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 8\u003Cbr\u003E                    | (ulong) smReverse8[n \u0026gt;\u0026gt; 56] );\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private static ulong Reverse16( ulong n )\u003Cbr\u003E        {\u003Cbr\u003E            return ( (ulong) smReverse16[n \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 48\u003Cbr\u003E                    | (ulong) smReverse16[( n \u0026gt;\u0026gt; 16 ) \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 32\u003Cbr\u003E                    | (ulong) smReverse16[( n \u0026gt;\u0026gt; 32 ) \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 16\u003Cbr\u003E                    | (ulong) smReverse16[( n \u0026gt;\u0026gt; 48 ) \u0026amp; 0xFFFF] );\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private static ulong Reverse24( ulong n )\u003Cbr\u003E        {\u003Cbr\u003E            return ( (ulong) smReverse24[( n \u0026gt;\u0026gt; 40 ) \u0026amp; 0xFFFFFF]\u003Cbr\u003E                    | (ulong) smReverse24[( n \u0026gt;\u0026gt; 16 ) \u0026amp; 0xFFFFFF] \u0026lt;\u0026lt; 24\u003Cbr\u003E                    | (ulong) smReverse24[n \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 40 );\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private static ulong Next64( this Random rand )\u003Cbr\u003E        {\u003Cbr\u003E            return (ulong) rand.Next() \u0026lt;\u0026lt; 32 | (ulong) rand.Next();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private static string FormatTime( TimeSpan time )\u003Cbr\u003E        {\u003Cbr\u003E            double ms = time.TotalMilliseconds / Samples;\u003Cbr\u003E\u003Cbr\u003E            if( ms \u0026gt; 10000 ) return string.Format( \u0022{0} s\u0022, ms / 1000 );\u003Cbr\u003E            if( ms \u0026gt; 10 ) return string.Format( \u0022{0} ms\u0022, ms );\u003Cbr\u003E            if( ms \u0026gt; 0.01 ) return string.Format( \u0022{0} \u00C3\u201A\u00C2\u00B5s\u0022, ms * 1000 );\u003Cbr\u003E            return string.Format( \u0022{0} ns\u0022, ms * 1000000 );\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private static readonly byte[] smReverse8;\u003Cbr\u003E        private static readonly ushort[] smReverse16;\u003Cbr\u003E        private static readonly uint[] smReverse24;\u003Cbr\u003E    }\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENow, looking at the methods, one would expect Reverse16 to be about twice as fast as Reverse8 and Reverse24 to be about 3 times as fast. If computation time was purely a function of the number of instructions that pass through the CPU, anyway.\u003C/p\u003E\u003Cp\u003EHere\u0027s what a typical run looks like:\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EInitializing...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E8-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E16-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E24-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETesting...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETests passed.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Random...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4D522B76016D765B\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EBase time: 20.373974 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse8...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0xDA6EB6806ED44AB2\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse8: 8.063506 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse16...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0xDA6EB6806ED44AB2\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse16: 4.015819 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse24...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0xDA6EB6806ED44AB2\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse24: 49.221145 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003EWhat do you know, Reverse16 is about twice as fast as Reverse8, that\u0027s reassuring. But, oh, Reverse24 is over 6 times slower than Reverse8. So our prediction is off by a factor of 18, what gives? Locality of reference. The lookup table for 24 bits is too big fit in the cache so only portions of it are loaded at any given time. If we were iterating through every 64-bit value (which we\u0027re not going to do because none of us have that amount of time to wait), you\u0027d probably see completely different timing behavior. Instead, I\u0027m throwing random values at it, which means lots of cache misses and the CPU ends up spending a lot of time fetching stuff from main memory (or slower cache levels).\u003C/p\u003E\u003Cp\u003EOf course I don\u0027t know what the optimal lookup table size is. It\u0027s probably hardware dependent at the very least, but I\u0027d be willing to bet that the 16-bit lookup table is a good starting point. As usual, standard advice applies: \u003Ca href=\u0022http://c2.com/cgi/wiki?ProfileBeforeOptimizing\u0022 rel=\u0022external nofollow\u0022\u003EProfile before optimizing\u003C/a\u003E, and \u003Ca href=\u0022https://cbednarski.com/articles/make-it-work-make-it-right-make-it-fast/\u0022 rel=\u0022external nofollow\u0022\u003Emake it work, make it right, make it fast\u003C/a\u003E in that order.\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-25T18:52:36Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Yourself\u0022 data-cite=\u0022Yourself\u0022\u003E\u003Cdiv\u003EOf course I don\u0027t know what the optimal lookup table size is. It\u0027s probably hardware dependent at the very least, but I\u0027d be willing to bet that the 16-bit lookup table is a good starting point. As usual, standard advice applies: \u003Ca href=\u0022http://c2.com/cgi/wiki?ProfileBeforeOptimizing\u0022 rel=\u0022external nofollow\u0022\u003EProfile before optimizing\u003C/a\u003E, and \u003Ca href=\u0022https://cbednarski.com/articles/make-it-work-make-it-right-make-it-fast/\u0022 rel=\u0022external nofollow\u0022\u003Emake it work, make it right, make it fast\u003C/a\u003E in that order.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou may want to repeat the experiment with the random samples stored in an array instead of being generated on the fly.\u003C/p\u003E\u003Cp\u003EThese days, processors typically have 64 kilobytes of L1 cache and 256 kilobytes of L2 cache per core. An 8-bit lookup table takes 256 bytes, while a 16-bit lookup table requires 128 kilobytes. When you benchmark Reverse8() and Reverse16() with randomly generated numbers, you\u0027re essentially comparing an 8-bit lookup table in L1 cache vs. a 16-bit lookup table in L2 cache. On the other hand, if the data resides in memory (as it would in the real use case), an 8-bit lookup table would probably still remain in L1 cache most of the time, while you might have constant L2 cache misses with a 16-bit lookup table.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-25T19:37:00Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Yourself\u0022 data-cite=\u0022Yourself\u0022\u003E\u003Cdiv\u003ESure, use a small lookup table, like one that can reverse the bits of a single 8-bit byte. Then the problem reduces to just reversing the bytes in a structure and passing each of them through the lookup table (the code sample I provided had an example of this for 64-bit integers). If you try to make a lookup table for reversing every possible 48-bit value, the whole thing is going to end up being even slower because of all the memory shenanigans it\u0027ll cause. Even if you had that kind of memory available, you\u0027re basically just going to take a dump all over your cache locality and that can be a very big deal for speed.\u003Cp\u003EIn fact, I was curious exactly to what extent that will impact performance, so I wrote a quick little app in C# to test this out. I have 3 methods for reversing the bits in a 64-bit integer. Each one reverses it either 8-bits, 16-bits, or 24-bits at a time. I first profile generating a random 64-bit integer and xor-ing it into a result variable (to make sure nothing optimizes out the function calls, I always make sure to use the result). I then profile each of the 3 methods and subtract out the overhead from the first run.\u003C/p\u003E\u003Cp\u003E........\u003C/p\u003E\u003Cp\u003EHere\u0027s what a typical .......\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Random...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4D522B76016D765B\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EBase time: 20.373974 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse8...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0xDA6EB6806ED44AB2\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse8: 8.063506 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse16...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0xDA6EB6806ED44AB2\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse16: 4.015819 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse24...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0xDA6EB6806ED44AB2\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse24: 49.221145 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003EWhat do you know, Reverse16 is about twice as fast as Reverse8, that\u0027s reassuring. But, oh, Reverse24 is over 6 times slower than Reverse8. So our prediction is off by a factor of 18, what gives? Locality of reference. The lookup table for 24 bits is too big fit in the cache so only portions of it are loaded at any given time. If we were iterating through every 64-bit value (which we\u0027re not going to do because none of us have that amount of time to wait), you\u0027d probably see completely different timing behavior. Instead, I\u0027m throwing random values at it, which means lots of cache misses and the CPU ends up spending a lot of time fetching stuff from main memory (or slower cache levels).\u003C/p\u003E\u003Cp\u003EOf course I don\u0027t know what the optimal lookup table size is. It\u0027s probably hardware dependent at the very least, but I\u0027d be willing to bet that the 16-bit lookup table is a good starting point. As usual, standard advice applies: \u003Ca href=\u0022http://c2.com/cgi/wiki?ProfileBeforeOptimizing\u0022 rel=\u0022external nofollow\u0022\u003EProfile before optimizing\u003C/a\u003E, and \u003Ca href=\u0022https://cbednarski.com/articles/make-it-work-make-it-right-make-it-fast/\u0022 rel=\u0022external nofollow\u0022\u003Emake it work, make it right, make it fast\u003C/a\u003E in that order.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ECool, i suspected 16 would be. but the biggest advantage of 16 is that its a register compatible size, 32 is way too big and 8 is not specific enough.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E\u003Cspan style=\u0022color:#C0C0C0;\u0022\u003E- - - Updated - - -\u003C/span\u003E\u003C/span\u003E\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022NikkyD\u0022 data-cite=\u0022NikkyD\u0022\u003E\u003Cdiv\u003EThis thread feels either like:\u003Cp\u003E- someone wants help with his homework\u003C/p\u003E\u003Cp\u003Eor\u003C/p\u003E\u003Cp\u003E- someone wants to rant about something he doesnt like but would need\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENot homework, its a project. The major rant that i have is the documentation, partcularly for the GNU stuff is really weak.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-26T00:05:51Z\u0022 title=\u002210/26/2015 12:05  AM\u0022 data-short=\u00228 yr\u0022\u003EOctober 26, 2015\u003C/time\u003E by PB666\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Yourself","CreatedById":4465,"CreatedDateTime":"2015-10-25T19:43:53Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EYou may want to repeat the experiment with the random samples stored in an array instead of being generated on the fly.\u003Cp\u003EThese days, processors typically have 64 kilobytes of L1 cache and 256 kilobytes of L2 cache per core. An 8-bit lookup table takes 256 bytes, while a 16-bit lookup table requires 128 kilobytes. When you benchmark Reverse8() and Reverse16() with randomly generated numbers, you\u0027re essentially comparing an 8-bit lookup table in L1 cache vs. a 16-bit lookup table in L2 cache. On the other hand, if the data resides in memory (as it would in the real use case), an 8-bit lookup table would probably still remain in L1 cache most of the time, while you might have constant L2 cache misses with a 16-bit lookup table.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThat\u0027s a simple enough change, here\u0027s the modified code and results:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cdiv\u003E\u003Cbr\u003Eusing System.Diagnostics;\u003Cbr\u003E\u003Cbr\u003Enamespace ReverseProfile\u003Cbr\u003E{\u003Cbr\u003E static class Program\u003Cbr\u003E {\u003Cbr\u003E const int SampleCount = 100000000;\u003Cbr\u003E\u003Cbr\u003E static void Main()\u003Cbr\u003E {\u003Cbr\u003E var rand = new Random();\u003Cbr\u003E\u003Cbr\u003E var samples = new ulong[SampleCount];\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Testing...\u0022 );\u003Cbr\u003E\u003Cbr\u003E for( int i = 0; i \u0026lt; SampleCount; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E samples[i] = rand.Next64();\u003Cbr\u003E\u003Cbr\u003E if( Reverse8( samples[i] ) != Reverse16( samples[i] ) )\u003Cbr\u003E {\u003Cbr\u003E Console.WriteLine( \u0022Failed: Reverse8 != Reverse16 @ 0x{0:X16}\u0022, samples[i] );\u003Cbr\u003E return;\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E if( Reverse16( samples[i] ) != Reverse24( samples[i] ) )\u003Cbr\u003E {\u003Cbr\u003E Console.WriteLine( \u0022Failed: Reverse16 != Reverse24 @ 0x{0:X16}\u0022, samples[i] );\u003Cbr\u003E return;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Tests passed.\\n\u0022 );\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Profiling array access...\u0022 );\u003Cbr\u003E\u003Cbr\u003E ulong r = 0;\u003Cbr\u003E\u003Cbr\u003E var sw = Stopwatch.StartNew();\u003Cbr\u003E for( int i = 0; i \u0026lt; SampleCount; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E r ^= samples[i];\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E sw.Stop();\u003Cbr\u003E\u003Cbr\u003E var baseTime = sw.Elapsed;\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E Console.WriteLine( \u0022Base time: {0}/call\\n\u0022, FormatTime( baseTime ) );\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Profiling Reverse8...\u0022 );\u003Cbr\u003E\u003Cbr\u003E r = 0;\u003Cbr\u003E sw.Restart();\u003Cbr\u003E for( int i = 0; i \u0026lt; SampleCount; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E r ^= Reverse8( samples[i] );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E sw.Stop();\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E Console.WriteLine( \u0022Reverse8: {0}/call\\n\u0022, FormatTime( sw.Elapsed - baseTime ) );\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Profiling Reverse16...\u0022 );\u003Cbr\u003E\u003Cbr\u003E r = 0;\u003Cbr\u003E sw.Restart();\u003Cbr\u003E for( int i = 0; i \u0026lt; SampleCount; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E r ^= Reverse16( samples[i] );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E sw.Stop();\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E Console.WriteLine( \u0022Reverse16: {0}/call\\n\u0022, FormatTime( sw.Elapsed - baseTime ) );\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Profiling Reverse24...\u0022 );\u003Cbr\u003E\u003Cbr\u003E r = 0;\u003Cbr\u003E sw.Restart();\u003Cbr\u003E for( int i = 0; i \u0026lt; SampleCount; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E r ^= Reverse24( samples[i] );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E sw.Stop();\u003Cbr\u003E\u003Cbr\u003E Console.WriteLine( \u0022Result = 0x{0:X16}\u0022, r );\u003Cbr\u003E Console.WriteLine( \u0022Reverse24: {0}/call\\n\u0022, FormatTime( sw.Elapsed - baseTime ) );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E static Program()\u003Cbr\u003E {\u003Cbr\u003E Console.WriteLine( \u0022Initializing...\u0022 );\u003Cbr\u003E byte[] reverse4 = { 0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE, 0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF };\u003Cbr\u003E\u003Cbr\u003E smReverse8 = new byte[1 \u0026lt;\u0026lt; 8];\u003Cbr\u003E for( int i = 0; i \u0026lt; smReverse8.Length; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E smReverse8[i] = (byte) ( ( reverse4[i \u0026amp; 0xF] \u0026lt;\u0026lt; 4 ) | reverse4[i \u0026gt;\u0026gt; 4] );\u003Cbr\u003E }\u003Cbr\u003E Console.WriteLine( \u00228-bit table built.\u0022 );\u003Cbr\u003E\u003Cbr\u003E smReverse16 = new ushort[1 \u0026lt;\u0026lt; 16];\u003Cbr\u003E for( int i = 0; i \u0026lt; smReverse16.Length; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E smReverse16[i] = (ushort) ( ( smReverse8[i \u0026amp; 0xFF] \u0026lt;\u0026lt; 8 ) | smReverse8[i \u0026gt;\u0026gt; 8] );\u003Cbr\u003E }\u003Cbr\u003E Console.WriteLine( \u002216-bit table built.\u0022 );\u003Cbr\u003E\u003Cbr\u003E smReverse24 = new uint[1 \u0026lt;\u0026lt; 24];\u003Cbr\u003E for( int i = 0; i \u0026lt; smReverse24.Length; \u002B\u002Bi )\u003Cbr\u003E {\u003Cbr\u003E smReverse24[i] =\u003Cbr\u003E (uint) ( ( smReverse8[i \u0026amp; 0xFF] \u0026lt;\u0026lt; 16 ) | ( smReverse8[( i \u0026gt;\u0026gt; 8 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 8 ) | smReverse8[i \u0026gt;\u0026gt; 16] );\u003Cbr\u003E }\u003Cbr\u003E Console.WriteLine( \u002224-bit table built.\u0022 );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private static ulong Reverse8( ulong n )\u003Cbr\u003E {\u003Cbr\u003E return ( (ulong) smReverse8[n \u0026amp; 0xFF] \u0026lt;\u0026lt; 56\u003Cbr\u003E | (ulong) smReverse8[( n \u0026gt;\u0026gt; 8 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 48\u003Cbr\u003E | (ulong) smReverse8[( n \u0026gt;\u0026gt; 16 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 40\u003Cbr\u003E | (ulong) smReverse8[( n \u0026gt;\u0026gt; 24 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 32\u003Cbr\u003E | (ulong) smReverse8[( n \u0026gt;\u0026gt; 32 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 24\u003Cbr\u003E | (ulong) smReverse8[( n \u0026gt;\u0026gt; 40 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 16\u003Cbr\u003E | (ulong) smReverse8[( n \u0026gt;\u0026gt; 48 ) \u0026amp; 0xFF] \u0026lt;\u0026lt; 8\u003Cbr\u003E | (ulong) smReverse8[n \u0026gt;\u0026gt; 56] );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private static ulong Reverse16( ulong n )\u003Cbr\u003E {\u003Cbr\u003E return ( (ulong) smReverse16[n \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 48\u003Cbr\u003E | (ulong) smReverse16[( n \u0026gt;\u0026gt; 16 ) \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 32\u003Cbr\u003E | (ulong) smReverse16[( n \u0026gt;\u0026gt; 32 ) \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 16\u003Cbr\u003E | (ulong) smReverse16[( n \u0026gt;\u0026gt; 48 ) \u0026amp; 0xFFFF] );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private static ulong Reverse24( ulong n )\u003Cbr\u003E {\u003Cbr\u003E return ( (ulong) smReverse24[( n \u0026gt;\u0026gt; 40 ) \u0026amp; 0xFFFFFF]\u003Cbr\u003E | (ulong) smReverse24[( n \u0026gt;\u0026gt; 16 ) \u0026amp; 0xFFFFFF] \u0026lt;\u0026lt; 24\u003Cbr\u003E | (ulong) smReverse24[n \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 40 );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private static ulong Next64( this Random rand )\u003Cbr\u003E {\u003Cbr\u003E return (ulong) rand.Next() \u0026lt;\u0026lt; 32 | (ulong) rand.Next();\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private static string FormatTime( TimeSpan time )\u003Cbr\u003E {\u003Cbr\u003E double ms = time.TotalMilliseconds / SampleCount;\u003Cbr\u003E\u003Cbr\u003E if( ms \u0026gt; 10000 ) return string.Format( \u0022{0} s\u0022, ms / 1000 );\u003Cbr\u003E if( ms \u0026gt; 10 ) return string.Format( \u0022{0} ms\u0022, ms );\u003Cbr\u003E if( ms \u0026gt; 0.01 ) return string.Format( \u0022{0} \u00C3\u201A\u00C2\u00B5s\u0022, ms * 1000 );\u003Cbr\u003E return string.Format( \u0022{0} ns\u0022, ms * 1000000 );\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private static readonly byte[] smReverse8;\u003Cbr\u003E private static readonly ushort[] smReverse16;\u003Cbr\u003E private static readonly uint[] smReverse24;\u003Cbr\u003E }\u003Cbr\u003E}\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eusing System;\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EInitializing...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E8-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E16-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E24-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETesting...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETests passed.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling array access...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x6CFAB40F37C448F1\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EBase time: 1.97389 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse8...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x8F1223ECF02D5F36\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse8: 10.088138 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse16...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x8F1223ECF02D5F36\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse16: 5.013811 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse24...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x8F1223ECF02D5F36\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse24: 31.326612 ns/call\u003C/span\u003E\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-25T21:24:03Z","Content":"\n\u003Cp\u003EI did a quick C\u002B\u002B conversion of the code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003E#include \u0026lt;array\u0026gt;\u003Cbr\u003E#include \u0026lt;chrono\u0026gt;\u003Cbr\u003E#include \u0026lt;cstdint\u0026gt;\u003Cbr\u003E#include \u0026lt;iostream\u0026gt;\u003Cbr\u003E#include \u0026lt;random\u0026gt;\u003Cbr\u003E#include \u0026lt;vector\u0026gt;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Econst uint64_t SAMPLE_COUNT = 100000000;\u003Cbr\u003Econst double TO_NANO = 1000000000.0 / SAMPLE_COUNT;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Edouble\u003Cbr\u003EreadTimer()\u003Cbr\u003E{\u003Cbr\u003E std::chrono::duration\u0026lt;double\u0026gt; temp = std::chrono::steady_clock::now().time_since_epoch();\u003Cbr\u003E return temp.count();\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Estruct array_access\u003Cbr\u003E{\u003Cbr\u003E std::string name;\u003Cbr\u003E\u003Cbr\u003E array_access() : name(\u0022access\u0022) {}\u003Cbr\u003E\u003Cbr\u003E inline uint64_t operator() (uint64_t n) { return n; }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Estruct reverse8\u003Cbr\u003E{\u003Cbr\u003E std::string name;\u003Cbr\u003E std::array\u0026lt;uint8_t, 256\u0026gt; data;\u003Cbr\u003E\u003Cbr\u003E reverse8() : name(\u0022reverse8\u0022)\u003Cbr\u003E {\u003Cbr\u003E std::vector\u0026lt;uint64_t\u0026gt; reverse4 = { 0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE, 0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF };\u003Cbr\u003E for(uint64_t i = 0; i \u0026lt; data.size(); i\u002B\u002B)\u003Cbr\u003E {\u003Cbr\u003E data[i] = ((reverse4[i \u0026amp; 0xF] \u0026lt;\u0026lt; 4) | reverse4[i \u0026gt;\u0026gt; 4]);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E inline uint64_t operator() (uint64_t n) const\u003Cbr\u003E {\u003Cbr\u003E return ((uint64_t)data[n \u0026amp; 0xFF] \u0026lt;\u0026lt; 56\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 8) \u0026amp; 0xFF] \u0026lt;\u0026lt; 48\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 16) \u0026amp; 0xFF] \u0026lt;\u0026lt; 40\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 24) \u0026amp; 0xFF] \u0026lt;\u0026lt; 32\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 32) \u0026amp; 0xFF] \u0026lt;\u0026lt; 24\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 40) \u0026amp; 0xFF] \u0026lt;\u0026lt; 16\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 48) \u0026amp; 0xFF] \u0026lt;\u0026lt; 8\u003Cbr\u003E | (uint64_t)data[n \u0026gt;\u0026gt; 56]);\u003Cbr\u003E }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Estruct reverse16\u003Cbr\u003E{\u003Cbr\u003E std::string name;\u003Cbr\u003E std::vector\u0026lt;uint16_t\u0026gt; data;\u003Cbr\u003E\u003Cbr\u003E reverse16(const reverse8\u0026amp; r8) : name(\u0022reverse16\u0022), data(1 \u0026lt;\u0026lt; 16)\u003Cbr\u003E {\u003Cbr\u003E for(uint64_t i = 0; i \u0026lt; data.size(); i\u002B\u002B)\u003Cbr\u003E {\u003Cbr\u003E data[i] = ((r8.data[i \u0026amp; 0xFF] \u0026lt;\u0026lt; 8) | r8.data[i \u0026gt;\u0026gt; 8]);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E inline uint64_t operator() (uint64_t n)\u003Cbr\u003E {\u003Cbr\u003E return ((uint64_t)data[n \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 48\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 16) \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 32\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 32) \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 16\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 48) \u0026amp; 0xFFFF]);\u003Cbr\u003E }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003Estruct reverse24\u003Cbr\u003E{\u003Cbr\u003E std::string name;\u003Cbr\u003E std::vector\u0026lt;uint32_t\u0026gt; data;\u003Cbr\u003E\u003Cbr\u003E reverse24(const reverse8\u0026amp; r8) : name(\u0022reverse24\u0022), data(1 \u0026lt;\u0026lt; 24)\u003Cbr\u003E {\u003Cbr\u003E for(uint64_t i = 0; i \u0026lt; data.size(); i\u002B\u002B)\u003Cbr\u003E {\u003Cbr\u003E data[i] = ((r8.data[i \u0026amp; 0xFF] \u0026lt;\u0026lt; 16) | (r8.data[(i \u0026gt;\u0026gt; 8) \u0026amp; 0xFF] \u0026lt;\u0026lt; 8) | r8.data[i \u0026gt;\u0026gt; 16]);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E inline uint64_t operator() (uint64_t n)\u003Cbr\u003E {\u003Cbr\u003E return ((uint64_t)data[(n \u0026gt;\u0026gt; 40) \u0026amp; 0xFFFFFF]\u003Cbr\u003E | (uint64_t)data[(n \u0026gt;\u0026gt; 16) \u0026amp; 0xFFFFFF] \u0026lt;\u0026lt; 24\u003Cbr\u003E | (uint64_t)data[n \u0026amp; 0xFFFF] \u0026lt;\u0026lt; 40);\u003Cbr\u003E }\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Etemplate\u0026lt;class Func\u0026gt;\u003Cbr\u003Evoid\u003Cbr\u003Eprofile(Func\u0026amp; func, const std::vector\u0026lt;uint64_t\u0026gt;\u0026amp; samples)\u003Cbr\u003E{\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u0022Profiling \u0022 \u0026lt;\u0026lt; func.name \u0026lt;\u0026lt; \u0022...\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E\u003Cbr\u003E uint64_t r = 0;\u003Cbr\u003E double start = readTimer();\u003Cbr\u003E for(uint64_t i = 0; i \u0026lt; samples.size(); i\u002B\u002B)\u003Cbr\u003E {\u003Cbr\u003E r ^= func(samples[i]);\u003Cbr\u003E }\u003Cbr\u003E double seconds = readTimer() - start;\u003Cbr\u003E\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u0022Result = \u0022 \u0026lt;\u0026lt; r \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E std::cout \u0026lt;\u0026lt; func.name \u0026lt;\u0026lt; \u0022: \u0022 \u0026lt;\u0026lt; (seconds * TO_NANO) \u0026lt;\u0026lt; \u0022 ns/call\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E std::cout \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Eint main(int argc, char** argv)\u003Cbr\u003E{\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u0022Initializing...\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E\u003Cbr\u003E array_access aa;\u003Cbr\u003E\u003Cbr\u003E reverse8 r8;\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u00228-bit table built.\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E\u003Cbr\u003E reverse16 r16(r8);\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u002216-bit table built.\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E\u003Cbr\u003E reverse24 r24(r8);\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u002224-bit table built.\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u0022Testing...\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E std::mt19937_64 rng(0xDEADBEEF);\u003Cbr\u003E std::vector\u0026lt;uint64_t\u0026gt; samples(SAMPLE_COUNT);\u003Cbr\u003E for(uint64_t i = 0; i \u0026lt; samples.size(); i\u002B\u002B)\u003Cbr\u003E {\u003Cbr\u003E samples[i] = rng();\u003Cbr\u003E if(r8(samples[i]) != r16(samples[i]))\u003Cbr\u003E {\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u0022Failed: reverse8 != reverse16 @ \u0022 \u0026lt;\u0026lt; samples[i] \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E return 1;\u003Cbr\u003E }\u003Cbr\u003E if(r16(samples[i]) != r24(samples[i]))\u003Cbr\u003E {\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u0022Failed: reverse16 != reverse24 @ \u0022 \u0026lt;\u0026lt; samples[i] \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E return 1;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E std::cout \u0026lt;\u0026lt; \u0022Tests passed.\u0022 \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E std::cout \u0026lt;\u0026lt; std::endl;\u003Cbr\u003E\u003Cbr\u003E profile(aa, samples);\u003Cbr\u003E profile(r8, samples);\u003Cbr\u003E profile(r16, samples);\u003Cbr\u003E profile(r24, samples);\u003Cbr\u003E\u003Cbr\u003E return 0;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EWith the C# version, I also observed a significant performance difference between the 8-bit lookup table and the 16-bit lookup table:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E$ mcs -o\u002B foo.cs\u003C/p\u003E\u003Cp\u003E$ mono foo.exe\u003C/p\u003E\u003Cp\u003EInitializing...\u003C/p\u003E\u003Cp\u003E8-bit table built.\u003C/p\u003E\u003Cp\u003E16-bit table built.\u003C/p\u003E\u003Cp\u003E24-bit table built.\u003C/p\u003E\u003Cp\u003ETesting...\u003C/p\u003E\u003Cp\u003ETests passed.\u003C/p\u003E\u003Cp\u003EProfiling array access...\u003C/p\u003E\u003Cp\u003EResult = 0x611E686E163A105C\u003C/p\u003E\u003Cp\u003EBase time: 1,054863 ns/call\u003C/p\u003E\u003Cp\u003EProfiling Reverse8...\u003C/p\u003E\u003Cp\u003EResult = 0x3A085C6876167886\u003C/p\u003E\u003Cp\u003EReverse8: 10,821065 ns/call\u003C/p\u003E\u003Cp\u003EProfiling Reverse16...\u003C/p\u003E\u003Cp\u003EResult = 0x3A085C6876167886\u003C/p\u003E\u003Cp\u003EReverse16: 6,586188 ns/call\u003C/p\u003E\u003Cp\u003EProfiling Reverse24...\u003C/p\u003E\u003Cp\u003EResult = 0x3A085C6876167886\u003C/p\u003E\u003Cp\u003EReverse24: 34,173045 ns/call\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EIn the C\u002B\u002B version, the differences in performance were quite minor:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E$ g\u002B\u002B-5 -std=c\u002B\u002B11 -Wall -O3 foo.cpp -o foo\u003C/p\u003E\u003Cp\u003E$ ./foo\u003C/p\u003E\u003Cp\u003EInitializing...\u003C/p\u003E\u003Cp\u003E8-bit table built.\u003C/p\u003E\u003Cp\u003E16-bit table built.\u003C/p\u003E\u003Cp\u003E24-bit table built.\u003C/p\u003E\u003Cp\u003ETesting...\u003C/p\u003E\u003Cp\u003ETests passed.\u003C/p\u003E\u003Cp\u003EProfiling access...\u003C/p\u003E\u003Cp\u003EResult = 1630952772224003662\u003C/p\u003E\u003Cp\u003Eaccess: 0.585153 ns/call\u003C/p\u003E\u003Cp\u003EProfiling reverse8...\u003C/p\u003E\u003Cp\u003EResult = 8247669395094127976\u003C/p\u003E\u003Cp\u003Ereverse8: 4.34656 ns/call\u003C/p\u003E\u003Cp\u003EProfiling reverse16...\u003C/p\u003E\u003Cp\u003EResult = 8247669395094127976\u003C/p\u003E\u003Cp\u003Ereverse16: 4.06664 ns/call\u003C/p\u003E\u003Cp\u003EProfiling reverse24...\u003C/p\u003E\u003Cp\u003EResult = 8247669395094127976\u003C/p\u003E\u003Cp\u003Ereverse24: 26.3678 ns/call\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\n"},{"CreatedByName":"Yourself","CreatedById":4465,"CreatedDateTime":"2015-10-25T22:04:36Z","Content":"\n\u003Cp\u003EPretty interesting seeing the performance differences. Not sure why exactly that is. I could imagine that it may be related to some of the overhead in the array accesses in C#, since it may be doing some bounds checking on the lookup tables. I could try rolling unsafe versions of the lookup functions, since that would allow me to essentially force it to skip the bounds checks. \u003C/p\u003E\u003Cp\u003EBut at least the cache misses still have an obvious and significant impact on performance. That\u0027s the only thing I actually set out to demonstrate in the first place, after all.\u003C/p\u003E\u003Cp\u003EEDIT:\u003C/p\u003E\u003Cp\u003EWell, that\u0027s not it:\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EInitializing...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E8-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E16-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E24-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETesting...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETests passed.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling array access...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x35B74AB9323BAF0A\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EBase time: 2.114285 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse8...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x50F5DC4C9D52EDAC\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse8: 7.892897 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse16...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x50F5DC4C9D52EDAC\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse16: 4.123271 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse24...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x50F5DC4C9D52EDAC\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse24: 32.213506 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling UnsafeReverse8...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x50F5DC4C9D52EDAC\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EUnsafeReverse8: 8.589045 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling UnsafeReverse16...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x50F5DC4C9D52EDAC\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EUnsafeReverse16: 5.796279 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling UnsafeReverse24...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x50F5DC4C9D52EDAC\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EUnsafeReverse24: 36.317731 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003EIt closed the gap somewhat, but not nearly to the extent necessary to say that\u0027s where the majority of the performance difference is coming in.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-25T22:39:29Z\u0022 title=\u002210/25/2015 10:39  PM\u0022 data-short=\u00228 yr\u0022\u003EOctober 25, 2015\u003C/time\u003E by Yourself\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-25T22:35:08Z","Content":"\n\u003Cp\u003EL2 cache is shared, IIRC. So that is something to keep in mind if you have threads.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-25T22:37:02Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EI did a quick C\u002B\u002B conversion of the code:?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThis is very good to know, it means there is not too high of a price to be paid using C#.\u003C/p\u003E\u003Cp\u003EI noticed that earlier it looked like you were using visual studio iDE, then on you C# looks like you are using MonoDevelop.\u003C/p\u003E\u003Cp\u003EI take it you are using Mono in windows, or are you also comparing OS at the same time?\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-25T22:53:43Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003EI noticed that earlier it looked like you were using visual studio iDE, then on you C# looks like you are using MonoDevelop.\u003Cp\u003EI take it you are using Mono in windows, or are you also comparing OS at the same time?\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI\u0027m using g\u002B\u002B 5.2.0 on OS X. The C# code was compiled on Mono 4.2.0. I didn\u0027t even know that I had Mono installed, and this was the first time I compiled any C# code. The last time I used Visual Studio was 15 years ago, and the last version of Windows I used was Windows 2000.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-25T23:59:58Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EI\u0027m using g\u002B\u002B 5.2.0 on OS X. The C# code was compiled on Mono 4.2.0. I didn\u0027t even know that I had Mono installed, and this was the first time I compiled any C# code. The last time I used Visual Studio was 15 years ago, and the last version of Windows I used was Windows 2000.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ESorry, i seem to be confusing posts with YourSelf , he appears to be using a windows environ. The g\u002B\u002B compiler lead i saw. This is kind of wow, here we have all kinds of OS, hardware even, who knows if AMD is represented. \u003C/p\u003E\u003Cp\u003EI have an i4590s with apparently 6 MB smart cache, 16GB base which i can expand to 32, SSE4.2/AVX2.0. This is what intel says: L2,L3 cache shared by all four processors, essentially each processor has access to 6 Mb, but doubt this is actually the case, each chip has its own unique L1 cache. \u003C/p\u003E\u003Cp\u003Eaccording to \u003Ca href=\u0022http://www.cpu-world.com/Compare/431/Intel_Core_i5_i5-4570_vs_Intel_Core_i5_i5-4590.html\u0022 rel=\u0022external nofollow\u0022\u003Ethis\u003C/a\u003E site its L1 is 128 program, 128 data, L2 proper is 1mb, L3 is 6 MB which i guess muddles with L2 as needed.\u003C/p\u003E\n"},{"CreatedByName":"Yourself","CreatedById":4465,"CreatedDateTime":"2015-10-26T03:47:35Z","Content":"\n\u003Cp\u003EYes, I\u0027m on Windows. I primarily develop in Visual Studio, though I\u0027ll use LINQPad if I don\u0027t want to go through all the trouble of actually creating a new solution. \u003C/p\u003E\u003Cp\u003EI also ran the whole test suite again, but this time I targeted x64. Previously I was running with the default, which is Any CPU which would run as x64 on a 64-bit machine and x86 on a 32-bit machine. At least, it would if I had changed it from the default. By default it prefers 32-bit, so essentially it was running as a 32-bit process before. If I specifically target 64-bit, I get a different Jitter and different results:\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EInitializing...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E8-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E16-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003E24-bit table built.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETesting...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003ETests passed.\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling array access...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x563765EE46B64B32\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EBase time: 0.608915 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse8...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4CD26D6277A6EC6A\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse8: 8.348577 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse16...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4CD26D6277A6EC6A\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse16: 5.116408 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling Reverse24...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4CD26D6277A6EC6A\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EReverse24: 33.064754 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling UnsafeReverse8...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4CD26D6277A6EC6A\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EUnsafeReverse8: 6.70843 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling UnsafeReverse16...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4CD26D6277A6EC6A\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EUnsafeReverse16: 5.058065 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EProfiling UnsafeReverse24...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EResult = 0x4CD26D6277A6EC6A\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Consolas;\u0022\u003EUnsafeReverse24: 29.71604 ns/call\u003C/span\u003E\u003C/p\u003E\u003Cp\u003ENotably the baseline array access and XORs are \u003Cstrong\u003Emuch\u003C/strong\u003E faster (presumably because the XORs are operating on 64-bit integers) and the unsafe code actually edges out the safe code for performance.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-26T10:02:47Z","Content":"\n\u003Cp\u003EYeah, Studio was throwing me errors on the snippet, though looking at the safe versus unsafe it may simply be statistical variation, did you use a random seed or randomize on the system time. \u003C/p\u003E\u003Cp\u003EDoes studio C\u002B\u002B have a 32bit limitation on the compile? It keeps throwing errors on the 64bit ints.\u003C/p\u003E\n"},{"CreatedByName":"WinkAllKerb\u0026#039;\u0026#039;","CreatedById":78047,"CreatedDateTime":"2015-11-04T00:41:28Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003E ... but eventually found I could code directly in hexadecimal.... why do I want to waste the clock cycles trying to achieve 20 places.... across many platforms.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E2cp regarding thoose few pointers\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022https://en.wikipedia.org/wiki/Reference_(computer_science)\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://en.wikipedia.org/wiki/Reference_(computer_science)\u003C/a\u003E\u003C/p\u003E\u003Cp\u003Eyou also got the tralalala blablablabla of defense(s) related versions that\u0027s why some languages are popular\u0027ized and some don\u0027t: Hardware deeply shared architecture\u003C/p\u003E\u003Cp\u003Ei do love how the \u0022external data reference\u0022 pages disapeared(may be vanished is more acurate ... anyway) a few month ago ; ) no tralalalala no blablablabla you know some might found them usefull ; )\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-11-04T00:47:07Z\u0022 title=\u002211/04/2015 12:47  AM\u0022 data-short=\u00228 yr\u0022\u003ENovember 4, 2015\u003C/time\u003E by WinkAllKerb\u0026#39;\u0026#39;\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-11-12T17:55:28Z","Content":"\n\u003Cp\u003E\u003Ca href=\u0022https://msdn.microsoft.com/en-us/library/yyaad03b%28v=vs.90%29.aspx\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://msdn.microsoft.com/en-us/library/yyaad03b%28v=vs.90%29.aspx\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EJust to note from this C sharp and VB are basically now two \u0027ways\u0027 of saying the same thing. \u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EArrays: In C\u002B\u002B an array is merely a pointer. In C#, arrays are objects that include methods and properties. For example, the size of an array can be queried via the \u003Ca href=\u0022https://msdn.microsoft.com/en-us/library/system.array.length%28v=vs.90%29.aspx\u0022 rel=\u0022external nofollow\u0022\u003ELength\u003C/a\u003E property. C# arrays also employ indexers that verify each index used to access the array. The syntax for declaring C# arrays is different from that for C\u002B\u002B arrays: the tokens \u0022[]\u0022 appear following the array type in C#, not the variable.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIn C# and VB an array is an object inherited from the Array.Class of System. It is in essence a slightly weaker brother of the System.Collection. set. \u003C/p\u003E\u003Cp\u003EHere is the problem, is using some of the features of C you might find yourself wanting to implement a jagged array or a structure with certain properties, for examples in programming controls, its somewhat hindered in\u003C/p\u003E\u003Cp\u003EC\u002B\u002B setting up a control array (Note: it is not easy as VB6 setting up control arrays in either case). You end up with a massive collection class dealing with rather simple implimentations. But new to the program there is a process for dumping the trash on anything you might generate, and so it is possible to silence a class once it is no longer needed. \u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EInheritance: In C\u002B\u002B, classes and structs are virtually identical whereas in C#, they are quite different. C# classes can implement any number of interfaces, but can inherit from only one base class. Furthermore, C# structs do not support inheritance, and do not support explicit default constructors (one is provided by default).\u003C/div\u003E\u003C/blockquote\u003E\n"},{"CreatedByName":"EladDv","CreatedById":118368,"CreatedDateTime":"2015-11-30T22:52:23Z","Content":"\n\u003Cp\u003E\nWell if you try and find sense in coding languages you\u0027ll always find questionable decisions after all it was designed by humans\n\u003C/p\u003E\n"}]}