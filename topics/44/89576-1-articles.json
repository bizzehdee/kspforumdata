{"TopicId":89576,"ForumId":44,"TopicTitle":"2-body propagation","CreatedByName":"jhnrs","CreatedById":128402,"CreatedDateTime":"2014-11-06T14:53:49Z","PageNum":1,"Articles":[{"CreatedByName":"jhnrs","CreatedById":128402,"CreatedDateTime":"2014-11-06T14:53:49Z","Content":"\n\u003Cp\u003Ehey guys,\u003C/p\u003E\u003Cp\u003EI\u0027m trying to make program/game in unity that involves orbital mechanics. I would like to get the physics more or less simular to KSP\u0027s rail system. So I found \u003Ca href=\u0022http://biomathman.com/pair/ElementConversionRecipes.pdf\u0022 rel=\u0022external nofollow\u0022\u003Ethis\u003C/a\u003E paper where i got most of my equations from and\n\u003C/p\u003E\u003Cdiv class=\u0022ipsEmbeddedVideo\u0022 contenteditable=\u0022false\u0022\u003E\u003Cdiv\u003E\u003Ciframe width=\u0022480\u0022 height=\u0022270\u0022 src=\u0022https://www.youtube.com/embed/cf9Jh44kL20?feature=oembed\u0022 frameborder=\u00220\u0022 allowfullscreen=\u0022true\u0022\u003E\u003C/iframe\u003E\u003C/div\u003E\u003C/div\u003E video which explains orbital propagation. But when I try to implement it ,the orbiting body/satellite slows down at some point in its orbit and just keeps oscilating back and forth around that point. When I play it backwards (negative timeScale value) it speeds up and slow down at roughly the same point in it\u0027s orbit. This is my code (C#):\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eusing UnityEngine;using System.Collections;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Epublic class GameController {\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public GameObject satellite;\u003Cbr\u003E    public float timeScale;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    void Start()\u003Cbr\u003E    {\u003Cbr\u003E        orbit = new Orbit (4f, 0.6f, 0.0f, 1.0f, 0.0f, 0.0f); //orbital parameters\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    void Update()\u003Cbr\u003E    {\u003Cbr\u003E        satellite.transform.Position = orbit.NextPosition (Time.deltaTime*timeScale);\u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eusing UnityEngine;\u003Cbr\u003Eusing System.Collections;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Epublic class Orbit {\u003Cbr\u003E    public float a;        //Semi-major axis\u003Cbr\u003E    public float e;        //eccentricity\u003Cbr\u003E    public float i;        //inclination\u003Cbr\u003E    public float w;        //argument of perigee\u003Cbr\u003E    public float LAN;    //longitude of the ascending node\u003Cbr\u003E    public float MA;    //mean anomaly\u003Cbr\u003E    public float n;        //mean motion\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public float TA;    //True anomaly\u003Cbr\u003E    public float EA;    //eccentric anomaly\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public float Mu = 1f;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    Vector3 P;\u003Cbr\u003E    Vector3 Q;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public Orbit(float semiMajorAxis,float eccentricity,float inclination,float argPerigee,float longAscNode,float trAn,GameObject orbitPrimary)\u003Cbr\u003E    {\u003Cbr\u003E        primary = orbitPrimary;\u003Cbr\u003E        a = semiMajorAxis;\u003Cbr\u003E        e = eccentricity;\u003Cbr\u003E        i = inclination;\u003Cbr\u003E        w = argPerigee;\u003Cbr\u003E        LAN = longAscNode;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        float EA = TAtoEA (trAn);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        MA = EAtoMA (EA);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        n = Mathf.Sqrt (Mu / (a * a * a));\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        SetPQ ();\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    void SetPQ()\u003Cbr\u003E    {\u003Cbr\u003E        P = (Mathf.Cos(w)*Mathf.Cos(LAN)-Mathf.Sin(w)*Mathf.Cos(i)*Mathf.Sin(LAN))*Vector3.right\u002B\u003Cbr\u003E            (Mathf.Sin(w)*Mathf.Sin(i))*Vector3.up\u002B\u003Cbr\u003E            (Mathf.Cos(w)*Mathf.Sin(LAN)\u002BMathf.Sin(w)*Mathf.Cos(i)*Mathf.Cos(LAN))*Vector3.forward;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        Q = (-Mathf.Sin(w)*Mathf.Cos(LAN)-Mathf.Cos(w)*Mathf.Cos(i)*Mathf.Sin(LAN))*Vector3.right\u002B\u003Cbr\u003E            (Mathf.Sin(i)*Mathf.Cos(w))*Vector3.up\u002B\u003Cbr\u003E            (-Mathf.Sin(w)*Mathf.Sin(LAN)\u002BMathf.Cos(w)*Mathf.Cos(i)*Mathf.Cos(LAN))*Vector3.forward;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public Vector3 NextPosition(float passedTime)\u003Cbr\u003E    {\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        MA = EAtoMA (EA);\u003Cbr\u003E        MA = MA \u002B n * passedTime;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        if(MA \u0026gt; 2*Mathf.PI)\u003Cbr\u003E            MA -= 2*Mathf.PI;\u003Cbr\u003E        if(MA \u0026lt; 0)\u003Cbr\u003E            MA \u002B= 2*Mathf.PI;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        EA = MAtoEA (MA);\u003Cbr\u003E        TA = EAtoTA (EA);\u003Cbr\u003E\u003Cbr\u003E        return a*(Mathf.Cos(EA)-e)*P\u002Ba*Mathf.Sqrt(1-e*e)*Mathf.Sin(EA)*Q;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    float TAtoEA(float T)\u003Cbr\u003E    {\u003Cbr\u003E        float E =  Mathf.Acos ((e\u002BMathf.Cos(T))/(1\u002Be*Mathf.Cos(T)));\u003Cbr\u003E        if (T \u0026gt; Mathf.PI \u0026amp;\u0026amp; T \u0026lt; 2 * Mathf.PI)\u003Cbr\u003E            E = 2 * Mathf.PI - E;\u003Cbr\u003E\u003Cbr\u003E        return E;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    float EAtoMA(float E)\u003Cbr\u003E    {\u003Cbr\u003E        return E - e * Mathf.Sin (E); \u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    float MAtoEA(float M)\u003Cbr\u003E    {\u003Cbr\u003E        float E = M;\u003Cbr\u003E        float Enext = E-(E-e*Mathf.Sin(E)-M)/(1-e*Mathf.Cos(E));;\u003Cbr\u003E\u003Cbr\u003E        while (Enext-E\u0026gt;Mathf.Pow (10,-15)) \u003Cbr\u003E        {\u003Cbr\u003E            E = Enext;\u003Cbr\u003E            Enext = E-(E-e*Mathf.Sin(E)-M)/(1-e*Mathf.Cos(E));\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        return Enext;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    float EAtoTA(float E)\u003Cbr\u003E    {\u003Cbr\u003E        float T = Mathf.Acos ((Mathf.Cos(E)-e)/(1-e*Mathf.Cos(E)));\u003Cbr\u003E        if (E \u0026gt; Mathf.PI \u0026amp;\u0026amp; E \u0026lt; 2* Mathf.PI)\u003Cbr\u003E            T = 2 * Mathf.PI - T;\u003Cbr\u003E        return T;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EIf one of you could find my mistake it would be really helpfull and if you have a question about my code ,please ask?\u003C/p\u003E\u003Cp\u003Eps. if you have any sugestions or know a better (please not to complicated) way to calculate the position of a satellite ,please tell me \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif\u0022 alt=\u0022:D\u0022\u003E\u003C/p\u003E\n"}]}