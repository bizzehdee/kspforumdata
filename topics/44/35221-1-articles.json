{"TopicId":35221,"ForumId":44,"TopicTitle":"A bit of An Orbital Issue","CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-29T02:48:02Z","PageNum":1,"Articles":[{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-29T02:48:02Z","Content":"\n\u003Cp\u003EI seem to be having quite a bit of issue with a Non-Gravitational Orbital Simulation. Well, saying it is a bit is understating it. I can\u0027t seem to get the orbit to actually work. \u003C/p\u003E\u003Cp\u003EWith the Planet having a Semi-Major of 57.909100, a period of 4.092346 degrees/sec, and an Ecc of 0, so that it is a Circle, it goes way out in an elliptical orbit. I am unsure what I am doing wrong. \u003C/p\u003E\u003Cp\u003EHere are the Equations I am using:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003EFinding the Coords:\u003Cbr\u003E        t = Degrees * Math.Degrees2Radians //Convert to Radians\u003Cbr\u003E        x = a cos(t) (Radius along the Semi-Major Axis)\u003Cbr\u003E\tz = b sin(t) (Radius along the Semi-Minor Axis)\u003Cbr\u003E\u003Cbr\u003ECalculating the Semi-Minor as:\u003Cbr\u003E\tb = a sqrt(1 - Ecc^2)\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2013-06-29T03:03:53Z","Content":"\n\u003Cp\u003EYou do have the code for computing semi-minor before you are using it to compute the z coordinate, right? Otherwise, it\u0027d be useful to see a bit more of your actual code.\u003C/p\u003E\u003Cp\u003EAlso, keep in mind that x = 0, z = 0 is going to be center of ellipse, not focus. In other words, barycenter of your system is not going to be at (0, 0). I don\u0027t know which one you are going for.\u003C/p\u003E\n"},{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-29T03:20:58Z","Content":"\n\u003Cp\u003EHere is my actual Code.\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.invasion3042.com/app/OrbitalMechanics.zip\u0022 rel=\u0022external nofollow\u0022\u003EOrbital Mechanics\u003C/a\u003E\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2013-06-29T15:03:12Z","Content":"\n\u003Cp\u003EOk, I might be wrong, but it looks to me like OrbitalMechanics.FindSemiMinor() is called when object is created, and only then do you set the SemiMajor axis. So SemiMinor would be computed wrong. You can check that by displaying or printing to console the values of SemiMajor and SemiMnior axis on every tick.\u003C/p\u003E\u003Cp\u003EIf that\u0027s really the problem, the simplest way to fix it would be to create a Body.Initialize() function and call it after you set all the other parameters. So it\u0027d be something like this.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EPlanet = (GameObject)UnityEngine.Object.Instantiate(sphere);\u003Cbr\u003EPlanet.name = \u0022Mercury\u0022;\u003Cbr\u003EPlanet.SetActive(true);\u003Cbr\u003Etransform = Planet.transform;\u003Cbr\u003Ebody = Planet.AddComponent\u0026lt;Body\u0026gt;();  //I\u0027m guessing Body.Start() gets called here.\u003Cbr\u003Ebody.Root = GameObject.Find(\u0022Sol\u0022).transform;\u003Cbr\u003Ebody.SemiMajor_Axis = 57.909100f;\u003Cbr\u003Ebody.Size = 2439.7f;\u003Cbr\u003Ebody.degrees = 4.092346f;\u003Cbr\u003Ebody.Initialize();   //This call should set up body.SemiMinor_Axis\u003Cbr\u003Etransform.parent = SolSystem.transform;\u003Cbr\u003EPlanet.renderer.material.color = Color.red;\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI might be wrong, though. I haven\u0027t worked with Unity too much. But in either case, taking a look at what the values of SemiMinor and SemiMajor actually are would help you diagnose the problem.\u003C/p\u003E\n"},{"CreatedByName":"metaphor","CreatedById":57640,"CreatedDateTime":"2013-06-29T16:26:37Z","Content":"\n\u003Cp\u003EAre you looking at the mass of the sun? The position of a planet and its speed are not enough to generate an orbit, you also need the mass of the central body to be just right to make a circular orbit. Unless the orbit is hardcoded regardless of the sun\u0027s mass, in which case this is not relevant.\u003C/p\u003E\n"},{"CreatedByName":"maltesh","CreatedById":17144,"CreatedDateTime":"2013-06-29T17:07:02Z","Content":"\n\u003Cp\u003EYou seem to be conflating the Mean Anomaly, the Eccentric Anomaly, and the True Anomaly. The three are equivalent if your orbit is circular, if your orbit is elliptical, they are only equivalent at periapse (where all three are 0), and apoapse (when all three are equal to pi)\u003C/p\u003E\n"},{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-30T04:21:24Z","Content":"\n\u003Cp\u003E@K^2: Doing that doesn\u0027t make a difference, but you are right, I should be sure to do it after I set the Major axis. \u003C/p\u003E\u003Cp\u003E@metaphor: I am attempting to do it on rails like KSP does. Gravity is not a factor.\u003C/p\u003E\u003Cp\u003E@maltesh: I may be using the wrong terminology in defining my variables, but I am copying KSP for simplicity, and they call it Mean Anomaly. \u003C/p\u003E\u003Cp\u003EFor reference, this is where I got my \u003Ca href=\u0022http://www.mathopenref.com/coordparamellipse.html\u0022 rel=\u0022external nofollow\u0022\u003ECoordinate equations\u003C/a\u003E... I just don\u0027t understand why I can\u0027t get it to work. I can set both the Major and Minor axis to 3, and it still goes far out of the orbit I intended, and for some reason, never negative on the z axis... I would look into how Unity does the RotateAround method, but since it calls and external dll to do it, I can\u0027t. \u003C/p\u003E\u003Cp\u003ESo, for those following along at home, I am trying to create a function to give me the Coordinates of a body based only, for now, on the Semi-Major axis, the degrees per second, and the Eccentricity of the orbit. I will of course need to add in the Inclination, but that is more equations, and if I can\u0027t get it to function with just 2, I can imagine how it will do with more.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2013-06-30T04:41:17Z","Content":"\n\u003Cp\u003EHm. What about this bit of code in Body.Update()\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Etransform.Translate(Coords);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EDoes this call translate object to Coords or by Coords? Because if it\u0027s the later, it would explain a lot, including why z doesn\u0027t go negative.\u003C/p\u003E\n"},{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-30T06:08:41Z","Content":"\n\u003Cp\u003EGood catch... Now it works. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_happy.png\u0022 alt=\u0022^_^\u0022\u003E\u003C/p\u003E\u003Cp\u003ENow to work on being able to incline the orbit. You wouldn\u0027t happen to know the equation would you? \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_happy.png\u0022 alt=\u0022^_^\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2013-06-30T07:20:45Z","Content":"\n\u003Cp\u003EI\u0027d start with making sure that your orbit has the star at the focus rather than center. As I mentioned earlier, your equations set the star in the geometrical center of the ellipse. That\u0027s not a problem for a circular orbit, since the foci coincide with center for circle, but the moment you add a bit of eccentricity, it will look wrong.\u003C/p\u003E\u003Cp\u003EYou have equation for ellipse with origin on center:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ex = a*cos(t);\u003Cbr\u003Ez = b*sin(t);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EInstead, you want equation where origin is at the focus. This is achieved by simply shifting the ellipse by focal distance.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ex = a*e \u002B a*cos(t);\u003Cbr\u003Ez = b*sin(t);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EInclination (i) is simply a rotation around the Z axis (since your major axis runs along X). In general, a rotation around Z axis looks like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ex_after_rotation = cos(angle) * x_before_rotation - sin(angle) * y_before_rotation;\u003Cbr\u003Ey_after_rotation = sin(angle) * x_before_rotation \u002B cos(angle) * y_before_rotation;\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EBut prior to inclination y is zero. So if you apply this formula, the equation for an inclined ellipse looks like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ex = cos(i) * (a*e \u002B a*cos(t));\u003Cbr\u003Ey = sin(i) * (a*e \u002B a*cos(t));\u003Cbr\u003Ez = b*sin(t);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe z coordinate doesn\u0027t change since Z is the axis we are rotating around.\u003C/p\u003E\u003Cp\u003EIn principle, there are two more angles you need to set the orbit. That\u0027s the argument of periapsis and longitude of ascending node. But if you are modeling a solar system, where all inclinations are small, you can just add a rotation around the Y axis. If you do so, the full equation takes the following form.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ex = cos(f) * cos(i) * (a*e \u002B a*cos(t)) \u002B sin(f) * b*sin(t);;\u003Cbr\u003Ey = sin(i) * (a*e \u002B a*cos(t));\u003Cbr\u003Ez = cos(f) * b*sin(t) - sin(f) * cos(i) * (a*e \u002B a*cos(t));\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EHere f is the angle by which you rotate position of the major axis. For most notable objects in the Solar system, this is more than adequate.\u003C/p\u003E\u003Cp\u003EOh, and maltesh is absolutely correct about the fact that your equations are for eccentric anomaly (variable t in all of the above), not mean anomaly. What that means is that for highly eccentric orbits your objects won\u0027t traverse the orbit at quite the right rate. Mean anomaly and eccentric anomaly are closely related, however, so it\u0027s not very difficult to recompute one from the other. I can show you how to do that if you\u0027ll want to correct for this.\u003C/p\u003E\n"},{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-30T07:55:30Z","Content":"\n\u003Cp\u003EFirst off, Thank you. \u003C/p\u003E\u003Cp\u003EAll I know is that \u003Cem\u003Et\u003C/em\u003E is called the Parameter... Beyond that... So I assumed it was the same as the Mean Anomaly. So, Calculating it as Degrees/Second * Degrees2Radians won\u0027t produce the proper \u0027orbital speed\u0027? IE a Body with an e of .2 and one of 0 won\u0027t reach the intercepts at the same time.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2013-06-30T08:14:42Z","Content":"\n\u003Cp\u003EParameter is a general term for the independent variable in the parametric equation. The simplest parametric equation for ellipse is written with eccentric anomaly as parameter. That\u0027s the equation you used. But it\u0027s possible to use a different parameter, including the mean anomaly. You\u0027ll just need a different equation. (Or a map from mean anomaly to eccentric anomaly.)\u003C/p\u003E\u003Cp\u003EMean anomaly is defined in such a way that it advances by equal amounts over equal time intervals. In other words, if you want to define the rate at which toe object traverses orbit in terms of degrees/second, you are talking about mean anomaly. So if you still want to use parametric equations based on eccentric anomaly, you need to first convert mean anomaly to eccentric anomaly.\u003C/p\u003E\u003Cp\u003EBut like I said, the correction is small if the eccentricity is small, so I\u0027d focus on getting everything else to work first.\u003C/p\u003E\n"},{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-30T08:17:57Z","Content":"\n\u003Cp\u003EI am guessing, but the fact that my venus is going clockwise, that the inclination is in radians. Am I correct?\u003C/p\u003E\u003Cp\u003ESo, what is the conversion from what I am using to the \u0027proper\u0027 one? If I am going to do this, I would like to do it right. There is a Comet with an Ecc of .7 so, Ecc will be an issue. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_happy.png\u0022 alt=\u0022^_^\u0022\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-06-30T08:20:17Z\u0022 title=\u002206/30/2013 08:20  AM\u0022 data-short=\u002211 yr\u0022\u003EJune 30, 2013\u003C/time\u003E by LordVe\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2013-06-30T08:38:38Z","Content":"\n\u003Cp\u003EYes, all angles are in radians. So if your input is in degrees, don\u0027t forget to convert them.\u003C/p\u003E\u003Cp\u003EIt\u0027s easy to go from eccentric anomaly to mean anomaly. m = t - e * sin(t). But you need to go backwards and get t from m. I\u0027m not sure there is an exact solution for that, but there are some iterative methods you can use. Off the top of my head, this should work.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E//Given m and e, compute t.\u003Cbr\u003Et = 0;\u003Cbr\u003Efor(j = 0; j \u0026lt; 100; j\u002B\u002B)t = m \u002B e * sin(t);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe higher the number in \u0022j \u0026lt; 100\u0022 the better the approximation is going to be. There is \u003Cem\u003Eprobably\u003C/em\u003E a better way.\u003C/p\u003E\n"},{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-06-30T08:43:55Z","Content":"\n\u003Cp\u003ESo, everytime I calculate the Mean, I will need to run the iteration? That will get me the slowing down and speeding up of the orbit?\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2013-06-30T11:13:13Z","Content":"\n\u003Cp\u003EYes. And it should.\u003C/p\u003E\n"},{"CreatedByName":"Yourself","CreatedById":4465,"CreatedDateTime":"2013-06-30T15:30:26Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EYes, all angles are in radians. So if your input is in degrees, don\u0027t forget to convert them.\u003Cp\u003EIt\u0027s easy to go from eccentric anomaly to mean anomaly. m = t - e * sin(t). But you need to go backwards and get t from m. I\u0027m not sure there is an exact solution for that, but there are some iterative methods you can use. Off the top of my head, this should work.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E//Given m and e, compute t.\u003Cbr\u003Et = 0;\u003Cbr\u003Efor(j = 0; j \u0026lt; 100; j\u002B\u002B)t = m \u002B e * sin(t);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe higher the number in \u0022j \u0026lt; 100\u0022 the better the approximation is going to be. There is \u003Cem\u003Eprobably\u003C/em\u003E a better way.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThere is no analytical solution to the equation*, so iterative methods are typical for solving it. The method you\u0027ve given, which is fixed-point iteration, will converge reasonably quickly (likely 100 iterations will put you far past the precision of most floating point types) if it does converge (which it will so long as e \u0026lt; 1; it can also converge if e \u0026gt;=1, but not all the time). You can immediately knock one iteration off of your loop by starting with t = m rather than 0.\u003C/p\u003E\u003Cp\u003EOther common methods for solving this equation is to use Newton\u0027s method (which is technically still fixed-point iteration, but we change the form of the function to hopefully get better convergence rates) on f(t) = t - m - e * sin(t), which yields the following scheme:\u003C/p\u003E\u003Cp\u003Ef\u0027(t) = 1 - e * cos(t)\u003C/p\u003E\u003Cp\u003Et[n\u002B1] = t[n] - f(t[n]) / f\u0027(t[n]) = t[n] - (t[n] - M - e * sin(t[n])) / (1 - e * cos(t[n]))\u003C/p\u003E\u003Cp\u003EOr, in a slightly more readable code form:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Et = m;\u003Cbr\u003Efor( int j = 0; j \u0026lt; 100; \u002B\u002Bj ) t -= ( t - m - e * sin(t) ) / ( 1 - e * cos( t ) );\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis will actually converge very quickly, again 100 iterations is likely not necessary. In fact 7 iterations should be sufficient for e \u0026lt; 0.5. If e is near 1 things will get worse, but I never saw it take more than about 35 iterations to get within machine precision. Ideally your loop would look more like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Et0 = 0;\u003Cbr\u003Et1 = m;\u003Cbr\u003Eepsilon = 1e-15;\u003Cbr\u003Ej = 0;\u003Cbr\u003Ewhile( abs( t1 - t0 ) \u0026gt; epsilon \u0026amp;\u0026amp; j \u0026lt; 100 )\u003Cbr\u003E{\u003Cbr\u003E    t0 = t1;\u003Cbr\u003E    t1 -= ( t1 - m - e * sin(t1) ) / ( 1 - e * cos(t1) );\u003Cbr\u003E    \u002B\u002Bj;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E*NOTE: Strictly speaking there kind of is an analytical solution for it, but you\u0027ll get it in terms of a Taylor series. I\u0027m not sure that this gives any computational advantages; the standard iterative approaches may still be quicker to compute to the desired accuracy.\u003C/p\u003E\n"},{"CreatedByName":"LordVe","CreatedById":25360,"CreatedDateTime":"2013-07-05T02:36:57Z","Content":"\n\u003Cp\u003EWhile I know I have already asked a lot, I wonder if you can also tell me how to find the the rotation on the Y, IE to find f in K^2\u0027s equation.\u003C/p\u003E\u003Cp\u003EAlso, since the equations are for bodies orbiting origin, How do I do a Moon?\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-07-05T04:48:59Z\u0022 title=\u002207/05/2013 04:48  AM\u0022 data-short=\u002211 yr\u0022\u003EJuly 5, 2013\u003C/time\u003E by LordVe\u003C/strong\u003E\n\u003C/span\u003E\n"}]}