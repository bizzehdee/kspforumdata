{"TopicId":120525,"ForumId":29,"TopicTitle":"PQS Altiudes and Terrain Height","CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-09T18:52:48Z","PageNum":1,"Articles":[{"CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-09T18:52:48Z","Content":"\n\u003Cp\u003EHello everyone, \u003C/p\u003E\u003Cp\u003EI have written and released a boat navigation plugin \u003Ca href=\u0022https://forum.kerbalspaceprogram.com/threads/132913-1-0-4-Maritime-Missions-and-Boat-Navigation-Plugin-%28V1-0-1%29-29-08-2015?p=2167423#post2167423\u0022 rel=\u0022external nofollow\u0022\u003Ehere\u003C/a\u003E, I am focusing on a new method of navigation using courses (lists of coordinates that a vessel follows across the surface). The issue I am having is that my current system avoids a ship being moved onto land based on the biome (currently only water is a valid biome).\u003C/p\u003E\u003Cp\u003EHowever for making the ship navigate through the various rivers on Kerbin the shore biome must be used, but the big issue is that the shore biome is not unique to coastal waters and thus covers coastal land too, this could mean a vessel could be beached on land during an update. The only way I can think of preventing this would be to make a protovessel \u0027image\u0027 ahead of the actual vessel and from this detect collisions with land (however this would certainly slow the system down). \u003C/p\u003E\u003Cp\u003EI am hoping that someone may be able to assist me with a different solution? \u003C/p\u003E\u003Cp\u003EI am thinking along the lines of differences in the PQS height of the body and the actual surface height; but I do not know enough to understand whether this could be used, to determine if the latitude and longitude of a certain point lies at sea level (0 meters) (implying that the point is valid and the vessel can travel here) or beneath the actual surface (implying that the point is invalid)? \u003C/p\u003E\u003Cp\u003EAny ideas / code would be greatly appreciated! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EThanks,\u003C/p\u003E\u003Cp\u003EWhitecat106\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-09-09T23:53:19Z\u0022 title=\u002209/09/2015 11:53  PM\u0022 data-short=\u00228 yr\u0022\u003ESeptember 9, 2015\u003C/time\u003E by Whitecat106\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"EladDv","CreatedById":118368,"CreatedDateTime":"2015-09-09T19:12:41Z","Content":"\n\u003Cp\u003Emaybe try and scan ahead a bit with raycasts and stay in the middle of a river by trying to get those distances equal? if you can get a point at each bank say 50 meters ahead from your current location you could calculate the middle point of the river with simple trigonometry and then calculate what bearing your ship needs to be to get there. and if you\u0027d like to you could enter a small deviation (with set min and max from center) to make it less robotic or just make the distances longer(but that might be an issue with sharp turns)\u003C/p\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-09-09T19:15:35Z","Content":"\n\u003Cp\u003Egetting the terrain height on latitude/longitude data is very, very slow. Your solution would probably be into raycasts, yeah.\u003C/p\u003E\n"},{"CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-09T19:26:55Z","Content":"\n\u003Cp\u003EThanks! I had noticed a reduced speed during jumps when checking by the terrain height (that didnt work anyway) so anything that can make everything smooth is a bonus. All I need is to be able to determine if a point lies at around 0m, the bearing and everything is pre-calculated and running in the background (on rails) with 30 second updates so not much detail is necessary its just verification so the player does not switch back to the vessel halfway through and find it sat 15 meters under the river bank and exploding.. \u003C/p\u003E\u003Cp\u003EI have no idea what a Raycast even is so I will do some research and see what I can come up with! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"EladDv","CreatedById":118368,"CreatedDateTime":"2015-09-09T19:28:48Z","Content":"\n\u003Cp\u003Eraycast is basically you pointing at some direction and the game telling you what\u0027s there. it could be limited by distance (good for sea travel) and can return null if it hit nothing\u003C/p\u003E\n"},{"CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-09T19:37:58Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022EladDv\u0022 data-cite=\u0022EladDv\u0022\u003E\u003Cdiv\u003Eraycast is basically you pointing at some direction and the game telling you what\u0027s there. it could be limited by distance (good for sea travel) and can return null if it hit nothing\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThanks, it sounds like the exact solution!\u003C/p\u003E\u003Cp\u003E I assume this process would work for background vessels (non active)? Since the boundaries of Kerbin\u0027s surface still exist regardless of the GameScene? \u003C/p\u003E\u003Cp\u003EThe only possible issue would be say collisions with unloaded vessels upon loading of the flight scene since the vessels have no physical presence for the raycast to detect if they are beyond 2.5km or in the background but this is pretty unlikely (and unlucky) anyway! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_tongue2.gif\u0022 alt=\u0022:sticktongue:\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"EladDv","CreatedById":118368,"CreatedDateTime":"2015-09-09T20:06:42Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Whitecat106\u0022 data-cite=\u0022Whitecat106\u0022\u003E\u003Cdiv\u003EThanks, it sounds like the exact solution!\u003Cp\u003E I assume this process would work for background vessels (non active)? Since the boundaries of Kerbin\u0027s surface still exist regardless of the GameScene? \u003C/p\u003E\u003Cp\u003EThe only possible issue would be say collisions with unloaded vessels upon loading of the flight scene since the vessels have no physical presence for the raycast to detect if they are beyond 2.5km or in the background but this is pretty unlikely (and unlucky) anyway! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_tongue2.gif\u0022 alt=\u0022:sticktongue:\u0022\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003Ei dont know if it works for unloaded entities but worst case and it dosnt you just do it once when loaded and set the course and keep a bunch of points to move between.\u003C/p\u003E\u003Cp\u003E(Psudo code)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eraycast casts[]=cast(Ship.position,direction,distance),cast(Ship.position,direction2,distance);\u003Cbr\u003EMiddlePoint=GetCenter(casts);\u003Cbr\u003Ewhile(cast(middlePoint,MiddlePointToEndPointDirection,MTEDistance)!=null)\u003Cbr\u003E{\u003Cbr\u003E     Navigator.add(middlePoint);\u003Cbr\u003E     raycast casts[]=cast(middlePoint.position,direction,distance),cast(middlePoint.position,direction2,distance);\u003Cbr\u003E     MiddlePoint=GetCenter(casts);\u003Cbr\u003E }\u003Cbr\u003ENavigator.add(endPoint);\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E\u003Cspan style=\u0022color:#C0C0C0;\u0022\u003E- - - Updated - - -\u003C/span\u003E\u003C/span\u003E\u003C/p\u003E\u003Cp\u003Eactually you might want to use do{}....While() for eliminating the initial configuration.\u003C/p\u003E\n"},{"CreatedByName":"nightingale","CreatedById":119307,"CreatedDateTime":"2015-09-09T20:13:40Z","Content":"\n\u003Cp\u003EHave a look at the \u003Ca href=\u0022https://github.com/jrossignol/ContractConfigurator/blob/master/source/ContractConfigurator/ScenarioModules/BiomeTracker.cs\u0022 rel=\u0022external nofollow\u0022\u003EBiomeTracker \u003C/a\u003Eclass in Contract Configurator. It\u0027s used in the science subsystem to come up with a rough estimate of what proportion of a given biome is water by sampling points. It samples a 2048 x 4096 array of points, and completes in the background within a minute or two on my machine (to give you an idea of the slowness of this method). In my case I just store the aggregated value (biome \u002B the ratio of it that is water).\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Edouble lonRads = Math.PI * longitude / 180.0;\u003Cbr\u003Edouble latRads = Math.PI * latitude / 180.0;\u003Cbr\u003Edouble cosLon = Math.Cos(lonRads);\u003Cbr\u003Edouble sinLon = Math.Sin(lonRads);\u003Cbr\u003Edouble cosLat = Math.Cos(latRads);\u003Cbr\u003Edouble sinLat = Math.Sin(latRads);\u003Cbr\u003EVector3d radialVector = new Vector3d(cosLat * cosLon, sinLat, cosLat * sinLon);\u003Cbr\u003Edouble height = body.pqsController.GetSurfaceHeight(radialVector) - body.pqsController.radius;\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThere\u0027s also a CelestialBody.GetSurfaceNVector(lat, lon) method that is a bit easier coding-wise - can\u0027t remember why I didn\u0027t use it in the BiomeTracker code, this might\u0027ve been slightly less expensive. Or it was because I had the numbers in (u, v) coordinates, so it was easier to just do it manually.\u003C/p\u003E\u003Cp\u003EI\u0027m thinking that if you use this in combination with an A* pathfinding algorithm (only checking for whether a point is water when you examine it) you\u0027ll get reasonable enough performance (although I\u0027m 100% sure you\u0027ll have to do it as a coroutine). You\u0027ll probably also need some added smarts to increase the search resolution when you hit a \u0022wall\u0022 - otherwise you\u0027ll by trying out too many points and performance will suffer, or you won\u0027t be at a detailed enough resolution to find the rivers/inlets.\u003C/p\u003E\u003Cp\u003EEDIT: Oh and when I say it takes a couple minutes, that is in a coroutine that is limited to 0.01 seconds per invocation - that way it falls beneath the player\u0027s notice in terms of the performance hit.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-09-09T20:16:40Z\u0022 title=\u002209/09/2015 08:16  PM\u0022 data-short=\u00228 yr\u0022\u003ESeptember 9, 2015\u003C/time\u003E by nightingale\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-09T23:52:29Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022nightingale\u0022 data-cite=\u0022nightingale\u0022\u003E\u003Cdiv\u003EHave a look at the \u003Ca href=\u0022https://github.com/jrossignol/ContractConfigurator/blob/master/source/ContractConfigurator/ScenarioModules/BiomeTracker.cs\u0022 rel=\u0022external nofollow\u0022\u003EBiomeTracker \u003C/a\u003Eclass in Contract Configurator. It\u0027s used in the science subsystem to come up with a rough estimate of what proportion of a given biome is water by sampling points. It samples a 2048 x 4096 array of points, and completes in the background within a minute or two on my machine (to give you an idea of the slowness of this method). In my case I just store the aggregated value (biome \u002B the ratio of it that is water).\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Edouble lonRads = Math.PI * longitude / 180.0;\u003Cbr\u003Edouble latRads = Math.PI * latitude / 180.0;\u003Cbr\u003Edouble cosLon = Math.Cos(lonRads);\u003Cbr\u003Edouble sinLon = Math.Sin(lonRads);\u003Cbr\u003Edouble cosLat = Math.Cos(latRads);\u003Cbr\u003Edouble sinLat = Math.Sin(latRads);\u003Cbr\u003EVector3d radialVector = new Vector3d(cosLat * cosLon, sinLat, cosLat * sinLon);\u003Cbr\u003Edouble height = body.pqsController.GetSurfaceHeight(radialVector) - body.pqsController.radius;\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThere\u0027s also a CelestialBody.GetSurfaceNVector(lat, lon) method that is a bit easier coding-wise - can\u0027t remember why I didn\u0027t use it in the BiomeTracker code, this might\u0027ve been slightly less expensive. Or it was because I had the numbers in (u, v) coordinates, so it was easier to just do it manually.\u003C/p\u003E\u003Cp\u003EI\u0027m thinking that if you use this in combination with an A* pathfinding algorithm (only checking for whether a point is water when you examine it) you\u0027ll get reasonable enough performance (although I\u0027m 100% sure you\u0027ll have to do it as a coroutine). You\u0027ll probably also need some added smarts to increase the search resolution when you hit a \u0022wall\u0022 - otherwise you\u0027ll by trying out too many points and performance will suffer, or you won\u0027t be at a detailed enough resolution to find the rivers/inlets.\u003C/p\u003E\u003Cp\u003EEDIT: Oh and when I say it takes a couple minutes, that is in a coroutine that is limited to 0.01 seconds per invocation - that way it falls beneath the player\u0027s notice in terms of the performance hit.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThanks nightingale!\u003C/p\u003E\u003Cp\u003EThis was exactly what I was looking for and proves easier than Raycasts..\u003C/p\u003E\u003Cp\u003EMy code calculates a new latitude and longitude every 30 seconds and then verifies with the code you have provided above so thank you very much! I will make use of your algorithm idea in a following update when everything gets path finding and the 30 second check can move to a much faster background check! \u003C/p\u003E\u003Cp\u003E The raycasts (which although work for background vessels, they aren\u0027t able to work when a vessel\u0027s new coordinates are actually underneath the surface of Kerbin (such as under a mountain) the raycasts cannot seem to detect the surface from within so the vessels spawn underground), plus the fact that at least 8 raycasts would need to be made to make sure no part of the vessel (since its orientation/heading can change - especially tricky if the root part of the vessel is at one end rather than central) impacts land. \u003C/p\u003E\u003Cp\u003EThanks everyone for your advice! I will look back to this thread for a future update to include some pathfinding rather than just avoidance! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-09-10T00:03:29Z","Content":"\n\u003Cp\u003E.... This is what I was warning against. Using the PQS to get height by latitude/longitude is extreeeemely slow. You will create a ridiculous amount of overhead if you use this often.\u003C/p\u003E\u003Cp\u003EThe PQS system is an incredibly complex mess, and it\u0027s ridiculously slow. Each access to pqsController.GetSurfaceHeight consumes a lot of resources, and really, if you\u0027re gonna be doing this as often as I think you will, that\u0027s not gonna work out. 20 Raycasts is going to be loads faster than just one access to this method.\u003C/p\u003E\n"},{"CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-10T01:03:20Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022stupid_chris\u0022 data-cite=\u0022stupid_chris\u0022\u003E\u003Cdiv\u003E.... This is what I was warning against. Using the PQS to get height by latitude/longitude is extreeeemely slow. You will create a ridiculous amount of overhead if you use this often.\u003Cp\u003EThe PQS system is an incredibly complex mess, and it\u0027s ridiculously slow. Each access to pqsController.GetSurfaceHeight consumes a lot of resources, and really, if you\u0027re gonna be doing this as often as I think you will, that\u0027s not gonna work out. 20 Raycasts is going to be loads faster than just one access to this method.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAt the moment the system only does this once every 30 seconds and in this time the game jitters a tad as a vessel is despawned copied and respawned at the coordinates so for the time being its a quick solution that doesn\u0027t change much. But as I said the issue with Raycasts seems to be height related again, and I think will still require the body pqs, the way I see it (correct me if I\u0027m wrong):\u003C/p\u003E\u003Cp\u003E- The latitude and longitude are calculated and then passed to a check subroutine (this system) to make sure the new coordinates are on water at an altitude of close to 0. \u003C/p\u003E\u003Cp\u003E- Since the altitude of these points based on the terrain is unknown without using the Pqs the raycast origin altitude is unknown\u003C/p\u003E\u003Cp\u003E- From what I can see the raycast origin altitude is not the Pqs altitude from sea level? I\u0027m not sure what I mean here but the issue is basically this: \u003C/p\u003E\u003Cp\u003EThe raycasts are sent out from the origin point to a distance of 100m (pretty safe for a boat), but since the origin altitude is unknown the raycasts are sent from the sea level which is below the terrain level which is within the object/pqs thing of Kerbins surface, from what I can see this means that raycasts do not detect the boundary from within so all of the \u0027pings\u0027 return false allowing the vessel to spawn here underground. I tried sending out raycasts in all six directions but none returned true when below the surface. I will definitely need to play around with this for path finding in the future.\u003C/p\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-09-10T02:03:56Z","Content":"\n\u003Cp\u003EMaybe once every 30s, but how many times when that is done? If you\u0027re doing this just a few time at each of those 30s intervals, you\u0027ll have noticable jitter, and that\u0027s going to get real annoying during extended periods of play.\u003C/p\u003E\u003Cp\u003EFor raycasts, what you want to be doing is Physics.Raycast(origin, direction, out hitInfo, maxDistance, layerMask). Is there any part that *has* to be on any ship? If so you can easily set an origin point that is directly below that part, exactly on the ocean level, and from there on you can just raycast in the direction you want. If the method returns true, you know there is land in that given direction. Then what you can do is send some raycasts every few seconds to see if anything is around. Something like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E        public float angle = 0;\u003Cbr\u003E\u003Cbr\u003E        //Run this every few seconds\u003Cbr\u003E        public void CheckForLand()\u003Cbr\u003E        {\u003Cbr\u003E            Ray ray = new Ray();\u003Cbr\u003E            Vector3 pos = this.part.transform.position; //replace for any \u0022origin\u0022 you want\u003Cbr\u003E            float ASL = FlightGlobals.getAltitudeAtPos(pos);\u003Cbr\u003E            Vector3 origin = pos - (FlightGlobals.getUpAxis(pos).normalized * ASL); //This is on the sea level\u003Cbr\u003E            //The next few lines make sure the direction is horizontal in case speed is slightly upwards (or downwards)\u003Cbr\u003E            Vector3 v = origin \u002B this.part.vessel.srf_velocity.normalized;\u003Cbr\u003E            ASL = FlightGlobals.getAltitudeAtPos(v);\u003Cbr\u003E            direction = Quaternion.AngleAxis(angle, origin) * direction; //Rotates the vector a certain angle\u003Cbr\u003E            angle \u002B= 20; //Or whatever angle offset you want on each pass\u003Cbr\u003E            angle %= 360; //Caps the angle at 360\u003Cbr\u003E            RaycastHit hit = new RaycastHit();\u003Cbr\u003E            //Raycasting\u003Cbr\u003E            if (Physics.Raycast(origin, direction, out hit, 100, 1 \u0026lt;\u0026lt; 15))\u003Cbr\u003E            {\u003Cbr\u003E                //Do stuff here, the distance of land is stored in hit.distance\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            //Same but in opposite direction\u003Cbr\u003E            if (Physics.Raycast(origin, -direction, out hit, 100, 1 \u0026lt;\u0026lt; 15))\u003Cbr\u003E            {\u003Cbr\u003E                //Do stuff here, the distance of land is stored in hit.distance\u003Cbr\u003E            }\u003Cbr\u003E        }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis is a rough sketch, but something like that would work. My vector math may be a bit off but I think it makes sense. This does two casts per frame, and if run every few seconds, you could check all around the boat every now and then. Just to give you an idea, every solar panel does a raycast per second. So this isn\u0027t gonna be heavy. The PQS though would.\u003C/p\u003E\n"},{"CreatedByName":"nightingale","CreatedById":119307,"CreatedDateTime":"2015-09-10T02:27:03Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022stupid_chris\u0022 data-cite=\u0022stupid_chris\u0022\u003E\u003Cdiv\u003E\u0026lt;snip\u0026gt;\u003Cp\u003EThis is a rough sketch, but something like that would work. My vector math may be a bit off but I think it makes sense. This does two casts per frame, and if run every few seconds, you could check all around the boat every now and then. Just to give you an idea, every solar panel does a raycast per second. So this isn\u0027t gonna be heavy. The PQS though would.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ELooks like we\u0027re solving different problems, and to be honest I\u0027m not sure which one is the one that WhiteCat is looking to have solved. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EI assumed he is looking for navigation on a global scale (ie. get from point A to point B halfway across the globe). I also assumed that it needed to work when not focused on the vessel in question. Under those restrictions, I don\u0027t imagine the raycasting would work (I have no idea how/when the colliders for the celestial body are loaded, but assume they\u0027re only loaded for a fairly localized area around the active vessel.\u003C/p\u003E\u003Cp\u003EAnd totally agree with you - the calls into PQS are a massive performance hit - but I don\u0027t see any better options if the restrictions above are correct.\u003C/p\u003E\u003Cp\u003ESo WhiteCat - if indeed you need localized navigation, then the solution stupid_chris provided is far better than mine.\u003C/p\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2015-09-10T02:36:13Z","Content":"\n\u003Cp\u003EIf the PQS is used on on-rail vessels, this will have a \u003Cem\u003Emassive\u003C/em\u003E performance hit if only a few vessels are doing this in the background, and I strongly reccomend to not do this.\u003C/p\u003E\n"},{"CreatedByName":"nightingale","CreatedById":119307,"CreatedDateTime":"2015-09-10T02:43:40Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022stupid_chris\u0022 data-cite=\u0022stupid_chris\u0022\u003E\u003Cdiv\u003EIf the PQS is used on on-rail vessels, this will have a \u003Cem\u003Emassive\u003C/em\u003E performance hit if only a few vessels are doing this in the background, and I strongly reccomend to not do this.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ERight - which is why I recommended it in a coroutine with a per-invocation time limit as in my example.\u003C/p\u003E\n"},{"CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-10T12:38:15Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022stupid_chris\u0022 data-cite=\u0022stupid_chris\u0022\u003E\u003Cdiv\u003EMaybe once every 30s, but how many times when that is done? If you\u0027re doing this just a few time at each of those 30s intervals, you\u0027ll have noticable jitter, and that\u0027s going to get real annoying during extended periods of play.\u003Cp\u003EFor raycasts, what you want to be doing is Physics.Raycast(origin, direction, out hitInfo, maxDistance, layerMask). Is there any part that *has* to be on any ship? If so you can easily set an origin point that is directly below that part, exactly on the ocean level, and from there on you can just raycast in the direction you want. If the method returns true, you know there is land in that given direction. Then what you can do is send some raycasts every few seconds to see if anything is around. Something like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E        public float angle = 0;\u003Cbr\u003E\u003Cbr\u003E        //Run this every few seconds\u003Cbr\u003E        public void CheckForLand()\u003Cbr\u003E        {\u003Cbr\u003E            Ray ray = new Ray();\u003Cbr\u003E            Vector3 pos = this.part.transform.position; //replace for any \u0022origin\u0022 you want\u003Cbr\u003E            float ASL = FlightGlobals.getAltitudeAtPos(pos);\u003Cbr\u003E            Vector3 origin = pos - (FlightGlobals.getUpAxis(pos).normalized * ASL); //This is on the sea level\u003Cbr\u003E            //The next few lines make sure the direction is horizontal in case speed is slightly upwards (or downwards)\u003Cbr\u003E            Vector3 v = origin \u002B this.part.vessel.srf_velocity.normalized;\u003Cbr\u003E            ASL = FlightGlobals.getAltitudeAtPos(v);\u003Cbr\u003E            direction = Quaternion.AngleAxis(angle, origin) * direction; //Rotates the vector a certain angle\u003Cbr\u003E            angle \u002B= 20; //Or whatever angle offset you want on each pass\u003Cbr\u003E            angle %= 360; //Caps the angle at 360\u003Cbr\u003E            RaycastHit hit = new RaycastHit();\u003Cbr\u003E            //Raycasting\u003Cbr\u003E            if (Physics.Raycast(origin, direction, out hit, 100, 1 \u0026lt;\u0026lt; 15))\u003Cbr\u003E            {\u003Cbr\u003E                //Do stuff here, the distance of land is stored in hit.distance\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            //Same but in opposite direction\u003Cbr\u003E            if (Physics.Raycast(origin, -direction, out hit, 100, 1 \u0026lt;\u0026lt; 15))\u003Cbr\u003E            {\u003Cbr\u003E                //Do stuff here, the distance of land is stored in hit.distance\u003Cbr\u003E            }\u003Cbr\u003E        }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis is a rough sketch, but something like that would work. My vector math may be a bit off but I think it makes sense. This does two casts per frame, and if run every few seconds, you could check all around the boat every now and then. Just to give you an idea, every solar panel does a raycast per second. So this isn\u0027t gonna be heavy. The PQS though would.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAhh I understand this much better now, my only question now is: Is there a way of getting the vector position of a latitude and longitude without a call to the PQS system and causing the performance hit? Since the vessel does not actually exist at the coordinates of the raycast yet. \u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022nightingale\u0022 data-cite=\u0022nightingale\u0022\u003E\u003Cdiv\u003ELooks like we\u0027re solving different problems, and to be honest I\u0027m not sure which one is the one that WhiteCat is looking to have solved. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003Cp\u003EI assumed he is looking for navigation on a global scale (ie. get from point A to point B halfway across the globe). I also assumed that it needed to work when not focused on the vessel in question. Under those restrictions, I don\u0027t imagine the raycasting would work (I have no idea how/when the colliders for the celestial body are loaded, but assume they\u0027re only loaded for a fairly localized area around the active vessel.\u003C/p\u003E\u003Cp\u003EAnd totally agree with you - the calls into PQS are a massive performance hit - but I don\u0027t see any better options if the restrictions above are correct.\u003C/p\u003E\u003Cp\u003ESo WhiteCat - if indeed you need localized navigation, then the solution stupid_chris provided is far better than mine.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI understand what you mean, yes the navigation is globally and solely in the background right now, my code is abit of a mess at the moment but since this is a background process and that there is a noticeable jitter every 30 seconds due to the vessel.die and spawn system used to teleport the vessel to a new position while on rails, I think that unless a player would be moving an armada of boats the jitter would be okay (especially since high time warp practically limits this to only one jitter interrupting timewarp as the vessel arrives at the destination). When it comes to active pathfinding raycasts would be the way to go. Ill see what people say and how performance is when I release the update with the PQS system and switch to raycast if need be! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"Fengist","CreatedById":78435,"CreatedDateTime":"2015-09-10T13:23:14Z","Content":"\n\u003Cp\u003EAnother solution may be sphereCast. It\u0027s like raycast but sends out a sphere of a size you can determine instead of a beam. Using it, you won\u0027t have to count on terrain being directly in front of you and being infinitesimally small. You can cast a 20 meter sphere and determine if the river is wide enough to navigate.\u003C/p\u003E\u003Cp\u003EYou may also want to look at rigidbody.sweeptest and physics.capsulecast. I\u0027ve never played with them but look like they may do what you\u0027re wanting.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-09-10T13:26:00Z\u0022 title=\u002209/10/2015 01:26  PM\u0022 data-short=\u00228 yr\u0022\u003ESeptember 10, 2015\u003C/time\u003E by Fengist\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"EladDv","CreatedById":118368,"CreatedDateTime":"2015-09-10T14:01:51Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Fengist\u0022 data-cite=\u0022Fengist\u0022\u003E\u003Cdiv\u003EAnother solution may be sphereCast. It\u0027s like raycast but sends out a sphere of a size you can determine instead of a beam. Using it, you won\u0027t have to count on terrain being directly in front of you and being infinitesimally small. You can cast a 20 meter sphere and determine if the river is wide enough to navigate.\u003Cp\u003EYou may also want to look at rigidbody.sweeptest and physics.capsulecast. I\u0027ve never played with them but look like they may do what you\u0027re wanting.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003Ethe problem is that he\u0027s trying to get a path in the river and for that if you just periodically raycast the banks it\u0027s much more efficiant then the sphere cast due to the size\u003C/p\u003E\n"},{"CreatedByName":"nightingale","CreatedById":119307,"CreatedDateTime":"2015-09-10T14:18:13Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Whitecat106\u0022 data-cite=\u0022Whitecat106\u0022\u003E\u003Cdiv\u003EAhh I understand this much better now, my only question now is: Is there a way of getting the vector position of a latitude and longitude without a call to the PQS system and causing the performance hit? Since the vessel does not actually exist at the coordinates of the raycast yet.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Ca href=\u0022https://anatid.github.io/XML-Documentation-for-the-KSP-API/class_celestial_body.html#aa7a1697e517a2d083cb80f4762d244fa\u0022 rel=\u0022external nofollow\u0022\u003ECelestialBody.GetWorldSurfacePosition\u003C/a\u003E() just does some fairly simple trigonometry, it doesn\u0027t use the PQS system at all (but you need to provide an altitude). \u003Cem\u003EIf\u003C/em\u003E the collider is loaded at the given latitude/longitude, then you could use it to raycast straight down from a specific altitude that is above the max terrain height and get the terrain height at the given position that way. However - this is what I was warning you about - I doubt that colliders are loaded for very far from the active vessel. Tens of kilometers is probably fine, but I suspect if you try to do this hundreds of km away it\u0027ll just return no hit (or maybe a default hit at sea level? haven\u0027t really looked into planetary colliders much).\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003E[...] there is a noticeable jitter every 30 seconds due to the vessel.die and spawn system used to teleport the vessel to a new position while on rails [...]\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYikes. There has got to be a better way to move a vessel that\u0027s on rails. Looking at the persistence file, the stuff that I see that would need to be changed on a teleport are lat, lon, alt, nrm (normal vector for vessel\u0027s \u0022up\u0022), rot (quaternion for the vessel\u0027s rotation) and ORBIT. All of these are calculated in my code for \u003Ca href=\u0022https://github.com/jrossignol/ContractConfigurator/blob/master/source/ContractConfigurator/ContractBehaviour/SpawnVessel.cs#L216\u0022 rel=\u0022external nofollow\u0022\u003ESpawnVessel\u003C/a\u003E. Some are done directly in the config node before writing it though - those one you\u0027ll have to figure out how to get them to change in the protovessel if they are needed for what you are doing.\u003C/p\u003E\n"},{"CreatedByName":"Whitecat106","CreatedById":140086,"CreatedDateTime":"2015-09-10T16:03:04Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022nightingale\u0022 data-cite=\u0022nightingale\u0022\u003E\u003Cdiv\u003E\u003Ca href=\u0022https://anatid.github.io/XML-Documentation-for-the-KSP-API/class_celestial_body.html#aa7a1697e517a2d083cb80f4762d244fa\u0022 rel=\u0022external nofollow\u0022\u003E\u003C/a\u003E\u003Cp\u003E\u003Ca href=\u0022https://anatid.github.io/XML-Documentation-for-the-KSP-API/class_celestial_body.html#aa7a1697e517a2d083cb80f4762d244fa\u0022 rel=\u0022external nofollow\u0022\u003ECelestialBody.GetWorldSurfacePosition\u003C/a\u003E\u003C/p\u003E\u003Ca href=\u0022https://anatid.github.io/XML-Documentation-for-the-KSP-API/class_celestial_body.html#aa7a1697e517a2d083cb80f4762d244fa\u0022 rel=\u0022external nofollow\u0022\u003E\u003C/a\u003E() just does some fairly simple trigonometry, it doesn\u0027t use the PQS system at all (but you need to provide an altitude). \u003Cem\u003EIf\u003C/em\u003E the collider is loaded at the given latitude/longitude, then you could use it to raycast straight down from a specific altitude that is above the max terrain height and get the terrain height at the given position that way. However - this is what I was warning you about - I doubt that colliders are loaded for very far from the active vessel. Tens of kilometers is probably fine, but I suspect if you try to do this hundreds of km away it\u0027ll just return no hit (or maybe a default hit at sea level? haven\u0027t really looked into planetary colliders much).\u003Cp\u003EYikes. There has got to be a better way to move a vessel that\u0027s on rails. Looking at the persistence file, the stuff that I see that would need to be changed on a teleport are lat, lon, alt, nrm (normal vector for vessel\u0027s \u0022up\u0022), rot (quaternion for the vessel\u0027s rotation) and ORBIT. All of these are calculated in my code for \u003Ca href=\u0022https://github.com/jrossignol/ContractConfigurator/blob/master/source/ContractConfigurator/ContractBehaviour/SpawnVessel.cs#L216\u0022 rel=\u0022external nofollow\u0022\u003ESpawnVessel\u003C/a\u003E. Some are done directly in the config node before writing it though - those one you\u0027ll have to figure out how to get them to change in the protovessel if they are needed for what you are doing.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI will experiment with the GetWorldSurfacePosition(), I think I have sometimes been confusing this for a PQS call, but yeah I understand what you mean I have no idea how colliders work beyond a flight scene, for instance the tracking station - would any colliders exist at all in this scene since no vessel really \u0027exists\u0027? \u003C/p\u003E\u003Cp\u003EMy spawn vessel code is actually derived from your contract configurator code, it is the only method for spawning vessels I have found that works in the background and is pretty smooth (Previously with my Orbital Decay mod I used derivations from HyperEdit since this could manipulate vessel orbits in the background but sadly its landing function does not function for non active vessels). My code basically creates a copy of the craft information at the moment of update (at the vessel not protovessel level - so not very optimized), then deletes the original craft using vessel.die() (probably the big cause of the jitter) and spawns the copy in a very similar way to the SpawnVessel code. So I believe it is the removal of the original that actually causes the jitter. That being said the jitter is no more noticeable than the small pauses that occur sometimes when an asteroid enters a different SOI. \u003C/p\u003E\u003Cp\u003EI have the exact same issue with Orbital Decay, to a greater degree, KSP just does not like changing vessel positions in the background. It would be a lot simpler to have a method of accessing the code used for the calculation of the vessel positions which moves the vessels themselves, from this, rather than having to force orbits/positions to change, a variable could just be altered in the \u0027natural\u0027 (probably somewhat hardcoded) way that KSP/Unity makes vessels orbit regardless of activity or background. If you get what I mean? I\u0027m sure somewhere deep dark in KSP\u0027s code there is a subroutine of \u0027UpdateOrbit(vessel)\u0027 set to \u0027protected\u0027 rather than \u0027static\u0027 that could make things like this less forced. The issue has been around ever since the first teleport/hyperspace/orbital decay/solar sail mods and ideas came around (with most solar sail mods now using derivatives of Hyperedits orbital code too). \u003C/p\u003E\u003Cp\u003EAs Fengist said I will look at rigidbody.sweeptest and physics.capsulecast too, for now the issue is sort of fixed atleast until my 1.3.0 release with pathfinding.\u003C/p\u003E\n"}]}