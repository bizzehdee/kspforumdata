{"TopicId":121888,"ForumId":44,"TopicTitle":"C, C\u002B\u002B, C# Programming - what is the sense in this","CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-09-28T14:21:11Z","PageNum":5,"Articles":[{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-08T05:19:20Z","Content":"\n\u003Cp\u003EC simply has \u0022by value\u0022 as default mode. You can simply pass in a pointer, and then treat it as a by-reference call. In fact, C\u002B\u002B makes that explicit. void func(int \u0026amp;x) takes integer x as parameter passed by reference.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E// C\u002B\u002B style reference.\u003Cbr\u003Evoid foo(int \u0026amp;x)\u003Cbr\u003E{\u003Cbr\u003E\tx = 5;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eint main(void)\u003Cbr\u003E{\u003Cbr\u003E\tint y = 7;\u003Cbr\u003E\u003Cbr\u003E\tfoo(y);\u003Cbr\u003E\tprintf(\u0022y = %d\\n\u0022, y);\u003Cbr\u003E\u003Cbr\u003E\treturn 0;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E//C style reference.\u003Cbr\u003Evoid foo(int *x)\u003Cbr\u003E{\u003Cbr\u003E\t*x = 5;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eint main(void)\u003Cbr\u003E{\u003Cbr\u003E\tint y = 7;\u003Cbr\u003E\u003Cbr\u003E\tfoo(\u0026amp;y);\u003Cbr\u003E\tprintf(\u0022y = %d\\n\u0022, y);\u003Cbr\u003E\u003Cbr\u003E\treturn 0;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EAnd this is what code for foo would look like if you want to write it in assembly.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E.intel_syntax\u003Cbr\u003E.global _foo\u003Cbr\u003E_foo:\u003Cbr\u003E\tpush ebp\u003Cbr\u003E\tmov ebp, esp\u003Cbr\u003E\u003Cbr\u003E\tmov edi, [ebp\u002B8]\u003Cbr\u003E\tmov eax, 5\u003Cbr\u003E\tmov [edi], eax \u003Cbr\u003E\u003Cbr\u003E\tmov esp, ebp\u003Cbr\u003E\tpop ebp\u003Cbr\u003E\tret\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThat one will have to be called in C style.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Evoid foo(int *);\u003Cbr\u003E\u003Cbr\u003Eint main(void)\u003Cbr\u003E{\u003Cbr\u003E\tint y = 7;\u003Cbr\u003E\u003Cbr\u003E\tfoo(\u0026amp;y);\u003Cbr\u003E\tprintf(\u0022y = %d\\n\u0022, y);\u003Cbr\u003E\u003Cbr\u003E\treturn 0;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-08T05:30:16Z\u0022 title=\u002210/08/2015 05:30  AM\u0022 data-short=\u00228 yr\u0022\u003EOctober 8, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-08T12:50:39Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EC simply has \u0022by value\u0022 as default mode. You can simply pass in a pointer, and then treat it as a by-reference call. In fact, C\u002B\u002B makes that explicit. void func(int \u0026amp;x) takes integer x as parameter passed by reference.\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E// C\u002B\u002B style reference.\u003Cbr\u003Evoid foo(int \u0026amp;x)\u003Cbr\u003E{\u003Cbr\u003E    x = 5;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eint main(void)\u003Cbr\u003E{\u003Cbr\u003E    int y = 7;\u003Cbr\u003E\u003Cbr\u003E    foo(y);\u003Cbr\u003E    printf(\u0022y = %d\\n\u0022, y);\u003Cbr\u003E\u003Cbr\u003E    return 0;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003Ethis is a bit disconcerting. I\u0027m not going to say i missed this but i have two C\u002B\u002B books and both glossed over this. \u003C/p\u003E\u003Cp\u003Ethe ampersand is nothing but an aliasing identifyer, but because of the way arguments are defined in C\u002B\u002B applying this turns them into a special reference, to a variable when it is passed. Makes sense, but the problem is that once an alias is made it cannot be unmade. If i the create int z = 12 and call foo(z) then I should hope that the previous function had been cleared from scope, otherwise problems. \u003C/p\u003E\u003Cp\u003EI don\u0027t know if you have this but check out page 32-34 microsoft introduction to C\u002B\u002B.....A short programming guide to C\u002B\u002B. I don\u0027t know what the example intended to do other than confuse the crap out of the reader, but it looks like a survey of all the various ways to make things go wrong with referencing. \u003C/p\u003E\u003Cp\u003EAnyway, lets clarify this foo(int \u0026amp;x)creates an alias to a calling variable when a \u0027funtion\u0027 is called. Its the same as saying that x\u0027s addresses has a name in two places, y is its birth name and foo.x is one of its names when its in function land. Unlike Vegas what happens in function_land does not stay in function land.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-08T16:13:52Z\u0022 title=\u002210/08/2015 04:13  PM\u0022 data-short=\u00228 yr\u0022\u003EOctober 8, 2015\u003C/time\u003E by PB666\u003C/strong\u003E\n\u003Cbr\u003ERepaired ambiguous reference to x\n\u003C/span\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2015-10-08T15:01:35Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003Ethis is a bit disconcerting. I\u0027m not going to say i missed this but i have two C\u002B\u002B books and both glossed over this. \u003Cp\u003Ethe ampersand is nothing but an aliasing identifyer, but because of the way arguments are defined in C\u002B\u002B applying this turns them into a special reference, to a variable when it is passed. Makes sense, but the problem is that once an alias is made it cannot be unmade.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe ampersand serves multiple functions, but in this case it\u0027s a pass-by-reference operator, not an aliasing identifier. It simply means that when you call this function, the compiler will ensure somehow that the parameters passed by reference are actually referenced. Usually it will do this by pushing the address of the variable onto the stack (which is the explicit implementation in C that K^2 showed), but C\u002B\u002B abstracts that a bit and leaves the actual implementation up to the compiler. In C#, you do the same thing using the keyword \u0027ref\u0027:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E// C# style reference.\u003Cbr\u003Evoid foo(ref int x)\u003Cbr\u003E{\u003Cbr\u003E\tx = 5;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Estatic void Main()\u003Cbr\u003E{\u003Cbr\u003E\tint y = 7;\u003Cbr\u003E\u003Cbr\u003E\tfoo(y);\u003Cbr\u003E\tConsole.WriteLine(y);\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENote that in C#, \u003Cem\u003Eonly value types\u003C/em\u003E (int, long, double, float, bool, struct, enum) are ever passed by value. All other types (i.e. classes) are \u003Cem\u003Ealways \u003C/em\u003Epassed by reference.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003EIf i the create int z = 12 and call foo(z) then I should hope that the previous function had been cleared from scope, otherwise problems.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EEvery time you call the function, a new set of parameters are pushed onto the stack and used to execute the function. It doesn\u0027t matter if it\u0027s been cleared from scope or not. You can call the function from inside itself. The only way you can create problems is to declare your local variables inside the function (x in this case) with static scope, which will essentially mean that they\u0027re always called by reference. This feature proves useful for recursion or for tracking values. \u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003EAnyway, lets clarify this foo(int \u0026amp;x)creates an alias to a calling variable when a \u0027funtion\u0027 is called. Its the same as saying that x has a name in two places, y is its birth name and foo.x is one of its names when its in function land. Ulike Vegas what happens in function_land does not stay in function land.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIt\u0027s not quite aliasing. Both C and C\u002B\u002B require some understanding of the underlying memory model. Variables describe memory locations that hold values. When I say \u0022int x=0\u0022, the compiler assigns the name x to a particular memory location and stores the value 0 there. (Actually it\u0027s the linker that assigns memory locations; the compiler simply exports a set of symbols to the linker.) Every time I refer to x, the compiler grabs the value 0 from that memory location. When I pass a variable to a function I can either pass the value of the variable or the address of the memory location where the variable is stored. If I pass the value, then it doesn\u0027t matter what I do in the function because the function only has the \u003Cem\u003Evalue \u003C/em\u003E, not the variable itself. If I pass the memory location (i.e. pass-by-reference), then what happens in the function affects the value of the variable because it\u0027s affecting the same memory location.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-08T16:11:07Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Mr Shifty\u0022 data-cite=\u0022Mr Shifty\u0022\u003E\u003Cdiv\u003EThe ampersand serves multiple functions, but in this case it\u0027s a pass-by-reference operator, not an aliasing identifier. It simply means that when you call this function, the compiler will ensure somehow that the parameters passed by reference are actually referenced. \u003C/div\u003E\u003C/blockquote\u003E I\u0027de actually like to see a literary reference to this, I did not pick this out of a couple of books. It like, gee wow with C\u002B\u002B you can avoid dealing with pointers and here\u0027s how, a reference identifyer and btw its just an alias ...........and here\u0027s another thing you can do stick them in a function definition. The microsoft description is confusing and I still don\u0027t know how they work in struct statements, since MS totally avoids struct issues in C\u002B\u002B. \u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EUsually it will do this by pushing the address of the variable onto the stack (which is the explicit implementation in C that K^2 showed), but C\u002B\u002B abstracts that a bit and leaves the actual implementation up to the compiler. In C#, you do the same thing using the keyword \u0027ref\u0027:\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWe\u0027ll leave C# out of this for a while, I don\u0027t need this to write ASM integratives, but the question is whether one can reference an array and access the array in ASM, obviously I don\u0027t want to pass array variables on a stack as this would superceded the stack, you might want to pass the array dimensions. \u003C/p\u003E\u003Cp\u003EI think I need to run a trial of this is C\u002B\u002B and see how it functions, maybe that will clear things up. Thanks for the help. \u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003E\u003Cp\u003ENote that in C#, \u003Cem\u003Eonly value types\u003C/em\u003E (int, long, double, float, bool, struct, enum) are ever passed by value. All other types (i.e. classes) are \u003Cem\u003Ealways \u003C/em\u003Epassed by reference.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYes the problem is however are what are the specific stack handling procedures for C# passes to ASM, do they differ from C\u002B\u002B?\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EEvery time you call the function, a new set of parameters are pushed onto the stack and used to execute the function. It doesn\u0027t matter if it\u0027s been cleared from scope or not. You can call the function from inside itself. The only way you can create problems is to declare your local variables inside the function (x in this case) with static scope, which will essentially mean that they\u0027re always called by reference. This feature proves useful for recursion or for tracking values. \u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThis is somewhat in contradiction to what is written or maybe there are nuances to it. The issue is that \u0026amp; character creates a reference. At least the way I understand it, the char myString[] = \u0022hey bubba\u0022; \u0026amp;heyBubba = mystring, that heyBubba always refers to the location of \u0022hey bubba\u0022 and no other comparable reference can refer to it or potentially alter mystring as long as heyBubba exist. \u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EWhen I pass a variable to a function I can either pass the value of the variable or the address of the memory location where the variable is stored. If I pass the value, then it doesn\u0027t matter what I do in the function because the function only has the \u003Cem\u003Evalue \u003C/em\u003E, not the variable itself.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAt least in theory, if C is passing the same way to C functions as it is to ASM functions interrupt the stack. Before you return you remove the \u0027return\u0027 register values from the stack and tuck them into memory elsewhere, then you remove the arguments from the stack and change them putting them back, then place return values back into their registers and return. When they are returned however C compiler encode will simply remove them from the stack and make them go bye-bye, unless you stop C from doing this (theoretically by a kobiashi-maru manuever) and then replace the originating variables with the value. This is probably one of those C transformations that the whole GNU world would frown upon. Theoretically you could create a new type of function call (lets say) \u0026amp;foo(argument list)\u0026amp; that tells the compiler to keep track of the address of the sending variable (where else but on the stack) and pulls the arguements off the stacks and places them back into the variables memory location, after that it removes 8 or 16 bytes from the stack pointer per argument and everyone is none the less wiser to the whole ordeal. \u003C/p\u003E\u003Cp\u003EThe problem with passing references between C and a routine is that what if the routine or C is very big, would the ASM be actually referencing the right address in the right segment. As long as the programs are in the same 64k segment that\u0027s not a problem, if my routine is in another segment then that reference also needs to be combined with the appropriate segment address. For this to work seemlessly I need to be able to alter a variable defined in C. main and in mains segment from ASM.main and whatever segment it lies within. If my routine is compiled separately from C and added as a runtime library, how would it work\u003C/p\u003E\u003Cp\u003E \u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EIf I pass the memory location (i.e. pass-by-reference), then what happens in the function affects the value of the variable because it\u0027s affecting the same memory location.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWe can make this simple, if I compile several functions in different C-runtime libraries can I pass by reference variables and be assurred that the memory location will be accessed. Do the variables need to be declared global and how is this best done in main (or at the structure level?)\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-08T16:16:05Z\u0022 title=\u002210/08/2015 04:16  PM\u0022 data-short=\u00228 yr\u0022\u003EOctober 8, 2015\u003C/time\u003E by PB666\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2015-10-08T20:04:54Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003Echar myString[] = \u0022hey bubba\u0022; \u0026amp;heyBubba = mystring, that heyBubba always refers to the location of \u0022hey bubba\u0022 and no other comparable reference can refer to it or potentially alter mystring as long as heyBubba exist. \u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou can\u0027t do \u0022\u0026amp;heyBubba = mystring;\u0022. The \u0026amp; operator returns an address, which you can\u0027t assign to. You could say \u0022char *heyBubba = mystring;\u0022 but you can\u0027t assign an address directly to a non-pointer variable in C. There\u0027s no mechanism for preventing another variable from referring to the same memory location and changing it. The const keyword provides some protection which strength depends on the compiler, but there are usually ways around it with pointer tricks.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003EWe can make this simple, if I compile several functions in different C-runtime libraries can I pass by reference variables and be assurred that the memory location will be accessed. Do the variables need to be declared global and how is this best done in main (or at the structure level?)\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAny variable declared with extern scope, or declared at the top level (i.e. outside of any function definition) of a module (*.c file plus included *.h files) will have global scope and will be assigned a symbol by the linker. Typically each module is compiled to an object file (*.o or something), which contains assembly code with linker symbols in place of memory locations, and some information for the linker about how much and what type of memory the module needs. The linker trolls through all of the object files you give it, looking for symbols (function names are symbols too) and creating a symbol table: symbol name, number of bytes needed, initialization value (if any), and special instructions for it (like an explicit address assignment, or an assignment to a specific memory block using preprocessor directives or something.) Once the symbol tables are compiled, it assigns addresses to all the symbols, then pulls all the assembly together into final machine code, with the proper addresses in place of symbols. The linker doesn\u0027t care what language your source code is in; it always works with compiled assembly. It has no problem integrating an assembly object file, provided the symbol table exists.\u003C/p\u003E\u003Cp\u003EIt\u0027s worth looking, sometime, at all the intermediate files generated by your compile chain to get a sense of what each module does.\u003C/p\u003E\u003Cp\u003Etl;dr - If you pass a parameter by reference, you can always be assured that the correct memory location will be addressed, regardless of whether your passed variable is global in scope or not. The \u003Cem\u003Efunction \u003C/em\u003Ehas to have global scope, but they are by default.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-08T20:11:34Z\u0022 title=\u002210/08/2015 08:11  PM\u0022 data-short=\u00228 yr\u0022\u003EOctober 8, 2015\u003C/time\u003E by Mr Shifty\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-08T21:39:15Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Mr Shifty\u0022 data-cite=\u0022Mr Shifty\u0022\u003E\u003Cdiv\u003EYou can\u0027t do \u0022\u0026amp;heyBubba = mystring;\u0022. The \u0026amp; operator returns an address, which you can\u0027t assign to. You could say \u0022char *heyBubba = mystring;\u0022 but you can\u0027t assign an address directly to a non-pointer variable in C. There\u0027s no mechanism for preventing another variable from referring to the same memory location and changing it. The const keyword provides some protection which strength depends on the compiler, but there are usually ways around it with pointer tricks.\u003C/div\u003E\u003C/blockquote\u003E must be a miscommunication, thought we were talking about C\u002B\u002B; anyway will look later. Tonight is a coding night, no more reading. \u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EIf you pass a parameter by reference, you can always be assured that the correct memory location will be addressed, regardless of whether your passed variable is global in scope or not. The \u003Cem\u003Efunction \u003C/em\u003Ehas to have global scope, but they are by default.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIn C, C\u002B\u002B or C#? I know in MS you have to be explicit about scope in many instances, particularly variables.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-08T23:21:04Z","Content":"\n\u003Cp\u003EYou need to actually learn a few things about l-values vs r-values and scope.\u003C/p\u003E\u003Cp\u003EPassing parameter by reference has nothing to do with scope at all. You literally pass in a pointer to a memory location where relevant data is stored. Scope is irrelevant at this point. Life time of that data might be relevant. Here is an example of a thing you should NOT be doing.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Estatic int* var1;\u003Cbr\u003E\u003Cbr\u003Evoid function1(volatile int \u0026amp;var2)\u003Cbr\u003E{\u003Cbr\u003E\tvar1 = (int*)\u0026amp;var2;\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Evoid function2(void)\u003Cbr\u003E{\u003Cbr\u003E\tvolatile int var3 = 7;\u003Cbr\u003E\u003Cbr\u003E\tfunction1(var3);\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Evoid function3(void)\u003Cbr\u003E{\u003Cbr\u003E\tvolatile int var4 = 12;\u003Cbr\u003E\u003Cbr\u003E\tprintf(\u0022*var1 = %d\\n\u0022, *var1);\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Eint main(void)\u003Cbr\u003E{\u003Cbr\u003E\tfunction2();\u003Cbr\u003E\tfunction3();\u003Cbr\u003E\u003Cbr\u003E\treturn 0;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe \u0022unexpected\u0022 behavior of this program is that it will print out \u0022*var1 = 12\u0022. This has to do with the fact that var4 got allocated to the same place in stack as var3 used to occupy. So instead of printing val3, we\u0027re really asking the program to print var4. This is something to be aware of when passing variables by reference. But you have to get creative to actually break a program in this way.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-08T23:27:20Z\u0022 title=\u002210/08/2015 11:27  PM\u0022 data-short=\u00228 yr\u0022\u003EOctober 8, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"manaiaK","CreatedById":129599,"CreatedDateTime":"2015-10-09T03:21:51Z","Content":"\n\u003Cp\u003EPB666, about your genome processing code: have you profiled your code? \u003Cspan style=\u0022text-decoration:underline;\u0022\u003EWhich parts\u003C/span\u003E are too slow? \u003C/p\u003E\u003Cp\u003EThe normal situation when a program is \u0022too slow\u0022 is that: 1. the programmer has guessed \u003Cem\u003Ecompletely wrongly\u003C/em\u003E about where the program is slow; 2. the program spends more than 95% of its time executing less than 5% of the code -- that\u0027s the only code that needs to be re-written; 3. changing the algorithm, still using the same language, makes the problem go away. \u003C/p\u003E\u003Cp\u003EUnless you profile, you\u0027re wasting your time.\u003C/p\u003E\u003Cp\u003EAlso, modern compilers know almost infinitely more about the hardware they are compiling for than do 99.999% of programmers. Don\u0027t try to force the compiler to do things; write simple, clear code and let the compiler do its thing.\u003C/p\u003E\u003Cp\u003EOptimization effort (including re-writing in a different language) is completely wasted, unless you profile your code, so you \u003Cem\u003Eknow\u003C/em\u003E where the problems are.\u003C/p\u003E\u003Cp\u003EOf course if you just want to learn C or C\u002B\u002B or C# (three very different language ecosystems, by the way), then fine: go right ahead. I\u0027m learning some C myself, using \u003Cem\u003E21st Century C\u003C/em\u003E and \u003Cem\u003ELearn C the Hard Way\u003C/em\u003E. But each of those languages will take you about a thousand hours to get reasonable proficiency (sufficient for a well-written 10,000 LoC application); while you\u0027re learning the second language you\u0027ll lose proficiency in the first, because they\u0027re \u003Cem\u003Edifferent\u003C/em\u003E. \u003C/p\u003E\u003Cp\u003EI mean the following as friendly advice: from what you have written, you\u0027d get more value from spending that time (and book money) on learning algorithms, in Python or Lua (or VB.NET, if you prefer). Secondly, if you do use C or C\u002B\u002B, get in the habit of using valgrind and gprof every time you compile. (C#: There\u0027s a choice of profiling tools in the .NET world, it seems). Oh, and if compiling for your own use on i386, use gcc -march=native to use have gcc automatically use native hardware features like SSE2, ...., SSE4.1, or AVX.\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-09T08:52:46Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022manaiaK\u0022 data-cite=\u0022manaiaK\u0022\u003E\u003Cdiv\u003EOptimization effort (including re-writing in a different language) is completely wasted, unless you profile your code, so you \u003Cem\u003Eknow\u003C/em\u003E where the problems are.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThis is actually wrong.\u003C/p\u003E\u003Cp\u003ERoughly speaking, profilers are useful when you\u0027re writing software, but less so if you\u0027re writing algorithmic code. If your code is a complex combination of simple tasks, you usually need a profiler to see where the bottlenecks are. On the other hand, if your code is a simple combination of complex tasks, you\u0027re just a wrong person for the job, if you can\u0027t see where the bottlenecks are without any help 95% of the time.\u003C/p\u003E\u003Cp\u003EThere are also some common pitfalls when using profilers with algorithmic code (like in this case). One is that you may be measuring the wrong thing. It\u0027s quite common with algorithmic code that the bottleneck depends on input size, input type and/or the environment. By profiling with a handful of test cases and optimizing the code for them, you may actually be hurting its performance with real data. Thorough performance measurements may take weeks, months, or even years. Another issue is that the measurements themselves are wrong. Measuring the performance changes the behavior of the program and often moves the low-level bottlenecks to different places.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-09T10:51:00Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EMeasuring the performance changes the behavior of the program and often moves the low-level bottlenecks to different places.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThat\u0027s usually an indicator that your performance tools weren\u0027t written by someone who understands how to profile things quietly. There are ways to profile code with as little overhead as you need. E.g., reading system clock and storing result in a variable requires multiple calls, branches, and potentially cache misses. Whereas a read from TSC to a register is almost free.\u003C/p\u003E\n"},{"CreatedByName":"Van Disaster","CreatedById":58876,"CreatedDateTime":"2015-10-09T11:10:31Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022DestinyPlayer\u0022 data-cite=\u0022DestinyPlayer\u0022\u003E\u003Cdiv\u003EJust wanted to ask, is Lua a good language to learn how to program? What do people think of it, anyway?\u003Cp\u003EI already went through it, so this question is out of pure curiosity.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EA bit late to this: I really enjoy Lua, it\u0027s tiny but I keep finding more nuances all the time - I\u0027d also not recommend it as a starter language, it\u0027s a bit *too* fluid IMO. I learned on Turbo Pascal ( was it always OOP capable? my compiler came with a class library anyway ) \u0026amp; wrote C \u0026amp; Perl in roughly equal measure for a number of years - I\u0027d happily recommend a similar path to anyone wanting to start now, although I\u0027ve no idea what the equivalent would be these days.\u003C/p\u003E\u003Cp\u003ENot coded anything seriously - at least not in C, rarely in anything else - for a decade thanks to a horrendous accident, so anything I have to say is probably best taken with some salt.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-09T11:51:23Z","Content":"\n\u003Cp\u003ELooking for a good ASM/C debugger for ubuntu 14. Looks like the recommeneded debugger will not install, is there anything new out there that I am missing?\u003C/p\u003E\n"},{"CreatedByName":"Guest","CreatedById":-1,"CreatedDateTime":"2015-10-09T13:30:50Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022cicatrix\u0022 data-cite=\u0022cicatrix\u0022\u003E\u003Cdiv\u003EIt\u0027s history. There were Bell Labs, there was Unix and there was C (early 70s). Mainly, C became popular since Unix itself was re-written from the assembly language into C and Unix was pretty common these days.\u003Cp\u003EGenerally, there were also ALGOL, FORTRAN, PASCAL, etc but they were not universal enough and there were many dialects varying from one platform to another, from one compiler to another. So, the fact that there was a commonly accepted language standard added to the popularity of C.\u003C/p\u003E\u003Cp\u003EThen came C\u002B\u002B (mainly \u0027C with classes\u0027 and many new adepts followed the OOP paradigm). The language was adapted for IBM PC platform (now known as x86) and quickly become popular together with the platform itself. Certainly there were other languages but C\u002B\u002B compilers generated native code unlike their many counterparts that required runtime libraries. Thus C/C\u002B\u002B became the main tool for application development for x86.\u003C/p\u003E\u003Cp\u003EIt all runs along the same rails even now. Young people grow up with the knowledge that C\u002B\u002B is a \u0027must have\u0027 language in their portfolio, then they write applications and then there\u0027s another generation of programmers grows up with this knowledge.\u003C/p\u003E\u003Cp\u003ENow fortunately the CPU speeds and memory are huge and there\u0027s no need to count every CPU tick and every memory byte. This situation allowed creating huge frameworks that encapsulated many standard tasks in its classes. Java c C# were born. \u003C/p\u003E\u003Cp\u003EC#/Java allows you to quickly develop some tools you need without thinking of memory management, garbage collection, I/O, etc. They allow you to concentrate on the task you really need to solve. But everything comes at a price - you\u0027ve got .Net Framework or Java VM, you\u0027ve got slower execution performance and larger memory requirements.\u003C/p\u003E\u003Cp\u003EEvery task require an adequate tool, that\u0027s all. If you need performance or low system requirements use assembly / C / C\u002B\u002B. If you need simply to draw a window with a button without any particular requirements - use modern languages because it\u0027s simpler.\u003C/p\u003E\u003Cp\u003EAs for the brace matching - here\u0027s my advice - comment any closing brace:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Enamespace MyNamespace\u003Cbr\u003E{\u003Cbr\u003E    class MyClass\u003Cbr\u003E    {\u003Cbr\u003E\u003Cbr\u003E         while (someCondition)\u003Cbr\u003E         {\u003Cbr\u003E             try\u003Cbr\u003E             {\u003Cbr\u003E             } // try\u003Cbr\u003E             catch\u003Cbr\u003E             {\u003Cbr\u003E             } // catch\u003Cbr\u003E         } // while   \u003Cbr\u003E\u003Cbr\u003E    } // myClass\u003Cbr\u003E} // namespace MyNamespace\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ethis way you won\u0027t lose anything.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWhy didn\u0027t I think of that? Thanks!\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-09T14:24:59Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EThat\u0027s usually an indicator that your performance tools weren\u0027t written by someone who understands how to profile things quietly. There are ways to profile code with as little overhead as you need. E.g., reading system clock and storing result in a variable requires multiple calls, branches, and potentially cache misses. Whereas a read from TSC to a register is almost free.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIf the performance tools require special compiler options instead of working directly with the production executable, they\u0027re obviously producing wrong results. Similarly, if they execute any CPU instructions or use registers, cache and/or memory, they\u0027re by definition altering the behavior of the program.\u003C/p\u003E\u003Cp\u003EA profiler is a rough tool. If there is an obvious bottleneck in the code, the profiler can probably find it. If there are multiple and/or less obvious bottlenecks, the profiler may not be able to identify them correctly. C\u002B\u002B code is particularly hard to profile, because a change in one place may lead the optimizer to make different decisions in a seemingly unrelated place.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-09T21:00:26Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EIf the performance tools require special compiler options instead of working directly with the production executable, they\u0027re obviously producing wrong results. Similarly, if they execute any CPU instructions or use registers, cache and/or memory, they\u0027re by definition altering the behavior of the program.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThree are cache lines you can pretty much assume are going to be loaded - anything that contains current stack pointers for your process. An rdtsc call and a subtract to memory that\u0027s already in cache is going to cost you a few clock cycles, no additional latency, and no cache misses. It\u0027s as close as you can get to it being free and still have it do something. You can still mess up your timing by inserting this code in the middle of a tight loop, but if you are wrapping performance counters around something that takes less than 100 cycles to complete, you are just doing it wrong.\u003C/p\u003E\u003Cp\u003EWith correct usage, the impact of profiling code is smaller than fluctuations you get due to variations in thread-switching and cache miss stalls during normal operation. If the impact you introduce is smaller than fluctuations, it will not affect the results. You will not suddenly see it stall in a place it did not before.\u003C/p\u003E\u003Cp\u003EBut sure, if you use off-the-shelf profiling tools, and implement them haphazardly without understanding what they do, you\u0027ll get poor results. But it\u0027s your own fault then.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-09T22:34:46Z","Content":"\n\u003Cp\u003EJust some light reading. \u003Cstrong\u003EDon\u0027t click if you have a slow connection\u003C/strong\u003E its plus 3603 pages of that will put a highly caffinated clinical insomniac to sleep. \u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EOk having got that out of the way, I don\u0027t fathom how they are implementing 64 bit operations, it seems that some of the code is cryptic (and I don\u0027t mean the usual intel I32 codes were written by martians). \u003C/p\u003E\u003Cp\u003ESo for instance you have alot of restrictions you cannot add a 64 bit integer to a 64 bit integer, 32 is the limit. I am assuming that RAX is the 64 bit length instance of the A register, that RBX, RCX and RDX are the other registers. But there are supposed to be 8 more registers, but not any real way of accessing these. Although I am taking that R8-R15 are the registers and that they only allow 64 bit processes. IOW I can only load and operated 64 bit in these?\u003C/p\u003E\u003Cp\u003Ee.g. \u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Emov r8, [m1]\u003Cbr\u003Eadc rax, r8\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-09T23:11:00Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EYou can still mess up your timing by inserting this code in the middle of a tight loop, but if you are wrapping performance counters around something that takes less than 100 cycles to complete, you are just doing it wrong.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIn the kind of code I\u0027m talking about, the performance impact of anything taking more than 100 cycles (but less than a second) is usually obvious. We know quite precisely what the code is doing, and there are no black boxes or complex data-dependent call graphs around. The impact of high-level algorithmic choices can be less obvious, while it\u0027s hard to determine what takes the most time inside the innermost loops.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EWith correct usage, the impact of profiling code is smaller than fluctuations you get due to variations in thread-switching and cache miss stalls during normal operation. If the impact you introduce is smaller than fluctuations, it will not affect the results. You will not suddenly see it stall in a place it did not before.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EMy favorite is a loop that my laptop executes either 0.5 billion or 2 billion iterations/second, depending on whether a certain unrelated piece of code is present in the same compilation unit. The optimizers of modern compilers are incredibly smart, except when they happen to be incredibly stupid or incredibly unpredictable.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-09T23:24:57Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EIn the kind of code I\u0027m talking about, the performance impact of anything taking more than 100 cycles (but less than a second) is usually obvious.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIf you can predict where cache and thread contention/thrashing happens in multi-threaded code that has both complex control structures and tight computational loops, you are a wizard, and laws of human logic do not apply to you. The rest of us need to do frame captures to identify problem areas, and that requires snippets of performance-tracking codes scattered throughout.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EMy favorite is a loop that my laptop executes either 0.5 billion or 2 billion iterations/second, depending on whether a certain unrelated piece of code is present in the same compilation unit. The optimizers of modern compilers are incredibly smart, except when they happen to be incredibly stupid or incredibly unpredictable.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAgain, if your performance analysis code affects optimization, you don\u0027t know how to write performance analysis code.\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-10T10:25:26Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EIf you can predict where cache and thread contention/thrashing happens in multi-threaded code that has both complex control structures and tight computational loops, you are a wizard, and laws of human logic do not apply to you. The rest of us need to do frame captures to identify problem areas, and that requires snippets of performance-tracking codes scattered throughout.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ERemember that I was talking about simple combinations of complex things, not about complex combinations of simple things. Threads may run for minutes or hours independently. At any level above the innermost loop bodies, there are probably 1-3 sequentially executed tasks that take a nontrivial amount of time, and a number of smaller tasks that are orders of magnitude faster. You typically have no control over what other CPU/memory intensive processes are running at the same time.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EAgain, if your performance analysis code affects optimization, you don\u0027t know how to write performance analysis code.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EMy point was that it\u0027s always a minor change that pushes the optimizer past a critical threshold. You add a single instruction to a function or call it in one more place, and the optimizer decides that it\u0027s no longer beneficial to inline the function. That\u0027s the fundamental nature of binary choices.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-10T23:45:21Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003ERemember that I was talking about simple combinations of complex things, not about complex combinations of simple things.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAnd what do you think is inside these complex things? Anything complex in a computer is just a complex arrangement of simple instructions. But no matter. If all you have is a few complex algorithms, it\u0027s even more important to profile to know which one is the bottle neck. Then you dive inside and you profile the simple things it\u0027s built out of to see why.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EThreads may run for minutes or hours independently. At any level above the innermost loop bodies, there are probably 1-3 sequentially executed tasks that take a nontrivial amount of time, and a number of smaller tasks that are orders of magnitude faster. You typically have no control over what other CPU/memory intensive processes are running at the same time.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe threads can be running in different processes on different CPUs in different rooms on a supercomputer cluster. That doesn\u0027t make any difference. You still have to profile each thread to know what actually needs improvement.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Jouni\u0022 data-cite=\u0022Jouni\u0022\u003E\u003Cdiv\u003EMy point was that it\u0027s always a minor change that pushes the optimizer past a critical threshold. You add a single instruction to a function or call it in one more place, and the optimizer decides that it\u0027s no longer beneficial to inline the function. That\u0027s the fundamental nature of binary choices.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EFor all practical purposes, a static __inline will always get inlined. Has to do with scope. You should never, ever rely on optimizer to make these sorts of decisions for you. If it should be inlined, inline it. If it shouldn\u0027t, don\u0027t. Pretty simple.\u003C/p\u003E\u003Cp\u003ENow, if you wanted to be clever about this argument, you\u0027d bring up something like loop unrolling, which is entirely up to optimizer and can still have significant impact. But even that\u0027s fairly easy to predict if you understand what optimizer is optimizing.\u003C/p\u003E\u003Cp\u003ESo I will reiterate. If your profiling code upsets optimization, you are doing it wrong. You need to go back and learn low level optimization. Or at least, let someone who know what they are doing write the profiling code.\u003C/p\u003E\n"},{"CreatedByName":"Jouni","CreatedById":97346,"CreatedDateTime":"2015-10-11T10:02:14Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EAnd what do you think is inside these complex things? Anything complex in a computer is just a complex arrangement of simple instructions. But no matter. If all you have is a few complex algorithms, it\u0027s even more important to profile to know which one is the bottle neck. Then you dive inside and you profile the simple things it\u0027s built out of to see why.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAs I said, there are simple combinations of complex things inside those complex things. At any level above the innermost loop bodies, there are typically 1-3 sequentially executed tasks that take a nontrivial amount of time, and those tasks are almost always obvious to anyone. At any level, you can choose any of the nontrivial tasks to optimize, and you see a noticeable improvement in performance. Optimize all of them, and you see a significant improvement.\u003C/p\u003E\u003Cp\u003EThat\u0027s how things work in scientific computing, and in data processing in general. The structure of the code tends to be simple, and the bottlenecks are usually obvious.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EFor all practical purposes, a static __inline will always get inlined. Has to do with scope. You should never, ever rely on optimizer to make these sorts of decisions for you. If it should be inlined, inline it. If it shouldn\u0027t, don\u0027t. Pretty simple.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EMany compilers treat inline as a hint, which they can choose to ignore. Because scientific software is almost always distributed as source code, you can\u0027t rely on compiler-specific behavior.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-15T19:30:09Z","Content":"\n\u003Cp\u003ERunning into a bit of a snag in C\u002B\u002B.\u003C/p\u003E\u003Cp\u003EApparently, i am finding that generic C string processing does not exist. Instead string processing functions are left to variable included libraries. In fact, i learned that the char type is good for little more than holding. Manipulating char apparently thows a warning message. I think i have all th tools i need for capturing strings, but the problem is that character processing seems to be very ineffecient, I will have to 2 to 4 type conversions to get what i want.\u003C/p\u003E\u003Cp\u003E Does anyone know of a GNU library for C that has a broad spectrum of char comparison, manipulation or conversion functions. Right now because of my IDE i\u0027de like to have something that works well in # and \u002B\u002B.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-15T20:17:57Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022PB666\u0022 data-cite=\u0022PB666\u0022\u003E\u003Cdiv\u003ERunning into a bit of a snag in C\u002B\u002B.\u003Cp\u003EApparently, i am finding that generic C string processing does not exist. Instead string processing functions are left to variable included libraries. In fact, i learned that the char type is good for little more than holding. Manipulating char apparently thows a warning message. I think i have all th tools i need for capturing strings, but the problem is that character processing seems to be very ineffecient, I will have to 2 to 4 type conversions to get what i want.\u003C/p\u003E\u003Cp\u003E Does anyone know of a GNU library for C that has a broad spectrum of char comparison, manipulation or conversion functions. Right now because of my IDE i\u0027de like to have something that works well in # and \u002B\u002B.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWhy? A string in C is literally an array of characters. string.h has a bunch of functions for manipulating strings. And if you need to do conversion to number or what have you, there is sscanf() function in stdio.h.\u003C/p\u003E\u003Cp\u003EYou are just spoiled by managed types. These do not exist in C/C\u002B\u002B because they are \u003Cem\u003Eslow\u003C/em\u003E. Want to have fast code? Learn to manage your own data.\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-10-15T23:29:39Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EWhy? A string in C is literally an array of characters. string.h has a bunch of functions for manipulating strings. And if you need to do conversion to number or what have you, there is sscanf() function in stdio.h.\u003Cp\u003EYou are just spoiled by managed types. These do not exist in C/C\u002B\u002B because they are \u003Cem\u003Eslow\u003C/em\u003E. Want to have fast code? Learn to manage your own data.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou like to shoot first and asked questions later. Sscanf() maybe useful in the future but not right now. The base issue was the comparisons weren\u0027t working, the compiler was rejecting every data type that I could try for the char type comparison, I thought the 0x would work, it failed so I tried \u0022A\u0022 which failed. Not sure why but only immediate decimal is working at the moment. Also tried byte to char. Thats why I asked about comparison and conversion. Wasn\u0027t trying to VB your beloved C, simply tying to do a conversion that anyone who knows how to do assembly language can do.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-10-16T00:00:58Z","Content":"\n\u003Cp\u003EBecause \u0027A\u0027 isn\u0027t a string. It\u0027s a character. \u0022A\u0022 is a string, which contains two characters. \u0027A\u0027 and \u0027\\0\u0027. The trailing \u0027\\0\u0027, which happens to be ASCII 0, is there to indicate that the string has ended.\u003C/p\u003E\u003Cp\u003EHere\u0027s a demo for you that might help.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr\u003E#include \u0026lt;string.h\u0026gt;\u003Cbr\u003E\u003Cbr\u003Eint main(void)\u003Cbr\u003E{\u003Cbr\u003E\tchar* pcPassword = \u0022MySecretPassword\u0022; // This is the correct password. It\u0027s a pointer to first character.\u003Cbr\u003E\tchar pcBuffer[128]; // This is an array of characters where attempt will be stored.\u003Cbr\u003E\u003Cbr\u003E\twhile(1)\u003Cbr\u003E\t{\u003Cbr\u003E\t\tprintf(\u0022Enter password: \u0022);\u003Cbr\u003E\t\tscanf(\u0022%s\u0022, pcBuffer); // Read user input into pcBuffer.\u003Cbr\u003E\u003Cbr\u003E\t\tif(strcmp(pcPassword, pcBuffer)) // If strings are DIFFERENT...\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tprintf(\u0022Incorrect! Try again.\\n\u0022);\u003Cbr\u003E\t\t}\u003Cbr\u003E\t\telse // If they are the same...\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tprintf(\u0022Correct!\\n\u0022);\u003Cbr\u003E\t\t\tbreak; // Leave the loop.\u003Cbr\u003E\t\t}\u003Cbr\u003E\t}\u003Cbr\u003E\u003Cbr\u003E\treturn 0;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENote that you should never, ever test passwords like that, and not just because one could buffer-overflow this code. But I don\u0027t think you\u0027re worried about security in your code. This approach is fine if you are just parsing a file, or something. And you can use sscanf and fscanf in exactly the same way.\u003C/p\u003E\u003Cp\u003EThere are also several variations of that strcmp functions, including ones that ignore case differences and ones that only compare first n characters. Look up the docs. Keep in mind that strcmp will return false if strings are the same. It\u0027s counter-intuitive but there are some reasons for it that probably aren\u0027t relevant to what you are doing.\u003C/p\u003E\u003Cp\u003EP.S. I\u0027m using Hungarian Notation here. The \u0022pc\u0022 on variables stands for \u0022Pointer to Char\u0022. Technically, char[] and char* aren\u0027t the same thing, but in this case, they serve the same purpose, so both are labeled with \u0022pc\u0022.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-10-16T00:03:14Z\u0022 title=\u002210/16/2015 12:03  AM\u0022 data-short=\u00228 yr\u0022\u003EOctober 16, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"}]}