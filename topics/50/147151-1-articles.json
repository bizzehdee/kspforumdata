{"TopicId":147151,"ForumId":50,"TopicTitle":"Advanced Orbital Mechanics using kOS","CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-09-06T00:16:07Z","PageNum":1,"Articles":[{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-09-06T00:16:08Z","Content":"\n\u003Cp\u003E\nAfter a lot of research on various orbital manuevres, I\u0027ve managed to create a fairly simple bit of code that allows one to set both perigee and apogee in one burn.\n\u003C/p\u003E\n\u003Cp\u003E\nMost of the research I did showed that some people think this is impossible without complicated loops, and it\u0027s barely mentioned, if at all, in the textbooks I have access to, so I thought I\u0027d share it here.\n\u003C/p\u003E\n\u003Cp\u003E\nObviously, there are some conditions:\n\u003C/p\u003E\n\u003Cp\u003E\n1) The requested orbit and the current orbit must cross. It will crash if not - it would be mathematically and physically impossible to do in 1 burn.\n\u003C/p\u003E\n\u003Cp\u003E\n2) If the burn is not done at an apse, it will cause the apse line to rotate.\n\u003C/p\u003E\n\u003Cp\u003E\nObviously there are more fuel efficient ways to do this, however it can be useful for minor correction burns or when time is of the essence (perhaps you\u0027re about to crash into a planet!). Probably the most important advantage is that it can be done anywhere in the orbit (depending on how much fuel you can spare), so no more endlessly circularising and faffing about with those stupid \u0022hohmann\u0022 burns. Yay!\n\u003C/p\u003E\n\u003Cp\u003E\nAnyway, on with the show:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nfunction oneorbit\u003Cbr\u003E\n{\u003Cbr\u003E\n// Sets up a single burn in time t to effect an orbit with\u003Cbr\u003E\n// perigee p and apogee a.\u003Cbr\u003E\n// Necessarily will rotate the apse line, unless done at an apsis.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter t, p, a.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0print \u0022oneorbit(): t = \u0022 \u002Bround(t)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u002B\u0022s, p = \u0022 \u002Bround((p-BODY:RADIUS)/1000,2)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u002B\u0022km, a = \u0022 \u002Bround((a-BODY:RADIUS)/1000, 2) \u002B\u0022km\u00A0 \u0022.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// initial orbit characteristics at burn point\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vr to positionat(SHIP, TIME \u002Bt) -BODY:POSITION.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vi to velocityat(SHIP, TIME \u002Bt):ORBIT.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vn to VCRS(Vr, Vi):normalized. // normal\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vt to VCRS(Vn, Vr):normalized. // tangent direction\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local frame to -SHIP:PROGRADE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0*rotatefromto(Vi, OBT:VELOCITY:ORBIT).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// desired final orbit characteristics\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local smaf to (p \u002Ba) /2.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Sf to sqrt(BODY:MU *(2/Vr:mag -1/smaf)).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Sp to sqrt((2*BODY:MU *a)/(p*(a\u002Bp))).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// calculate flight path angles...\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local zaf to arcsin((Sp *p)/(Vr:mag *Sf)).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local fpaf to 90 -zaf.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local Vf to (angleaxis(fpaf, Vn) *Vt):normalized *Sf.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local dVf to frame *(Vf -Vi).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local nd to node(TIME:SECONDS \u002Bt, dVf:y, dVf:x, dVf:z).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0add nd.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return dVf:mag.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-09-06T01:05:18Z","Content":"\n\u003Cp\u003E\nHere\u0027s a simplified version that just circularises.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nfunction circ {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter lead.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0set Vr to positionat(SHIP, TIME \u002Blead) -BODY:POSITION.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set Vb to velocityat(SHIP, TIME \u002Blead):ORBIT.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// set a rotation frame to fix up wacky KSP coordinates...\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set frame to -SHIP:PROGRADE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0*rotatefromto(Vb, OBT:VELOCITY:ORBIT).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0set Sc to sqrt(BODY:MU /Vr:mag). // circular speed\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set onorm to VCRS(Vb, Vr).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set Vc to VCRS(Vr, onorm):normalized *Sc.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E to frame *(Vc -Vb).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E:mag \u0026gt; 0.1 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0print \u0022circ(): circularizing in \u0022\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u002Bround(lead,1) \u002B\u0022s\u00A0\u00A0 \u0022.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set cn to node(TIME:SECONDS \u002Blead, \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E:y, \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E:x, \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E:z).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0add cn.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return cn.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return False.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003C/p\u003E\n\u003Cbr\u003E\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-09-14T09:59:56Z","Content":"\n\u003Cp\u003E\nAre we there yet, dad?\n\u003C/p\u003E\n\u003Cp\u003E\nThese will tell you how long it takes to get to another point in your orbit.\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\nfunction eccan\u003Cbr\u003E\n{\u003Cbr\u003E\n// returns eccentric anomaly for true anomaly t\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter t.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local ecc to OBT:ECCENTRICITY.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local i1 to sqrt((1 -ecc) /(1 \u002Becc)).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return arctan(i1 *tan(t/2)) *2.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nfunction tofang\u003Cbr\u003E\n{\u003Cbr\u003E\n// calculates time to rotate angle a around orbit from now.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter a.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local ecc to OBT:ECCENTRICITY.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local Eo to eccan(OBT:TRUEANOMALY).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Et to eccan(OBT:TRUEANOMALY \u002Ba).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// not sure why we need *RadtoDeg, ecc is a ratio\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// and everything else is in degrees. it works though.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local r2d to CONSTANT:RadtoDeg.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Mo to Eo -ecc *sin(Eo) *r2d.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Mt to Et -ecc *sin(Et) *r2d.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// Account for angles \u0026gt; 360. Dont do backward angles if\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// we cross perigee\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set dM to mod(Mt -Mo \u002B360, 360).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return (dM *(OBT:PERIOD/360)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u002B(OBT:PERIOD *floor(a/360)))\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0*(a/abs(a)).\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\nIt could be modified to determine time of flight between random points in the orbit. I\u0027ll leave that as an exercise, or maybe present it later if the personal need arises.\n\u003C/p\u003E\n\u003Cp\u003E\nTip: The hard part about that, is that you can\u0027t get true anomaly from the other angles/\u0022anomalys\u0022 easily, so you have to calculate the first point another way.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-09-14T10:30:00Z\u0022 title=\u002209/14/2016 10:30  AM\u0022 data-short=\u00227 yr\u0022\u003ESeptember 14, 2016\u003C/time\u003E by surge\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"kurja","CreatedById":66303,"CreatedDateTime":"2016-10-18T08:37:22Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222743563\u0022 data-ipsquote-contentid=\u0022147151\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221473120968\u0022 data-ipsquote-userid=\u0022136150\u0022 data-ipsquote-username=\u0022surge\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nOn 6.9.2016 at 3:16 AM, surge said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nAfter a lot of research on various orbital manuevres, I\u0027ve managed to create a fairly simple bit of code that allows one to set both perigee and apogee in one burn.\n\u003C/p\u003E\n\u003Cp\u003E\nMost of the research I did showed that some people think this is impossible without complicated loops, and it\u0027s barely mentioned, if at all, in the textbooks I have access to, so I thought I\u0027d share it here.\n\u003C/p\u003E\n\u003Cp\u003E\nObviously, there are some conditions:\n\u003C/p\u003E\n\u003Cp\u003E\n1) The requested orbit and the current orbit must cross. It will crash if not - it would be mathematically and physically impossible to do in 1 burn.\n\u003C/p\u003E\n\u003Cp\u003E\n2) If the burn is not done at an apse, it will cause the apse line to rotate.\n\u003C/p\u003E\n\u003Cp\u003E\nObviously there are more fuel efficient ways to do this, however it can be useful for minor correction burns or when time is of the essence (perhaps you\u0027re about to crash into a planet!). Probably the most important advantage is that it can be done anywhere in the orbit (depending on how much fuel you can spare), so no more endlessly circularising and faffing about with those stupid \u0022hohmann\u0022 burns. Yay!\n\u003C/p\u003E\n\u003Cp\u003E\nAnyway, on with the show:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Ca href=\u0022#\u0022 rel=\u0022\u0022\u003E\u00A0\u003C/a\u003E \u003Cspan\u003EHide contents\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nfunction oneorbit\u003Cbr\u003E\n{\u003Cbr\u003E\n// Sets up a single burn in time t to effect an orbit with\u003Cbr\u003E\n// perigee p and apogee a.\u003Cbr\u003E\n// Necessarily will rotate the apse line, unless done at an apsis.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter t, p, a.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0print \u0022oneorbit(): t = \u0022 \u002Bround(t)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u002B\u0022s, p = \u0022 \u002Bround((p-BODY:RADIUS)/1000,2)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u002B\u0022km, a = \u0022 \u002Bround((a-BODY:RADIUS)/1000, 2) \u002B\u0022km\u00A0 \u0022.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// initial orbit characteristics at burn point\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vr to positionat(SHIP, TIME \u002Bt) -BODY:POSITION.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vi to velocityat(SHIP, TIME \u002Bt):ORBIT.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vn to VCRS(Vr, Vi):normalized. // normal\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Vt to VCRS(Vn, Vr):normalized. // tangent direction\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local frame to -SHIP:PROGRADE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0*rotatefromto(Vi, OBT:VELOCITY:ORBIT).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// desired final orbit characteristics\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local smaf to (p \u002Ba) /2.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Sf to sqrt(BODY:MU *(2/Vr:mag -1/smaf)).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local Sp to sqrt((2*BODY:MU *a)/(p*(a\u002Bp))).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// calculate flight path angles...\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local zaf to arcsin((Sp *p)/(Vr:mag *Sf)).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local fpaf to 90 -zaf.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local Vf to (angleaxis(fpaf, Vn) *Vt):normalized *Sf.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local dVf to frame *(Vf -Vi).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local nd to node(TIME:SECONDS \u002Bt, dVf:y, dVf:x, dVf:z).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0add nd.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return dVf:mag.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nNice! What do you mean by \u0022rotating apse line\u0022? I\u0027m not familiar with that term. Longitude of the apse changes?\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-10-18T08:42:15Z\u0022 title=\u002210/18/2016 08:42  AM\u0022 data-short=\u00227 yr\u0022\u003EOctober 18, 2016\u003C/time\u003E by kurja\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-11-10T01:00:42Z","Content":"\n\u003Cp\u003E\nIt\u0027s fairly self-explanatory. According to textbooks, the \u0027apse line\u0027 is the line between periapsis and apoapsis. If you don\u0027t understand what\u0027s happening, I guess this maneuvre isn\u0027t for you!\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-11-10T06:34:43Z\u0022 title=\u002211/10/2016 06:34  AM\u0022 data-short=\u00227 yr\u0022\u003ENovember 10, 2016\u003C/time\u003E by surge\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"felgerkarb","CreatedById":172704,"CreatedDateTime":"2016-12-20T03:18:38Z","Content":"\n\u003Cp\u003E\nI am curious as to your source for the conversions of the Keplerian elements, since they are a bit different (and seem much more concise) than the ones I have found or have derived using my own rusty algebra, for example your eccentric anomaly from true anomaly formula. If you have a reference, I would love to know which one you use.\n\u003C/p\u003E\n\u003Cp\u003E\nThanks in advance.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2017-01-08T11:48:16Z","Content":"\n\u003Cp\u003E\nThe word \u0027Inflammable\u0027 was officially removed from real dictionaries at about the same time Pluto was declassified as a planet. Both of them had been in use for, lets average it out to about 1000 years.\n\u003C/p\u003E\n\u003Cp\u003E\nNarcissistic rocket scientists keep making up new names for the same concept just because they can.\n\u003C/p\u003E\n\u003Cp\u003E\nDoes that help?\n\u003C/p\u003E\n\u003Cp\u003E\nIf it doesn\u0027t, I chose the least mathematically computative of them. I\u0027m a computer scientist, not a rocket scientist, and I have very little idea or interest in what you\u0027re talking about.\n\u003C/p\u003E\n\u003Cp\u003E\nIf you can improve it computationally, go ahead, this is copyright free software!\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222017-01-08T11:58:49Z\u0022 title=\u002201/08/2017 11:58  AM\u0022 data-short=\u00227 yr\u0022\u003EJanuary 8, 2017\u003C/time\u003E by surge\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"felgerkarb","CreatedById":172704,"CreatedDateTime":"2017-01-08T12:32:05Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nQuote\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cdiv style=\u0022table-layout:fixed;width:975.455px;line-height:1.6;color:rgb(39,42,52);font-size:14px;margin-bottom:20px;margin-top:0px;font-family:\u0027Helvetica Neue\u0027, Helvetica, Arial, sans-serif;font-style:normal;font-weight:normal;letter-spacing:normal;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);\u0022\u003E\n\u003Cp style=\u0022margin-top:0px;\u0022\u003E\nAfter a lot of research on various orbital manuevres, I\u0027ve managed to create a fairly simple bit of code...\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThis is what I was hoping you could help with, based on your research. If you found a good reference, I would be grateful if you could share it, since, as I said, your could seems better than what I have been able to find or derive on my own. I am not sure why you say you don\u0027t know what I mean about True Anomaly or Eccentric Anomaly, since you use those terms in your code.\n\u003C/p\u003E\n\u003Cp\u003E\nSince I am not a rocket scientist nor a computer scientist, I doubt I can improve on it, which is why I asked the question.\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2017-03-25T17:23:53Z","Content":"\n\u003Cp\u003E\nWell, ok. I\u0027ve read parts of books such as \u0022Orbital Mechanics for Engineering Students\u0022, \u0022Fundamentals of Astrodynamics\u0022, Bate Mueller, and \u0022Fundamentals of Astrodynamics and Applications\u0022, D. Vallado.\n\u003C/p\u003E\n\u003Cp\u003E\nBut actually there is a video on youtube that explains all the \u0022anomalies\u0022 (there is of course Mean Anomoly too), and that was in part, my real source. The guy that made such an eloquent video is called \u003Ca href=\u0022https://www.youtube.com/channel/UCAUBEmQw1JNo5rD0MbMXoLg\u0022 rel=\u0022external nofollow\u0022\u003EOrbitNerd\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nAnd of course \u003Ca href=\u0022http://www.braeunig.us/space/orbmech.htm\u0022 rel=\u0022external nofollow\u0022\u003Ebraeunig\u0027s site\u003C/a\u003E which had all the fundamental mathematical equations in non-ridiculous terms that all those books above didn\u0027t. I essentially just condensed his work into the above code.\n\u003C/p\u003E\n\u003Cp\u003E\nHappy reading.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2018-03-14T20:37:51Z","Content":"\n\u003Cp\u003E\nReiterating over Lambert problems is taking forever? Tired of the sysadmins yelling at you for clogging up the cpus? Fear not, the laziest solution is relatively simple!\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\nfunction lambertMinE {\u003Cbr\u003E\n//\u003Cbr\u003E\n// Calculate V1 at R1 to get to R2.\u003Cbr\u003E\n//\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter R1, R2.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local R1R2 to R1:mag *R2:mag.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local cosdA to VDOT(R1, R2) /R1R2.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local sindA to VCRS(R1, R2):mag /R1R2.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// some weird excrements to do with geometry.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local c to sqrt(R1:mag^2 \u002BR2:mag^2 -2 *R1R2 *cosdA).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local s to (R1:mag \u002BR2:mag \u002Bc)/2.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// orbital parameters\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local amin to (R1:mag \u002BR2:mag \u002Bc) /4.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local pmin to R1R2 /c *(1 -cosdA).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local emin to sqrt(1 -2 *pmin /s).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local k to sqrt(BODY:MU *pmin) /(R1R2 *sindA).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local V1 to k *(R2 -(1 -R2:mag/pmin * (1 -cosdA)) *R1).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return V1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// FIXME: we could give TOF \u0026amp; V2 too, i think? (untested)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local b to arcsin(sqrt((s -c) /s)) *2.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local dT to sqrt(amin^3/BODY:MU) *(CONSTANT:PI -b \u002Bsin(b)).\u003Cbr\u003E\n//\u00A0\u00A0 \u00A0return list(V1, V2, dT).\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\nIt will give you V1, which is how fast you need to be going (as in the \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E and direction of your burn) at a radius of R1 to hit something at a radius of R2.\n\u003C/p\u003E\n\u003Cp\u003E\nAs you can see, you only need to supply the two \u0022positions\u0022. It can potentially do the rest; V2 is the vector you will to be going when you get there, and dT is an *untested* calculation of the time it will take.\n\u003C/p\u003E\n\u003Cp\u003E\nUseful if you want to land at an exact point on a planet, or rendevous with something else out there.\n\u003C/p\u003E\n\u003Cp\u003E\nAs always there are caveats:\n\u003C/p\u003E\n\u003Cp\u003E\n1) It doesn\u0027t take into account movement/rotation of targets or planets; you must pre-calculate that.\n\u003C/p\u003E\n\u003Cp\u003E\n2) It calculates \u0022minimum energy\u0022, but it\u0027s minimum energy from an absolute 0 starting velocity. So if you try to use this to descend from a higher orbit, it will often give a very inefficient path that \u0022jumps up\u0022 first, then descends to the target radius. It really works best from a lower orbit, or even the ground, like an ICBM.\n\u003C/p\u003E\n\u003Cp\u003E\nNow you too, can act like america and threaten everyone on Kerbin with this new technology!\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222018-03-14T21:03:07Z\u0022 title=\u002203/14/2018 09:03  PM\u0022 data-short=\u00226 yr\u0022\u003EMarch 14, 2018\u003C/time\u003E by surge\u003C/strong\u003E\n\u003Cbr\u003Ei wonder why the censorship pluralised \u0026#039;s_h_i_t\u0026#039;, singular\n\u003C/span\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2018-03-24T09:47:58Z","Content":"\n\u003Cp\u003E\nIf you\u0027re left wondering how to turn these vectors into something tangable, this function converts body-relative vectors into the strange ship-relative triplets required by node():\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003EFUNCTION nodeFromVector\n// from a reddit post somewhere (I\u0027ve forgotten)\n{\n  PARAMETER vec, n_time IS TIME:SECONDS.\n  LOCAL s_pro IS VELOCITYAT(SHIP,n_time):ORBIT.\n  // The following assumes you do not change sphere of influence\n  // between now and n_time\n  LOCAL s_pos IS POSITIONAT(SHIP,n_time) - BODY:POSITION.\n  LOCAL s_nrm IS VCRS(s_pro,s_pos).\n  LOCAL s_rad IS VCRS(s_nrm,s_pro).\n\n  LOCAL pro IS VDOT(vec,s_pro:NORMALIZED).\n  LOCAL nrm IS VDOT(vec,s_nrm:NORMALIZED).\n  LOCAL rad IS VDOT(vec,s_rad:NORMALIZED).\n\n  RETURN NODE(n_time, rad, nrm, pro).\n}\n\n\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nAs noted I don\u0027t take credit for this (nor do I really take credit for anything here, since it\u0027s all just regurgitated equations from other sources). I found it on reddit after the much worse version I invented didn\u0027t work properly (see the oneorbit() post). Anyway, you can now do things like:\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003Eset V1 to lambertMinE(R1,R2) -velocityat(SHIP, burntime).\nset n to nodeFromVector(V1, TIME:seconds \u002Bburntime).\nadd n.\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nto add the calculated maneuvres into the map. Making them actually happen is a less advanced topic not for this thread.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222018-03-24T09:56:34Z\u0022 title=\u002203/24/2018 09:56  AM\u0022 data-short=\u00226 yr\u0022\u003EMarch 24, 2018\u003C/time\u003E by surge\u003C/strong\u003E\n\u003C/span\u003E\n"}]}