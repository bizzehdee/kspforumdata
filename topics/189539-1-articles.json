{"TopicId":189539,"ForumId":69,"TopicTitle":"VSYNC is not working","CreatedByName":"pmborg","CreatedById":198861,"CreatedDateTime":"2019-11-03T13:41:27Z","PageNum":1,"Articles":[{"CreatedByName":"pmborg","CreatedById":198861,"CreatedDateTime":"2019-11-03T13:41:28Z","Content":"\n\u003Cp\u003E\nActually, removing my comment, after additional tests:\n\u003C/p\u003E\n\u003Cp\u003E\nThe real problem was related with the real FPS calculation.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003EHello,\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003EThe feature VSYNC in settings is not working during the main rendering, is working for example in main menu and settings.\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003EIs \u003Cstrong\u003Esettings.cfg \u003C/strong\u003EI have:\u003C/s\u003E\n\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003E\n\u003Cs\u003ESYNC_VBL = 1\u003C/s\u003E\n\u003C/li\u003E\n\u003C/ul\u003E\u003Cp\u003E\n\u003Cs\u003EI have 3 monitors with 144Hz, the main one the one that is rendering KSP 1.8.1 at full-screen 1920x1080@144Hz, is getting FPS between 145 and 149Hz, which prove that VSYNC is not working at all.\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003EOf-course get high FPS is \u0022always\u0022 (not always) good, but if there is a setting in Menu to limit the VSYNC it should work, is there as dummy setting that don\u0027t work, using some settings of 60 , 75 or 100 depending the monitor/card level that should work as well and don\u0027t work at all.\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u003Cimg alt=\u0022ZN3Suze.png\u0022 class=\u0022ipsImage\u0022 data-ratio=\u002256.25\u0022 height=\u0022576\u0022 width=\u00221024\u0022 src=\u0022https://i.imgur.com/ZN3Suze.png\u0022\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003EEven better than fast FPS is the smooth a real VSYNC working and this is just a line of code:\u003C/s\u003E\n\u003C/p\u003E\n\u003Ctable border=\u00221\u0022 cellpadding=\u00221\u0022 cellspacing=\u00221\u0022 style=\u0022width:500px;\u0022\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd\u003E\n\u003Cp\u003E\n\u003Cs\u003E// ----------------------------------------------------------------------------------------------\u003Cbr\u003E\nbool DX11Class::createSwapChainDX11device (\u00A0\u00A0 \u00A0HWND hwnd, int screenWidth, int screenHeight, BOOL vsync,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0BOOL fullscreen, BOOL g_UseDoubleBuffering, BOOL g_AllowResize,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0UINT numerator, UINT denominator)\u003Cbr\u003E\n// ----------------------------------------------------------------------------------------------\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0HRESULT result = S_OK;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0ASSERT (hwnd); // FATAL ERROR: Create Main Window first!\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Fill out the description of the swap chain\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// ==========================================\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// Initialize the swap chain description:\u003Cbr\u003E\n\u00A0\u00A0 \u00A0DXGI_SWAP_CHAIN_DESC swapChainDesc = {0};\u00A0\u00A0 \u00A0// ZeroMemory(\u0026amp;swapChainDesc, sizeof(swapChainDesc));\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Set to a single/double-buffering back buffer:\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.BufferCount = (g_UseDoubleBuffering) ? 2 : 1; // Use double-buffering to minimize latency.\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Set the width and height of the back buffer:\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.BufferDesc.Width = screenWidth;\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.BufferDesc.Height = screenHeight;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// The default: 32-bit surface for the back buffer: (RGB \u002B A) 8 bits each (This is the most common swap chain format)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.BufferDesc.Format = BUFFER_COLOR_FORMAT; // Default: DXGI_FORMAT_R8G8B8A8_UNORM\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Set the refresh rate of the back buffer:\u003Cbr\u003E\u003Cstrong\u003E\u00A0\u00A0 \u00A0swapChainDesc.BufferDesc.RefreshRate.Numerator = (vsync) ? numerator : 0;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.BufferDesc.RefreshRate.Denominator = (vsync) ? denominator : 1;\u003C/strong\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Set the default usage of the back buffer:\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0swapChainDesc.Windowed = !fullscreen;\u00A0\u00A0 \u00A0// Set to \u0022Fullscreen\u0022 or \u0022Windowed Mode\u0022:\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Default: 0, This member is used to tell Direct3D how to perform multisample anti-aliased (MSAA) rendering\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.SampleDesc.Count = ReqMSAAmultiSampleCount;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0swapChainDesc.SampleDesc.Quality = ReqMSAAquality - 1;\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// MSAA\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0swapChainDesc.Flags = (g_AllowResize) ? DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH : 0;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Set the scan line ordering and scaling to unspecified:\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// Discard the back buffer contents after presenting:\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0IDXGIDevice* pDXGIDevice = NULL;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0result = m_device-\u0026gt;QueryInterface(__uuidof(IDXGIDevice), (void **)\u0026amp;pDXGIDevice);\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if( FAILED( result ) ) return false;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E#if defined DXGI1_1 || defined DXGI1_2\u003Cbr\u003E\n\u00A0\u00A0 \u00A0pDXGIDevice-\u0026gt;SetGPUThreadPriority(7);\u003Cbr\u003E\n#endif\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0IDXGIAdapterN* pDXGIAdapter = NULL;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0result = pDXGIDevice-\u0026gt;GetParent(__uuidof(IDXGIAdapterN), (void **)\u0026amp;pDXGIAdapter);\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if( FAILED( result ) ) return false;\u00A0\u00A0 \u00A0\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0if (pDXGIAdapter)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DXGI_ADAPTER_DESC sDXGIAdapterDesc;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0pDXGIAdapter-\u0026gt;GetDesc(\u0026amp;sDXGIAdapterDesc);\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0m_sCapabilities.nTotalAvailableGPUMemory = sDXGIAdapterDesc.DedicatedVideoMemory; //unit: bytes\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0IDXGIFactoryN* pIDXGIFactory = NULL;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0result = pDXGIAdapter-\u0026gt;GetParent(__uuidof(IDXGIFactoryN), (void **)\u0026amp;pIDXGIFactory);\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if( FAILED( result ) ) return false;\u00A0\u00A0 \u00A0\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0// For each Monitor:\u003Cbr\u003E\n\u00A0\u00A0 \u00A0for (int i = 0; i \u0026lt; SystemHandle-\u0026gt;windowsArray.size(); i\u002B\u002B)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DXwindowDataContainer DXwindow;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DXwindow.m_swapChain = NULL;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DXwindow.m_backBuffer = NULL;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DXwindow.m_renderTargetView = NULL;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DXwindow.m_depthStencilView = NULL;\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0swapChainDesc.OutputWindow = SystemHandle-\u0026gt;windowsArray\u003Cem\u003E.hWnd;\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// Set the handle for the window to render to.\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0result = pIDXGIFactory-\u0026gt;CreateSwapChain(m_device,\u0026amp;swapChainDesc,\u0026amp;DXwindow.m_swapChain); // Turn Screen to Black\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (FAILED(result)) return false; \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DX11windowsArray.push_back(DXwindow);\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0} \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0if (!g_AllowResize)\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0pIDXGIFactory-\u0026gt;MakeWindowAssociation(SystemHandle-\u0026gt;windowsArray[0].hWnd, DXGI_MWA_NO_WINDOW_CHANGES | DXGI_MWA_NO_ALT_ENTER); //Prevent DXGI from responding to \u003C/em\u003E\u003Cem\u003Ean\u003C/em\u003E\u003Cem\u003E alt-enter sequence. \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0SAFE_RELEASE(pDXGIDevice);\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0SAFE_RELEASE(pDXGIAdapter);\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0SAFE_RELEASE(pIDXGIFactory); \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0return true;\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E} \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003C/td\u003E\n\u003C/tr\u003E\u003C/tbody\u003E\u003C/table\u003E\u003Cp\u003E\n\u003Cs\u003E\u003Cem\u003E\u00A0 \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u003Cem\u003EUsing it: \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cs\u003E\u003Cem\u003E// ----------------------------------------------------------------------------------------------\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003Evoid DX11Class::EndScene(UINT monitorWindow)\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E// ----------------------------------------------------------------------------------------------\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E{\u003C/em\u003E\u003Cbr\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0// \u0026lt;PRINT THE 3D SCENE TO SCREEN\u0026gt; to Swap Chain (wait from VSYNC refresh rate, if it is the case)\u003C/em\u003E\u003Cbr\u003E\u003Cstrong\u003E\u003Cem\u003E\u00A0\u00A0 \u00A0DX11windowsArray[monitorWindow].m_swapChain-\u0026gt;Present(m_VSYNC_ENABLED, 0);\u003C/em\u003E\u003C/strong\u003E\u003Cbr\u003E\u003Cem\u003E} \u003C/em\u003E\u003C/s\u003E\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222019-11-03T13:52:43Z\u0022 title=\u002211/03/2019 01:52  PM\u0022 data-short=\u00224 yr\u0022\u003ENovember 3, 2019\u003C/time\u003E by pmborg\u003C/strong\u003E\n\u003C/span\u003E\n"}]}