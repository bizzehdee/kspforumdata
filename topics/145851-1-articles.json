{"TopicId":145851,"ForumId":18,"TopicTitle":"OpenGL 4.5 on Intel HD 4400","CreatedByName":"Souper","CreatedById":86003,"CreatedDateTime":"2016-08-12T23:52:33Z","PageNum":1,"Articles":[{"CreatedByName":"Souper","CreatedById":86003,"CreatedDateTime":"2016-08-12T23:52:33Z","Content":"\n\u003Cp\u003E\nI\u0027ve got an Intel HD 4400 graphics card and i need to run No Man\u0027s Sky, which means i need OpenGL 4.5. I cannot upgrade in any physical or monetary\u00A0way from my current setup. I am becoming desperate. My game just crashes after the no man\u0027s sky logo. No error, nothing, just an instant exit. I did however get this in a report:\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n#version 450 compatibility\u00A0\u003Cbr\u003E\n#define D_PLATFORM_PC\u003Cbr\u003E\n#define D_VERTEX\n\u003C/p\u003E\n\u003Cp\u003E\n// VERTEX SHADER:\u00A0\u00A0 \u00A0SHADERS/LINE3D.SHADER.BIN\u003Cbr\u003E\n// CONTEXT:\u00A0\u00A0 \u00A0LINE3D\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#define D_VERTEX\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @file \u00A0 \u00A0 \u00A0 Im3dFragment.shader.h\u003Cbr\u003E\n/// \u00A0 \u00A0 @author \u00A0 \u00A0\u00A0\u003Cbr\u003E\n/// \u00A0 \u00A0 @date \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0Immediate Mode Fragment\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Copyright (c) 2009 Hello Games Ltd. All Rights Reserved.\u003Cbr\u003E\n///\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\n\u003C/p\u003E\n\u003Cp\u003E\n#ifndef D_DEFINES\u003Cbr\u003E\n#define D_DEFINES\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Platform defines\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #pragma optionNV(strict on)\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_gpu_shader5 : enable\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_fragment_coord_conventions : enable\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_derivative_control : enable\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #ifdef D_FRAGMENT\u003Cbr\u003E\n\u00A0 \u00A0 //{\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 //layout( origin_upper_left, pixel_center_integer ) in vec4 gl_FragCoord;\u003Cbr\u003E\n\u00A0 \u00A0 //}\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // use this with sdk 2.0 compiler\u00A0\u003Cbr\u003E\n\u00A0 \u00A0// #pragma argument (allow-scratch-buffer-spill)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //define these flags so they don\u0027t get ignored in build process and in the comb mask\u003Cbr\u003E\n\u00A0 \u00A0 //this is because materials, vertex layouts and shaders need to be synced on 360 to avoid patching\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F27_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F28_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F29_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F21_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F02_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F03_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #if defined( _F01_ ) || defined( D_LOD0 ) || defined( D_LOD1 ) || defined( D_LOD2 ) || defined( D_LOD3) || defined( D_LOD4 )\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F01_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F09_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F10_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 // disable warnings for unused parameters. This happens a lot because of defining different things.\u003Cbr\u003E\n\u00A0 \u00A0 #pragma warning (disable: 5203)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // temp thing to know what things are still required on ps4.\u003Cbr\u003E\n\u00A0 \u00A0 #define D_PLATFORM_ORBIS_FIX\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Basic Types\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define JOINT_TYPE \u00A0 \u00A0vec4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define CONST \u00A0 \u00A0 \u00A0 \u00A0 const\u003Cbr\u003E\n\u00A0 \u00A0 #define STATIC_CONST \u00A0const\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define JOINT_TYPE \u00A0 \u00A0 \u00A0int4\u003Cbr\u003E\n\u00A0 \u00A0 #define float \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 float\u003Cbr\u003E\n\u00A0 \u00A0 #define vec2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float2\u003Cbr\u003E\n\u00A0 \u00A0 #define vec3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float3\u003Cbr\u003E\n\u00A0 \u00A0 #define vec4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float4\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int2\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int3\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int4\u003Cbr\u003E\n\u00A0 \u00A0 // NOTE:\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // operator[] accesses rows, not columns\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // matrix constructors interpret the passed vectors as row vectors, not column vectors\u003Cbr\u003E\n\u00A0 \u00A0 #define mat2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float2x2\u003Cbr\u003E\n\u00A0 \u00A0 #define mat3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float3x3\u003Cbr\u003E\n\u00A0 \u00A0 #define mat4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float4x4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define CONST \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define STATIC_CONST \u00A0 \u00A0static const\u003Cbr\u003E\n\u00A0 \u00A0// #define const \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 ERROR, DON\u0027T USE CONST FOR PS4. USE STATIC_CONST INSTEAD FOR A COMPILED IN CONSTANT. OTHERWISE IT TRIES TO PUT IT IN A CONSTANT BUFFER AND FOR SOME REASON IT DOESN\u0027T WORK.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Functions\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define saturate( V ) \u00A0min( max( V, 0.0) , 1.0)\u003Cbr\u003E\n\u00A0 \u00A0 #define atan2( Y, X ) \u00A0atan( Y, X )\u003Cbr\u003E\n\u00A0 \u00A0 #define invsqrt( X ) \u00A0 inversesqrt( X )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// These can be deleted if ARB_derivative_control can be used\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//#define dFdxFine\u00A0\u00A0 \u00A0dFdx\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//#define dFdyFine\u00A0\u00A0 \u00A0dFdy\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define mix \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 lerp\u003Cbr\u003E\n\u00A0 \u00A0 #define fract \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 frac\u003Cbr\u003E\n\u00A0 \u00A0 #define dFdx\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddx\u003Cbr\u003E\n\u00A0 \u00A0 #define dFdy\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddy\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define dFdxFine\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddx_fine\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define dFdyFine\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddy_fine\u003Cbr\u003E\n#define mod\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0fmod\u003Cbr\u003E\n\u00A0 \u00A0 #define saturate( V ) \u00A0 ( min( max( V, 0.0) , 1.0) )\u003Cbr\u003E\n\u00A0 \u00A0 #define invsqrt( X ) \u00A0 \u00A0rsqrt( X )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Samplers and textures\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW( NAME, REG ) \u00A0 \u00A0uniform sampler2DShadow NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0in sampler2D NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYARG( NAME ) \u00A0 \u00A0 \u00A0 in sampler2DArray NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLERCUBE( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 samplerCube NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLERCUBEARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0in samplerCube NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLERCUBEPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYPARAM( NAME ) \u00A0 \u00A0 NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // TEMP while switching ps4 over to srt\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 sampler2D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2D_TEMP( NAME, INDEX ) \u00A0 uniform sampler2D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAY( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0sampler2DArray \u00A0NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER3D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 sampler3D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW_SRT( NAME ) \u00A0 \u00A0 sampler2DShadow NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLERCUBE( NAME, REG ) \u00A0 \u00A0 \u00A0 \u00A0SamplerState NAME##SS : register( s##REG ); TextureCube NAME##TU : register( t##REG )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Texture2D NAME; SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW_SRT( NAME ) \u00A0 \u00A0 Texture2D NAME; SamplerComparisonState NAME##SS \u00A0//SAMPLER2D( NAME )\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER3D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Texture3D NAME; SamplerState NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAY( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Texture2D_Array NAME; SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYARG( NAME ) \u00A0 \u00A0 \u00A0 Texture2D_Array NAME, SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYPARAM( NAME ) \u00A0 \u00A0 NAME, NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0NAME, NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Texture2D NAME, SamplerState NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define texture2D( T, C )\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.Sample( T##SS, C )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define texture2DLod( T, C, N ) \u00A0 \u00A0 \u00A0 \u00A0 T.SampleLOD( T##SS, C, N )\u003Cbr\u003E\n\u00A0 \u00A0 #define texture2DArray( \u00A0T, C ) \u00A0 \u00A0 \u00A0 \u00A0 T.Sample( T##SS, C )\u003Cbr\u003E\n\u00A0 \u00A0 #define texture3DLod( T, C, N ) \u00A0 \u00A0 \u00A0 \u00A0 T.SampleLOD( T##SS, C, N )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec3( C.z \u0026gt; T.Sample( T##SS, C.xy ).x ? 1.0 : 0.0 ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.GatherCmp( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.SampleCmpLOD0( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 #define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.SampleCmp( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureCube( T, C )\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T##TU.Sample( T##SS, C )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureCubeLod( T, C, N )\u00A0\u00A0 \u00A0 \u00A0 \u00A0T##TU.Sample( T##SS, C, N )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureGrad( T, C, DDX, DDY ) \u00A0 T.SampleGradient( T##SS, C, DDX, DDY ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Matrices\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MUL( INPUT_A, INPUT_B ) \u00A0 \u00A0 \u00A0 \u00A0 (INPUT_A * INPUT_B)\u003Cbr\u003E\n\u00A0 \u00A0 #define PLATFORM_TRANSPOSE\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_POS( M, P ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0M[ 3 ] = P\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_TRANSLATION( M, T ) \u00A0 \u00A0M[ 3 ].xyz = T\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ].xyz\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT3_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ]\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN_VEC4( M, C ) \u00A0 \u00A0M[ C ]\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MAT3_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MUL( INPUT_A, INPUT_B ) \u00A0 \u00A0 \u00A0 \u00A0 mul( INPUT_B, INPUT_A )\u003Cbr\u003E\n\u00A0 \u00A0 #define PLATFORM_TRANSPOSE\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_POS( M, P ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0M[ 3 ] = P\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_TRANSLATION( M, T ) \u00A0 \u00A0M[ 3 ].xyz = T\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ].xyz\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT3_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ]\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN_VEC4( M, C ) \u00A0 \u00A0M[ C ]\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MAT3_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Arrays (workaround AMD shader compiler issues by making arrays have global scope)\u003Cbr\u003E\n// =================================================================================================\n\u003C/p\u003E\n\u003Cp\u003E\n#if defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _UNIFORMS._ELEMENT[_INDEX]\u003Cbr\u003E\n#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _UNIFORMS._ELEMENT[_INDEX]\n\u003C/p\u003E\n\u003Cp\u003E\n#else\n\u003C/p\u003E\n\u003Cp\u003E\n#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _ELEMENT[_INDEX]\u003Cbr\u003E\n#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _ELEMENT[_INDEX]\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Input and Output\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define UNIFORM( TYPE, NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform TYPE NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define UNIFORM_SRT( TYPE, NAME ) \u00A0 \u00A0 \u00A0 uniform TYPE NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define DECLARE_INPUT\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_OUTPUT\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_END \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_PTR( TYPE, NAME ) \u00A0 \u00A0 \u00A0 TYPE \u00A0NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define INPUT( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0in \u00A0 \u00A0TYPE NAME;\u003Cbr\u003E\n\u00A0 \u00A0 #define INPUT_NOINTERP( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0in \u00A0 \u00A0TYPE NAME;\u003Cbr\u003E\n\u00A0 \u00A0 #define OUTPUT( \u00A0TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0out \u00A0 TYPE NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4_DEFINE \u00A0 \u00A0layout ( location = 0 ) out uvec4 out_color0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 out_color0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 gl_FragColor\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 0 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR1 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 1 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 2 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 3 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_DEPTH \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragDepth\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define IN( \u00A0VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\u003Cbr\u003E\n\u00A0 \u00A0 #define OUT( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\u003Cbr\u003E\n\u00A0 \u00A0 #define DEREF_PTR( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define OUT_VERTEX_SCREEN_POSITION\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define IN_SCREEN_POSITION\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_Position\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define UNIFORM( TYPE, NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 ConstantBuffer NAME##CB{ TYPE NAME; };\u003Cbr\u003E\n\u00A0 \u00A0 #define UNIFORM_SRT( TYPE, NAME ) \u00A0 \u00A0 \u00A0 ConstantBuffer NAME##CB{ TYPE NAME : S_SRT_DATA; };\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define DECLARE_OUTPUT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput {\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_INPUT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 struct cInput \u00A0{\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_END \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 };\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_PTR( TYPE, NAME ) \u00A0 \u00A0 \u00A0 TYPE* NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define INPUT( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 TYPE NAME : REG;\u003Cbr\u003E\n\u00A0 \u00A0 #define INPUT_NOINTERP( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0nointerp TYPE NAME : REG; \u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define OUTPUT( \u00A0TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0TYPE NAME : REG;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4_DEFINE\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Out.mColour\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Out.mColour\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR1 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour1\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour2\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour3\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_DEPTH \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mDepth\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define IN( \u00A0VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0In.VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define OUT( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.VAR\n\u003C/p\u003E\n\u003Cp\u003E\n// TODO get rid of this - don\u0027t pass struct through functinos, pass members.\u003Cbr\u003E\n\u00A0 \u00A0 #define DEREF_PTR( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0*VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define OUT_VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0OUTPUT( vec4, mScreenPositionVec4, S_POSITION )\u003Cbr\u003E\n\u00A0 \u00A0 #define IN_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0INPUT ( vec4, mScreenPositionVec4, S_POSITION )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0OUT( mScreenPositionVec4 )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Main\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0void main( void )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define VOID_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH \u00A0 \u00A0 \u00A0void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT \u00A0uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT \u00A0uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define VOID_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined( D_PLATFORM_ORBIS )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out )\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; float mDepth \u00A0: S_DEPTH_OUTPUT; };\u00A0\u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #if !defined( D_ATTRIBUTES )\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0 \u00A0 struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_OUTPUT; \u00A0 \u00A0}; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT \u00A0struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_GE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT \u00A0struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_LE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0[FORCE_EARLY_DEPTH_STENCIL]void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #else\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u00A0 \u00A0#pragma PSSL_target_output_format(target 1 FMT_32_AR)\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float mDepth \u00A0 : S_DEPTH_OUTPUT; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [FORCE_EARLY_DEPTH_STENCIL] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Viewport\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) A.xy\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) ( float2( A.x, 1.0 - A.y ) )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nSTATIC_CONST float radius \u00A0 \u00A0 \u00A0= 1.0;\u003Cbr\u003E\nSTATIC_CONST float invScrRatio = 1280.0 / 720.0;\n\u003C/p\u003E\n\u003Cp\u003E\n#define D_PARTICLE_UNIFORMS\n\u003C/p\u003E\n\u003Cp\u003E\n////////////////////////////////////////////////////////////////////////////////\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @file \u00A0 \u00A0 \u00A0 CommonVertex.h\u003Cbr\u003E\n/// \u00A0 \u00A0 @author \u00A0 \u00A0 User\u003Cbr\u003E\n/// \u00A0 \u00A0 @date \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CommonVertex\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Copyright (c) 2008 Hello Games Ltd. All Rights Reserved.\u003Cbr\u003E\n///\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n// \u00A0 \u00A0 \u00A0Compilation defines\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n// \u00A0 \u00A0 \u00A0Include files\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n// \u00A0 \u00A0 \u00A0Global Data\n\u003C/p\u003E\n\u003Cp\u003E\n////////////////////////////////////////////////////////////////////////////////\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @file \u00A0 \u00A0 \u00A0 CommonUniforms.h\u003Cbr\u003E\n/// \u00A0 \u00A0 @author \u00A0 \u00A0 User\u003Cbr\u003E\n/// \u00A0 \u00A0 @date \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CommonUniforms\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Copyright (c) 2008 Hello Games Ltd. All Rights Reserved.\u003Cbr\u003E\n///\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#ifndef D_COMMONUNIFORMS2_H\u003Cbr\u003E\n#define D_COMMONUNIFORMS2_H\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\n\u003C/p\u003E\n\u003Cp\u003E\n#ifndef D_DEFINES\u003Cbr\u003E\n#define D_DEFINES\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Platform defines\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #pragma optionNV(strict on)\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_gpu_shader5 : enable\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_fragment_coord_conventions : enable\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_derivative_control : enable\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #ifdef D_FRAGMENT\u003Cbr\u003E\n\u00A0 \u00A0 //{\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 //layout( origin_upper_left, pixel_center_integer ) in vec4 gl_FragCoord;\u003Cbr\u003E\n\u00A0 \u00A0 //}\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // use this with sdk 2.0 compiler\u00A0\u003Cbr\u003E\n\u00A0 \u00A0// #pragma argument (allow-scratch-buffer-spill)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //define these flags so they don\u0027t get ignored in build process and in the comb mask\u003Cbr\u003E\n\u00A0 \u00A0 //this is because materials, vertex layouts and shaders need to be synced on 360 to avoid patching\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F27_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F28_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F29_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F21_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F02_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F03_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #if defined( _F01_ ) || defined( D_LOD0 ) || defined( D_LOD1 ) || defined( D_LOD2 ) || defined( D_LOD3) || defined( D_LOD4 )\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F01_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F09_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F10_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 // disable warnings for unused parameters. This happens a lot because of defining different things.\u003Cbr\u003E\n\u00A0 \u00A0 #pragma warning (disable: 5203)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // temp thing to know what things are still required on ps4.\u003Cbr\u003E\n\u00A0 \u00A0 #define D_PLATFORM_ORBIS_FIX\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Basic Types\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define JOINT_TYPE \u00A0 \u00A0vec4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define CONST \u00A0 \u00A0 \u00A0 \u00A0 const\u003Cbr\u003E\n\u00A0 \u00A0 #define STATIC_CONST \u00A0const\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define JOINT_TYPE \u00A0 \u00A0 \u00A0int4\u003Cbr\u003E\n\u00A0 \u00A0 #define float \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 float\u003Cbr\u003E\n\u00A0 \u00A0 #define vec2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float2\u003Cbr\u003E\n\u00A0 \u00A0 #define vec3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float3\u003Cbr\u003E\n\u00A0 \u00A0 #define vec4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float4\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int2\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int3\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int4\u003Cbr\u003E\n\u00A0 \u00A0 // NOTE:\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // operator[] accesses rows, not columns\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // matrix constructors interpret the passed vectors as row vectors, not column vectors\u003Cbr\u003E\n\u00A0 \u00A0 #define mat2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float2x2\u003Cbr\u003E\n\u00A0 \u00A0 #define mat3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float3x3\u003Cbr\u003E\n\u00A0 \u00A0 #define mat4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float4x4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define CONST \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define STATIC_CONST \u00A0 \u00A0static const\u003Cbr\u003E\n\u00A0 \u00A0// #define const \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 ERROR, DON\u0027T USE CONST FOR PS4. USE STATIC_CONST INSTEAD FOR A COMPILED IN CONSTANT. OTHERWISE IT TRIES TO PUT IT IN A CONSTANT BUFFER AND FOR SOME REASON IT DOESN\u0027T WORK.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Functions\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define saturate( V ) \u00A0min( max( V, 0.0) , 1.0)\u003Cbr\u003E\n\u00A0 \u00A0 #define atan2( Y, X ) \u00A0atan( Y, X )\u003Cbr\u003E\n\u00A0 \u00A0 #define invsqrt( X ) \u00A0 inversesqrt( X )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// These can be deleted if ARB_derivative_control can be used\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//#define dFdxFine\u00A0\u00A0 \u00A0dFdx\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//#define dFdyFine\u00A0\u00A0 \u00A0dFdy\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define mix \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 lerp\u003Cbr\u003E\n\u00A0 \u00A0 #define fract \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 frac\u003Cbr\u003E\n\u00A0 \u00A0 #define dFdx\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddx\u003Cbr\u003E\n\u00A0 \u00A0 #define dFdy\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddy\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define dFdxFine\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddx_fine\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define dFdyFine\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddy_fine\u003Cbr\u003E\n#define mod\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0fmod\u003Cbr\u003E\n\u00A0 \u00A0 #define saturate( V ) \u00A0 ( min( max( V, 0.0) , 1.0) )\u003Cbr\u003E\n\u00A0 \u00A0 #define invsqrt( X ) \u00A0 \u00A0rsqrt( X )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Samplers and textures\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW( NAME, REG ) \u00A0 \u00A0uniform sampler2DShadow NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0in sampler2D NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYARG( NAME ) \u00A0 \u00A0 \u00A0 in sampler2DArray NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLERCUBE( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 samplerCube NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLERCUBEARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0in samplerCube NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLERCUBEPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYPARAM( NAME ) \u00A0 \u00A0 NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // TEMP while switching ps4 over to srt\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 sampler2D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2D_TEMP( NAME, INDEX ) \u00A0 uniform sampler2D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAY( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0sampler2DArray \u00A0NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER3D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 sampler3D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW_SRT( NAME ) \u00A0 \u00A0 sampler2DShadow NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLERCUBE( NAME, REG ) \u00A0 \u00A0 \u00A0 \u00A0SamplerState NAME##SS : register( s##REG ); TextureCube NAME##TU : register( t##REG )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Texture2D NAME; SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW_SRT( NAME ) \u00A0 \u00A0 Texture2D NAME; SamplerComparisonState NAME##SS \u00A0//SAMPLER2D( NAME )\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER3D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Texture3D NAME; SamplerState NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAY( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Texture2D_Array NAME; SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYARG( NAME ) \u00A0 \u00A0 \u00A0 Texture2D_Array NAME, SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYPARAM( NAME ) \u00A0 \u00A0 NAME, NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0NAME, NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Texture2D NAME, SamplerState NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define texture2D( T, C )\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.Sample( T##SS, C )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define texture2DLod( T, C, N ) \u00A0 \u00A0 \u00A0 \u00A0 T.SampleLOD( T##SS, C, N )\u003Cbr\u003E\n\u00A0 \u00A0 #define texture2DArray( \u00A0T, C ) \u00A0 \u00A0 \u00A0 \u00A0 T.Sample( T##SS, C )\u003Cbr\u003E\n\u00A0 \u00A0 #define texture3DLod( T, C, N ) \u00A0 \u00A0 \u00A0 \u00A0 T.SampleLOD( T##SS, C, N )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec3( C.z \u0026gt; T.Sample( T##SS, C.xy ).x ? 1.0 : 0.0 ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.GatherCmp( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.SampleCmpLOD0( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 #define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.SampleCmp( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureCube( T, C )\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T##TU.Sample( T##SS, C )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureCubeLod( T, C, N )\u00A0\u00A0 \u00A0 \u00A0 \u00A0T##TU.Sample( T##SS, C, N )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureGrad( T, C, DDX, DDY ) \u00A0 T.SampleGradient( T##SS, C, DDX, DDY ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Matrices\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MUL( INPUT_A, INPUT_B ) \u00A0 \u00A0 \u00A0 \u00A0 (INPUT_A * INPUT_B)\u003Cbr\u003E\n\u00A0 \u00A0 #define PLATFORM_TRANSPOSE\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_POS( M, P ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0M[ 3 ] = P\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_TRANSLATION( M, T ) \u00A0 \u00A0M[ 3 ].xyz = T\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ].xyz\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT3_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ]\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN_VEC4( M, C ) \u00A0 \u00A0M[ C ]\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MAT3_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MUL( INPUT_A, INPUT_B ) \u00A0 \u00A0 \u00A0 \u00A0 mul( INPUT_B, INPUT_A )\u003Cbr\u003E\n\u00A0 \u00A0 #define PLATFORM_TRANSPOSE\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_POS( M, P ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0M[ 3 ] = P\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_TRANSLATION( M, T ) \u00A0 \u00A0M[ 3 ].xyz = T\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ].xyz\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT3_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ]\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN_VEC4( M, C ) \u00A0 \u00A0M[ C ]\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MAT3_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Arrays (workaround AMD shader compiler issues by making arrays have global scope)\u003Cbr\u003E\n// =================================================================================================\n\u003C/p\u003E\n\u003Cp\u003E\n#if defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _UNIFORMS._ELEMENT[_INDEX]\u003Cbr\u003E\n#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _UNIFORMS._ELEMENT[_INDEX]\n\u003C/p\u003E\n\u003Cp\u003E\n#else\n\u003C/p\u003E\n\u003Cp\u003E\n#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _ELEMENT[_INDEX]\u003Cbr\u003E\n#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _ELEMENT[_INDEX]\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Input and Output\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define UNIFORM( TYPE, NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform TYPE NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define UNIFORM_SRT( TYPE, NAME ) \u00A0 \u00A0 \u00A0 uniform TYPE NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define DECLARE_INPUT\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_OUTPUT\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_END \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_PTR( TYPE, NAME ) \u00A0 \u00A0 \u00A0 TYPE \u00A0NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define INPUT( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0in \u00A0 \u00A0TYPE NAME;\u003Cbr\u003E\n\u00A0 \u00A0 #define INPUT_NOINTERP( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0in \u00A0 \u00A0TYPE NAME;\u003Cbr\u003E\n\u00A0 \u00A0 #define OUTPUT( \u00A0TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0out \u00A0 TYPE NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4_DEFINE \u00A0 \u00A0layout ( location = 0 ) out uvec4 out_color0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 out_color0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 gl_FragColor\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 0 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR1 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 1 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 2 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 3 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_DEPTH \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragDepth\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define IN( \u00A0VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\u003Cbr\u003E\n\u00A0 \u00A0 #define OUT( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\u003Cbr\u003E\n\u00A0 \u00A0 #define DEREF_PTR( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define OUT_VERTEX_SCREEN_POSITION\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define IN_SCREEN_POSITION\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_Position\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define UNIFORM( TYPE, NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 ConstantBuffer NAME##CB{ TYPE NAME; };\u003Cbr\u003E\n\u00A0 \u00A0 #define UNIFORM_SRT( TYPE, NAME ) \u00A0 \u00A0 \u00A0 ConstantBuffer NAME##CB{ TYPE NAME : S_SRT_DATA; };\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define DECLARE_OUTPUT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput {\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_INPUT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 struct cInput \u00A0{\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_END \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 };\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_PTR( TYPE, NAME ) \u00A0 \u00A0 \u00A0 TYPE* NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define INPUT( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 TYPE NAME : REG;\u003Cbr\u003E\n\u00A0 \u00A0 #define INPUT_NOINTERP( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0nointerp TYPE NAME : REG; \u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define OUTPUT( \u00A0TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0TYPE NAME : REG;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4_DEFINE\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Out.mColour\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Out.mColour\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR1 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour1\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour2\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour3\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_DEPTH \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mDepth\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define IN( \u00A0VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0In.VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define OUT( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.VAR\n\u003C/p\u003E\n\u003Cp\u003E\n// TODO get rid of this - don\u0027t pass struct through functinos, pass members.\u003Cbr\u003E\n\u00A0 \u00A0 #define DEREF_PTR( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0*VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define OUT_VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0OUTPUT( vec4, mScreenPositionVec4, S_POSITION )\u003Cbr\u003E\n\u00A0 \u00A0 #define IN_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0INPUT ( vec4, mScreenPositionVec4, S_POSITION )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0OUT( mScreenPositionVec4 )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Main\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0void main( void )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define VOID_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH \u00A0 \u00A0 \u00A0void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT \u00A0uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT \u00A0uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define VOID_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined( D_PLATFORM_ORBIS )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out )\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; float mDepth \u00A0: S_DEPTH_OUTPUT; };\u00A0\u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #if !defined( D_ATTRIBUTES )\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0 \u00A0 struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_OUTPUT; \u00A0 \u00A0}; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT \u00A0struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_GE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT \u00A0struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_LE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0[FORCE_EARLY_DEPTH_STENCIL]void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #else\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u00A0 \u00A0#pragma PSSL_target_output_format(target 1 FMT_32_AR)\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float mDepth \u00A0 : S_DEPTH_OUTPUT; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [FORCE_EARLY_DEPTH_STENCIL] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Viewport\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) A.xy\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) ( float2( A.x, 1.0 - A.y ) )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nstruct PerFrameUniforms\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gLightPositionVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_LightPositionVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gLightDirectionVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_LightDirectionVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec3 \u00A0 \u00A0gViewPositionVec3; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ViewPositionVec3\u003Cbr\u003E\n\u00A0 \u00A0 float \u00A0 gfTime; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_Time\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gClipPlanesVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ClipPlanesVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gClipPlanesRVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ClipPlanesRVec4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gCameraMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_CameraMat4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gFrameBufferSizeVec4; \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gFoVValuesVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_FoVValuesVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gShadowSizeVec4; \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gShadowFadeParamVec4; \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gViewMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ViewMat4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //\u003Cbr\u003E\n\u00A0 \u00A0 // These are per pass really. Probably just rename PerFrame to PerPass.\u003Cbr\u003E\n\u00A0 \u00A0 //\u003Cbr\u003E\n\u00A0 \u00A0 //mat4 \u00A0 \u00A0gProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 //mat4 \u00A0 \u00A0gCameraMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_CameraMat4\u003Cbr\u003E\n\u00A0 \u00A0 //mat4 \u00A0 \u00A0gaShadowMat4[ 2 ]; \u00A0 // EShaderConst_ShadowMat4\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 \u00A0 \u00A0gClipPlanesVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ClipPlanesVec4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //SAMPLER2D( gDualPMapFront ); \u00A0 \u00A0// 32 bytes each\u003Cbr\u003E\n\u00A0 \u00A0 //SAMPLER2D( gDualPMapBack );\u003Cbr\u003E\n\u00A0 \u00A0 //SAMPLER2D( gCloudShadowMap );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //SAMPLER2D( gFadeNoiseMap );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //SAMPLER2D( gCausticMap );\u003Cbr\u003E\n\u00A0 \u00A0 //SAMPLER2D( gCausticOffsetMap );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // how to set samplers\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // putting these here would require removing them from the shader and material, and making them part of the common global\u003Cbr\u003E\n\u00A0 \u00A0 // list so they can be set like the ones above... i think.\u003Cbr\u003E\n\u00A0 \u00A0 // Fog\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSkyColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gHorizonColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSunColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gWaterColourNearVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gWaterColourFarVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gWaterFogVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gHeightFogParamsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gHeightFogColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceHorizonColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gFogColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gFogParamsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gScatteringParamsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceFogWavelength1Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceFogWavelength2Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceFogWavelength3Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceSkyColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gFogFadeHeightsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSunPositionVec4;\u003Cbr\u003E\n};\n\u003C/p\u003E\n\u003Cp\u003E\nstruct CommonPerMeshUniforms\u003Cbr\u003E\n{ \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // These are planet specific. Should they be here?\u003Cbr\u003E\n\u00A0 \u00A0 vec4 gPlanetPositionVec4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Stop these being compiled in when recolouring as the recolour shader needs ALL tex units.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseModelMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseModelMat4 = 0\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gWorldMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_WorldMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gWorldViewProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_WorldViewProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gWorldNormalMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_WorldNormalMat4\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef D_FADE\u003Cbr\u003E\n\u00A0 \u00A0 float \u00A0 gfFadeValue; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_FadeTime\u003Cbr\u003E\n#else\u003Cbr\u003E\n\u00A0 \u00A0 float \u00A0 fdFadeValueDummy;\u003Cbr\u003E\n#endif\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n#if defined( D_SKINNING_UNIFORMS ) \u0026amp;\u0026amp; defined( D_PLATFORM_ORBIS )\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 gaSkinMatrixRowsVec4[ 75 * 3 ]; \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //float \u00A0 gfShadowBias; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ShadowBias\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0// \u00A0have particle shader use a particlecommon instead of uber, and put these into it.\u003Cbr\u003E\n#if defined( D_PARTICLE_UNIFORMS ) \u0026amp;\u0026amp; defined( D_PLATFORM_ORBIS )\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleCornersVec4[ 4 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ParticleCornersVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticlePositionsVec4[ 32 ]; \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticlePositionsVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleSizeAndRotationsVec4[ 32 ]; \u00A0// EShaderConst_ParticleSizeAndRotationsVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleNormalsVec4[ 32 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleNormalsVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleColoursVec4[ 32 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleColoursVec4\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 // This stuff is here atm because of shadows. The shadow shader is one thing, but renders twice, with these needing to be set differently.\u003Cbr\u003E\n\u00A0 \u00A0 // ideally we don\u0027t want them set per mesh though, probably a SRT for \u0027percamera\u0027 or something\u003Cbr\u003E\n\u00A0 \u00A0 //\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 //\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gViewProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0 \u00A0// EShaderConst_ViewProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseViewMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseViewMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseViewProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseViewProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gaShadowMat4[ 3 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ShadowMat4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gShadowProjScaleVec4[3]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ShadowProjScaleVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gLightColourVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_LightColourVec4\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u00A0 \u00A0vec4\u00A0\u00A0 \u00A0gGenericParam0Vec4;\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// EShaderConst_GenericParam0Vec4\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // These shouldn\u0027t be per mesh, the should be per rendertarget. BUT we need to add them to the enum\u003Cbr\u003E\n\u00A0 \u00A0 // in egShader and SetPErRenderTargetUniforms for that to work and we\u0027re trying to do a build for sony\u003Cbr\u003E\n\u00A0 \u00A0 // so that will have to wait. (also probably need a way of setting per RT uniforms from Game).\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsPosVec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsCfg1Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsCfg2Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsCfg3Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanColourVec4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0 \u00A0 \u00A0vec4 gSpotlightPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 gSpotlightDirectionVec4;\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n};\n\u003C/p\u003E\n\u003Cp\u003E\n#if defined( D_PARTICLE_UNIFORMS ) \u0026amp;\u0026amp; defined( D_PLATFORM_PC )\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleCornersVec4[4]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ParticleCornersVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticlePositionsVec4[32]; \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticlePositionsVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleSizeAndRotationsVec4[32]; \u00A0// EShaderConst_ParticleSizeAndRotationsVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleNormalsVec4[32]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleNormalsVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleColoursVec4[32]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleColoursVec4\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @file \u00A0 \u00A0 \u00A0 Common.h\u003Cbr\u003E\n/// \u00A0 \u00A0 @author \u00A0 \u00A0 User\u003Cbr\u003E\n/// \u00A0 \u00A0 @date \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0Common\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Copyright (c) 2008 Hello Games Ltd. All Rights Reserved.\u003Cbr\u003E\n///\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\n\u003C/p\u003E\n\u003Cp\u003E\n#ifndef D_COMMON_H\u003Cbr\u003E\n#define D_COMMON_H\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nSTATIC_CONST vec3 kGammaOutVec3 = vec3( 1.0 / 2.2 );\u003Cbr\u003E\nSTATIC_CONST vec3 kGammaInVec3 \u00A0= vec3( 2.2 );\u003Cbr\u003E\nSTATIC_CONST vec4 RGBToHSV_K \u00A0 \u00A0= vec4( 0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0 );\u003Cbr\u003E\nSTATIC_CONST vec4 HSVToRGB_K \u00A0 \u00A0= vec4( 1.0, \u00A02.0 / 3.0, 1.0 / 3.0, \u00A03.0 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 GammaCorrect\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nGammaCorrectInput(\u003Cbr\u003E\n\u00A0 \u00A0 in vec3 lColourVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lCorrectColourVec3;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lCorrectColourVec3 = pow( lColourVec3, kGammaInVec3 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lCorrectColourVec3;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 GammaCorrect\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nGammaCorrectOutput(\u003Cbr\u003E\n\u00A0 \u00A0 in vec3 lColourVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lCorrectColourVec3;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lCorrectColourVec3 = pow( lColourVec3, kGammaOutVec3 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lCorrectColourVec3;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 RGBToHSV\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nRGBToHSV(\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lRGB )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 p = mix( vec4(lRGB.bg, RGBToHSV_K.wz), vec4(lRGB.gb, RGBToHSV_K.xy), step(lRGB.b, lRGB.g) );\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 q = mix( vec4(p.xyw, lRGB.r), vec4(lRGB.r, p.yzx), step(p.x, lRGB.r) );\u003Cbr\u003E\n\u00A0 \u00A0 // This variant is faster, since it generates conditional moves\u003Cbr\u003E\n\u00A0 \u00A0 vec4 p = lRGB.g \u0026lt; lRGB.b ? vec4(lRGB.bg, RGBToHSV_K.wz) : vec4(lRGB.gb, RGBToHSV_K.xy);\u003Cbr\u003E\n\u00A0 \u00A0 vec4 q = lRGB.r \u0026lt; p.x ? vec4(p.xyw, lRGB.r) : vec4(lRGB.r, p.yzx); \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 float d = q.x - min(q.w, q.y);\u003Cbr\u003E\n\u00A0 \u00A0 float e = 1.0e-10;\u003Cbr\u003E\n\u00A0 \u00A0 return vec3(abs(q.z \u002B (q.w - q.y) / (6.0 * d \u002B e)), d / (q.x \u002B e), q.x);\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 HSVToRGB\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u003Ca href=\u0022http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\u003C/a\u003E\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nHSVToRGB(\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lHSV )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec3 p = abs(fract(lHSV.xxx \u002B HSVToRGB_K.xyz) * 6.0 - HSVToRGB_K.www);\u003Cbr\u003E\n\u00A0 \u00A0 return lHSV.z * mix(HSVToRGB_K.xxx, saturate(p - HSVToRGB_K.xxx), lHSV.y);\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 BrightnessVibranceContrast\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3 BrightnessVibranceContrast(\u003Cbr\u003E\n\u00A0 \u00A0 vec3 \u00A0lInputColour,\u003Cbr\u003E\n\u00A0 \u00A0 float lfBrightness,\u003Cbr\u003E\n\u00A0 \u00A0 float lfVibrance,\u003Cbr\u003E\n\u00A0 \u00A0 float lfContrast)\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lBrtResult \u00A0 \u00A0 = lInputColour * lfBrightness;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // get lum\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lLuma \u00A0 \u00A0 \u00A0 \u00A0 \u00A0= vec3( dot(lBrtResult, vec3( 0.2125, 0.7154, 0.0721 )) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // get saturation\u003Cbr\u003E\n\u00A0 \u00A0 float lfMaxCol \u00A0 \u00A0 \u00A0= max( lBrtResult.r, max(lBrtResult.g, lBrtResult.b) );\u003Cbr\u003E\n\u00A0 \u00A0 float lfMinCol \u00A0 \u00A0 \u00A0= min( lBrtResult.r, min(lBrtResult.g, lBrtResult.b) );\u003Cbr\u003E\n\u00A0 \u00A0 float lfCurSatV \u00A0 \u00A0 = lfMaxCol - lfMinCol;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // lerp by 1 \u002B (1 - vibrance) - current saturation\u003Cbr\u003E\n\u00A0 \u00A0 float lfVibranceMix = (1.0 \u002B (lfVibrance * (1.0 - (sign(lfVibrance) * lfCurSatV))));\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lVibResult \u00A0 \u00A0 = mix( lLuma, lBrtResult, lfVibranceMix );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // lerp from mid gray for contrast\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lContrastBase \u00A0= vec3( 0.5, 0.5, 0.5 );\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lConResult \u00A0 \u00A0 = mix( lContrastBase , lVibResult, lfContrast );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lConResult;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Desaturate\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3 Desaturate( vec3 color, float lfAmount )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec3 gray = vec3( dot( vec3( 0.299, 0.587, 0.114 ), color) );\u003Cbr\u003E\n\u00A0 \u00A0 return mix( color, gray, lfAmount );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// improved rgb lerp by @stormoid\u003Cbr\u003E\n// \u003Ca href=\u0022https://www.shadertoy.com/view/lsdGzN\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://www.shadertoy.com/view/lsdGzN\u003C/a\u003E\u003Cbr\u003E\n//---------------Improved RGB--------------\n\u003C/p\u003E\n\u003Cp\u003E\n/*\u003Cbr\u003E\n\u00A0 \u00A0 The idea behind this function is to avoid the low saturation area in the\u003Cbr\u003E\n\u00A0 \u00A0 rgb color space. This is done by getting the direction to that diagonal\u003Cbr\u003E\n\u00A0 \u00A0 and displacing the interpolated color by it\u0027s inverse while scaling it\u003Cbr\u003E\n\u00A0 \u00A0 by saturation error and desired lightness.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 I find it behaves very well under most circumstances, the only instance\u003Cbr\u003E\n\u00A0 \u00A0 where it doesn\u0027t behave ideally is when the hues are very close to 180\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 degrees apart, since the method I am using to find the displacement vector\u003Cbr\u003E\n\u00A0 \u00A0 does not compensate for non-curving motion. I tried a few things to\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 circumvent this problem but none were cheap and effective enough..\u003Cbr\u003E\n*/\n\u003C/p\u003E\n\u003Cp\u003E\n//Changes the strength of the displacement\u003Cbr\u003E\n#define DSP_STR 1.5\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nfloat _getsat( vec3 lColour )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 float mi = min(min(lColour.x, lColour.y), lColour.z);\u003Cbr\u003E\n\u00A0 \u00A0 float ma = max(max(lColour.x, lColour.y), lColour.z);\u003Cbr\u003E\n\u00A0 \u00A0 return (ma - mi) / (ma \u002B 1e-7);\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nvec3 NmzRgbLerp( vec3 a, vec3 b, float x )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 // interpolated base color (with singularity fix)\u003Cbr\u003E\n\u00A0 \u00A0 vec3 ic = mix( a, b, x ) \u002B vec3( 1e-6, 0.0, 0.0 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // saturation difference from ideal scenario\u003Cbr\u003E\n\u00A0 \u00A0 float sd = abs( _getsat( ic ) - mix( _getsat( a ), _getsat( b ), x ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // displacement direction\u003Cbr\u003E\n\u00A0 \u00A0 vec3 dir = normalize(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 vec3( 2.0 * ic.x - ic.y - ic.z,\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 2.0 * ic.y - ic.x - ic.z,\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 2.0 * ic.z - ic.y - ic.x )\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // simple Lighntess\u003Cbr\u003E\n\u00A0 \u00A0 float lgt = dot( vec3( 1.0 ), ic );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // extra scaling factor for the displacement\u003Cbr\u003E\n\u00A0 \u00A0 float ff = dot( dir, normalize( ic ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // displace the color\u003Cbr\u003E\n\u00A0 \u00A0 ic \u002B= DSP_STR * dir * sd * ff * lgt;\u003Cbr\u003E\n\u00A0 \u00A0 return clamp( ic, 0.0, 1.0 );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Inverse\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nmat4\u003Cbr\u003E\nInverse(\u003Cbr\u003E\n\u00A0 \u00A0 const mat4 lInMat4 )\u003Cbr\u003E\n{\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\u003Cbr\u003E\n\u00A0 \u00A0 return inverse( lInMat4 );\u003Cbr\u003E\n#else\u003Cbr\u003E\n\u00A0 \u00A0 float det = determinant( lInMat4 );\u003Cbr\u003E\n\u00A0 \u00A0 det = 1.0f / det;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 mat4 M = lInMat4;\u003Cbr\u003E\n\u00A0 \u00A0 mat4 IM;\u003Cbr\u003E\n\u00A0 \u00A0 IM[0][0] = det * ( M[1][2]*M[2][3]*M[3][1] - M[1][3]*M[2][2]*M[3][1] \u002B M[1][3]*M[2][1]*M[3][2] - M[1][1]*M[2][3]*M[3][2] - M[1][2]*M[2][1]*M[3][3] \u002B M[1][1]*M[2][2]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[0][1] = det * ( M[0][3]*M[2][2]*M[3][1] - M[0][2]*M[2][3]*M[3][1] - M[0][3]*M[2][1]*M[3][2] \u002B M[0][1]*M[2][3]*M[3][2] \u002B M[0][2]*M[2][1]*M[3][3] - M[0][1]*M[2][2]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[0][2] = det * ( M[0][2]*M[1][3]*M[3][1] - M[0][3]*M[1][2]*M[3][1] \u002B M[0][3]*M[1][1]*M[3][2] - M[0][1]*M[1][3]*M[3][2] - M[0][2]*M[1][1]*M[3][3] \u002B M[0][1]*M[1][2]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[0][3] = det * ( M[0][3]*M[1][2]*M[2][1] - M[0][2]*M[1][3]*M[2][1] - M[0][3]*M[1][1]*M[2][2] \u002B M[0][1]*M[1][3]*M[2][2] \u002B M[0][2]*M[1][1]*M[2][3] - M[0][1]*M[1][2]*M[2][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[1][0] = det * ( M[1][3]*M[2][2]*M[3][0] - M[1][2]*M[2][3]*M[3][0] - M[1][3]*M[2][0]*M[3][2] \u002B M[1][0]*M[2][3]*M[3][2] \u002B M[1][2]*M[2][0]*M[3][3] - M[1][0]*M[2][2]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[1][1] = det * ( M[0][2]*M[2][3]*M[3][0] - M[0][3]*M[2][2]*M[3][0] \u002B M[0][3]*M[2][0]*M[3][2] - M[0][0]*M[2][3]*M[3][2] - M[0][2]*M[2][0]*M[3][3] \u002B M[0][0]*M[2][2]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[1][2] = det * ( M[0][3]*M[1][2]*M[3][0] - M[0][2]*M[1][3]*M[3][0] - M[0][3]*M[1][0]*M[3][2] \u002B M[0][0]*M[1][3]*M[3][2] \u002B M[0][2]*M[1][0]*M[3][3] - M[0][0]*M[1][2]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[1][3] = det * ( M[0][2]*M[1][3]*M[2][0] - M[0][3]*M[1][2]*M[2][0] \u002B M[0][3]*M[1][0]*M[2][2] - M[0][0]*M[1][3]*M[2][2] - M[0][2]*M[1][0]*M[2][3] \u002B M[0][0]*M[1][2]*M[2][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[2][0] = det * ( M[1][1]*M[2][3]*M[3][0] - M[1][3]*M[2][1]*M[3][0] \u002B M[1][3]*M[2][0]*M[3][1] - M[1][0]*M[2][3]*M[3][1] - M[1][1]*M[2][0]*M[3][3] \u002B M[1][0]*M[2][1]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[2][1] = det * ( M[0][3]*M[2][1]*M[3][0] - M[0][1]*M[2][3]*M[3][0] - M[0][3]*M[2][0]*M[3][1] \u002B M[0][0]*M[2][3]*M[3][1] \u002B M[0][1]*M[2][0]*M[3][3] - M[0][0]*M[2][1]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[2][2] = det * ( M[0][1]*M[1][3]*M[3][0] - M[0][3]*M[1][1]*M[3][0] \u002B M[0][3]*M[1][0]*M[3][1] - M[0][0]*M[1][3]*M[3][1] - M[0][1]*M[1][0]*M[3][3] \u002B M[0][0]*M[1][1]*M[3][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[2][3] = det * ( M[0][3]*M[1][1]*M[2][0] - M[0][1]*M[1][3]*M[2][0] - M[0][3]*M[1][0]*M[2][1] \u002B M[0][0]*M[1][3]*M[2][1] \u002B M[0][1]*M[1][0]*M[2][3] - M[0][0]*M[1][1]*M[2][3] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[3][0] = det * ( M[1][2]*M[2][1]*M[3][0] - M[1][1]*M[2][2]*M[3][0] - M[1][2]*M[2][0]*M[3][1] \u002B M[1][0]*M[2][2]*M[3][1] \u002B M[1][1]*M[2][0]*M[3][2] - M[1][0]*M[2][1]*M[3][2] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[3][1] = det * ( M[0][1]*M[2][2]*M[3][0] - M[0][2]*M[2][1]*M[3][0] \u002B M[0][2]*M[2][0]*M[3][1] - M[0][0]*M[2][2]*M[3][1] - M[0][1]*M[2][0]*M[3][2] \u002B M[0][0]*M[2][1]*M[3][2] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[3][2] = det * ( M[0][2]*M[1][1]*M[3][0] - M[0][1]*M[1][2]*M[3][0] - M[0][2]*M[1][0]*M[3][1] \u002B M[0][0]*M[1][2]*M[3][1] \u002B M[0][1]*M[1][0]*M[3][2] - M[0][0]*M[1][1]*M[3][2] );\u003Cbr\u003E\n\u00A0 \u00A0 IM[3][3] = det * ( M[0][1]*M[1][2]*M[2][0] - M[0][2]*M[1][1]*M[2][0] \u002B M[0][2]*M[1][0]*M[2][1] - M[0][0]*M[1][2]*M[2][1] - M[0][1]*M[1][0]*M[2][2] \u002B M[0][0]*M[1][1]*M[2][2] );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return IM;\u003Cbr\u003E\n#endif\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef _F19_\u003Cbr\u003E\nstruct CommonVertexUniforms\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec4 gCustomParams01Vec4;\u003Cbr\u003E\n};\u003Cbr\u003E\nUNIFORM( CommonVertexUniforms, gCommonVertexUniforms );\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\nSTATIC_CONST float kfScaleUpFactor = 1.001;\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcWorldPos\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcWorldPos\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcWorldPos(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldMat4,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec4 lLocalPositionVec4 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 return MUL( lWorldMat4, lLocalPositionVec4 );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef D_INSTANCE\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcWorldPosInstanced\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcWorldPosInstanced\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcWorldPosInstanced(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldMat4,\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldInstanceMat4,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec4 lLocalPositionVec4 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lWorldPositionVec4 = MUL( lWorldMat4, lLocalPositionVec4 );\u003Cbr\u003E\n\u00A0 \u00A0 return MUL( lWorldInstanceMat4, lWorldPositionVec4 );\u003Cbr\u003E\n}\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcScreenPosFromWorld\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcScreenPosFromWorld\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcScreenPosFromWorld(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lViewMatrix4,\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lProjectionMatrix4,\u003Cbr\u003E\n\u00A0 \u00A0 in vec4 lWorldPositionVec4 )\u003Cbr\u003E\n{ \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lViewPositionVec4 = MUL( lViewMatrix4, lWorldPositionVec4 );\u003Cbr\u003E\n\u00A0 \u00A0 return MUL( lProjectionMatrix4, lViewPositionVec4 );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcScreenPosFromWorld\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcScreenPosFromWorld\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcScreenPosFromWorld(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lViewProjectionMatrix4,\u003Cbr\u003E\n\u00A0 \u00A0 in vec4 lWorldPositionVec4 )\u003Cbr\u003E\n{ \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 return MUL( lViewProjectionMatrix4, lWorldPositionVec4 );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcScreenPosFromLocal\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcScreenPosFromLocal\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcScreenPosFromLocal(\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec4 lLocalPositionVec4 )\u003Cbr\u003E\n{ \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 mat4 lTemp;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lWorldPositionVec4 = CalcWorldPos( lTemp, lLocalPositionVec4 );\u003Cbr\u003E\n\u00A0 \u00A0 return CalcScreenPosFromWorld( lTemp, lTemp, lWorldPositionVec4 );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcScreenPosFromLocal\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcScreenPosFromLocal\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcScreenPosFromLocal(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldViewProjectionMatrix4,\u003Cbr\u003E\n\u00A0 \u00A0 in vec4 lLocalPositionVec4 )\u003Cbr\u003E\n{ \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 return MUL( lWorldViewProjectionMatrix4, lLocalPositionVec4 );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef _F19_\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcBillboardPos\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcBillboardPosFromDirection\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in vec4 lDirection\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in vec4 lLocalPositionVec4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in float lfSphereFactor\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in mat4 lWorldMat4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0out vec4 lOutWorldPositionVec4\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 vec4\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcBillboardPos(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 \u00A0 lCameraMatrix4,\u003Cbr\u003E\n\u00A0 \u00A0 in vec4 \u00A0 lLocalPositionVec4,\u003Cbr\u003E\n\u00A0 \u00A0 in float \u00A0lfSphereFactor,\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 \u00A0 lWorldMat4,\u003Cbr\u003E\n\u00A0 \u00A0 in vec4 \u00A0 lShearParamsVec4,\u003Cbr\u003E\n\u00A0 \u00A0 out vec4 \u00A0lOutWorldPositionVec4 )\u00A0\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lUpVector;\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lCamUp \u00A0 \u00A0= MAT4_GET_COLUMN( lCameraMatrix4, 1 );\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lCamRight = MAT4_GET_COLUMN( lCameraMatrix4, 0 );\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lCamAt \u00A0 \u00A0= MAT4_GET_COLUMN( lCameraMatrix4, 2 );\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lCamPos \u00A0 = MAT4_GET_COLUMN( lCameraMatrix4, 3 );\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lWorldPos = MAT4_GET_COLUMN( lWorldMat4, 3 );\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lMatUpVector = MAT4_GET_COLUMN( lWorldMat4, 1 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#if defined( _F44_ )\u003Cbr\u003E\n\u00A0 \u00A0 // imposters will keep pointing \u0027up\u0027 even if the camera rolls\u003Cbr\u003E\n\u00A0 \u00A0 lCamUp \u00A0 \u00A0= normalize( MAT4_GET_COLUMN( lWorldMat4, 1 ) );\u003Cbr\u003E\n\u00A0 \u00A0 lCamRight = normalize( cross( lCamUp, lCamAt ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // make sure that an orthonormal frame is created\u003Cbr\u003E\n\u00A0 \u00A0 // ==\u0026gt; make these 3 vectors pairwise orthogonal to each other\u003Cbr\u003E\n\u00A0 \u00A0 lCamAt \u00A0 \u00A0= normalize( cross( lCamRight, lCamUp ) );\u003Cbr\u003E\n\u00A0 \u00A0 lUpVector = lCamUp;\u003Cbr\u003E\n#else\u003Cbr\u003E\n\u00A0 \u00A0 lCamRight = MAT4_GET_COLUMN( lCameraMatrix4, 0 );\u003Cbr\u003E\n\u00A0 \u00A0 lCamAt \u00A0 \u00A0= MAT4_GET_COLUMN( lCameraMatrix4, 2 );\u003Cbr\u003E\n\u00A0 \u00A0 lCamUp \u00A0 \u00A0= MAT4_GET_COLUMN( lCameraMatrix4, 1 );\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef D_INSTANCE\u003Cbr\u003E\n\u00A0 \u00A0 // undo the shear... I am not sure this is a super great way to do this...\u003Cbr\u003E\n\u00A0 \u00A0 lMatUpVector = MAT4_GET_COLUMN( lWorldMat4, 1 ) - lShearParamsVec4.x * MAT4_GET_COLUMN( lWorldMat4, 0 ) - lShearParamsVec4.y * MAT4_GET_COLUMN( lWorldMat4, 2 );\u003Cbr\u003E\n#endif\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 lUpVector = mix( lMatUpVector, lCamUp, lfSphereFactor );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lUpVector \u00A0 \u00A0 \u00A0= normalize( lUpVector );\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0| Cylinder Values \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 | Sphere Values \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 mat3 lBillboardMat3; \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef _F46_\u003Cbr\u003E\n\u00A0\u00A0 \u00A0vec3 lWorldAt \u00A0 \u00A0 = MAT4_GET_COLUMN( lWorldMat4, 2 );\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lBillboardMat3, 2, lWorldAt );\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lBillboardMat3, 1, normalize( cross( lWorldAt, ( lCamPos - lWorldPos ) ) ) );\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lBillboardMat3, 0, normalize( cross( MAT3_GET_COLUMN( lBillboardMat3, 1 ), MAT3_GET_COLUMN( lBillboardMat3, 2 ) ) ) );\u003Cbr\u003E\n#else\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lBillboardMat3, 2, normalize( mix( normalize( lCamPos - lWorldPos ), lCamAt, lfSphereFactor*lfSphereFactor*lfSphereFactor) ) );\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lBillboardMat3, 0, normalize( mix( cross( lUpVector, MAT3_GET_COLUMN( lBillboardMat3, 2 ) ), \u00A0lCamRight, lfSphereFactor) ) );\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lBillboardMat3, 1, lUpVector );\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 vec4 lBillboardPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 lBillboardPositionVec4.xyz = MUL( lBillboardMat3, lLocalPositionVec4.xyz ).xyz; //transform by billboard\u0027s orthonormal basis\u003Cbr\u003E\n\u00A0 \u00A0 lBillboardPositionVec4.w \u00A0 = 1.0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lOutWorldPositionVec4 = lBillboardPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lWorldMatScale = vec3( length( MAT4_GET_COLUMN_VEC4( lWorldMat4, 0 ) ), length( lMatUpVector ), length( MAT4_GET_COLUMN_VEC4( lWorldMat4, 2 ) ) );\u003Cbr\u003E\n\u00A0 \u00A0 lOutWorldPositionVec4.xyz *= lWorldMatScale;\u003Cbr\u003E\n\u00A0 \u00A0 lOutWorldPositionVec4.xyz \u002B= lWorldPos.xyz;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 mat4 lOriginModelInvMat4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lOriginModelInvMat4 \u00A0 \u00A0 \u00A0= Inverse( lWorldMat4 );\u003Cbr\u003E\n\u00A0 \u00A0 MAT4_SET_COLUMN( lOriginModelInvMat4, 0, normalize( MAT4_GET_COLUMN_VEC4( lOriginModelInvMat4, 0 ) ) );\u003Cbr\u003E\n\u00A0 \u00A0 MAT4_SET_COLUMN( lOriginModelInvMat4, 1, normalize( MAT4_GET_COLUMN_VEC4( lOriginModelInvMat4, 1 ) ) );\u003Cbr\u003E\n\u00A0 \u00A0 MAT4_SET_COLUMN( lOriginModelInvMat4, 2, normalize( MAT4_GET_COLUMN_VEC4( lOriginModelInvMat4, 2 ) ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0MAT4_SET_POS( lOriginModelInvMat4, vec4( 0.0, 0.0, 0.0, 1.0 ) );\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 lBillboardPositionVec4 = MUL( lOriginModelInvMat4, lBillboardPositionVec4 );\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef D_INSTANCE\u003Cbr\u003E\n\u00A0 \u00A0 lOutWorldPositionVec4.xyz \u002B= lLocalPositionVec4.y * ( MAT4_GET_COLUMN( lWorldMat4, 0 ) * lShearParamsVec4.x \u002B MAT4_GET_COLUMN( lWorldMat4, 2 ) * lShearParamsVec4.y );\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lBillboardPositionVec4;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef _F12_\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcBatchedBillboardMat4\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcBatchedBillboardMat4\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in vec4 lTexCoords\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in mat4 lWorldMat\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 mat4\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nmat4\u003Cbr\u003E\nCalcBatchedBillboardMat4(\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0mat4 lGlobalWorldMat,\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0vec4 lTexCoords,\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0vec4 lLocalPosVec4,\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0mat4 lWorldMat4,\u003Cbr\u003E\n\u00A0 \u00A0 out \u00A0 vec4 lOutCenterVec4 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec2 lBillboardPositionVec2;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lLocalPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lCenterPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 mat4 lBillboardWorldMat4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lLocalPositionVec4 = lLocalPosVec4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Calculate center position as offset from local position, using UVs\u003Cbr\u003E\n\u00A0 \u00A0 lBillboardPositionVec2 = lTexCoords.xy;\u003Cbr\u003E\n\u00A0 \u00A0 lBillboardPositionVec2 = vec2( lBillboardPositionVec2.x - 0.5, \u00A00.5 - lBillboardPositionVec2.y);\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n#ifdef D_INSTANCE\u003Cbr\u003E\n\u00A0 \u00A0 // Scale\u003Cbr\u003E\n\u00A0 \u00A0 lBillboardPositionVec2.x *= length( MAT4_GET_COLUMN( lGlobalWorldMat, 0 ) );\u003Cbr\u003E\n\u00A0 \u00A0 lBillboardPositionVec2.y *= length( MAT4_GET_COLUMN( lGlobalWorldMat, 1 ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lLocalPositionVec4.xyz = MUL( lGlobalWorldMat, lLocalPositionVec4 ).xyz;\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Calculate offset of center position from model position\u003Cbr\u003E\n\u00A0 \u00A0 lCenterPositionVec4.xy = lLocalPositionVec4.xy - lBillboardPositionVec2.xy;\u003Cbr\u003E\n\u00A0 \u00A0 lCenterPositionVec4.z \u00A0= lLocalPositionVec4.z;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lBillboardWorldMat4 \u00A0= lWorldMat4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0vec4 lTransPos = MUL( lBillboardWorldMat4, vec4(lCenterPositionVec4.xyz, 1.0));\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0MAT4_SET_POS( lBillboardWorldMat4, lTransPos );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lOutCenterVec4 = vec4(lBillboardPositionVec2.xy, 0.0, 1.0);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lBillboardWorldMat4;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcBillboardValues\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcBillboardValues\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in \u00A0vec4 lLocalPositionVec4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in \u00A0mat4 lWorldMat4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in \u00A0vec4 lTexCoordsVec4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0out vec4 lOutLocalPositionVec4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0out vec4 lOutWorldPositionVec4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0out vec3 lOutLocalNormalVec3\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0out vec3 lOutWorldNormalVec3\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 void\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvoid\u00A0\u003Cbr\u003E\nCalcBillboardValues(\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0mat4 \u00A0 lCameraMatrix,\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0mat4 \u00A0 lGlobalWorldMat,\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0vec4 \u00A0 lLocalPositionVec4, \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0vec4 \u00A0 lCustomParams01Vec4, \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0mat4 \u00A0 lWorldMat4,\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0vec4 \u00A0 lTexCoordsVec4,\u003Cbr\u003E\n\u00A0 \u00A0 in \u00A0vec4 \u00A0 lShearParamsVec4,\u003Cbr\u003E\n\u00A0 \u00A0 out \u00A0 vec4 \u00A0 lOutLocalPositionVec4,\u003Cbr\u003E\n\u00A0 \u00A0 out \u00A0 vec4 \u00A0 lOutWorldPositionVec4,\u003Cbr\u003E\n\u00A0 \u00A0 out \u00A0 vec3 \u00A0 lOutLocalNormalVec3,\u003Cbr\u003E\n\u00A0 \u00A0 out \u00A0 vec3 \u00A0 lOutWorldNormalVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n#ifdef D_INSTANCE\u003Cbr\u003E\n\u00A0 \u00A0 mat4 lCombinedWorldMat4 = MUL( lWorldMat4, lGlobalWorldMat );\u003Cbr\u003E\n#else \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 mat4 lCombinedWorldMat4 = lGlobalWorldMat;\u003Cbr\u003E\n#endif \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n#ifdef _F12_\u003Cbr\u003E\n\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 mat4 lBillboardWorldMat4;\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 vec4 lBillboardLocalCenterVec4;\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lBillboardWorldMat4 = CalcBatchedBillboardMat4( lGlobalWorldMat, \u00A0lTexCoordsVec4, lLocalPositionVec4, lWorldMat4, lBillboardLocalCenterVec4 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lOutLocalPositionVec4 \u00A0= CalcBillboardPos( lCameraMatrix, lBillboardLocalCenterVec4, lCustomParams01Vec4.x, lBillboardWorldMat4, lShearParamsVec4, lOutWorldPositionVec4 );\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lOutWorldPositionVec4 \u00A0= MUL( lBillboardWorldMat4, vec4(lOutLocalPositionVec4.xyz, 1.0)); \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lOutLocalNormalVec3 \u00A0 \u00A0= normalize( lOutLocalPositionVec4.xyz );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 // Calculate normal\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 float \u00A0lfRadius \u00A0 \u00A0 \u00A0 \u00A0= length( MAT4_GET_COLUMN( lGlobalWorldMat, 0 ) ) * 0.5;\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 vec3 \u00A0 lMidPointVec3 \u00A0 = MAT4_GET_COLUMN( lBillboardWorldMat4, 3 );\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 vec3 \u00A0 lSphereApexVec3 = lMidPointVec3 - ( MAT4_GET_COLUMN( lCameraMatrix, 2 ) * lfRadius);\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lOutWorldNormalVec3 \u00A0 \u00A0= normalize( lOutWorldPositionVec4.xyz - lSphereApexVec3 );\u003Cbr\u003E\n\u00A0 \u00A0 }\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n#else\u003Cbr\u003E\n\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 // Billboarding for mesh which is already a single quad\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lOutLocalPositionVec4 = CalcBillboardPos( lCameraMatrix, lLocalPositionVec4, lCustomParams01Vec4.x, lCombinedWorldMat4, lShearParamsVec4, lOutWorldPositionVec4 );\u003Cbr\u003E\n#if 0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 // Original and test code to check results \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 // lOutWorldPositionVec4 = CalcWorldPos( lWorldMat4, lOutLocalPositionVec4 );\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 vec4 lOutWorldPositionVec4_2 = CalcWorldPos( lWorldMat4, lOutLocalPositionVec4 ); \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 float lfDiff = abs(lOutWorldPositionVec4_2.x - lOutWorldPositionVec4.x) \u002B abs(lOutWorldPositionVec4_2.y - lOutWorldPositionVec4.y) \u002B abs(lOutWorldPositionVec4_2.z - lOutWorldPositionVec4.z);\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 if (lfDiff \u0026gt; 0.001) \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 _SCE_BREAK();\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 }\u003Cbr\u003E\n#endif \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 // Calculate normal\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 float \u00A0lfRadius \u00A0 \u00A0 \u00A0 \u00A0= length( MAT4_GET_COLUMN( lCombinedWorldMat4, 0 ) ) * 0.5;\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 vec3 \u00A0 lMidPointVec3 \u00A0 = MAT4_GET_COLUMN( lCombinedWorldMat4, 3 );\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 vec3 \u00A0 lSphereApexVec3 = lMidPointVec3 - ( MAT4_GET_COLUMN( lCameraMatrix, 2 ) * lfRadius);\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lOutWorldNormalVec3 \u00A0 \u00A0= normalize( lOutWorldPositionVec4.xyz - lSphereApexVec3 );\u003Cbr\u003E\n\u00A0 \u00A0 }\u003Cbr\u003E\n#endif\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcWorldVec\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcWorldVec\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nCalcWorldVec(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldNormalMat4,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lLocalVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return MUL( lWorldNormalMat4, vec4( lLocalVec3, 1.0 ) ).xyz;\u003Cbr\u003E\n\u00A0 \u00A0 //return lLocalVec3;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef D_INSTANCE\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcWorldVecInstanced\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcWorldVecInstanced\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nCalcWorldVecInstanced(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldNormalMat4,\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldInstancedMat4,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lLocalVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 mat4 lWorldInstancedNormalMat4;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0lWorldInstancedNormalMat4 = mat4( normalize(vec3(lWorldInstancedMat4[0][0], lWorldInstancedMat4[0][1], lWorldInstancedMat4[0][2])), 0.0, \u00A0\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0normalize(vec3(lWorldInstancedMat4[1][0], lWorldInstancedMat4[1][1], lWorldInstancedMat4[1][2])), 0.0, \u00A0\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0normalize(vec3(lWorldInstancedMat4[2][0], lWorldInstancedMat4[2][1], lWorldInstancedMat4[2][2])), 0.0, \u00A0\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 0.0,\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A00.0,\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 0.0,\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A01.0 );\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lWorldNormal = MUL( lWorldNormalMat4, vec4( lLocalVec3, 1.0 ) ).xyz;\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return MUL( lWorldInstancedNormalMat4, vec4( lWorldNormal, 1.0 ) ).xyz;\u003Cbr\u003E\n}\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcTanToWorldMat\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcTanToWorldMat\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nmat3\u00A0\u003Cbr\u003E\nCalcTanToWorldMat(\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lTangentVec3,\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lBitangentVec3,\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lNormalVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return mat3( lTangentVec3, lBitangentVec3, lNormalVec3 );\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcTanVec\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcTanVec\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n#ifdef _F20_\n\u003C/p\u003E\n\u003Cp\u003E\nvec3\u00A0\u003Cbr\u003E\nCalcTanVec(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in vec3 lViewPositionVec3,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec4 lWorldPositionVec4,\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lTangentVec3,\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lBitangentVec3,\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0in vec3 lNormalVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0vec3 lResultVec3;\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lDirectionVec3;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lDirectionVec3 = lViewPositionVec3 - lWorldPositionVec4.xyz;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0lResultVec3.x = dot( lDirectionVec3, lTangentVec3 );\u003Cbr\u003E\n\u00A0\u00A0 \u00A0lResultVec3.y = dot( lDirectionVec3, lBitangentVec3 );\u003Cbr\u003E\n\u00A0\u00A0 \u00A0lResultVec3.z = dot( lDirectionVec3, lNormalVec3 );\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return lResultVec3;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 ApplyRotation\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0ApplyRotation\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n#ifdef _F17_\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nApplyRotation(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 float lfTheta,\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec3 \u00A0 lLocalPositionVec3 )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 mat3 lRotationMat3;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 float lfCosTheta = cos( lfTheta * 3.0 );\u003Cbr\u003E\n\u00A0 \u00A0 float lfSinTheta = sin( lfTheta * 3.0 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lRotationMat3, 0, vec3( lfCosTheta, 0.0, lfSinTheta ) );\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lRotationMat3, 1, vec3( 0.0, 1.0, 0.0 ) );\u003Cbr\u003E\n\u00A0 \u00A0 MAT3_SET_COLUMN( lRotationMat3, 2, vec3( -lfSinTheta, 0.0, lfCosTheta ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return MUL( lRotationMat3, lLocalPositionVec3 );\u003Cbr\u003E\n}\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcScreenPosFromWorld\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcScreenPosFromWorld\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0void\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 Nothing.\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcCompressedVertexWorldPosition(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lWorldMatrix,\u003Cbr\u003E\n\u00A0 \u00A0 in vec4 lLocalPositionVec4 )\u003Cbr\u003E\n{ \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // [peter] NOT USED ANYMORE? IF YES, NEED TO REWRITE MATRIX ACCESSOR TO BE PLATFORM INDEPENDENT\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //ALEXCHECK - multiplication order\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lWorldPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 mat4 lWorldMat4 = lWorldMatrix;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Scale up slightly to hide cracks\u003Cbr\u003E\n\u00A0 \u00A0 lWorldMat4[0][0] *= kfScaleUpFactor;\u003Cbr\u003E\n\u00A0 \u00A0 lWorldMat4[1][1] *= kfScaleUpFactor;\u003Cbr\u003E\n\u00A0 \u00A0 lWorldMat4[2][2] *= kfScaleUpFactor;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Strip scale from model position and add this first\u003Cbr\u003E\n\u00A0 \u00A0 lWorldPositionVec4 \u00A0= lLocalPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 lWorldPositionVec4 \u002B= vec4( lWorldMat4[ 3 ][ 0 ] / lWorldMat4[ 0 ][ 0 ], lWorldMat4[ 3 ][ 1 ] / lWorldMat4[ 1 ][ 1 ], lWorldMat4[ 3 ][ 2 ] / lWorldMat4[ 2 ][ 2 ], 0.0 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Scale up world position\u003Cbr\u003E\n\u00A0 \u00A0 lWorldMat4[3] \u00A0 \u00A0 \u00A0 = vec4( 0.0, 0.0, 0.0, 1.0 );\u003Cbr\u003E\n\u00A0 \u00A0 lWorldPositionVec4 \u00A0= MUL( lWorldMat4, lWorldPositionVec4 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lWorldPositionVec4;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CalcDualParaboloidScreenPosition\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CalcDualParaboloidScreenPosition\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in mat4 lViewMat4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in vec4 lWorldPositionVec4\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0in vec2 lClipPlanes\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 vec4\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec4\u00A0\u003Cbr\u003E\nCalcDualParaboloidScreenPosition(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 in mat4 lViewMat4,\u003Cbr\u003E\n\u00A0 \u00A0 in vec4 lWorldPositionVec4,\u003Cbr\u003E\n\u00A0 \u00A0 in vec2 lClipPlanes )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lScreenSpacePositionVec4 = MUL( lViewMat4, lWorldPositionVec4 );\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// transform vertex into the maps basis\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // Our Camera At is backwards\u003Cbr\u003E\n\u00A0 \u00A0 lScreenSpacePositionVec4.z = -lScreenSpacePositionVec4.z;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //Next we need to find the vector from the the vertex to the origin of the paraboloid, which is simply:\u003Cbr\u003E\n\u00A0 \u00A0 float L = length( lScreenSpacePositionVec4.xyz );\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// determine the distance between (0,0,0) and the vertex\u003Cbr\u003E\n\u00A0 \u00A0 lScreenSpacePositionVec4.xyz = lScreenSpacePositionVec4.xyz / L;\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// divide the vertex position by the distance\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //Now we need to find the x and y coordinates of the point where the incident ray intersects the paraboloid surface.\u003Cbr\u003E\n\u00A0 \u00A0 lScreenSpacePositionVec4.z = lScreenSpacePositionVec4.z \u002B 1.0;\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// add the reflected vector to find the normal vector\u003Cbr\u003E\n\u00A0 \u00A0 lScreenSpacePositionVec4.x = lScreenSpacePositionVec4.x / lScreenSpacePositionVec4.z;\u00A0\u00A0 \u00A0// divide x coord by the new z-value\u003Cbr\u003E\n\u00A0 \u00A0 lScreenSpacePositionVec4.y = lScreenSpacePositionVec4.y / lScreenSpacePositionVec4.z;\u00A0\u00A0 \u00A0// divide y coord by the new z-value\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Finally we set the z value as the distance from the vertex to the origin of the paraboloid, scaled and biased by the near and far planes of the paraboloid \u0027camera\u0027.\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 lScreenSpacePositionVec4.z = (L - lClipPlanes.x) / (lClipPlanes.y - lClipPlanes.x); \u00A0// set a depth value for correct z-buffering\u003Cbr\u003E\n\u00A0 \u00A0 lScreenSpacePositionVec4.w = 1;\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // set w to 1 so there is no w divide\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lScreenSpacePositionVec4;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 OctahedronNormalEncode\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0OctahedronNormalEncode\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0vec3 lNormal\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 vec2\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec2\u003Cbr\u003E\nOctahedronNormalEncode(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lNormal )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec2 lEncoded;\u003Cbr\u003E\n\u00A0 \u00A0 lNormal /= ( abs( lNormal.x ) \u002B abs( lNormal.y ) \u002B abs( lNormal.z ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 if( lNormal.z \u0026gt; 0.0 )\u003Cbr\u003E\n\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lEncoded = vec2( lNormal.x, lNormal.y );\u003Cbr\u003E\n\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0 \u00A0 else\u003Cbr\u003E\n\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lEncoded = vec2( 1.0 - abs( lNormal.y ), 1.0 - abs( lNormal.x ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lEncoded.x *= lNormal.x \u0026lt; 0.0 ? -1.0 : 1.0;\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lEncoded.y *= lNormal.y \u0026lt; 0.0 ? -1.0 : 1.0;\u003Cbr\u003E\n\u00A0 \u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lEncoded;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 OctahedronNormalDecode\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0OctahedronNormalDecode\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @param \u00A0 \u00A0 \u00A0vec2 lEncoded\u003Cbr\u003E\n/// \u00A0 \u00A0 @return \u00A0 \u00A0 vec3\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nvec3\u00A0\u003Cbr\u003E\nOctahedronNormalDecode(\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec2 lEncoded )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lNormal;\u003Cbr\u003E\n\u00A0 \u00A0 lNormal.z = 1.0 - abs( lEncoded.x ) - abs( lEncoded.y );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 if( lNormal.z \u0026gt;= 0.0 )\u003Cbr\u003E\n\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lNormal.xy = lEncoded.xy;\u003Cbr\u003E\n\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0 \u00A0 else\u003Cbr\u003E\n\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lNormal.x = 1.0 - abs( lEncoded.y );\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lNormal.y = 1.0 - abs( lEncoded.x );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lNormal.x *= lEncoded.x \u0026lt; 0.0 ? -1.0 : 1.0;\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lNormal.y *= lEncoded.y \u0026lt; 0.0 ? -1.0 : 1.0;\u003Cbr\u003E\n\u00A0 \u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lNormal = normalize( lNormal );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return lNormal;\u003Cbr\u003E\n}\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @file \u00A0 \u00A0 \u00A0 CommonUniforms.h\u003Cbr\u003E\n/// \u00A0 \u00A0 @author \u00A0 \u00A0 User\u003Cbr\u003E\n/// \u00A0 \u00A0 @date \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CommonUniforms\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Copyright (c) 2008 Hello Games Ltd. All Rights Reserved.\u003Cbr\u003E\n///\u003Cbr\u003E\n////////////////////////////////////////////////////////////////////////////////\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#ifndef D_COMMONUNIFORMS2_H\u003Cbr\u003E\n#define D_COMMONUNIFORMS2_H\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\n\u003C/p\u003E\n\u003Cp\u003E\n#ifndef D_DEFINES\u003Cbr\u003E\n#define D_DEFINES\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Platform defines\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #pragma optionNV(strict on)\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_gpu_shader5 : enable\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_fragment_coord_conventions : enable\u003Cbr\u003E\n\u00A0 \u00A0 #extension GL_ARB_derivative_control : enable\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #ifdef D_FRAGMENT\u003Cbr\u003E\n\u00A0 \u00A0 //{\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 //layout( origin_upper_left, pixel_center_integer ) in vec4 gl_FragCoord;\u003Cbr\u003E\n\u00A0 \u00A0 //}\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // use this with sdk 2.0 compiler\u00A0\u003Cbr\u003E\n\u00A0 \u00A0// #pragma argument (allow-scratch-buffer-spill)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //define these flags so they don\u0027t get ignored in build process and in the comb mask\u003Cbr\u003E\n\u00A0 \u00A0 //this is because materials, vertex layouts and shaders need to be synced on 360 to avoid patching\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F27_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F28_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F29_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F21_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F02_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F03_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #if defined( _F01_ ) || defined( D_LOD0 ) || defined( D_LOD1 ) || defined( D_LOD2 ) || defined( D_LOD3) || defined( D_LOD4 )\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F01_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F09_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\u003Cbr\u003E\n\u00A0 \u00A0 #ifdef _F10_\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 // disable warnings for unused parameters. This happens a lot because of defining different things.\u003Cbr\u003E\n\u00A0 \u00A0 #pragma warning (disable: 5203)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // temp thing to know what things are still required on ps4.\u003Cbr\u003E\n\u00A0 \u00A0 #define D_PLATFORM_ORBIS_FIX\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Basic Types\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define JOINT_TYPE \u00A0 \u00A0vec4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define CONST \u00A0 \u00A0 \u00A0 \u00A0 const\u003Cbr\u003E\n\u00A0 \u00A0 #define STATIC_CONST \u00A0const\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define JOINT_TYPE \u00A0 \u00A0 \u00A0int4\u003Cbr\u003E\n\u00A0 \u00A0 #define float \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 float\u003Cbr\u003E\n\u00A0 \u00A0 #define vec2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float2\u003Cbr\u003E\n\u00A0 \u00A0 #define vec3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float3\u003Cbr\u003E\n\u00A0 \u00A0 #define vec4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float4\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int2\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int3\u003Cbr\u003E\n\u00A0 \u00A0 #define ivec4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 int4\u003Cbr\u003E\n\u00A0 \u00A0 // NOTE:\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // operator[] accesses rows, not columns\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // matrix constructors interpret the passed vectors as row vectors, not column vectors\u003Cbr\u003E\n\u00A0 \u00A0 #define mat2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float2x2\u003Cbr\u003E\n\u00A0 \u00A0 #define mat3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float3x3\u003Cbr\u003E\n\u00A0 \u00A0 #define mat4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0row_major float4x4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define CONST \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define STATIC_CONST \u00A0 \u00A0static const\u003Cbr\u003E\n\u00A0 \u00A0// #define const \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 ERROR, DON\u0027T USE CONST FOR PS4. USE STATIC_CONST INSTEAD FOR A COMPILED IN CONSTANT. OTHERWISE IT TRIES TO PUT IT IN A CONSTANT BUFFER AND FOR SOME REASON IT DOESN\u0027T WORK.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Functions\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define saturate( V ) \u00A0min( max( V, 0.0) , 1.0)\u003Cbr\u003E\n\u00A0 \u00A0 #define atan2( Y, X ) \u00A0atan( Y, X )\u003Cbr\u003E\n\u00A0 \u00A0 #define invsqrt( X ) \u00A0 inversesqrt( X )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// These can be deleted if ARB_derivative_control can be used\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//#define dFdxFine\u00A0\u00A0 \u00A0dFdx\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//#define dFdyFine\u00A0\u00A0 \u00A0dFdy\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define mix \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 lerp\u003Cbr\u003E\n\u00A0 \u00A0 #define fract \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 frac\u003Cbr\u003E\n\u00A0 \u00A0 #define dFdx\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddx\u003Cbr\u003E\n\u00A0 \u00A0 #define dFdy\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddy\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define dFdxFine\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddx_fine\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define dFdyFine\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ddy_fine\u003Cbr\u003E\n#define mod\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0fmod\u003Cbr\u003E\n\u00A0 \u00A0 #define saturate( V ) \u00A0 ( min( max( V, 0.0) , 1.0) )\u003Cbr\u003E\n\u00A0 \u00A0 #define invsqrt( X ) \u00A0 \u00A0rsqrt( X )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Samplers and textures\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW( NAME, REG ) \u00A0 \u00A0uniform sampler2DShadow NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0in sampler2D NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYARG( NAME ) \u00A0 \u00A0 \u00A0 in sampler2DArray NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLERCUBE( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 samplerCube NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLERCUBEARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0in samplerCube NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLERCUBEPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYPARAM( NAME ) \u00A0 \u00A0 NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // TEMP while switching ps4 over to srt\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 sampler2D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2D_TEMP( NAME, INDEX ) \u00A0 uniform sampler2D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAY( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0sampler2DArray \u00A0NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER3D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 sampler3D \u00A0 \u00A0 \u00A0 NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW_SRT( NAME ) \u00A0 \u00A0 sampler2DShadow NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLERCUBE( NAME, REG ) \u00A0 \u00A0 \u00A0 \u00A0SamplerState NAME##SS : register( s##REG ); TextureCube NAME##TU : register( t##REG )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Texture2D NAME; SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DSHADOW_SRT( NAME ) \u00A0 \u00A0 Texture2D NAME; SamplerComparisonState NAME##SS \u00A0//SAMPLER2D( NAME )\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER3D( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Texture3D NAME; SamplerState NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAY( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Texture2D_Array NAME; SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYARG( NAME ) \u00A0 \u00A0 \u00A0 Texture2D_Array NAME, SamplerState NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARRAYPARAM( NAME ) \u00A0 \u00A0 NAME, NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SAMPLER2DPARAM( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0NAME, NAME##SS\u003Cbr\u003E\n\u00A0 \u00A0 #define SAMPLER2DARG( NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Texture2D NAME, SamplerState NAME##SS\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define texture2D( T, C )\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.Sample( T##SS, C )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define texture2DLod( T, C, N ) \u00A0 \u00A0 \u00A0 \u00A0 T.SampleLOD( T##SS, C, N )\u003Cbr\u003E\n\u00A0 \u00A0 #define texture2DArray( \u00A0T, C ) \u00A0 \u00A0 \u00A0 \u00A0 T.Sample( T##SS, C )\u003Cbr\u003E\n\u00A0 \u00A0 #define texture3DLod( T, C, N ) \u00A0 \u00A0 \u00A0 \u00A0 T.SampleLOD( T##SS, C, N )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec3( C.z \u0026gt; T.Sample( T##SS, C.xy ).x ? 1.0 : 0.0 ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.GatherCmp( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 //#define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.SampleCmpLOD0( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 #define shadow2D( T, C ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T.SampleCmp( T##SS, C.xy, C.z )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureCube( T, C )\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0T##TU.Sample( T##SS, C )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureCubeLod( T, C, N )\u00A0\u00A0 \u00A0 \u00A0 \u00A0T##TU.Sample( T##SS, C, N )\u003Cbr\u003E\n\u00A0 \u00A0 #define textureGrad( T, C, DDX, DDY ) \u00A0 T.SampleGradient( T##SS, C, DDX, DDY ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Matrices\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MUL( INPUT_A, INPUT_B ) \u00A0 \u00A0 \u00A0 \u00A0 (INPUT_A * INPUT_B)\u003Cbr\u003E\n\u00A0 \u00A0 #define PLATFORM_TRANSPOSE\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_POS( M, P ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0M[ 3 ] = P\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_TRANSLATION( M, T ) \u00A0 \u00A0M[ 3 ].xyz = T\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ].xyz\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT3_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ]\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN_VEC4( M, C ) \u00A0 \u00A0M[ C ]\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MAT3_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MUL( INPUT_A, INPUT_B ) \u00A0 \u00A0 \u00A0 \u00A0 mul( INPUT_B, INPUT_A )\u003Cbr\u003E\n\u00A0 \u00A0 #define PLATFORM_TRANSPOSE\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_POS( M, P ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0M[ 3 ] = P\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_TRANSLATION( M, T ) \u00A0 \u00A0M[ 3 ].xyz = T\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ].xyz\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT3_GET_COLUMN( M, C ) \u00A0 \u00A0 \u00A0 \u00A0 M[ C ]\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_GET_COLUMN_VEC4( M, C ) \u00A0 \u00A0M[ C ]\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define MAT3_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\u003Cbr\u003E\n\u00A0 \u00A0 #define MAT4_SET_COLUMN( M, C, V ) \u00A0 \u00A0 \u00A0M[ C ] = V;\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Arrays (workaround AMD shader compiler issues by making arrays have global scope)\u003Cbr\u003E\n// =================================================================================================\n\u003C/p\u003E\n\u003Cp\u003E\n#if defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _UNIFORMS._ELEMENT[_INDEX]\u003Cbr\u003E\n#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _UNIFORMS._ELEMENT[_INDEX]\n\u003C/p\u003E\n\u003Cp\u003E\n#else\n\u003C/p\u003E\n\u003Cp\u003E\n#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _ELEMENT[_INDEX]\u003Cbr\u003E\n#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX) \u00A0 _ELEMENT[_INDEX]\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Input and Output\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define UNIFORM( TYPE, NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform TYPE NAME\u003Cbr\u003E\n\u00A0 \u00A0 #define UNIFORM_SRT( TYPE, NAME ) \u00A0 \u00A0 \u00A0 uniform TYPE NAME\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define DECLARE_INPUT\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_OUTPUT\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_END \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_PTR( TYPE, NAME ) \u00A0 \u00A0 \u00A0 TYPE \u00A0NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define INPUT( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0in \u00A0 \u00A0TYPE NAME;\u003Cbr\u003E\n\u00A0 \u00A0 #define INPUT_NOINTERP( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0in \u00A0 \u00A0TYPE NAME;\u003Cbr\u003E\n\u00A0 \u00A0 #define OUTPUT( \u00A0TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0out \u00A0 TYPE NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4_DEFINE \u00A0 \u00A0layout ( location = 0 ) out uvec4 out_color0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 out_color0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 gl_FragColor\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 0 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR1 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 1 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 2 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragData[ 3 ]\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_DEPTH \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_FragDepth\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define IN( \u00A0VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\u003Cbr\u003E\n\u00A0 \u00A0 #define OUT( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\u003Cbr\u003E\n\u00A0 \u00A0 #define DEREF_PTR( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define OUT_VERTEX_SCREEN_POSITION\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define IN_SCREEN_POSITION\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0gl_Position\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define UNIFORM( TYPE, NAME ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 ConstantBuffer NAME##CB{ TYPE NAME; };\u003Cbr\u003E\n\u00A0 \u00A0 #define UNIFORM_SRT( TYPE, NAME ) \u00A0 \u00A0 \u00A0 ConstantBuffer NAME##CB{ TYPE NAME : S_SRT_DATA; };\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define DECLARE_OUTPUT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput {\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_INPUT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 struct cInput \u00A0{\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_END \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 };\u003Cbr\u003E\n\u00A0 \u00A0 #define DECLARE_PTR( TYPE, NAME ) \u00A0 \u00A0 \u00A0 TYPE* NAME;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define INPUT( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 TYPE NAME : REG;\u003Cbr\u003E\n\u00A0 \u00A0 #define INPUT_NOINTERP( \u00A0 TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0nointerp TYPE NAME : REG; \u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #define OUTPUT( \u00A0TYPE, NAME, REG ) \u00A0 \u00A0 \u00A0TYPE NAME : REG;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4_DEFINE\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR_UVEC4 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Out.mColour\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 Out.mColour\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour0\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR1 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour1\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR2 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour2\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_COLOUR3 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mColour3\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_DEPTH \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.mDepth\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define IN( \u00A0VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0In.VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define OUT( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0Out.VAR\n\u003C/p\u003E\n\u003Cp\u003E\n// TODO get rid of this - don\u0027t pass struct through functinos, pass members.\u003Cbr\u003E\n\u00A0 \u00A0 #define DEREF_PTR( VAR ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0*VAR\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define OUT_VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0OUTPUT( vec4, mScreenPositionVec4, S_POSITION )\u003Cbr\u003E\n\u00A0 \u00A0 #define IN_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0INPUT ( vec4, mScreenPositionVec4, S_POSITION )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_SCREEN_POSITION \u00A0 \u00A0 \u00A0 \u00A0 \u00A0OUT( mScreenPositionVec4 )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n// =================================================================================================\u003Cbr\u003E\n// Main\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0void main( void )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0#define VOID_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH \u00A0 \u00A0 \u00A0void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT \u00A0uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT \u00A0uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\u003Cbr\u003E\n\u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define VOID_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 uniform UniformBuffer lUniforms; void main( void )\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined( D_PLATFORM_ORBIS )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out )\u003Cbr\u003E\n\u00A0 \u00A0 #define VERTEX_MAIN_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, out cOutput Out )\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; float mDepth \u00A0: S_DEPTH_OUTPUT; };\u00A0\u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #if !defined( D_ATTRIBUTES )\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0 \u00A0 struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_OUTPUT; \u00A0 \u00A0}; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT \u00A0struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_GE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT \u00A0struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_LE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u003Cbr\u003E\n#define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour : S_TARGET_OUTPUT; };\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0[RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n#define VOID_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0[FORCE_EARLY_DEPTH_STENCIL]void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #else\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u00A0 \u00A0#pragma PSSL_target_output_format(target 1 FMT_32_AR)\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0float mDepth \u00A0 : S_DEPTH_OUTPUT; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT \u00A0 \u00A0 \u00A0 \u00A0struct cOutput { vec4 \u00A0mColour0 : S_TARGET_OUTPUT0; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour1 : S_TARGET_OUTPUT1; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour2 : S_TARGET_OUTPUT2; \u00A0 \u00A0\\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0vec4 \u00A0mColour3 : S_TARGET_OUTPUT3; }; \\\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 [FORCE_EARLY_DEPTH_STENCIL] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 #endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n// Viewport\u003Cbr\u003E\n// =================================================================================================\u003Cbr\u003E\n#ifdef D_PLATFORM_PC\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) A.xy\n\u003C/p\u003E\n\u003Cp\u003E\n#elif defined(D_PLATFORM_ORBIS)\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) ( float2( A.x, 1.0 - A.y ) )\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nstruct PerFrameUniforms\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gLightPositionVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_LightPositionVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gLightDirectionVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_LightDirectionVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec3 \u00A0 \u00A0gViewPositionVec3; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ViewPositionVec3\u003Cbr\u003E\n\u00A0 \u00A0 float \u00A0 gfTime; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_Time\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gClipPlanesVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ClipPlanesVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gClipPlanesRVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ClipPlanesRVec4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gCameraMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_CameraMat4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gFrameBufferSizeVec4; \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gFoVValuesVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_FoVValuesVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gShadowSizeVec4; \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gShadowFadeParamVec4; \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gViewMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ViewMat4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //\u003Cbr\u003E\n\u00A0 \u00A0 // These are per pass really. Probably just rename PerFrame to PerPass.\u003Cbr\u003E\n\u00A0 \u00A0 //\u003Cbr\u003E\n\u00A0 \u00A0 //mat4 \u00A0 \u00A0gProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 //mat4 \u00A0 \u00A0gCameraMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_CameraMat4\u003Cbr\u003E\n\u00A0 \u00A0 //mat4 \u00A0 \u00A0gaShadowMat4[ 2 ]; \u00A0 // EShaderConst_ShadowMat4\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 \u00A0 \u00A0gClipPlanesVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ClipPlanesVec4\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //SAMPLER2D( gDualPMapFront ); \u00A0 \u00A0// 32 bytes each\u003Cbr\u003E\n\u00A0 \u00A0 //SAMPLER2D( gDualPMapBack );\u003Cbr\u003E\n\u00A0 \u00A0 //SAMPLER2D( gCloudShadowMap );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //SAMPLER2D( gFadeNoiseMap );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //SAMPLER2D( gCausticMap );\u003Cbr\u003E\n\u00A0 \u00A0 //SAMPLER2D( gCausticOffsetMap );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // how to set samplers\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // putting these here would require removing them from the shader and material, and making them part of the common global\u003Cbr\u003E\n\u00A0 \u00A0 // list so they can be set like the ones above... i think.\u003Cbr\u003E\n\u00A0 \u00A0 // Fog\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSkyColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gHorizonColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSunColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gWaterColourNearVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gWaterColourFarVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gWaterFogVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gHeightFogParamsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gHeightFogColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceHorizonColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gFogColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gFogParamsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gScatteringParamsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceFogWavelength1Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceFogWavelength2Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceFogWavelength3Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSpaceSkyColourVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gFogFadeHeightsVec4;\u003Cbr\u003E\n\u00A0 \u00A0 //vec4 gSunPositionVec4;\u003Cbr\u003E\n};\n\u003C/p\u003E\n\u003Cp\u003E\nstruct CommonPerMeshUniforms\u003Cbr\u003E\n{ \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // These are planet specific. Should they be here?\u003Cbr\u003E\n\u00A0 \u00A0 vec4 gPlanetPositionVec4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Stop these being compiled in when recolouring as the recolour shader needs ALL tex units.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseModelMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseModelMat4 = 0\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gWorldMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_WorldMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gWorldViewProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_WorldViewProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gWorldNormalMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_WorldNormalMat4\n\u003C/p\u003E\n\u003Cp\u003E\n#ifdef D_FADE\u003Cbr\u003E\n\u00A0 \u00A0 float \u00A0 gfFadeValue; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_FadeTime\u003Cbr\u003E\n#else\u003Cbr\u003E\n\u00A0 \u00A0 float \u00A0 fdFadeValueDummy;\u003Cbr\u003E\n#endif\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n#if defined( D_SKINNING_UNIFORMS ) \u0026amp;\u0026amp; defined( D_PLATFORM_ORBIS )\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 gaSkinMatrixRowsVec4[ 75 * 3 ]; \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 //float \u00A0 gfShadowBias; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ShadowBias\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0// \u00A0have particle shader use a particlecommon instead of uber, and put these into it.\u003Cbr\u003E\n#if defined( D_PARTICLE_UNIFORMS ) \u0026amp;\u0026amp; defined( D_PLATFORM_ORBIS )\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleCornersVec4[ 4 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ParticleCornersVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticlePositionsVec4[ 32 ]; \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticlePositionsVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleSizeAndRotationsVec4[ 32 ]; \u00A0// EShaderConst_ParticleSizeAndRotationsVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleNormalsVec4[ 32 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleNormalsVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gaParticleColoursVec4[ 32 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleColoursVec4\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 // This stuff is here atm because of shadows. The shadow shader is one thing, but renders twice, with these needing to be set differently.\u003Cbr\u003E\n\u00A0 \u00A0 // ideally we don\u0027t want them set per mesh though, probably a SRT for \u0027percamera\u0027 or something\u003Cbr\u003E\n\u00A0 \u00A0 //\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 //\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gViewProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0 \u00A0// EShaderConst_ViewProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseViewMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseViewMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gInverseViewProjectionMat4; \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_InverseViewProjectionMat4\u003Cbr\u003E\n\u00A0 \u00A0 mat4 \u00A0 \u00A0gaShadowMat4[ 3 ]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ShadowMat4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gShadowProjScaleVec4[3]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ShadowProjScaleVec4\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gLightColourVec4; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_LightColourVec4\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u00A0 \u00A0vec4\u00A0\u00A0 \u00A0gGenericParam0Vec4;\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// EShaderConst_GenericParam0Vec4\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // These shouldn\u0027t be per mesh, the should be per rendertarget. BUT we need to add them to the enum\u003Cbr\u003E\n\u00A0 \u00A0 // in egShader and SetPErRenderTargetUniforms for that to work and we\u0027re trying to do a build for sony\u003Cbr\u003E\n\u00A0 \u00A0 // so that will have to wait. (also probably need a way of setting per RT uniforms from Game).\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsPosVec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsCfg1Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsCfg2Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanParamsCfg3Vec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0 \u00A0gScanColourVec4;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0 \u00A0 \u00A0vec4 gSpotlightPositionVec4;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 gSpotlightDirectionVec4;\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n};\n\u003C/p\u003E\n\u003Cp\u003E\n#if defined( D_PARTICLE_UNIFORMS ) \u0026amp;\u0026amp; defined( D_PLATFORM_PC )\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleCornersVec4[4]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0// EShaderConst_ParticleCornersVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticlePositionsVec4[32]; \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticlePositionsVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleSizeAndRotationsVec4[32]; \u00A0// EShaderConst_ParticleSizeAndRotationsVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleNormalsVec4[32]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleNormalsVec4\u003Cbr\u003E\nuniform vec4 \u00A0 \u00A0gaParticleColoursVec4[32]; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 // EShaderConst_ParticleColoursVec4\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 CustomPerMaterialUniforms\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0 \u00A0 \u00A0CustomPerMaterialUniforms\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Stuff that is only used for these types of meshes.\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nstruct CustomPerMaterialUniforms\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 SAMPLER2D( gDiffuseMap );\u003Cbr\u003E\n};\n\u003C/p\u003E\n\u003Cp\u003E\nstruct CustomPerMeshUniforms\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec4 gColour;\u003Cbr\u003E\n};\n\u003C/p\u003E\n\u003Cp\u003E\n//\u003Cbr\u003E\n// This is the SRT buffer that everything gets uploaded to (on PS4). PC just functions as normal.\u003Cbr\u003E\n//\u003Cbr\u003E\nstruct UniformBuffer\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 //DECLARE_PTR( CommonPerMaterialUniforms, mpCommonPerMaterial ) \u00A0 \u00A0// sematics currently crash the compiler so the parser is hardcoded to look for names. \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 DECLARE_PTR( PerFrameUniforms, \u00A0 \u00A0 \u00A0 \u00A0 \u00A0mpPerFrame ) \u00A0 \u00A0// sematics currently crash the compiler so the parser is hardcoded to look for names. \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 DECLARE_PTR( CommonPerMeshUniforms, \u00A0 \u00A0 mpCommonPerMesh ) \u00A0 \u00A0 \u00A0 \u00A0// sematics currently crash the compiler so the parser is hardcoded to look for names. \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 DECLARE_PTR( CustomPerMeshUniforms, \u00A0 \u00A0 mpCustomPerMesh ) \u00A0 \u00A0 \u00A0 \u00A0// sematics currently crash the compiler so the parser is hardcoded to look for names. \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 DECLARE_PTR( CustomPerMaterialUniforms, mpCustomPerMaterial ) \u00A0 \u00A0\u00A0\u003Cbr\u003E\n};\n\u003C/p\u003E\n\u003Cp\u003E\n//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\u003Cbr\u003E\n\u00A0// D_VERTEX\u003Cbr\u003E\n\u00A0//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\u003C/p\u003E\n\u003Cp\u003E\n#if defined( D_VERTEX )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Input\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0Input\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nDECLARE_INPUT\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0INPUT( \u00A0vec4, mkLocalPositionVec4, POSITION0 )\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0INPUT( vec4, mkLocalNormalVec4, \u00A0 \u00A0 TEXCOORD0 \u00A0 \u00A0 )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0INPUT( vec4, mkCustom1Vec4,\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0TEXCOORD1 \u00A0 \u00A0 )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0INPUT( vec4, mkCustom2Vec4,\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0TEXCOORD2 \u00A0 \u00A0 )\u003Cbr\u003E\n\u00A0\u00A0 \u00A0INPUT( vec4, mkColourVec4,\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0TEXCOORD3 \u00A0 \u00A0 )\n\u003C/p\u003E\n\u003Cp\u003E\nDECLARE_END \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 Output\u003Cbr\u003E\n///\u003Cbr\u003E\n/// \u00A0 \u00A0 @brief \u00A0Output\u003Cbr\u003E\n///\u003Cbr\u003E\n//-----------------------------------------------------------------------------\u003Cbr\u003E\nDECLARE_OUTPUT\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0OUT_VERTEX_SCREEN_POSITION\u003Cbr\u003E\n\u00A0\u00A0 \u00A0OUTPUT( vec2, \u00A0mfTexCoord, TEXCOORD1 )\u003Cbr\u003E\n\u00A0 \u00A0 OUTPUT( float, mfFade, \u00A0 \u00A0 TEXCOORD2 )\u003Cbr\u003E\n\u00A0 \u00A0 OUTPUT( float, mfLogZ, \u00A0 \u00A0 TEXCOORD3 )\u003Cbr\u003E\n\u00A0 \u00A0 OUTPUT( vec4, \u00A0mColourVec4,TEXCOORD4 )\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nDECLARE_END \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nvec4\u003Cbr\u003E\nGetLinePosition(\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lScreenPositionA,\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lScreenPositionB,\u003Cbr\u003E\n\u00A0 \u00A0 vec2 lOffset )\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0 \u00A0 vec2 lineDirProj;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // \u00A0line direction in screen space (perspective division required)\u003Cbr\u003E\n\u00A0 \u00A0 lineDirProj = radius * normalize( lScreenPositionA.xy/lScreenPositionA.ww - lScreenPositionB.xy/lScreenPositionB.ww );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // small trick to avoid inversed line condition when points are not on the same side of Z plane\u003Cbr\u003E\n\u00A0 \u00A0 if( sign(lScreenPositionA.w) != sign(lScreenPositionB.w) )\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0 lineDirProj = -lineDirProj;\u003Cbr\u003E\n\u00A0 \u00A0 \u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 vMVP \u00A0 \u00A0 = lScreenPositionA;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // offset position in screen space along line direction and orthogonal direction\u003Cbr\u003E\n\u00A0 \u00A0 vMVP.xy \u002B= lineDirProj.xy\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0* lOffset.xx * vec2(1.0,invScrRatio);\u003Cbr\u003E\n\u00A0 \u00A0 vMVP.xy \u002B= lineDirProj.yx\u00A0\u00A0 \u00A0* vec2( 1.0, -1.0 )\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0* lOffset.yy * vec2(1.0,invScrRatio);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 return vMVP;\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nVERTEX_MAIN_SRT\u003Cbr\u003E\n\u00A0{ \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 OffsetUV;\u003Cbr\u003E\n\u00A0 \u00A0 vec4 laPosition[3];\u003Cbr\u003E\n\u00A0 \u00A0 vec4 laScreenPosition[3];\u003Cbr\u003E\n\u00A0 \u00A0 vec3 lTemp = vec3(0.0);\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 laPosition[0] = IN( mkLocalPositionVec4 );\u003Cbr\u003E\n\u00A0 \u00A0 laPosition[1] = IN( mkLocalNormalVec4 );\u003Cbr\u003E\n\u00A0 \u00A0 laPosition[2] = IN( mkCustom1Vec4 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 laScreenPosition[0] = CalcScreenPosFromWorld( lUniforms.mpPerFrame.gViewMat4, lUniforms.mpCommonPerMesh.gProjectionMat4, laPosition[0] );\u003Cbr\u003E\n\u00A0 \u00A0 laScreenPosition[1] = CalcScreenPosFromWorld( lUniforms.mpPerFrame.gViewMat4, lUniforms.mpCommonPerMesh.gProjectionMat4, laPosition[1] );\u003Cbr\u003E\n\u00A0 \u00A0 laScreenPosition[2] = CalcScreenPosFromWorld( lUniforms.mpPerFrame.gViewMat4, lUniforms.mpCommonPerMesh.gProjectionMat4, laPosition[2] );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 OffsetUV = IN( mkCustom2Vec4 );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // scale\u003Cbr\u003E\n\u00A0 \u00A0 //OffsetUV.y *= lUniforms.mpCommonPerMesh.gaParticleSizeAndRotationsVec4[ 0 ].x;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 vec4 lFinalScreenPosition;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 vec4 vMVP_A \u00A0= GetLinePosition( laScreenPosition[0], laScreenPosition[1], vec2( 0.0, OffsetUV.y ) );\u003Cbr\u003E\n\u00A0 \u00A0 vec4 vMVP_B \u00A0= GetLinePosition( laScreenPosition[0], laScreenPosition[2], vec2( 0.0, -OffsetUV.y ) );\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lFinalScreenPosition \u00A0 \u00A0= (vMVP_A \u002B vMVP_B) * 0.5;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 vec2 lNormal = normalize( ( (vMVP_A.xy \u002B vMVP_B.xy) * 0.5) \u00A0- laScreenPosition[0].xy \u00A0);\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 // Keep the size constant regardless of distance. (pre multiply by homogenous w as it will get divided by W by the hardware after this.\u003Cbr\u003E\n\u00A0 \u00A0 //float lfScale = ( lUniforms.mpCustomPerMaterial.gLineWidthPixels.x / lUniforms.mpPerFrame.gFrameBufferSizeVec4.y ) * lFinalScreenPosition.w;\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 float lfScale = ( abs( OffsetUV.y ) / lUniforms.mpPerFrame.gFrameBufferSizeVec4.y ) * lFinalScreenPosition.w;\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 lFinalScreenPosition.xy = (laScreenPosition[0].xy \u002B (lNormal * vec2(1.0,invScrRatio) * lfScale ));\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 OUT( mfTexCoord ) = OffsetUV.zw;\u003Cbr\u003E\n\u00A0 \u00A0 OUT(mfFade) = ARRAY_LOOKUP_FP(lUniforms.mpCommonPerMesh, gaParticleSizeAndRotationsVec4, 0).y;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 // Write the log z on the fragment shader\u003Cbr\u003E\n\u00A0 \u00A0 OUT( mfLogZ ) \u00A0 \u00A0 \u00A0 \u00A0 \u00A0= lFinalScreenPosition.z;\u003Cbr\u003E\n\u00A0 \u00A0 OUT( mColourVec4 ) \u00A0 \u00A0 = IN( mkColourVec4 );\u003Cbr\u003E\n\u00A0 \u00A0 VERTEX_SCREEN_POSITION = lFinalScreenPosition; \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0} \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\u003Cbr\u003E\n\u00A0// D_FRAGMENT\u003Cbr\u003E\n\u00A0//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\u003C/p\u003E\n\u003Cp\u003E\n#if defined( D_FRAGMENT )\n\u003C/p\u003E\n\u003Cp\u003E\nDECLARE_INPUT\u003Cbr\u003E\n\u00A0 \u00A0 IN_SCREEN_POSITION\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 INPUT( vec2, \u00A0mfTexCoord, TEXCOORD1 )\u003Cbr\u003E\n\u00A0 \u00A0 INPUT( float, mfFade, \u00A0 \u00A0 TEXCOORD2 )\u003Cbr\u003E\n\u00A0 \u00A0 INPUT( float, mfLogZ,\u00A0\u00A0 \u00A0 \u00A0TEXCOORD3 )\u003Cbr\u003E\n\u00A0 \u00A0 INPUT( vec4, \u00A0mColourVec4,TEXCOORD4 )\n\u003C/p\u003E\n\u003Cp\u003E\nDECLARE_END\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0 \u00A0 /*\u003Cbr\u003E\nstruct cOutput\u00A0\u003Cbr\u003E\n{\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 \u00A0mColour : S_TARGET_OUTPUT;\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 float mDepth \u00A0: S_DEPTH_OUTPUT;\u00A0\u003Cbr\u003E\n};\u00A0\u00A0 \u00A0\u003Cbr\u003E\n*/\u003Cbr\u003E\n//void main( PS_IN In, \u00A0out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA \u00A0)\u00A0\u003Cbr\u003E\nFRAGMENT_MAIN_COLOUR_DEPTH_SRT\u003Cbr\u003E\n{ \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\u003Cbr\u003E\n\u00A0 \u00A0 vec4 lAlbedo;\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 lAlbedo = texture2D( lUniforms.mpCustomPerMaterial.gDiffuseMap, IN( mfTexCoord ) );\u003Cbr\u003E\n\u00A0 // \u00A0lAlbedo *= In.Color;\u00A0\u003Cbr\u003E\n\u00A0 \u00A0\u00A0\u003Cbr\u003E\n\u00A0 \u00A0 FRAGMENT_COLOUR = lAlbedo * IN( mColourVec4 );//lUniforms.mpCustomPerMesh.gColour;//vec4( 1.0, 0.0, 0.0, 1.0 );//\u003Cbr\u003E\n\u00A0 \u00A0 FRAGMENT_DEPTH \u00A0= log2( IN( mfLogZ ) ) * lUniforms.mpPerFrame.gClipPlanesVec4.w;\u003Cbr\u003E\n} \u00A0 \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n#endif\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n----------------------------------------\u003Cbr\u003E\nERROR----------------------------------------\u003Cbr\u003E\nERROR: 0:1: \u0027\u0027 : \u00A0Incorrect GLSL version: 450\u003Cbr\u003E\nWARNING: 0:35: \u0027#extension\u0027 : \u00A0\u0027GL_ARB_derivative_control\u0027 is not supported\u003Cbr\u003E\nERROR: 0:1000: \u0027lCorrectColourVec3\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1000: \u0027assign\u0027 : \u00A0cannot convert from \u00273-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:1017: \u0027lCorrectColourVec3\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1017: \u0027assign\u0027 : \u00A0cannot convert from \u00273-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nWARNING: 0:1171: \u0027inverse\u0027 : function is not available in current GLSL version\u00A0\u003Cbr\u003E\nERROR: 0:1307: \u0027lTemp\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1307: \u0027CalcWorldPos\u0027 : no matching overloaded function found (using implicit conversion)\u00A0\u003Cbr\u003E\nERROR: 0:1307: \u0027=\u0027 : \u00A0cannot convert from \u0027const float\u0027 to \u00274-component vector of float\u0027\u003Cbr\u003E\nERROR: 0:1308: \u0027CalcScreenPosFromWorld\u0027 : no matching overloaded function found (using implicit conversion)\u00A0\u003Cbr\u003E\nERROR: 0:1719: \u0027lWorldPositionVec4\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1719: \u0027assign\u0027 : \u00A0cannot convert from \u0027in 4-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:1720: \u0027assign\u0027 : \u00A0cannot convert from \u00274-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:1724: \u0027assign\u0027 : \u00A0cannot convert from \u00274X4 (default)row_major matrix of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nWARNING: 0:1764: \u0027assign\u0027 : implicit type conversion allowed from GLSL 1.20\u00A0\u003Cbr\u003E\nERROR: 0:1788: \u0027lEncoded\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1788: \u0027assign\u0027 : \u00A0cannot convert from \u00272-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:1792: \u0027lEncoded\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1792: \u0027assign\u0027 : \u00A0cannot convert from \u00272-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:1795: \u0027y\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:1798: \u0027lEncoded\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1816: \u0027lNormal\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:1816: \u0027z\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:1818: \u0027z\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:1820: \u0027xy\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:1820: \u0027assign\u0027 : \u00A0cannot convert from \u00272-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:1825: \u0027y\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:1828: \u0027y\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2457: \u0027lineDirProj\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2457: \u0027assign\u0027 : \u00A0cannot convert from \u00272-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:2466: \u0027xy\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2467: \u0027yx\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2479: \u0027mkLocalPositionVec4\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2479: \u0027assign\u0027 : \u00A0cannot convert from \u0027float\u0027 to \u00274-component vector of float\u0027\u003Cbr\u003E\nERROR: 0:2480: \u0027mkLocalNormalVec4\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2480: \u0027assign\u0027 : \u00A0cannot convert from \u0027float\u0027 to \u00274-component vector of float\u0027\u003Cbr\u003E\nERROR: 0:2481: \u0027mkCustom1Vec4\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2481: \u0027assign\u0027 : \u00A0cannot convert from \u0027float\u0027 to \u00274-component vector of float\u0027\u003Cbr\u003E\nERROR: 0:2483: \u0027lUniforms\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2483: \u0027mpPerFrame\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2483: \u0027gViewMat4\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2483: \u0027mpCommonPerMesh\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2483: \u0027gProjectionMat4\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2483: \u0027CalcScreenPosFromWorld\u0027 : no matching overloaded function found (using implicit conversion)\u00A0\u003Cbr\u003E\nERROR: 0:2483: \u0027assign\u0027 : \u00A0cannot convert from \u0027const float\u0027 to \u00274-component vector of float\u0027\u003Cbr\u003E\nERROR: 0:2484: \u0027mpPerFrame\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2484: \u0027gViewMat4\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2484: \u0027mpCommonPerMesh\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2484: \u0027gProjectionMat4\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2484: \u0027CalcScreenPosFromWorld\u0027 : no matching overloaded function found (using implicit conversion)\u00A0\u003Cbr\u003E\nERROR: 0:2484: \u0027assign\u0027 : \u00A0cannot convert from \u0027const float\u0027 to \u00274-component vector of float\u0027\u003Cbr\u003E\nERROR: 0:2485: \u0027mpPerFrame\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2485: \u0027gViewMat4\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2485: \u0027mpCommonPerMesh\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2485: \u0027gProjectionMat4\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2485: \u0027CalcScreenPosFromWorld\u0027 : no matching overloaded function found (using implicit conversion)\u00A0\u003Cbr\u003E\nERROR: 0:2485: \u0027assign\u0027 : \u00A0cannot convert from \u0027const float\u0027 to \u00274-component vector of float\u0027\u003Cbr\u003E\nERROR: 0:2487: \u0027OffsetUV\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2487: \u0027mkCustom2Vec4\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2494: \u0027y\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2495: \u0027y\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2497: \u0027lFinalScreenPosition\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2497: \u0027assign\u0027 : \u00A0cannot convert from \u00274-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:2503: \u0027y\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2503: \u0027mpPerFrame\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2503: \u0027gFrameBufferSizeVec4\u0027 : illegal vector field selection\u00A0\u003Cbr\u003E\nERROR: 0:2503: \u0027y\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2503: \u0027w\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2505: \u0027xy\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2505: \u0027assign\u0027 : \u00A0cannot convert from \u00272-component vector of float\u0027 to \u0027float\u0027\u003Cbr\u003E\nERROR: 0:2507: \u0027mfTexCoord\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2507: \u0027zw\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2508: \u0027mfFade\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2511: \u0027mfLogZ\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2511: \u0027z\u0027 : vector field selection out of range\u00A0\u003Cbr\u003E\nERROR: 0:2512: \u0027mColourVec4\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2512: \u0027mkColourVec4\u0027 : undeclared identifier\u00A0\u003Cbr\u003E\nERROR: 0:2513: \u0027assign\u0027 : \u00A0cannot convert from \u0027float\u0027 to \u0027Position 4-component vector of float\u0027\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"Elthy","CreatedById":63317,"CreatedDateTime":"2016-08-13T00:24:00Z","Content":"\n\u003Cp\u003E\nThe HD 4400 only supports OpenGl 4.3, no way to upgrade that. The minimum specs on steam clearly say \u0022GTX 480/HD 7870\u0022, those are way, way better than the integrated graphics in your CPU and also support OpenGl 4.5. Your PC is simply not compatible, read the specs before you buy. Maybe you can still get a refund...\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-08-13T00:35:11Z\u0022 title=\u002208/13/2016 12:35  AM\u0022 data-short=\u00227 yr\u0022\u003EAugust 13, 2016\u003C/time\u003E by Elthy\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Souper","CreatedById":86003,"CreatedDateTime":"2016-08-13T01:43:25Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222715031\u0022 data-ipsquote-contentid=\u0022145851\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221471047840\u0022 data-ipsquote-userid=\u002263317\u0022 data-ipsquote-username=\u0022Elthy\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n1 hour ago, Elthy said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nThe HD 4400 only supports OpenGl 4.3, no way to upgrade that. The minimum specs on steam clearly say \u0022GTX 480/HD 7870\u0022, those are way, way better than the integrated graphics in your CPU and also support OpenGl 4.5. Your PC is simply not compatible, read the specs before you buy. Maybe you can still get a refund...\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nWhat if the devs make it 4.3 compatible?\n\u003C/p\u003E\n"},{"CreatedByName":"Alphasus","CreatedById":147173,"CreatedDateTime":"2016-08-13T02:27:13Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222715104\u0022 data-ipsquote-contentid=\u0022145851\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221471052605\u0022 data-ipsquote-userid=\u002286003\u0022 data-ipsquote-username=\u0022Souper\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n43 minutes ago, Souper said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nWhat if the devs make it 4.3 compatible?\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nWouldn\u0027t matter because the GPU is too slow.\n\u003C/p\u003E\n"},{"CreatedByName":"Souper","CreatedById":86003,"CreatedDateTime":"2016-08-13T03:24:54Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222715133\u0022 data-ipsquote-contentid=\u0022145851\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221471055233\u0022 data-ipsquote-userid=\u0022147173\u0022 data-ipsquote-username=\u0022Alphasus\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n54 minutes ago, Alphasus said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nWouldn\u0027t matter because the GPU is too slow.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nWell, i\u0027m used to low end systems because i\u0027m poor and can tolerate framerates as low as 5 fps so yeah i think i\u0027m good\n\u003C/p\u003E\n"},{"CreatedByName":"Alphasus","CreatedById":147173,"CreatedDateTime":"2016-08-13T03:30:59Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222715196\u0022 data-ipsquote-contentid=\u0022145851\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221471058694\u0022 data-ipsquote-userid=\u002286003\u0022 data-ipsquote-username=\u0022Souper\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n11 minutes ago, Souper said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nWell, i\u0027m used to low end systems because i\u0027m poor and can tolerate framerates as low as 5 fps so yeah i think i\u0027m good\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThat is the minimum requirements. Try to refund the game... people with i7 5960x\u0027s and dual 980ti\u0027s can\u0027t hold 60 fps. That is 40 times faster than an hd 4400 GPU wise. If Ultra is 5\u00A0times more intensive than minimum, you will get less than 7 fps\u00A0at best. A\u00A0GTX 480 is 6 times as fast as your iGPU, and its minimum. Don\u0027t expect much above 5 FPS ever, and expect to be below it.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-08-13T03:37:59Z\u0022 title=\u002208/13/2016 03:37  AM\u0022 data-short=\u00227 yr\u0022\u003EAugust 13, 2016\u003C/time\u003E by Alphasus\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Souper","CreatedById":86003,"CreatedDateTime":"2016-08-13T04:52:10Z","Content":"\n\u003Cp\u003E\nYeah, i\u0027ve refunded it. Gonna get stellaris.\n\u003C/p\u003E\n"},{"CreatedByName":"Nuke","CreatedById":10883,"CreatedDateTime":"2016-08-13T04:53:56Z","Content":"\n\u003Cp\u003E\nlooks more like a header file than a debug log.\n\u003C/p\u003E\n\u003Cp\u003E\nim surprised they just didnt use vulkan.\n\u003C/p\u003E\n"}]}