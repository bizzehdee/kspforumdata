{"TopicId":99758,"ForumId":18,"TopicTitle":"[PROGRAMMING] When Nintendo hates your robot, and the exponential nature of code.","CreatedByName":"Starwhip","CreatedById":83990,"CreatedDateTime":"2015-02-15T19:03:36Z","PageNum":1,"Articles":[{"CreatedByName":"Starwhip","CreatedById":83990,"CreatedDateTime":"2015-02-15T19:03:36Z","Content":"\n\u003Cp\u003EOur FTC team made it to the States level. Yesterday was the competition.\u003C/p\u003E\u003Cp\u003ETwice our autonomous code worked. Twice.\u003C/p\u003E\u003Cp\u003EThe other nine times the robot just skipped the first five commands, went forward, turned, and fell off of a foot-high ramp backwards.\u003C/p\u003E\u003Cp\u003EAnd it worked 100% of the time on the practice field.\u003C/p\u003E\u003Cp\u003ELater on they said that they had been detecting Nintendo 3DS wifi signals in the audience and asked everyone to turn them off. Which, of course, nobody did, because IT KEPT HAPPENING! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_angry.gif\u0022 alt=\u0022:mad:\u0022\u003E\u003C/p\u003E\u003Cp\u003EWhy is the universe so cruel as to have that one guy on our frequency? \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_sad.gif\u0022 alt=\u0022:(\u0022\u003E\u003C/p\u003E\u003Cp\u003EOn another topic:\u003C/p\u003E\u003Cp\u003EOur FRC team has three days before the end of the build season. Our code for the robot has ballooned into this monster:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E#include \u0022WPILib.h\u0022\u003Cbr\u003E#include \u0026lt;thread\u0026gt;\u003Cbr\u003E/*\u003Cbr\u003E These are pre-processing directives, the compiler will find\u003Cbr\u003E in your code all these names, and replace them with the numbers\u003Cbr\u003E listed beside them.\u003Cbr\u003E */\u003Cbr\u003E\u003Cbr\u003E#define frontLeftChannel  0         //the port for the front left drive motor\u003Cbr\u003E#define frontRightChannel 1         //the port for the front right drive motor\u003Cbr\u003E#define rearLeftChannel   2         //the port for the back left drive motor\u003Cbr\u003E#define rearRightChannel  3         //the port for the back right drive motor\u003Cbr\u003E#define mainLiftChannel   4         //the port for the main lift motor\u003Cbr\u003E#define backupLiftChannel 5\u003Cbr\u003E\u003Cbr\u003E#define joystickDriveChannel   0    //what position in the controller array is the drive controller\u003Cbr\u003E#define joystickArmChannel     1    //what position in the controller array is the lift controller\u003Cbr\u003E\u003Cbr\u003E#define joystickThreshold 0.15      //the \u0022dead\u0022 zone of the controller\u003Cbr\u003E#define joystickLimit     1.0       // % of range (1.0 = 100%, .75 = 75% etc.)\u003Cbr\u003E\u003Cbr\u003E#define encFLreverse  false;        //Reverse the Front Left Encoder\u003Cbr\u003E#define encBLreverse  false;        //Reverse the Back Left Encoder\u003Cbr\u003E#define encFRreverse  false;        //Reverse the Front Right Encoder\u003Cbr\u003E#define encBRreverse  false;        //Reverse the Back Right Encoder\u003Cbr\u003E\u003Cbr\u003E#define encoderFLchannelA 0;\u003Cbr\u003E\u003Cbr\u003E#define encodingType  Encoder::k4X\u003Cbr\u003E\u003Cbr\u003E//idk if this even works but ima try it\u003Cbr\u003E\u003Cbr\u003E#define JOYZCAPABLE false               //are you using a z-axis capable controller (in our case the Logitech Log 3D pro)\u003Cbr\u003E\u003Cbr\u003E/*____________________________________HUGE PROGRAMMING NOTE!!!_____________________________________\u003Cbr\u003E * TO DEPLOY TO THE roboRIO, YOU MUST RIGHT CLICK ON THE BUILD.XML FILE,\u003Cbr\u003E * AND SELECT \u0022RUN AS ANT BUILD\u0022.\u003Cbr\u003E * ECLIPSE NO LONGER GIVES THE OPTION TO DEPLOY AS C\u002B\u002B CODE!!!\u003Cbr\u003E */\u003Cbr\u003E\u003Cbr\u003Eclass Robot: public SampleRobot {\u003Cbr\u003E    RobotDrive robotDrive;      // robot drive system\u003Cbr\u003E    Talon liftOne;                  // the lift motor controller\u003Cbr\u003E    Talon liftTwo;\u003Cbr\u003E    Joystick driveStick;        // only joystick\u003Cbr\u003E    Joystick armStick;          //Not anymore, you stupid comment!\u003Cbr\u003E    // why are you so mean to me? -driveStick comment\u003Cbr\u003E\u003Cbr\u003E    Encoder encoderFL;          //Front Left Encoder\u003Cbr\u003E    Encoder encoderBL;          //Back Left Encoder\u003Cbr\u003E    Encoder encoderFR;          //Front Right Encoder\u003Cbr\u003E    Encoder encoderBR;          //Back Right Encoder\u003Cbr\u003E    Encoder encoderLift;        //Take a wild guess\u003Cbr\u003E\u003Cbr\u003E    AnalogInput bottomLimitSwitch; //limit switch for the bottom bar\u003Cbr\u003E    AnalogInput topLimitSwitch; //limit switch for the top bar\u003Cbr\u003E\u003Cbr\u003E    int encoderPorts[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\u003Cbr\u003E\u003Cbr\u003E    int thing =0;\u003Cbr\u003E    float driveStick_x = 0;     //the first controller x axis value\u003Cbr\u003E    float driveStick_y = 0;     //the first controller y axis value\u003Cbr\u003E    float driveStick_z = 0;     //the first controller z axis value\u003Cbr\u003E    float armStick_y = 0;       // the second controller y axis value\u003Cbr\u003E    float attackRotRate = 0.75; //This is the rotation rate when using the buttons\u003Cbr\u003E    float slider = 0;           // i have no clue what this is supposed to be\u003Cbr\u003E    float currAvgPosition;\u003Cbr\u003E    float startPosition;\u003Cbr\u003E\u003Cbr\u003E    bool throttleEnabled = true; //True means throttle is enabled, false not...\u003Cbr\u003E    bool rotationLock = true; //True means that button 2 is needed for rotation.\u003Cbr\u003E    bool defDriveMode = true; //True defaults to analog drive\u003Cbr\u003E\u003Cbr\u003Epublic:\u003Cbr\u003E    //_____________________INITIALIZATION ROUTINES__________________________\u003Cbr\u003E    Robot() :\u003Cbr\u003E        robotDrive( frontLeftChannel,\u003Cbr\u003E                    rearLeftChannel,\u003Cbr\u003E                    frontRightChannel,\u003Cbr\u003E                    rearRightChannel), // these must be initialized in the same order\u003Cbr\u003E                liftOne(mainLiftChannel),           // as they are declared above.\u003Cbr\u003E                liftTwo(backupLiftChannel),\u003Cbr\u003E                driveStick(joystickDriveChannel),\u003Cbr\u003E                armStick(joystickArmChannel),\u003Cbr\u003E                encoderFL(encoderPorts[0],encoderPorts[1], false, encodingType),\u003Cbr\u003E                encoderBL(encoderPorts[2], encoderPorts[3], false, encodingType),\u003Cbr\u003E                encoderFR(encoderPorts[4], encoderPorts[5], false, encodingType),\u003Cbr\u003E                encoderBR(encoderPorts[6], encoderPorts[7], false, encodingType),\u003Cbr\u003E                encoderLift(encoderPorts[8], encoderPorts[9], false, encodingType),\u003Cbr\u003E                bottomLimitSwitch(1),\u003Cbr\u003E                topLimitSwitch(0)\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E        robotDrive.SetExpiration(0.1);\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kFrontLeftMotor, false);// do not invert the left side motors\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kRearLeftMotor, false);\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kFrontRightMotor, true);// invert the right side motors\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kRearRightMotor, true);// you may need to change or remove this to match your robot\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E    float map(float x, float in_min, float in_max, float out_min, float out_max)//*Dalek Voice* EXPLAIIIIIIIIIIN\u003Cbr\u003E    {\u003Cbr\u003E        //_____________________FLOAT MAPPING__________________________\u003Cbr\u003E        return (x - in_min) * (out_max - out_min) / (in_max - in_min) \u002B out_min;//*Dalek Voice* EXPLAIIIIIIIIIIIIIIIIIIIIIIN\u003Cbr\u003E        //Takes in a variable, and variable range, spits out new value\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void RoboInit()\u003Cbr\u003E    {\u003Cbr\u003E        float disPerTick = 0.013004; //Inches (I\u0027s small)\u003Cbr\u003E        //not compared to the size of an electron\u003Cbr\u003E\u003Cbr\u003E        //Encoder encoderList = {encoderFL, encoderBL, encoderFR, encoderBR}; //at least we tried\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void precisionDrive() {\u003Cbr\u003E        //_______________________________PRECISION DRIVE MODE_____________________________\u003Cbr\u003E        if (driveStick.GetPOV(1)) { //Forward\u003Cbr\u003E            driveStick_x = 0;\u003Cbr\u003E            driveStick_y = 1;\u003Cbr\u003E        } else if (driveStick.GetPOV(2)) { //Right Forward\u003Cbr\u003E            driveStick_x = 1;\u003Cbr\u003E            driveStick_y = 1;\u003Cbr\u003E        } else if (driveStick.GetPOV(3)) { //Right\u003Cbr\u003E            driveStick_x = 1;\u003Cbr\u003E            driveStick_y = 0;\u003Cbr\u003E        } else if (driveStick.GetPOV(4)) { //Right Backward\u003Cbr\u003E            driveStick_x = 1;\u003Cbr\u003E            driveStick_y = -1;\u003Cbr\u003E        } else if (driveStick.GetPOV(5)) { //Backward\u003Cbr\u003E            driveStick_x = 0;\u003Cbr\u003E            driveStick_y = -1;\u003Cbr\u003E        } else if (driveStick.GetPOV(6)) { //Left Backward\u003Cbr\u003E            driveStick_x = -1;\u003Cbr\u003E            driveStick_y = -1;\u003Cbr\u003E        } else if (driveStick.GetPOV(7)) { //Left\u003Cbr\u003E            driveStick_x = -1;\u003Cbr\u003E            driveStick_y = 0;\u003Cbr\u003E        } else if (driveStick.GetPOV(8)) { //Left Forward\u003Cbr\u003E            driveStick_x = -1;\u003Cbr\u003E            driveStick_y = 1;\u003Cbr\u003E        } else {\u003Cbr\u003E            driveStick_x = 0;\u003Cbr\u003E            driveStick_y = 0;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        //CODE FOR PRECISION ROTATION\u003Cbr\u003E        // I couldn\u0027t re-do this one into a switch because of the way GetRawButton works\u003Cbr\u003E        if (driveStick.GetRawButton(3)) { //Left Rotation\u003Cbr\u003E            driveStick_z = -1;\u003Cbr\u003E        } else if (driveStick.GetRawButton(4)) { //Right Rotation\u003Cbr\u003E            driveStick_z = 1;\u003Cbr\u003E        } else { //No Rotation\u003Cbr\u003E            driveStick_z = 0;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void analogDrive() {\u003Cbr\u003E        //_____________________________________NORMAL DRIVE MODE (ANALOG)_______________________________\u003Cbr\u003E        //Get Joystick Raw Values\u003Cbr\u003E        driveStick_x = driveStick.GetX();\u003Cbr\u003E        driveStick_y = driveStick.GetY();\u003Cbr\u003E\u003Cbr\u003E        //Written to account for lack of Logitec 3DPro joystick (Z-axis rotation of joystick)\u003Cbr\u003E        //could be redone so that it takes into account any z-axis capable joystick (rename the declaration more or less)\u003Cbr\u003E        if (JOYZCAPABLE) {\u003Cbr\u003E            if (throttleEnabled) { //CUSTOM CONFIG If enabled: throttle is usable\u003Cbr\u003E                slider = map(driveStick.GetRawAxis(3), -1, 1, 1, 0);// how is the out min bigger than the out max?\u003Cbr\u003E            } else { //Locks throttle to 100%\u003Cbr\u003E                slider = 1;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            driveStick_z = driveStick.GetZ(); //map(x, in_min, in_max, out_min, out_max)\u003Cbr\u003E            if (fabs(driveStick_z) \u0026lt; joystickThreshold\u003Cbr\u003E                    || (!driveStick.GetRawButton(2) \u0026amp;\u0026amp; rotationLock)\u003Cbr\u003E                    || driveStick.GetRawButton(1)) { //why are we checking for button 1? Accidental turning?? if so then the check for 2 is redundant\u003Cbr\u003E                driveStick_z = 0;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        else { //we might want to redo all of this so that the button input is saved in a var that way we can use controllers other than ours\u003Cbr\u003E            if (driveStick.GetRawButton(4)) { //if button 4 is pressed (left?) turn (left?)\u003Cbr\u003E                driveStick_z = -attackRotRate;\u003Cbr\u003E            } else if (driveStick.GetRawButton(5)) { //if button 5 is pressed (right?) turn (right?)\u003Cbr\u003E                driveStick_z = attackRotRate;\u003Cbr\u003E            } else {\u003Cbr\u003E                driveStick_z = 0;       //you press nothing... NATHING!\u003Cbr\u003E            }\u003Cbr\u003E            slider = map(driveStick.GetRawAxis(2), -1, 1, 1, 0); //wat? i is confuzed by slider\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        //Threshold Value Setting\u003Cbr\u003E        if (fabs(driveStick_x) \u0026lt; joystickThreshold\u003Cbr\u003E                || driveStick.GetRawButton(1)) { // if the x value is inside of the \u0022dead\u0022 zone or you are holding the trigger set the x value to 0\u003Cbr\u003E            driveStick_x = 0;\u003Cbr\u003E        }\u003Cbr\u003E        if (fabs(driveStick_y) \u0026lt; joystickThreshold\u003Cbr\u003E                || driveStick.GetRawButton(1)) { // if the y value is inside of the \u0022dead\u0022 zone or you are holding the trigger se thte y value to 0\u003Cbr\u003E            driveStick_y = 0;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void joySettings() {\u003Cbr\u003E        if (driveStick.GetRawButton(7)) { //Enables analog default drive\u003Cbr\u003E            defDriveMode = true;\u003Cbr\u003E        } else if (driveStick.GetRawButton(8)) { //Enables precision drive\u003Cbr\u003E            defDriveMode = false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        if (driveStick.GetRawButton(9)) { //Enables Rotation Lock Mode\u003Cbr\u003E            rotationLock = true;\u003Cbr\u003E        } else if (driveStick.GetRawButton(10)) { //Disables rotation lock\u003Cbr\u003E            rotationLock = false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        if (driveStick.GetRawButton(11)) { //Enables throttle\u003Cbr\u003E            throttleEnabled = true;\u003Cbr\u003E        } else if (driveStick.GetRawButton(12)) { //Disables Throttle (100%)\u003Cbr\u003E            throttleEnabled = false;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void driveEncoders(float distance, float rotation)\u003Cbr\u003E    {\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void driveEncoders(float distance) {\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void logOutput() {\u003Cbr\u003E        //outputs to the smart dashboard so we can see real-time values.\u003Cbr\u003E\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Joystick X \u0022, double(driveStick_x));\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Joystick Y \u0022, double(driveStick_y));\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Joystick Z \u0022, double(driveStick_z));\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Throttle \u0022, double(slider));\u003Cbr\u003E        //SmartDashboard::PutNumber(\u0022Top Limit \u0022, double(topLimitSwitch.GetValue()));\u003Cbr\u003E        //SmartDashboard::PutNumber(\u0022Bottom Limit\u0022, double(bottomLimitSwitch-\u0026gt;Get()));\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void liftControl() {\u003Cbr\u003E        //__________________________LIFT_SECTION_OF_MAIN_LOOP______________________\u003Cbr\u003E        armStick_y = armStick.GetY();//set the arm raising thing\u003Cbr\u003E\u003Cbr\u003E        if (fabs(armStick_y) \u0026lt; joystickThreshold){// ||\u003Cbr\u003E                //(armStick_y \u0026lt; 0 \u0026amp;\u0026amp; (topLimitSwitch.GetValue()) \u0026gt; 2058) ||\u003Cbr\u003E                //(armStick_y \u0026gt; 0 \u0026amp;\u0026amp; (bottomLimitSwitch.GetValue() \u0026gt; 2058))){\u003Cbr\u003E            // if armStick_y is in the dead zone or if you reached the top limit\u003Cbr\u003E            //or if you set the bottom limit set arm movement to 0\u003Cbr\u003E            armStick_y = 0;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        liftOne.SetSpeed(armStick_y); // THEN THE CODE SAID LET THERE BE LIFT!!!! maybe..\u003Cbr\u003E        liftTwo.SetSpeed(armStick_y);// THEN THE CODE SAID LET THERE BE LIFT!!!! maybe.. AGAIN!\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void driveModeSelect() {\u003Cbr\u003E        //___________________________DRIVE_SECTION_OF_MAIN_LOOP_______________________\u003Cbr\u003E        //if you are holding the trigger use precision drive, else use regular drive\u003Cbr\u003E        // Use the joystick X axis for lateral movement, Y axis for forward movement, and Z axis for rotation.\u003Cbr\u003E        // This sample does not use field-oriented drive, so the gyro input is set to zero.\u003Cbr\u003E\u003Cbr\u003E        if (defDriveMode) { //Analog Drive is Default\u003Cbr\u003E            if (!driveStick.GetRawButton(1)) { //\u0022Button 1\u0022 is the trigger.\u003Cbr\u003E                analogDrive();//Button 2 is for Z-Rotation Lock... And think about it:\u003Cbr\u003E                // How do you hit the thumb button if you\u0027re using your thumb on the hat switch?\u003Cbr\u003E            } else {\u003Cbr\u003E                precisionDrive();\u003Cbr\u003E            }\u003Cbr\u003E        } else {\u003Cbr\u003E            if (!driveStick.GetRawButton(1)) {\u003Cbr\u003E                precisionDrive();\u003Cbr\u003E            } else {\u003Cbr\u003E                analogDrive();\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E        robotDrive.MecanumDrive_Cartesian(driveStick_x * joystickLimit * slider,\u003Cbr\u003E                driveStick_y * joystickLimit * slider,\u003Cbr\u003E                driveStick_z * joystickLimit * slider); //Actually do the moving stuff\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void OperatorControl() {\u003Cbr\u003E\u003Cbr\u003E        robotDrive.SetSafetyEnabled(false);     //no safety for you\u003Cbr\u003E\u003Cbr\u003E        while (IsOperatorControl() \u0026amp;\u0026amp; IsEnabled()) {\u003Cbr\u003E            joySettings();\u003Cbr\u003E            driveModeSelect();\u003Cbr\u003E            liftControl();\u003Cbr\u003E            logOutput();\u003Cbr\u003E            Wait(0.005); // wait 5ms to avoid hogging CPU cycles\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    /*void Autonomous()\u003Cbr\u003E             {\u003Cbr\u003E             while(IsAutonomous() \u0026amp;\u0026amp; IsEnabled())\u003Cbr\u003E             {\u003Cbr\u003E             if(AutonChoice == 1)\u003Cbr\u003E             {\u003Cbr\u003E\u003Cbr\u003E             }\u003Cbr\u003E             }\u003Cbr\u003E             }*/\u003Cbr\u003E\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003ESTART_ROBOT_CLASS(Robot); //Initializes the class so the robot actually does stuff\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ESay hi to Mecanum drive! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_tongue.gif\u0022 alt=\u0022:P\u0022\u003E\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcRZxTn5AgV7g-AI0yeeoU8CReKcMZwFL0MZrl_pC2HgMHqz78PboQ\u0022 alt=\u0022images?q=tbn:ANd9GcRZxTn5AgV7g-AI0yeeoU8CReKcMZwFL0MZrl_pC2HgMHqz78PboQ\u0022\u003E\u003C/p\u003E\u003Cp\u003EI have not a single clue as to how it expanded so fast. It was only a hundred lines a few days ago! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif\u0022 alt=\u0022:D\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"Newt","CreatedById":131025,"CreatedDateTime":"2015-02-15T19:37:34Z","Content":"\n\u003Cp\u003EOur FTC competition is in less than a week, so we are trying to finish up our autonomous and general final tweaks today. So far we are able to get preloaded balls into a goal quite reliably and I am glad (but still nervous). At our last competition, there was a robot that was placed on the ramp backwards, and in its autonomous drove itself over the edge, crashing and damaging itself, while also removing itself from that game (the team fixed it up and was able to advance anyway). \u003C/p\u003E\u003Cp\u003ESorry about the nintendo and other errors.\u003C/p\u003E\u003Cp\u003EI like some of the comments in your code \u0027EXPLAIIIIIN\u0027. Hopefully all will go well for your FRC, and without annoying nintendos:).\u003C/p\u003E\n"},{"CreatedByName":"Starwhip","CreatedById":83990,"CreatedDateTime":"2015-02-15T19:56:00Z","Content":"\n\u003Cp\u003EOur autonomous program was really nice. We drove down the ramp, put a ball in the 60 centimeter goal, rotated and put the goal in the parking zone. It worked great.\u003C/p\u003E\u003Cp\u003EAs for the comments, that\u0027s what you get when you\u0027ve got three people working on the same code. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif\u0022 alt=\u0022:D\u0022\u003E Hoping it goes well in FRC too.\u003C/p\u003E\n"},{"CreatedByName":"Newt","CreatedById":131025,"CreatedDateTime":"2015-02-16T05:33:37Z","Content":"\n\u003Cp\u003EOur autonomous can drive down, load the 30cm goal, put it in the home base, and then knock out the stick (provided no one gets in our way). Incredibly, we have also had the robot hit the wall on accident, turn too much, and drive the loaded goal up the ramp by itself (which is neat, but not so great...). \u003C/p\u003E\u003Cp\u003E The code has some silly comments, but mostly it has been made by us all working at the same time, and thus there have been less occasions where questions were needed. The greater silliness comes from long-winded names, which sometimes seem to try to explain in one sentence (without spaces) exactly what the program should do and when to use it \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E.\u003C/p\u003E\n"},{"CreatedByName":"Starwhip","CreatedById":83990,"CreatedDateTime":"2015-02-17T23:39:30Z","Content":"\n\u003Cp\u003EHoly cow:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E#include \u0022WPILib.h\u0022\u003Cbr\u003E#include \u0026lt;thread\u0026gt;\u003Cbr\u003E#include \u0026lt;tuple\u0026gt;\u003Cbr\u003E#include \u0026lt;cmath\u0026gt;\u003Cbr\u003E/*\u003Cbr\u003E These are pre-processing directives, the compiler will find\u003Cbr\u003E in your code all these names, and replace them with the numbers\u003Cbr\u003E listed beside them.\u003Cbr\u003E */\u003Cbr\u003E\u003Cbr\u003E#define frontLeftChannel  0         //the port for the front left drive motor\u003Cbr\u003E#define frontRightChannel 1         //the port for the front right drive motor\u003Cbr\u003E#define rearLeftChannel   2         //the port for the back left drive motor\u003Cbr\u003E#define rearRightChannel  3         //the port for the back right drive motor\u003Cbr\u003E#define liftChannel       4         //the port for the main lift motor\u003Cbr\u003E#define rollerOneChannel  6\u003Cbr\u003E#define rollerTwoChannel  7\u003Cbr\u003E\u003Cbr\u003E#define rightRollerSolenoidChannel   0\u003Cbr\u003E#define leftRollerSolenoidChannel    1\u003Cbr\u003E#define rightForkSolenoidChannel     2\u003Cbr\u003E#define leftForkSolenoidChannel      3\u003Cbr\u003E\u003Cbr\u003E#define joystickDriveChannel   0    //what position in the controller array is the drive controller\u003Cbr\u003E#define joystickArmChannel     1    //what position in the controller array is the lift controller\u003Cbr\u003E\u003Cbr\u003E#define joystickThreshold 0.15      //the \u0022dead\u0022 zone of the controller\u003Cbr\u003E#define joystickLimit     1.0       // % of range (1.0 = 100%, .75 = 75% etc.)\u003Cbr\u003E\u003Cbr\u003E#define encFLreverse  false;        //Reverse the Front Left Encoder\u003Cbr\u003E#define encBLreverse  false;        //Reverse the Back Left Encoder\u003Cbr\u003E#define encFRreverse  false;        //Reverse the Front Right Encoder\u003Cbr\u003E#define encBRreverse  false;        //Reverse the Back Right Encoder\u003Cbr\u003E\u003Cbr\u003E#define encoderFLchannelA 0;\u003Cbr\u003E\u003Cbr\u003E#define encodingType  Encoder::k4X\u003Cbr\u003E\u003Cbr\u003E//idk if this even works but ima try it\u003Cbr\u003E\u003Cbr\u003E#define JOYZCAPABLE false               //are you using a z-axis capable controller (in our case the Logitech Log 3D pro)\u003Cbr\u003E\u003Cbr\u003E/*____________________________________HUGE PROGRAMMING NOTE!!!_____________________________________\u003Cbr\u003E * TO DEPLOY TO THE roboRIO, YOU MUST RIGHT CLICK ON THE BUILD.XML FILE,\u003Cbr\u003E * AND SELECT \u0022RUN AS ANT BUILD\u0022.\u003Cbr\u003E * ECLIPSE NO LONGER GIVES THE OPTION TO DEPLOY AS C\u002B\u002B CODE!!!\u003Cbr\u003E */\u003Cbr\u003E\u003Cbr\u003E//Autonomous turning does not work as of now.\u003Cbr\u003E\u003Cbr\u003Eclass Robot: public SampleRobot {\u003Cbr\u003E    RobotDrive robotDrive;      // robot drive system\u003Cbr\u003E    Talon liftMotor;                  // the lift motor controller\u003Cbr\u003E    //Talon liftTwo;\u003Cbr\u003E    Talon rollerOne;\u003Cbr\u003E    Talon rollerTwo;\u003Cbr\u003E\u003Cbr\u003E    Joystick driveStick;        // only joystick\u003Cbr\u003E    Joystick armStick;          //Not anymore, you stupid comment!\u003Cbr\u003E    // why are you so mean to me? -driveStick comment\u003Cbr\u003E\u003Cbr\u003E    Encoder encoderFL;          //Front Left Encoder\u003Cbr\u003E    Encoder encoderBL;          //Back Left Encoder\u003Cbr\u003E    Encoder encoderFR;          //Front Right Encoder\u003Cbr\u003E    Encoder encoderBR;          //Back Right Encoder\u003Cbr\u003E    Encoder encoderLift;        //Take a wild guess\u003Cbr\u003E\u003Cbr\u003E    AnalogInput bottomLimitSwitch; //limit switch for the bottom bar\u003Cbr\u003E    AnalogInput topLimitSwitch; //limit switch for the top bar\u003Cbr\u003E    AnalogInput toteLimitSwitch;\u003Cbr\u003E\u003Cbr\u003E    Solenoid rightArm;\u003Cbr\u003E    Solenoid leftArm;\u003Cbr\u003E    Solenoid rightFork;\u003Cbr\u003E    Solenoid leftFork;\u003Cbr\u003E\u003Cbr\u003E    int encoderPorts[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\u003Cbr\u003E\u003Cbr\u003E    int FLdis;\u003Cbr\u003E    int FRdis;\u003Cbr\u003E    int BLdis;\u003Cbr\u003E    int BRdis;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    int Auton = 0;\u003Cbr\u003E    int AutonChoice = 1;\u003Cbr\u003E    int rollerOneMult = 1;\u003Cbr\u003E    int rollerTwoMult = -1;\u003Cbr\u003E\u003Cbr\u003E    float driveStick_x = 0;     //the first controller x axis value\u003Cbr\u003E    float driveStick_y = 0;     //the first controller y axis value\u003Cbr\u003E    float driveStick_z = 0;     //the first controller z axis value\u003Cbr\u003E    float armStick_y = 0;       // the second controller y axis value\u003Cbr\u003E    float attackRotRate = 0.75; //This is the rotation rate when using the buttons\u003Cbr\u003E    float slider = 0;           // i have no clue what this is supposed to be\u003Cbr\u003E    float currAvgPosition;\u003Cbr\u003E    float startPosition;\u003Cbr\u003E    float rollerSpeed = 1;\u003Cbr\u003E\u003Cbr\u003E    bool throttleEnabled = true; //True means throttle is enabled, false not...\u003Cbr\u003E    bool rotationLock = true; //True means that button 2 is needed for rotation.\u003Cbr\u003E    bool defDriveMode = true; //True defaults to analog drive\u003Cbr\u003E    bool topSwitchPressed = false;\u003Cbr\u003E    bool bottomSwitchPressed = false;\u003Cbr\u003E\u003Cbr\u003E    bool rollerArmsOut = false;\u003Cbr\u003E\u003Cbr\u003E    double wheelDiam = 5.98; //Inches\u003Cbr\u003E\u003Cbr\u003Epublic:\u003Cbr\u003E    //_____________________INITIALIZATION ROUTINES__________________________\u003Cbr\u003E    Robot() :\u003Cbr\u003E        robotDrive( frontLeftChannel,\u003Cbr\u003E                rearLeftChannel,\u003Cbr\u003E                frontRightChannel,\u003Cbr\u003E                rearRightChannel), // these must be initialized in the same order\u003Cbr\u003E                liftMotor(liftChannel),           // as they are declared above.\u003Cbr\u003E                //liftTwo(backupLiftChannel),\u003Cbr\u003E                rollerOne(rollerOneChannel),\u003Cbr\u003E                rollerTwo(rollerTwoChannel),\u003Cbr\u003E                driveStick(joystickDriveChannel),\u003Cbr\u003E                armStick(joystickArmChannel),\u003Cbr\u003E                encoderFL(encoderPorts[0],encoderPorts[1], false, encodingType),\u003Cbr\u003E                encoderBL(encoderPorts[2], encoderPorts[3], false, encodingType),\u003Cbr\u003E                encoderFR(encoderPorts[4], encoderPorts[5], true, encodingType),\u003Cbr\u003E                encoderBR(encoderPorts[6], encoderPorts[7], true, encodingType),\u003Cbr\u003E                encoderLift(encoderPorts[8], encoderPorts[9], false, encodingType),\u003Cbr\u003E                bottomLimitSwitch(0),\u003Cbr\u003E                topLimitSwitch(1),\u003Cbr\u003E                toteLimitSwitch(2),\u003Cbr\u003E                rightArm(rightRollerSolenoidChannel),\u003Cbr\u003E                leftArm(leftRollerSolenoidChannel),\u003Cbr\u003E                rightFork(rightForkSolenoidChannel),\u003Cbr\u003E                leftFork(leftForkSolenoidChannel)\u003Cbr\u003E\u003Cbr\u003E{\u003Cbr\u003E        robotDrive.SetExpiration(0.1);\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kFrontLeftMotor, false);// do not invert the left side motors\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kRearLeftMotor, false);\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kFrontRightMotor, true);// invert the right side motors\u003Cbr\u003E        robotDrive.SetInvertedMotor(RobotDrive::kRearRightMotor, true);// you may need to change or remove this to match your robot\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E    float map(float x, float in_min, float in_max, float out_min, float out_max)//*Dalek Voice* EXPLAIIIIIIIIIIN\u003Cbr\u003E    {\u003Cbr\u003E        //_____________________FLOAT MAPPING__________________________\u003Cbr\u003E        return (x - in_min) * (out_max - out_min) / (in_max - in_min) \u002B out_min;//*Dalek Voice* EXPLAIIIIIIIIIIIIIIIIIIIIIIN\u003Cbr\u003E        //Takes in a variable, and variable range, spits out new value\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    float degToRad(float deg){\u003Cbr\u003E        return (deg*M_PI) / 180;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    float radToDeg(float rad){\u003Cbr\u003E        return (rad*180)/M_PI;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void rollerSpin(bool in)\u003Cbr\u003E    {\u003Cbr\u003E        if(in){\u003Cbr\u003E            rollerOne.SetSpeed(rollerSpeed); //Rollers IN\u003Cbr\u003E            rollerTwo.SetSpeed(-rollerSpeed);\u003Cbr\u003E        }\u003Cbr\u003E        else{\u003Cbr\u003E            rollerOne.SetSpeed(-rollerSpeed); //Rollers OUT\u003Cbr\u003E            rollerTwo.SetSpeed(rollerSpeed);\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void rollerArms(bool extend){\u003Cbr\u003E        if(extend){\u003Cbr\u003E            leftArm.Set(true);\u003Cbr\u003E            Wait(.05);\u003Cbr\u003E            rightArm.Set(true);\u003Cbr\u003E            rollerArmsOut = true;\u003Cbr\u003E        }\u003Cbr\u003E        else{\u003Cbr\u003E            rightArm.Set(false);\u003Cbr\u003E            Wait(.05);\u003Cbr\u003E            leftArm.Set(false);\u003Cbr\u003E            rollerArmsOut = false;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void joySettings() {\u003Cbr\u003E        if (driveStick.GetRawButton(7)) { //Enables analog default drive\u003Cbr\u003E            defDriveMode = true;\u003Cbr\u003E        } else if (driveStick.GetRawButton(8)) { //Enables precision drive\u003Cbr\u003E            defDriveMode = false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        if (driveStick.GetRawButton(9)) { //Enables Rotation Lock Mode\u003Cbr\u003E            rotationLock = true;\u003Cbr\u003E        } else if (driveStick.GetRawButton(10)) { //Disables rotation lock\u003Cbr\u003E            rotationLock = false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        if (driveStick.GetRawButton(11)) { //Enables throttle\u003Cbr\u003E            throttleEnabled = true;\u003Cbr\u003E        } else if (driveStick.GetRawButton(12)) { //Disables Throttle (100%)\u003Cbr\u003E            throttleEnabled = false;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void virtualDriveStick(float l_angle,float l_rot,float l_mag,float l_throttle){\u003Cbr\u003E        //Angle 0 is rightmost, PI is rightmost\u003Cbr\u003E        slider = l_throttle; //Bad naming convention is bad... Sets throttle\u003Cbr\u003E        driveStick_x = l_mag * cos(l_angle); //X axis of \u0022joystick\u0022\u003Cbr\u003E        driveStick_y = l_mag * sin(l_angle); //Y axis of \u0022joystick\u0022\u003Cbr\u003E        driveStick_z = l_rot;                //Rotation Zed Axis\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void killMotors(){\u003Cbr\u003E        virtualDriveStick(0,0,0,0); //No drive or rotation of \u0022joystick\u0022\u003Cbr\u003E        drive();\u003Cbr\u003E        liftControl(0);\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    float getAvgEncoder(Encoder enc1, Encoder enc2, Encoder enc3, Encoder enc4){\u003Cbr\u003E        //Average encoder value. So far unused.\u003Cbr\u003E        //and that makes me sad.\u003Cbr\u003E        return (enc1.GetDistance()\u002Benc2.GetDistance()\u002Benc3.GetDistance()\u002Benc4.GetDistance())/4;\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    std::tuple\u0026lt;double,double\u0026gt; getRobotDis(){\u003Cbr\u003E        //Gets your x and y components of translation\u003Cbr\u003E        double enc1Dis = encoderFL.GetDistance(); //FL\u003Cbr\u003E        double enc2Dis = encoderBL.GetDistance(); //BL\u003Cbr\u003E        double enc3Dis = encoderFR.GetDistance(); //FR\u003Cbr\u003E        double enc4Dis = encoderBR.GetDistance(); //BR\u003Cbr\u003E\u003Cbr\u003E        if(!encoderFL.GetDirection()){ //Lots of complicated stuff to get direction of encoders.\u003Cbr\u003E            enc1Dis *= -1;             //Encoder.GetDirection() returns true or false, false is default and \u0022backwards\u0022.\u003Cbr\u003E        }\u003Cbr\u003E        if(!encoderBL.GetDirection()){\u003Cbr\u003E            enc2Dis *= -1;\u003Cbr\u003E        }\u003Cbr\u003E        if(!encoderFR.GetDirection()){\u003Cbr\u003E            enc3Dis *= -1;\u003Cbr\u003E        }\u003Cbr\u003E        if(!encoderBR.GetDirection()){\u003Cbr\u003E            enc4Dis *= -1;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        double robotVector_x = (-(enc1Dis\u002Benc2Dis)\u002Benc3Dis\u002Benc4Dis)*cos(M_PI/4); //YAY, summations\u003Cbr\u003E        double robotVector_y = (-(enc2Dis\u002Benc4Dis)\u002Benc3Dis\u002Benc1Dis)*sin(M_PI/4);\u003Cbr\u003E\u003Cbr\u003E        return std::make_tuple(robotVector_x,robotVector_y); //WPI lib says hi. C\u002B\u002B doesn\u0027t support tuples by default\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void RoboInit()\u003Cbr\u003E    {\u003Cbr\u003E        double wheelCirc = wheelDiam * M_PI;\u003Cbr\u003E        double disPerTick = wheelCirc / 1440; //Inches (I\u0027s small)\u003Cbr\u003E        //not compared to the size of an electron\u003Cbr\u003E        //Encoder encoderList = {encoderFL, encoderBL, encoderFR, encoderBR}; //at least we tried\u003Cbr\u003E\u003Cbr\u003E        encoderFL.SetDistancePerPulse(disPerTick); //So that encoders return inches\u003Cbr\u003E        encoderBL.SetDistancePerPulse(disPerTick);\u003Cbr\u003E        encoderFR.SetDistancePerPulse(disPerTick);\u003Cbr\u003E        encoderBR.SetDistancePerPulse(disPerTick);\u003Cbr\u003E        //close solenoids\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void precisionControl() {\u003Cbr\u003E        //_______________________________PRECISION DRIVE MODE_____________________________\u003Cbr\u003E        int povAngle = driveStick.GetPOV(0);\u003Cbr\u003E        if(povAngle == -1){\u003Cbr\u003E            killMotors();\u003Cbr\u003E        }\u003Cbr\u003E        if (driveStick.GetRawButton(3)) { //Left Rotation\u003Cbr\u003E            driveStick_z = -1;\u003Cbr\u003E        } else if (driveStick.GetRawButton(4)) { //Right Rotation\u003Cbr\u003E            driveStick_z = 1;\u003Cbr\u003E        } else { //No Rotation\u003Cbr\u003E            driveStick_z = 0;\u003Cbr\u003E        }\u003Cbr\u003E        virtualDriveStick(degToRad(povAngle),driveStick_z,1,1);\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void analogControl() {\u003Cbr\u003E        //_____________________________________NORMAL DRIVE MODE (ANALOG)_______________________________\u003Cbr\u003E        //Get Joystick Raw Values\u003Cbr\u003E        driveStick_x = driveStick.GetX();\u003Cbr\u003E        driveStick_y = driveStick.GetY();\u003Cbr\u003E\u003Cbr\u003E        //Written to account for lack of Logitec 3DPro joystick (Z-axis rotation of joystick)\u003Cbr\u003E        //could be redone so that it takes into account any z-axis capable joystick (rename the declaration more or less)\u003Cbr\u003E        if (JOYZCAPABLE) {\u003Cbr\u003E            if (throttleEnabled) { //CUSTOM CONFIG If enabled: throttle is usable\u003Cbr\u003E                slider = map(driveStick.GetRawAxis(3), -1, 1, 1, 0);// how is the out min bigger than the out max?\u003Cbr\u003E            } else { //Locks throttle to 100%\u003Cbr\u003E                slider = 1;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            driveStick_z = driveStick.GetZ(); //map(x, in_min, in_max, out_min, out_max)\u003Cbr\u003E            if (fabs(driveStick_z) \u0026lt; joystickThreshold\u003Cbr\u003E                    || (!driveStick.GetRawButton(2) \u0026amp;\u0026amp; rotationLock)\u003Cbr\u003E                    || driveStick.GetRawButton(1)) { //why are we checking for button 1? Accidental turning?? if so then the check for 2 is redundant\u003Cbr\u003E                driveStick_z = 0;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        else { //we might want to redo all of this so that the button input is saved in a var that way we can use controllers other than ours\u003Cbr\u003E            if (driveStick.GetRawButton(4)) { //if button 4 is pressed (left?) turn (left?)\u003Cbr\u003E                driveStick_z = -attackRotRate;\u003Cbr\u003E            } else if (driveStick.GetRawButton(5)) { //if button 5 is pressed (right?) turn (right?)\u003Cbr\u003E                driveStick_z = attackRotRate;\u003Cbr\u003E            } else {\u003Cbr\u003E                driveStick_z = 0;       //you press nothing... NATHING!\u003Cbr\u003E            }\u003Cbr\u003E            slider = map(driveStick.GetRawAxis(2), -1, 1, 1, 0); //wat? i is confuzed by slider\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        //Threshold Value Setting\u003Cbr\u003E        if (fabs(driveStick_x) \u0026lt; joystickThreshold\u003Cbr\u003E                || driveStick.GetRawButton(1)) { // if the x value is inside of the \u0022dead\u0022 zone or you are holding the trigger set the x value to 0\u003Cbr\u003E            driveStick_x = 0;\u003Cbr\u003E        }\u003Cbr\u003E        if (fabs(driveStick_y) \u0026lt; joystickThreshold\u003Cbr\u003E                || driveStick.GetRawButton(1)) { // if the y value is inside of the \u0022dead\u0022 zone or you are holding the trigger set the y value to 0\u003Cbr\u003E            driveStick_y = 0;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void liftControl(float yAxis) {\u003Cbr\u003E        //__________________________LIFT_SECTION_OF_MAIN_LOOP______________________\u003Cbr\u003E\u003Cbr\u003E        topSwitchPressed = (topLimitSwitch.GetValue() \u0026lt; 2048) ? false : true;\u003Cbr\u003E        bottomSwitchPressed = (bottomLimitSwitch.GetValue() \u0026lt; 2048) ? false : true;\u003Cbr\u003E\u003Cbr\u003E        if((topSwitchPressed \u0026amp;\u0026amp; yAxis \u0026gt;= 0) ||\u003Cbr\u003E                (fabs(yAxis) \u0026lt;= joystickThreshold) ||\u003Cbr\u003E                (bottomSwitchPressed \u0026amp;\u0026amp; yAxis \u0026lt;= 0)){\u003Cbr\u003E\u003Cbr\u003E            liftMotor.SetSpeed(0);\u003Cbr\u003E        }\u003Cbr\u003E        else{\u003Cbr\u003E            liftMotor.SetSpeed(yAxis);\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void liftArm(float speed, float time){\u003Cbr\u003E        liftControl(speed);\u003Cbr\u003E        Wait(time);\u003Cbr\u003E        killMotors();\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void rollerArmSolenoidControl(){\u003Cbr\u003E        if (armStick.GetRawButton(7) \u0026amp;\u0026amp; toteLimitSwitch.GetValue() \u0026lt; 2048){ //Retract Roller Arms!\u003Cbr\u003E            rollerArms(false);\u003Cbr\u003E        }\u003Cbr\u003E        else if (armStick.GetRawButton(6)){ //Extend Roller Arms!\u003Cbr\u003E            rollerArms(true);\u003Cbr\u003E        }\u003Cbr\u003E        if (armStick.GetRawButton(1) \u0026amp;\u0026amp; rollerArmsOut){ //Trigger: Used to suck in totes\u003Cbr\u003E            rollerSpin(true);\u003Cbr\u003E        }\u003Cbr\u003E        else if (armStick.GetRawButton(3) \u0026amp;\u0026amp; rollerArmsOut){ //Middlemost button of joystick. Spits out totes\u003Cbr\u003E            rollerSpin(false);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void forkArms(bool extend){\u003Cbr\u003E        if(extend){\u003Cbr\u003E            rightFork.Set(true);\u003Cbr\u003E            leftFork.Set(true);\u003Cbr\u003E        }\u003Cbr\u003E        else{\u003Cbr\u003E            rightFork.Set(false);\u003Cbr\u003E            leftFork.Set(false);\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void forkArmSolenoidControl(){\u003Cbr\u003E        if(armStick.GetRawButton(11)){\u003Cbr\u003E            forkArms(true);\u003Cbr\u003E        }\u003Cbr\u003E        else if(armStick.GetRawButton(10)){\u003Cbr\u003E            forkArms(false);\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void logOutput() {\u003Cbr\u003E        //outputs to the smart dashboard so we can see real-time values.\u003Cbr\u003E\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Joystick X \u0022, double(driveStick_x));\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Joystick Y \u0022, double(driveStick_y));\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Joystick Z \u0022, double(driveStick_z));\u003Cbr\u003E        SmartDashboard::PutNumber(\u0022Throttle \u0022, double(slider));\u003Cbr\u003E        //SmartDashboard::PutNumber(\u0022Top Limit \u0022, double(topLimitSwitch.GetValue()));\u003Cbr\u003E        //SmartDashboard::PutNumber(\u0022Bottom Limit\u0022, double(bottomLimitSwitch-\u0026gt;Get()));\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void drive(){\u003Cbr\u003E        //Instead of copy-pasting below\u003Cbr\u003E        robotDrive.MecanumDrive_Cartesian(driveStick_x * joystickLimit * slider,\u003Cbr\u003E                driveStick_y * joystickLimit * slider,\u003Cbr\u003E                driveStick_z * joystickLimit * slider); //Actually do the moving stuff\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void driveAuto(float dis,float angle,float speed,float rot){\u003Cbr\u003E        //Autopilot drive system. Takes a distance at angle from front of robot, a speed, and a rotation value\u003Cbr\u003E        virtualDriveStick(angle,rot,speed,1); //Throttle is 1 by convention. Speed controls speed.\u003Cbr\u003E\u003Cbr\u003E        float dis_x = dis*cos(degToRad(angle)); //Distance to move (X-axis)\u003Cbr\u003E        float dis_y = dis*sin(degToRad(angle)); //Other distance (Y-axis)\u003Cbr\u003E\u003Cbr\u003E        double vec_x; //Encoder value X\u003Cbr\u003E        double vec_y; //Encoder value Y\u003Cbr\u003E\u003Cbr\u003E        drive(); //ENGAGE MOTORS!\u003Cbr\u003E\u003Cbr\u003E        while(vec_x \u0026gt;= dis_x || vec_y \u0026gt;= dis_y){ //If it\u0027s gone too far...\u003Cbr\u003E            std::tie(vec_x,vec_y) = getRobotDis(); //Update distance\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        killMotors(); //NO JOYSTICK FOR JU\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void driveModeSelect() {\u003Cbr\u003E        //___________________________DRIVE_SECTION_OF_MAIN_LOOP_______________________\u003Cbr\u003E        //if you are holding the trigger use precision drive, else use regular drive\u003Cbr\u003E        // Use the joystick X axis for lateral movement, Y axis for forward movement, and Z axis for rotation.\u003Cbr\u003E        // This sample does not use field-oriented drive, so the gyro input is set to zero.\u003Cbr\u003E\u003Cbr\u003E        if (defDriveMode) { //Analog Drive is Default\u003Cbr\u003E            if (!driveStick.GetRawButton(1)) { //\u0022Button 1\u0022 is the trigger.\u003Cbr\u003E                analogControl();//Button 2 is for Z-Rotation Lock... And think about it:\u003Cbr\u003E                // How do you hit the thumb button if you\u0027re using your thumb on the hat switch?\u003Cbr\u003E            } else {\u003Cbr\u003E                precisionControl();\u003Cbr\u003E            }\u003Cbr\u003E        } else {\u003Cbr\u003E            if (!driveStick.GetRawButton(1)) {\u003Cbr\u003E                precisionControl();\u003Cbr\u003E            } else {\u003Cbr\u003E                analogControl();\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E        drive();\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void OperatorControl() {\u003Cbr\u003E\u003Cbr\u003E        robotDrive.SetSafetyEnabled(false);     //no safety for you\u003Cbr\u003E\u003Cbr\u003E        while (IsOperatorControl() \u0026amp;\u0026amp; IsEnabled()) {\u003Cbr\u003E            joySettings();\u003Cbr\u003E            driveModeSelect();\u003Cbr\u003E            liftControl(armStick.GetY());\u003Cbr\u003E            rollerArmSolenoidControl();\u003Cbr\u003E            forkArmSolenoidControl();\u003Cbr\u003E\u003Cbr\u003E            logOutput();\u003Cbr\u003E            Wait(0.005); // wait 5ms to avoid hogging CPU cycles\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void Autonomous()\u003Cbr\u003E    {\u003Cbr\u003E        while(IsAutonomous() \u0026amp;\u0026amp; IsEnabled())\u003Cbr\u003E        {\u003Cbr\u003E            if(Auton != 1 \u0026amp;\u0026amp; Auton != 2 \u0026amp;\u0026amp; Auton != 3 \u0026amp;\u0026amp; Auton != 4){\u003Cbr\u003E                Auton = 1;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            switch (Auton){\u003Cbr\u003E            case 1:\u003Cbr\u003E                driveAuto(140,90,0.75,0); //Go to auto zone\u003Cbr\u003E                break;\u003Cbr\u003E            case 2:\u003Cbr\u003E                liftArm(0.75,0.5); //Lift up tote\u003Cbr\u003E                driveAuto(0,0,0.75,90); //Rotate 90 degrees\u003Cbr\u003E                Wait(0.1);\u003Cbr\u003E                driveAuto(140,90,0.75,0); //Go to auto zone\u003Cbr\u003E                break;\u003Cbr\u003E            case 3:\u003Cbr\u003E                forkArms(true); //Extend fork\u003Cbr\u003E                Wait(0.5);\u003Cbr\u003E                liftArm(0.75,0.5); //Lift tote\u003Cbr\u003E                driveAuto(0,0,0.75,-90); //Rotate left 90\u003Cbr\u003E                Wait(0.1);\u003Cbr\u003E                driveAuto(140,90,0.75,0); //Go to auto zone\u003Cbr\u003E                break;\u003Cbr\u003E\u003Cbr\u003E            case 4:\u003Cbr\u003E                forkArms(true); //Extend fork\u003Cbr\u003E                Wait(0.5);\u003Cbr\u003E                liftArm(0.75,1.5); //Raise arm and pick up trash can\u003Cbr\u003E                driveAuto(24,90,0.75,0); //Drive forward 2 feet to tote\u003Cbr\u003E                Wait(0.1);\u003Cbr\u003E                liftArm(-0.75,1.0); //Lower arm, drop trash can on tote\u003Cbr\u003E                forkArms(false); //Retract fork\u003Cbr\u003E                Wait(0.5);\u003Cbr\u003E                driveAuto(8,90,0.75,0); //Drive forward 8 inches\u003Cbr\u003E                Wait(0.1);\u003Cbr\u003E                liftArm(-0.75,1.5); //Lower arm under tote\u003Cbr\u003E                liftArm(0.75,1.5); //Raise arm, pick up both\u003Cbr\u003E                driveAuto(0,0,0.75,-90); //Rotate 90 left\u003Cbr\u003E                Wait(0.1);\u003Cbr\u003E                driveAuto(140,90,0.75,0); //Go to parking zone\u003Cbr\u003E                break;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E};\u003Cbr\u003E\u003Cbr\u003ESTART_ROBOT_CLASS(Robot); //Initializes the class so the robot actually does stuff\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EFive Hundred and Twelve lines of code. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_shocked.gif\u0022 alt=\u0022:0.0:\u0022\u003E\u003C/p\u003E\u003Cp\u003EAnd all of it yet untested!\u003C/p\u003E\u003Cp\u003EGO BUILD TEAM! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_angry.gif\u0022 alt=\u0022:mad:\u0022\u003E\u003C/p\u003E\u003Cp\u003ESeriously, the programming team never gets a chance to test anything... competition should be interesting. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E\u003C/p\u003E\u003Cp\u003EIt should now be able to to whatever the heck we want it to: just a couple lines and you\u0027ve got another autonomous program!\u003C/p\u003E\n"}]}