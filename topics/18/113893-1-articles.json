{"TopicId":113893,"ForumId":18,"TopicTitle":"PSA: When people say stuff about \u0022memory leaks\u0022, this is what it means.","CreatedByName":"kenbobo","CreatedById":70629,"CreatedDateTime":"2015-06-23T19:10:00Z","PageNum":1,"Articles":[{"CreatedByName":"kenbobo","CreatedById":70629,"CreatedDateTime":"2015-06-23T19:10:00Z","Content":"\u003Ciframe width=\u0022480\u0022 height=\u0022270\u0022 src=\u0022https://www.youtube.com/embed/67m5jwoNkfo?feature=oembed\u0022 frameborder=\u00220\u0022 allowfullscreen=\u0022true\u0022\u003E\u003C/iframe\u003E"},{"CreatedByName":"Fel","CreatedById":57121,"CreatedDateTime":"2015-06-23T19:58:22Z","Content":"I\u0027m not fond of youtube.\n\nBut C# is one huge memory leak as it is; letting a subsystem manage your memory in a complex application causes problems as you, the programmer, are smarter than any subsystem. C# will only deallocate memory when all references to an object have been removed. If you have a \u0022C# Pointer\u0022 hanging around somewhere (C#, by necessity, does have pointers; in fact everything except base types should be pointers now) the object will remain in memory forever.\n\nNow let\u0027s talk about cross-referencing, which two classes refer to each other. You try to \u0022delete\u0022 both classes by setting their pointers to null, but they cross-reference, and what is more have references to objects still in play. These type of classes, like singletons (self-referencing), can easily be by designer choice; and if the objects include a static member you can still manipulate them later on. It can get even messier if there are further objects in these classes which make a large self-referencing chain of headache. Makes you wish for simple automagical deletion and fixing the crashes with a strong IDE.\n\nSo say it with me! C# Bad, Garbage Collection Memory Management Bad, Assembly Good!\n\n**Edited \u003Ctime datetime=\u00222015-06-23T20:04:33Z\u0022 title=\u002206/23/2015 08:04  PM\u0022 data-short=\u00229 yr\u0022\u003EJune 23, 2015\u003C/time\u003E by Fel**"},{"CreatedByName":"Beowolf","CreatedById":48927,"CreatedDateTime":"2015-06-23T20:10:04Z","Content":"Wait a minute. Did I read that wrong or is Fel praising assembler coding for it\u0027s garbage collection and memory management?"},{"CreatedByName":"Kerbart","CreatedById":78303,"CreatedDateTime":"2015-06-23T20:10:07Z","Content":"\u003E \n\u003E I\u0027m not fond of youtube.\n\u003E But C# is one huge memory leak as it is; letting a subsystem manage your memory in a complex application causes problems as you, the programmer, are smarter than any subsystem. C# will only deallocate memory when all references to an object have been removed. If you have a \u0022C# Pointer\u0022 hanging around somewhere (C#, by necessity, does have pointers; in fact everything except base types should be pointers now) the object will remain in memory forever.\n\u003E \n\u003E Now let\u0027s talk about cross-referencing, which two classes refer to each other. You try to \u0022delete\u0022 both classes by setting their pointers to null, but they cross-reference, and what is more have references to objects still in play. These type of classes, like singletons (self-referencing), can easily be by designer choice; and if the objects include a static member you can still manipulate them later on.\n\u003E \n\u003E So say it with me! C# Bad, Garbage Collection Memory Management Bad, Assembly Good!\n\nClasses are not objects. Maybe stick to PERL. You can do a lot of damage in Assembly if you\u0027re sloppy."},{"CreatedByName":"Fel","CreatedById":57121,"CreatedDateTime":"2015-06-23T20:36:10Z","Content":"\u003E \n\u003E Classes are not objects. Maybe stick to PERL. You can do a lot of damage in Assembly if you\u0027re sloppy.\n\nSemantics.\n\n\u003E \n\u003E Wait a minute. Did I read that wrong or is Fel praising assembler coding for it\u0027s garbage collection and memory management?\n\nIt\u0027s a joke, I\u0027m shaming C# because it is a \u0022modern language.\u0022 People expect GC and self-managing memory, despite the problems that arise from the use of those. Even with C\u002B\u002B people are going to be passing more off to the GC than doing themselves, even if doing it themselves can create routes of optimization that leads to better performance.\n\nBasically, the only way to escape the problems of modern programming is to escape modern programming all together.\n\n**Edited \u003Ctime datetime=\u00222015-06-23T20:59:27Z\u0022 title=\u002206/23/2015 08:59  PM\u0022 data-short=\u00229 yr\u0022\u003EJune 23, 2015\u003C/time\u003E by Fel**"},{"CreatedByName":"LordFerret","CreatedById":111598,"CreatedDateTime":"2015-06-23T21:00:59Z","Content":"Classes are not objects? Well, yes. But, as **Fel** points out, they can be.\n\n[http://stackoverflow.com/questions/1425093/can-a-class-return-an-object-of-itself](http://stackoverflow.com/questions/1425093/can-a-class-return-an-object-of-itself)\n\nYes, you can do a lot of damage in Assembly if you\u0027re sloppy. Then again, you can equally do a lot of damage in C as well, as has happened time and time again ... likely with greater frequency considering the ever grown popularity of C languages.\n\n[Use and Abuse of Garbage Collected Languages](http://prog21.dadgum.com/134.html)\n\nThere\u0027s an old saying: If you want it done right, do it yourself."}]}