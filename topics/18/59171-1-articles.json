{"TopicId":59171,"ForumId":18,"TopicTitle":"The Optimisation Tip Swap Thread","CreatedByName":"technicalfool","CreatedById":70430,"CreatedDateTime":"2014-01-07T11:54:42Z","PageNum":1,"Articles":[{"CreatedByName":"technicalfool","CreatedById":70430,"CreatedDateTime":"2014-01-07T11:54:42Z","Content":"\n\u003Cp\u003EJust a little thread for amateurs and pros alike to swap hints and tips on how they make their projects go faster!\u003C/p\u003E\u003Cp\u003ENow, I\u0027m expecting that the Squad devs probably know every single one of these tricks. This thread will likely never result in an improvement in KSP\u0027s execution speed. However, this is for the people on the forums who are starting to learn to code, and might be wondering why the little demo they\u0027ve made is running like treacle in Winter. Thing is, there are a number of things you can do to improve the speed at which a computer can crunch numbers. Quite a lot of them are somewhat \u0022cheaty\u0022, but in the end, whether cheaty or not, it\u0027s the end result that matters!\u003C/p\u003E\u003Cp\u003EAnd hey, if someone replies and puts in their own tricks that Squad haven\u0027t heard of, then that\u0027s just awesome all round.\u003C/p\u003E\u003Cp\u003EAnd so I kick off with a couple of simple algorithm optimisations that anybody who\u0027s studied this stuff for a few years probably already knows. However, for the newbies, it could just save them some lost hair and fingernails.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Cspan style=\u0022font-size:12px;\u0022\u003EOptimisation 1: Precalculating Sine Tables\u003C/span\u003E\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003ESo you\u0027re making a computer game. There\u0027s a lot of occasions where you might need to rotate something, or work with angles. In this case, you\u0027ll be doing a lot of playing around with the sine and cosine functions of your chosen programming language. Thing is, calculating a sine or cosine is an expensive operation. You don\u0027t want to be doing it a lot, and yet you might just need to do it a lot when you\u0027ve got a boatload of stuff moving around in your game world. The answer to this? Well, you can swap memory for speed. See, you usually get, for instance, the sine value of an angle by punching in something like the following:\u003C/p\u003E\u003Cp\u003E\u003Cem\u003Evalue = sin(angle_in_radians)\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EAll well and good. That\u0027ll get you the sine of any angle, however tiny, right down to the limits of your system\u0027s accuracy. However, in many cases, you don\u0027t need to be that accurate. You can get away with the sine value only being accurate to say, 1/10\u003Csub\u003Eth\u003C/sub\u003E or 1/100\u003Csub\u003Eth\u003C/sub\u003E of a degree (or some fraction of a radian). In this case, try creating an array, and before the main part of your game or demo, you fill that array up with all the values from running sin(angle) from 0 to 360, going up in steps of 0.1, or 0.01, or however accurate you need to be. One big FOR loop, basically.\u003C/p\u003E\u003Cp\u003ELater on in your project, when you need to calculate a sine value, rather than calling sin(value), you can convert the radians (or even better, degrees) value with a multiplication operation, and then look up the value in the array, with something like \u003Cem\u003Evalue = sine_array[angle]\u003C/em\u003E. Creating a function to do the lookup for you makes it even easier, so you can call \u003Cem\u003Evalue = sineFunc(radians)\u003C/em\u003E, without having to write out the conversion steps for the angle each time.\u003C/p\u003E\u003Cp\u003EAs the cosine value for a given angle is basically the same as the sine value but 90 degrees out of phase, if you\u0027re clever, you can even use the same sine table to calculate cosines with. This saves a little bit of RAM. In the end, rather than having to run many sine or cosine operations, instead you\u0027re performing many lookups on an array, which in many programming languages, is a vastly quicker operation.\u003C/p\u003E\u003Cp\u003EThis approach can save a lot of time on any expensive operation. If you\u0027re working strictly with integers (whole numbers with no decimal point) for example, you could even precalculate square-root values. Why? Well, read on...\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Cspan style=\u0022font-size:12px;\u0022\u003EOptimisation 2: Working in the Square Domain\u003C/span\u003E\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EThe what, I hear some people say?\u003C/p\u003E\u003Cp\u003EOkay, there are many occasions when you need to calculate the distance between two points. The classic method for doing this is the \u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EPythagorean equation\u003C/a\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003E. You know the bit about \u0022the length of the hypotenuse is equal to the sum of the square of the other two sides\u0022 thing? Yeah, I wasn\u0027t paying attention in that lesson at school either. But, as a refresher, here\u0027s how you would normally do it:\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003ELet\u0027s say you have two coordinates, [x1,y1] and [x2,y2]. You want to know how far apart they are. So, you do this:\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003Ed1 = x1 - x2\u003C/a\u003E\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003Ed2 = y1 - y2\u003C/a\u003E\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EThis has now created an imaginary right angled triangle, which you can use to run the Pythagorean equation against.\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003Edistance = sqrt((d1 * d1) \u002B (d2 * d2))\u003C/a\u003E\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EAnd herein lies the problem. That square root function. It\u0027s hugely expensive, more so than sine and cosine operations. In fact, a square root calculation is one of the most expensive operations you can ask a computer to perform. It takes quite an obscenely long amount of time to complete. And yet, sometimes you don\u0027t need to know the exact distance. Sometimes, you only need to know if distance A is greater or lesser than distance B. The answer?\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EEasy. Just skip the square root.\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EdistanceA = (d1 * d1) \u002B (d2 * d2)\u003C/a\u003E\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EAnd then some time later...\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EdistanceB = (d1 * d1) \u002B (d2 * d2)\u003C/a\u003E\u003C/em\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003ENow you have two values, distanceA and distanceB, which, while they do not represent an exact distance value, can still tell you whether distanceA is greater or lesser than distanceB. While doing so, you\u0027ve just saved on a square root operation. Well, go you! Give yourself a pat on the back.\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EConsidering that converting a number to the square domain (by multiplying it by itself) is vastly cheaper than getting the square root of a number that\u0027s already in the square domain, you can use this approach in many parts of a program where you already have a distance value and want to compare it with a calculated distance. Take the distance you want to compare with, square it (multiply it by itself, or raise it by the power 2 if you like), then compare it against the value obtained by running \u003C/a\u003E\u003Cem\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003E(d1 * d1) \u002B (d2 * d2)\u003C/a\u003E\u003C/em\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003E, without the square root operation.\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003EJust these two tricks alone could save a newbie coder a lot of headaches when it comes to making their program run faster. There\u0027s a lot of tricks out there and I\u0027ve only scratched the surface with these two examples. If anybody out there has their own little tricks that they\u0027d like to share, this is the thread to do it in!\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://www.mathsisfun.com/pythagoras.html\u0022\u003E(And please tell me if I\u0027m just posting unreadable gobbledegook, I\u0027ve only just had my first coffee!)\u003C/a\u003E\u003C/p\u003E\n"}]}