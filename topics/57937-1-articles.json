{"TopicId":57937,"ForumId":29,"TopicTitle":"Determine collision at point","CreatedByName":"EvilKot","CreatedById":72193,"CreatedDateTime":"2013-12-27T20:32:39Z","PageNum":1,"Articles":[{"CreatedByName":"EvilKot","CreatedById":72193,"CreatedDateTime":"2013-12-27T20:32:39Z","Content":"\n\u003Cp\u003EHello. I\u0027m developing a warp drive mod (thousands of them! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E)\u003C/p\u003E\u003Cp\u003EThe general idea based on teleporting vessel very very very fast (once per frame) using vessel.SetPosition(Vector3d position) method which makes illusion that ship is really flying whenever you need.\u003C/p\u003E\u003Cp\u003EEverything works great expect of \u0022through planet warp\u0022 and i asking you for help. I have serious language(english) problems and i suck at explaining things (Just wanna say sorry).\u003C/p\u003E\u003Cp\u003EAs i said i\u0027m teleporting vessel every frame in target direction:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EjumpToPos = vessel.transform.position \u002B (TS.TargetVector * destination); //jumpToPos, TargetVector are Vector3d variables, destination is increases and decreases.\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ethen:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Evessel.SetPosition(jumpToPos);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ebut if new vessel position will be under surface vessel will explode (ORLY? \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E ) \u003C/p\u003E\u003Cp\u003Eso i have to check jumpToPos before jumping on it.\u003C/p\u003E\u003Cp\u003Ei can simple determine collision:\u003C/p\u003E\u003Cp\u003E(x-a)^2 \u002B (y-\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_cool.png\u0022 alt=\u0022B)\u0022\u003E^2 \u002B (z-c)^2 Mustn\u0027t be less or equals to R^2,\u003C/p\u003E\u003Cp\u003Ewhere a, b, c, R - planet position and radius\u003C/p\u003E\u003Cp\u003Eand x, y, z are jumpToPos values.\u003C/p\u003E\u003Cp\u003Eor:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E(Math.Pow((jumpToPos.x - vessel.mainBody.transform.position.x), 2) \u002B Math.Pow((jumpToPos.y - vessel.mainBody.transform.position.y), 2) \u002B Math.Pow((jumpToPos.z - vessel.mainBody.transform.position.z), 2)) \u0026lt;= Math.Pow(vessel.mainBody.Radius, 2)\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ESo if this condition returns true i shouldn\u0027t jump because of explosion.\u003C/p\u003E\u003Cp\u003EBut this thing work only if planet is a perfect sphere without mountains, hils and etc (nothing above sea level)\u003C/p\u003E\u003Cp\u003Eso i have a second check using raycast:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eif (Physics.Raycast(jumpToPos, TS.TargetVector, out headHit, (float)(destination), 1 \u0026lt;\u0026lt; 15))\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eand if this condition is true i shouldn\u0027t jump too.\u003C/p\u003E\u003Cp\u003ENow everything is simple:\u003C/p\u003E\u003Cp\u003Eevery frame i\u0027m calculate jumpToPos and when it\u0027s safe to jump on i\u0027m jumping on it, if not(planet collision) i\u0027m just standing and waiting when jumpToPos will became safe again (flew from planet)\u003C/p\u003E\u003Cp\u003Ehere\u0027s example (Mad skillz included):\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://cs606417.vk.me/v606417952/233/0gbu0C0el_E.jpg\u0022 alt=\u00220gbu0C0el_E.jpg\u0022\u003E\u003C/p\u003E\u003Cp\u003Ewhere jumpToPos is A, then B, thec C....\u003C/p\u003E\u003Cp\u003EWhen the vessel is at point C, next jumpToPos will be D and the raycast with length CD will say vessel to keep on C.\u003C/p\u003E\u003Cp\u003EOn the next step raycast from D to E won\u0027t find collision but E belongs to sphere and the vessel will keep on C too.\u003C/p\u003E\u003Cp\u003ESame for the F point. \u003C/p\u003E\u003Cp\u003EAt the end vessel will jump to G and everything will be ok.\u003C/p\u003E\u003Cp\u003EJust show a dark screen while vessel is holding on C \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EZoomed:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://cs606417.vk.me/v606417952/23a/lEeoxjlqoyI.jpg\u0022 alt=\u0022lEeoxjlqoyI.jpg\u0022\u003E\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EBut\u003C/strong\u003E!!!\u003C/p\u003E\u003Cp\u003Eif \u003Cstrong\u003Emore than one\u003C/strong\u003E jumpToPos points will be \u003Cstrong\u003Ebelow surface but above sea level\u003C/strong\u003E there\u0027s will be a problem:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://cs606417.vk.me/v606417952/241/y6ELhGnPUAs.jpg\u0022 alt=\u0022y6ELhGnPUAs.jpg\u0022\u003E\u003C/p\u003E\u003Cp\u003Estep 1: vessel on A, jumpToPos = B, B is safe(no collision) =\u0026gt; jumping to B\u003C/p\u003E\u003Cp\u003Estep 2: vessel on B, jumpToPos = C, C isn\u0027t safe(raycast detected hit), keep vessel on B\u003C/p\u003E\u003Cp\u003Estep 3: vessel on B, JumpToPos = D, D\u003Cstrong\u003E is safe\u003C/strong\u003E! No raycast hit, not belongs to sphere(red area), jumping to D and exploding!\u003C/p\u003E\u003Cp\u003ESo i need a 3rd check:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eif(lastColAlt\u0026gt;vessel.altitude)\u003Cbr\u003E            {\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E            }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ewhere\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003ElastColAlt = FlightGlobals.getAltitudeAtPos(headHit.barycentricCoordinate); //from last raycast hit with surface\u003C/pre\u003E\u003Cp\u003E \u003C/p\u003E\u003Cp\u003Eto determine if the vessel is under surface\u003C/p\u003E\u003Cp\u003EFull code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eprivate void Jump(double destination)\u003Cbr\u003E        {\u003Cbr\u003E            bool isSafeToJump = true;\u003Cbr\u003E\u003Cbr\u003E            if (Physics.Raycast(jumpToPos, TS.TargetVector, out headHit, (float)(destination \u002B 50.0), 1 \u0026lt;\u0026lt; 15)) //is any collision on the way to next jump point. Do it before calculating new jumpToPos value\u003Cbr\u003E            {                \u003Cbr\u003E                lastColAlt = FlightGlobals.getAltitudeAtPos(headHit.barycentricCoordinate);\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E            }\u003Cbr\u003E            if (lastColAlt \u0026gt; vessel.altitude) // if under surface\u003Cbr\u003E            {\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            jumpToPos = vessel.transform.position \u002B (TS.TargetVector * destination);  // calculate next jump point\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            if ((Math.Pow((jumpToPos.x - vessel.mainBody.transform.position.x), 2) \u002B Math.Pow((jumpToPos.y - vessel.mainBody.transform.position.y), 2) \u002B Math.Pow((jumpToPos.z - vessel.mainBody.transform.position.z), 2)) \u0026lt;= Math.Pow(vessel.mainBody.Radius \u002B 5, 2)) // is next jump point belongs to planet(sphere only)\u003Cbr\u003E            {\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E                lastColAlt = 0.0; //drop value\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E                ///Jump or not\u003Cbr\u003E\u003Cbr\u003E            if(isSafeToJump)\u003Cbr\u003E            {\u003Cbr\u003E                lastSafePos = vessel.transform.position;\u003Cbr\u003E                lastColAlt = 0.0;\u003Cbr\u003E\u003Cbr\u003E                vessel.SetPosition(jumpToPos);\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                vessel.SetPosition(lastSafePos);\u003Cbr\u003E                print(\u0022ABORT!\u0022);\u003Cbr\u003E            }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENow i have brilliant monkey code which works every 2nd time.\u003C/p\u003E\u003Cp\u003ESo...\u003C/p\u003E\u003Cp\u003EIs there any way to check collision at point (like i can check altitude FlightGlobals.getAltitudeAtPos())?\u003C/p\u003E\u003Cp\u003EOr any ideas?!\u003C/p\u003E\u003Cp\u003EOr how can i disable collision at all?\u003C/p\u003E\u003Cp\u003Evessel.GoOnRails() can\u0027t solve this problem.\u003C/p\u003E\u003Cp\u003Evessel.collider retutrns null ref exception, looping from every part of the vessel and disabling collider has no effect, Physics.IgnoreCollision - nothing too.\u003C/p\u003E\u003Cp\u003EThank you for your answers!\u003C/p\u003E\u003Cp\u003EP.S.\u003C/p\u003E\u003Cp\u003Ebounus-proof of concept:\u003C/p\u003E\u003Cp\u003ELaythe:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://cs606417.vk.me/v606417952/25e/fXJFYej8JNw.jpg\u0022 alt=\u0022fXJFYej8JNw.jpg\u0022\u003E\u003C/p\u003E\u003Cp\u003EWarping to Ike:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://cs606417.vk.me/v606417952/267/PuLh06mXfus.jpg\u0022 alt=\u0022PuLh06mXfus.jpg\u0022\u003E\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://cs606417.vk.me/v606417952/270/iKDjSq3pW5c.jpg\u0022 alt=\u0022iKDjSq3pW5c.jpg\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2013-12-27T21:06:21Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022EvilKot\u0022 data-cite=\u0022EvilKot\u0022\u003E\u003Cdiv\u003EHello. I\u0027m developing a warp drive mod (thousands of them! \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E)\u003Cp\u003EThe general idea based on teleporting vessel very very very fast (once per frame) using vessel.SetPosition(Vector3d position) method which makes illusion that ship is really flying whenever you need.\u003C/p\u003E\u003Cp\u003EEverything works great expect of \u0022through planet warp\u0022 and i asking you for help. I have serious language(english) problems and i suck at explaining things (Just wanna say sorry).\u003C/p\u003E\u003Cp\u003EAs i said i\u0027m teleporting vessel every frame in target direction:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EjumpToPos = vessel.transform.position \u002B (TS.TargetVector * destination); //jumpToPos, TargetVector are Vector3d variables, destination is increases and decreases.\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ethen:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Evessel.SetPosition(jumpToPos);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ebut if new vessel position will be under surface vessel will explode (ORLY? \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E ) \u003C/p\u003E\u003Cp\u003Eso i have to check jumpToPos before jumping on it.\u003C/p\u003E\u003Cp\u003Ei can simple determine collision:\u003C/p\u003E\u003Cp\u003E(x-a)^2 \u002B (y-\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_cool.png\u0022 alt=\u0022B)\u0022\u003E^2 \u002B (z-c)^2 Mustn\u0027t be less or equals to R^2,\u003C/p\u003E\u003Cp\u003Ewhere a, b, c, R - planet position and radius\u003C/p\u003E\u003Cp\u003Eand x, y, z are jumpToPos values.\u003C/p\u003E\u003Cp\u003Eor:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E(Math.Pow((jumpToPos.x - vessel.mainBody.transform.position.x), 2) \u002B Math.Pow((jumpToPos.y - vessel.mainBody.transform.position.y), 2) \u002B Math.Pow((jumpToPos.z - vessel.mainBody.transform.position.z), 2)) \u0026lt;= Math.Pow(vessel.mainBody.Radius, 2)\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ESo if this condition returns true i shouldn\u0027t jump because of explosion.\u003C/p\u003E\u003Cp\u003EBut this thing work only if planet is a perfect sphere without mountains, hils and etc (nothing above sea level)\u003C/p\u003E\u003Cp\u003Eso i have a second check using raycast:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eif (Physics.Raycast(jumpToPos, TS.TargetVector, out headHit, (float)(destination), 1 \u0026lt;\u0026lt; 15))\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eand if this condition is true i shouldn\u0027t jump too.\u003C/p\u003E\u003Cp\u003ENow everything is simple:\u003C/p\u003E\u003Cp\u003Eevery frame i\u0027m calculate jumpToPos and when it\u0027s safe to jump on i\u0027m jumping on it, if not(planet collision) i\u0027m just standing and waiting when jumpToPos will became safe again (flew from planet)\u003C/p\u003E\u003Cp\u003Ehere\u0027s example (Mad skillz included):\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://cs606417.vk.me/v606417952/233/0gbu0C0el_E.jpg\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://cs606417.vk.me/v606417952/233/0gbu0C0el_E.jpg\u003C/a\u003E\u003C/p\u003E\u003Cp\u003Ewhere jumpToPos is A, then B, thec C....\u003C/p\u003E\u003Cp\u003EWhen the vessel is at point C, next jumpToPos will be D and the raycast with length CD will say vessel to keep on C.\u003C/p\u003E\u003Cp\u003EOn the next step raycast from D to E won\u0027t find collision but E belongs to sphere and the vessel will keep on C too.\u003C/p\u003E\u003Cp\u003ESame for the F point. \u003C/p\u003E\u003Cp\u003EAt the end vessel will jump to G and everything will be ok.\u003C/p\u003E\u003Cp\u003EJust show a dark screen while vessel is holding on C \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EZoomed:\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://cs606417.vk.me/v606417952/23a/lEeoxjlqoyI.jpg\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://cs606417.vk.me/v606417952/23a/lEeoxjlqoyI.jpg\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EBut\u003C/strong\u003E!!!\u003C/p\u003E\u003Cp\u003Eif \u003Cstrong\u003Emore than one\u003C/strong\u003E jumpToPos points will be \u003Cstrong\u003Ebelow surface but above sea level\u003C/strong\u003E there\u0027s will be a problem:\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://cs606417.vk.me/v606417952/241/y6ELhGnPUAs.jpg\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://cs606417.vk.me/v606417952/241/y6ELhGnPUAs.jpg\u003C/a\u003E\u003C/p\u003E\u003Cp\u003Estep 1: vessel on A, jumpToPos = B, B is safe(no collision) =\u0026gt; jumping to B\u003C/p\u003E\u003Cp\u003Estep 2: vessel on B, jumpToPos = C, C isn\u0027t safe(raycast detected hit), keep vessel on B\u003C/p\u003E\u003Cp\u003Estep 3: vessel on B, JumpToPos = D, D\u003Cstrong\u003E is safe\u003C/strong\u003E! No raycast hit, not belongs to sphere(red area), jumping to D and exploding!\u003C/p\u003E\u003Cp\u003ESo i need a 3rd check:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eif(lastColAlt\u0026gt;vessel.altitude)\u003Cbr\u003E            {\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E            }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ewhere\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003ElastColAlt = FlightGlobals.getAltitudeAtPos(headHit.barycentricCoordinate); //from last raycast hit with surface\u003C/pre\u003E\u003Cp\u003E \u003C/p\u003E\u003Cp\u003Eto determine if the vessel is under surface\u003C/p\u003E\u003Cp\u003EFull code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eprivate void Jump(double destination)\u003Cbr\u003E        {\u003Cbr\u003E            bool isSafeToJump = true;\u003Cbr\u003E\u003Cbr\u003E            if (Physics.Raycast(jumpToPos, TS.TargetVector, out headHit, (float)(destination \u002B 50.0), 1 \u0026lt;\u0026lt; 15)) //is any collision on the way to next jump point. Do it before calculating new jumpToPos value\u003Cbr\u003E            {                \u003Cbr\u003E                lastColAlt = FlightGlobals.getAltitudeAtPos(headHit.barycentricCoordinate);\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E            }\u003Cbr\u003E            if (lastColAlt \u0026gt; vessel.altitude) // if under surface\u003Cbr\u003E            {\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            jumpToPos = vessel.transform.position \u002B (TS.TargetVector * destination);  // calculate next jump point\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            if ((Math.Pow((jumpToPos.x - vessel.mainBody.transform.position.x), 2) \u002B Math.Pow((jumpToPos.y - vessel.mainBody.transform.position.y), 2) \u002B Math.Pow((jumpToPos.z - vessel.mainBody.transform.position.z), 2)) \u0026lt;= Math.Pow(vessel.mainBody.Radius \u002B 5, 2)) // is next jump point belongs to planet(sphere only)\u003Cbr\u003E            {\u003Cbr\u003E                isSafeToJump = false;\u003Cbr\u003E                lastColAlt = 0.0; //drop value\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E                ///Jump or not\u003Cbr\u003E\u003Cbr\u003E            if(isSafeToJump)\u003Cbr\u003E            {\u003Cbr\u003E                lastSafePos = vessel.transform.position;\u003Cbr\u003E                lastColAlt = 0.0;\u003Cbr\u003E\u003Cbr\u003E                vessel.SetPosition(jumpToPos);\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                vessel.SetPosition(lastSafePos);\u003Cbr\u003E                print(\u0022ABORT!\u0022);\u003Cbr\u003E            }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENow i have brilliant monkey code which works every 2nd time.\u003C/p\u003E\u003Cp\u003ESo...\u003C/p\u003E\u003Cp\u003EIs there any way to check collision at point (like i can check altitude FlightGlobals.getAltitudeAtPos())?\u003C/p\u003E\u003Cp\u003EOr any ideas?!\u003C/p\u003E\u003Cp\u003EOr how can i disable collision at all?\u003C/p\u003E\u003Cp\u003Evessel.GoOnRails() can\u0027t solve this problem.\u003C/p\u003E\u003Cp\u003Evessel.collider retutrns null ref exception, looping from every part of the vessel and disabling collider has no effect, Physics.IgnoreCollision - nothing too.\u003C/p\u003E\u003Cp\u003EThank you for your answers!\u003C/p\u003E\u003Cp\u003EP.S.\u003C/p\u003E\u003Cp\u003Ebounus-proof of concept:\u003C/p\u003E\u003Cp\u003ELaythe:\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://cs606417.vk.me/v606417952/25e/fXJFYej8JNw.jpg\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://cs606417.vk.me/v606417952/25e/fXJFYej8JNw.jpg\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EWarping to Ike:\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://cs606417.vk.me/v606417952/267/PuLh06mXfus.jpg\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://cs606417.vk.me/v606417952/267/PuLh06mXfus.jpg\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://cs606417.vk.me/v606417952/270/iKDjSq3pW5c.jpg\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://cs606417.vk.me/v606417952/270/iKDjSq3pW5c.jpg\u003C/a\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou could solve this by adding \u0022fudge physics\u0022 with something along the lines of \u0022gravitational effects cause warp to slow down or malfunction\u0022 so that once you have x ammount of gravity, warp stops. Much like how timewarp currently works.\u003C/p\u003E\n"},{"CreatedByName":"EvilKot","CreatedById":72193,"CreatedDateTime":"2013-12-28T01:37:01Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022rbray89\u0022 data-cite=\u0022rbray89\u0022\u003E\u003Cdiv\u003EYou could solve this by adding \u0022fudge physics\u0022 with something along the lines of \u0022gravitational effects cause warp to slow down or malfunction\u0022 so that once you have x ammount of gravity, warp stops. Much like how timewarp currently works.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThank you, but if i understood you right this solution will be equals to \u0022stop warp if vessel below constant altitude at sea level\u0022. I can just increase \u0022sphere\u0022 where warp stops like: vessel.mainBody.Radius \u002B 10000, so warp will brake under 10km (altitude at sea level). \u003C/p\u003E\u003Cp\u003EAnd are you shure that time warp works simmilar to your answer?\u003C/p\u003E\u003Cp\u003EI see in documentation that every CelestialBodiy object has their own set of altitude limits for maximum time warp multiper.\u003C/p\u003E\u003Cp\u003EThis is not actually i\u0027m looking for.\u003C/p\u003E\u003Cp\u003EFor example - i wanna warp from KSC\u0027s runway to the Mun which is behind those mountains on the west side, so minimum warp altitude at KSC will be ~100 meters and in mountains it should be several thousands. I can\u0027t set constant \u0022x\u0022 for all planet.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-12-28T02:01:30Z\u0022 title=\u002212/28/2013 02:01  AM\u0022 data-short=\u002210 yr\u0022\u003EDecember 28, 2013\u003C/time\u003E by EvilKot\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"EvilKot","CreatedById":72193,"CreatedDateTime":"2013-12-29T13:53:09Z","Content":"\n\u003Cp\u003EAt this moment i\u0027ll use temporary solution - simply force to sleep all Rigidbodys:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003ERigidbody[] rbs = (Rigidbody[])FindObjectsOfType(typeof(Rigidbody));\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eand OnFixedUpdate() :\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eforeach (var rb in rbs)\u003Cbr\u003E              {\u003Cbr\u003E                  rb.Sleep();\u003Cbr\u003E              }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis completely disables physics and collisions, so it may be helpful to anyone who looking for this.\u003C/p\u003E\u003Cp\u003EI just not sure if this is a best way...\u003C/p\u003E\u003Cp\u003E----------\u003C/p\u003E\u003Cp\u003EFinally slove this problem, so how to \u0022Determine collision at point\u0022:\u003C/p\u003E\u003Cp\u003ECelestialBody.pqsController.GetSurfaceHeight(Vector3d radialVector) gives us a terrain altitude at some point.\u003C/p\u003E\u003Cp\u003EAccording to mechJeb \u0026amp; HyperEdit:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EVector3d radialVector =  ( QuaternionD.AngleAxis(Longitude, Vector3d.down) *\u003Cbr\u003E                    QuaternionD.AngleAxis(Latitude, Vector3d.forward) * Vector3d.right),\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Ewhere:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Edouble Longitude = vessel.mainBody.GetLongitude(point);\u003Cbr\u003Edouble Latitude = vessel.mainBody.GetLatitude(point);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eand:\u003C/p\u003E\u003Cp\u003EVector3d point - some coords in world coord system.\u003C/p\u003E\u003Cp\u003EFinally:\u003C/p\u003E\u003Cp\u003E \u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EVector3d point;  //coords (vessel or anything else)\u003Cbr\u003E            double Longitude = vessel.mainBody.GetLongitude(point);\u003Cbr\u003E            double Latitude = vessel.mainBody.GetLatitude(point);\u003Cbr\u003E\u003Cbr\u003E            double srfHeight = vessel.mainBody.pqsController.GetSurfaceHeight(\u003Cbr\u003E                    QuaternionD.AngleAxis(Longitude, Vector3d.down) *\u003Cbr\u003E                    QuaternionD.AngleAxis(Latitude, Vector3d.forward) * Vector3d.right) -\u003Cbr\u003E                          vessel.mainBody.pqsController.radius; //surface height, shows negative values if under sea level\u003Cbr\u003E\u003Cbr\u003E            double alt = (Vector3d.Distance(vessel.mainBody.transform.position, point) - vessel.mainBody.Radius);  //altitude, shows negative values if under sea level too \u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eand if \u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EsrfHeight \u0026gt; alt\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eanything located on \u0022point\u0022 will explode.\u003C/p\u003E\u003Cp\u003EJust note that pqsController of Sun = null!\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-01-02T21:49:45Z\u0022 title=\u002201/02/2014 09:49  PM\u0022 data-short=\u002210 yr\u0022\u003EJanuary 2, 2014\u003C/time\u003E by EvilKot\u003C/strong\u003E\n\u003C/span\u003E\n"}]}