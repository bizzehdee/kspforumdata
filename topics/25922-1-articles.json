{"TopicId":25922,"ForumId":36,"TopicTitle":"[WIP] [Plugin] KerbCom Avionics - Analytical engine and RCS thrust balancing","CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-07T19:55:38Z","PageNum":1,"Articles":[{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-07T19:55:38Z","Content":"\n\u003Cp\u003E\u003Cstrong\u003EThe release thread is \u003C/strong\u003E\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/showthread.php/29387-Plugin-0-20-2-KerbCom-Avionics-0-2-0-1-%28July-2013%29-includes-VTOL-balancing\u0022 rel=\u0022external nofollow\u0022\u003E\u003Cstrong\u003Ehere\u003C/strong\u003E\u003C/a\u003E\u003Cstrong\u003E.\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003E\u003Cem\u003E\u003Cstrong\u003EEdit: This mod is now an engine thrust balancer for VTOLs and unbalanced lifters, as well as an RCS thrust balancer. See the latest posts for details.\u003C/strong\u003E\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EEveryone knows what a pain it can be to try to maneuver a large craft or station with RCS, as RCS thrusters by default operate using a simple model that does not account for the distribution of thruster ports around the centre of mass. You try to translate, and it rotates whether you like it or not, and vice versa. Thus I am going to try to develop a module that automatically solves this problem with no user input required whatsoever, for arbitrary port layouts.\u003C/p\u003E\u003Cp\u003EThe general problem, as far as I can see, is how to calculate the combination of thrust values (per thruster port) that produce the desired resultant angular and linear acceleration. You need to solve a linear system of equations and inequalities. The main equation is that of the directional and angular thrust produced by a combination of thrust values, and the inequalities describe the maximum thrust limits of the individual ports. You also ideally want to minimise the fuel expenditure. Mathematically, all of this is a convex\u003Csup\u003E1\u003C/sup\u003E optimisation\u003Csup\u003E2\u003C/sup\u003E problem, easily solvable\u003Csup\u003E3\u003C/sup\u003E using existing numerical methods libraries.\u003C/p\u003E\u003Cp\u003EPlease note that this is my first foray into modding KSP, so bear with me if progress is slow. I have learnt from other threads that this add-on should be possible, as modules can control the exact thrust of individual ports.\u003C/p\u003E\u003Cp\u003EI would also be grateful for any tips regarding the implementation of such a plugin (such as which callbacks to use), though I think I have a grasp of the essentials.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[1] due to the inequalities\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[2] due to the minimisation of fuel use and maximisation of movement in desired direction\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[3] in theory\u003C/span\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-07-05T21:14:47Z\u0022 title=\u002207/05/2013 09:14  PM\u0022 data-short=\u002211 yr\u0022\u003EJuly 5, 2013\u003C/time\u003E by ZRM\u003C/strong\u003E\n\u003Cbr\u003EAdded link to release thread.\n\u003C/span\u003E\n"},{"CreatedByName":"EndlessWaves","CreatedById":41302,"CreatedDateTime":"2013-05-07T21:28:27Z","Content":"\n\u003Cp\u003ENice to see someone with a bit of mathematical background tackle it, unfortunately mine only goes far enough that I can point out the flaws in simple approaches without having enough experience to suitably frame the problem for solving.\u003C/p\u003E\u003Cp\u003EI\u0027m interested you think the problem has no local minimums\u00C3\u201A\u00C2\u00B2, that seems far from obvious intuitively. Is not the necessity of needing to counter forces on two others axes possibly going to create local minimums if you\u0027re aiming to minimise fuel use as well as maximise thrust?\u003C/p\u003E\u003Cp\u003E\u00C3\u201A\u00C2\u00B2which is apparently the definition of convex in this context.\u003C/p\u003E\u003Cp\u003EAnyway, uninformed speculation aside I probably can help on the coding side, here\u0027s the code I wrote for an RCS Balancer using a much simpler (and not entirely effective algorithm). It should give you some idea of the various commands you\u0027ll need to use. It was only a tech demo though, so I didn\u0027t bother to remember the original thrust and set it to 1 instead, which is probably something you do want to do for a release version.\u003C/p\u003E\u003Cp\u003EYou can\u0027t actually set thrust per port on the stock 4 port RCS thruster, you can only set it per part. It\u0027ll still work on the linear thrusters of course, and a custom RCS module that allowed per port control could be created.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003Epublic class SimpleRCSBalancer : PartModule\u003Cbr\u003E{\u003Cbr\u003E\tprivate List\u0026lt;ModuleRCS\u0026gt; RCSModules = new List\u0026lt;ModuleRCS\u0026gt;();\u003Cbr\u003E\tprivate bool balanceEnabled = true;\u003Cbr\u003E\u003Cbr\u003E\tpublic override void OnActive()\u003Cbr\u003E\t{\u003Cbr\u003E\t\tif(HighLogic.LoadedSceneIsFlight \u0026amp;\u0026amp; this.vessel.isActiveVessel)\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tforeach(Part aPart in vessel.Parts)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tforeach(PartModule potentialRCSModule in aPart.Modules)\u003Cbr\u003E\t\t\t\t{\u003Cbr\u003E\t\t\t\t\tif(potentialRCSModule is ModuleRCS)\u003Cbr\u003E\t\t\t\t\t\tRCSModules.Add((ModuleRCS)potentialRCSModule);\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t}\u003Cbr\u003E\t}\u003Cbr\u003E\u003Cbr\u003E\tpublic override void OnFixedUpdate()\u003Cbr\u003E\t{\t\t\u003Cbr\u003E\t\tif(HighLogic.LoadedSceneIsFlight \u0026amp;\u0026amp; this.vessel.isActiveVessel \u0026amp;\u0026amp; balanceEnabled)\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tVector3 directionOfTravel = Vector3.zero;\u003Cbr\u003E\t\t\tVector3 directionOfBalance = Vector3.zero;\u003Cbr\u003E\t\t\tif(Mathf.Approximately(FlightInputHandler.state.X, 0) == false)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tdirectionOfTravel = (Vector3.right * FlightInputHandler.state.X).normalized;\u003Cbr\u003E\t\t\t\tdirectionOfBalance = Vector3.forward;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t\telse if(Mathf.Approximately(FlightInputHandler.state.Y, 0) == false)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tdirectionOfTravel = (Vector3.forward * FlightInputHandler.state.Y).normalized;\u003Cbr\u003E\t\t\t\tdirectionOfBalance = Vector3.up;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t\telse if(Mathf.Approximately(FlightInputHandler.state.Z, 0) == false)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tdirectionOfTravel = (Vector3.up * FlightInputHandler.state.Z).normalized;\u003Cbr\u003E\t\t\t\tdirectionOfBalance = Vector3.forward;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t\telse\u003Cbr\u003E\t\t\t\treturn;\u003Cbr\u003E\u003Cbr\u003E\t\t\tfloat positiveAxisTorque = 0;\u003Cbr\u003E\t\t\tfloat negativeAxisTorque = 0;\u003Cbr\u003E\u003Cbr\u003E\t\t\tforeach(ModuleRCS anRCS in RCSModules)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tforeach(Transform aNozzle in anRCS.thrusterTransforms)\u003Cbr\u003E\t\t\t\t{\u003Cbr\u003E\t\t\t\t\tVector3 nozzlePosition = vessel.transform.InverseTransformPoint(aNozzle.position) - vessel.findLocalCenterOfMass();\u003Cbr\u003E\t\t\t\t\tif(Vector3.Angle(aNozzle.transform.forward, directionOfTravel) \u0026lt;= 90)\u003Cbr\u003E\t\t\t\t\t{\u003Cbr\u003E\t\t\t\t\t\tfloat straightLineDistance = Vector3.Project(nozzlePosition, directionOfBalance).magnitude;\u003Cbr\u003E\t\t\t\t\t\tif(straightLineDistance \u0026gt;= 0)\u003Cbr\u003E\t\t\t\t\t\t\tpositiveAxisTorque \u002B= straightLineDistance * anRCS.thrusterPower;\u003Cbr\u003E\t\t\t\t\t\telse\u003Cbr\u003E\t\t\t\t\t\t\tnegativeAxisTorque \u002B= -straightLineDistance * anRCS.thrusterPower;\u003Cbr\u003E\t\t\t\t\t}\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\t\tif(positiveAxisTorque \u0026gt; negativeAxisTorque)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tfloat ratio = negativeAxisTorque / positiveAxisTorque;\u003Cbr\u003E\t\t\t\tforeach(ModuleRCS anRCS in RCSModules)\u003Cbr\u003E\t\t\t\t{\u003Cbr\u003E\t\t\t\t\tforeach(Transform aNozzle in anRCS.thrusterTransforms)\u003Cbr\u003E\t\t\t\t\t{\u003Cbr\u003E\t\t\t\t\t\tVector3 nozzlePosition = vessel.transform.InverseTransformPoint(aNozzle.position) - vessel.findLocalCenterOfMass();\u003Cbr\u003E\t\t\t\t\t\tfloat straightLineDistance = Vector3.Project(nozzlePosition, directionOfBalance).magnitude;\u003Cbr\u003E\t\t\t\t\t\tif(straightLineDistance \u0026gt;= 0)\u003Cbr\u003E\t\t\t\t\t\t\tanRCS.thrusterPower = 1 * ratio;\u003Cbr\u003E\t\t\t\t\t}\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t\tif(negativeAxisTorque \u0026gt; positiveAxisTorque)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tfloat ratio = positiveAxisTorque / negativeAxisTorque;\u003Cbr\u003E\t\t\t\tforeach(ModuleRCS anRCS in RCSModules)\u003Cbr\u003E\t\t\t\t{\u003Cbr\u003E\t\t\t\t\tforeach(Transform aNozzle in anRCS.thrusterTransforms)\u003Cbr\u003E\t\t\t\t\t{\u003Cbr\u003E\t\t\t\t\t\tVector3 nozzlePosition = vessel.transform.InverseTransformPoint(aNozzle.position) - vessel.findLocalCenterOfMass();\u003Cbr\u003E\t\t\t\t\t\tfloat straightLineDistance = Vector3.Project(nozzlePosition, directionOfBalance).magnitude;\u003Cbr\u003E\t\t\t\t\t\tif(straightLineDistance \u0026lt;= 0)\u003Cbr\u003E\t\t\t\t\t\t\tanRCS.thrusterPower = 1 * ratio;\u003Cbr\u003E\t\t\t\t\t}\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t}\u003Cbr\u003E\t}\u003Cbr\u003E\t[KSPAction(\u0022Toggle\u0022, KSPActionGroup.Custom07)]\u003Cbr\u003E\tpublic void toggle(KSPActionParam param)\u003Cbr\u003E\t{\u003Cbr\u003E\t\tbalanceEnabled = !balanceEnabled;\u003Cbr\u003E\t\tforeach(ModuleRCS anRCS in RCSModules)\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tanRCS.thrusterPower = 1;\u003Cbr\u003E\t\t}\u003Cbr\u003E\t}\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-08T10:43:04Z","Content":"\n\u003Cp\u003EThanks for the support. Don\u0027t overestimate my mathematical background - I have now realised that I incorrectly used the term convex - I intended it to mean that the space of solutions is bounded by a convex region (specifically an n-dimensional hypercube, where n is the number of ports). However I have hope that the problem does not have local minimums, as (I think) the linear and angular acceleration are linear functions of each of the thrust vectors, but we will see. I am hoping to try solving this problem with a variety of optimisation algorithms\u003Csup\u003E1\u003C/sup\u003E. If it does turn out to be non-convex (using the correct meaning) I can try to guesstimate the the appropriate starting values for the optimiser using some kind of heuristic. \u003C/p\u003E\u003Cp\u003ERegarding the implementation, I had already made a copy of the code you provide from another thread you posted it in. I now realise that unfortunately the thrust is per part, not port. Do you have any insight on the potential usage of the other public variables of ModuleRCS, such as thrustForces? How about how to implement a custom RCS thruster module? If all else fails, I can try constraining the optimisation problem so that it takes into account the lack of control over individual ports.\u003C/p\u003E\u003Cp\u003E\u003Cem\u003EEdit:\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EI now see that the desired result should be possible by setting isJustForShow to true on all thrusters, then applying forces manually. Resource will be drained as if the thrusters were operating normally.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[1] Solving the underdetermined system given by just the port transforms for a desired force should give a surface (an n-d plane) of all valid thrust combinations, which can then be clipped to the hypercube of physically possible port thrusts and optimised for fuel usage.\u003C/span\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-05-08T12:12:50Z\u0022 title=\u002205/08/2013 12:12  PM\u0022 data-short=\u002211 yr\u0022\u003EMay 8, 2013\u003C/time\u003E by ZRM\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-09T20:22:10Z","Content":"\n\u003Cp\u003EI have now implemented an extended version of ModuleRCS called ModuleARCS\u003Csup\u003E1\u003C/sup\u003E, which behaves identically to ModuleRCS in every way, except that if you set isExternallyControlled to true on it, it will instead take the thrust values for each port from a public list thrustExternalInputs. \u0022Externally controlled\u0022 also shows up as a GUI field in game. It is not a subclass of ModuleRCS, which makes it incompatible with other mods working with ModuleRCS (I may change this).\u003C/p\u003E\u003Cp\u003EMy RCS balancing module is called ModuleRCSComputer, and is designed to be attached to one part of a vessel. I have the foundation of one solving method implemented (not yet tested), using BLEIC (Bound and Linear Equality/Inequality Constrained) optimisation. This method simply relies on a list of linear constraints and a minimisation function, so no complex matrix decompositions are required. I now need to calculate the total inertia tensor matrix for the entire vessel manually, as I have learnt that findLocalMOI is inaccurate (it is no longer used in MechJeb for this reason) since it just adds up the moments of inertia of point masses representing each part.\u003C/p\u003E\u003Cp\u003EI also need some way of determining the ideal scaling factor for the inputs - i.e. the responsiveness of the system. If I set this too high, the target acceleration may be out of range of the capability of the thrusters. If I set it too low the system may be sluggish despite the thrusters being more than capable of adequate thrust. Does anyone else have any thoughts about this? I am currently leaning towards providing a GUI panel that lets the user set their desired linear and angular responsiveness, with a notification if their selected values are impossible. This is an improvement over the vanilla interface that does not allow adjustment of responsiveness.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E\u0027A\u0027 for Advanced. What else?\u003C/span\u003E\u003C/p\u003E\n"},{"CreatedByName":"EndlessWaves","CreatedById":41302,"CreatedDateTime":"2013-05-10T11:45:32Z","Content":"\n\u003Cp\u003ESo you\u0027ve got:\u003C/p\u003E\u003Cp\u003ETranslation X \u0026lt; 0.001\u003C/p\u003E\u003Cp\u003ETranslation Y \u0026lt; 0.001\u003C/p\u003E\u003Cp\u003ETranslation Z \u0026gt; N\u003C/p\u003E\u003Cp\u003EAnd you need a sensible value for N?\u003C/p\u003E\u003Cp\u003EI presume your choice of algorithm doesn\u0027t support any sort of weighting in this case so it needs to be lower than achievable or the translations on the other axes will quickly build up?\u003C/p\u003E\u003Cp\u003ECan you do it iteratively and solve several times for increasing values for N until you find a value that can\u0027t be solved? You don\u0027t need much interaction with the game so you could do the actual calculations on a secondary thread if they\u0027re computationally intensive and just use the main thread for grabbing values and setting thrusts.\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-10T14:42:54Z","Content":"\n\u003Cp\u003EThe solver works by providing it with the target acceleration vectors. So it\u0027s a case of equalities, not inequalities. So in your example (attempting linear Z axis acceleration), it\u0027s more like\u003C/p\u003E\u003Cp\u003EX = 0\u003C/p\u003E\u003Cp\u003EY = 0\u003C/p\u003E\u003Cp\u003EZ = N\u003C/p\u003E\u003Cp\u003Eis the target vector. If you set N too high it can\u0027t be solved and the solver reports failure. (I am not sure what you mean regarding weighting.)\u003C/p\u003E\u003Cp\u003EI can determine the maximum value of N just by letting the magnitude of the vector be a free variable then optimising for magnitude, however this requires calculation of a completely different matrix of inputs for the solver. Don\u0027t forget that this maximum magnitude N depends on the direction of intended acceleration, so it would need to be determined in every update. I am not yet sure whether performance will be a problem. I could let it update concurrently if necessary, as you suggest, and fix its update rate to a multiple of the game update rate.\u003C/p\u003E\u003Cp\u003EAnyway, finding the maximum value of N is not the the real problem. In some cases the maximum possible N may be very high, and if this is achieved the vessel would be \u003Cem\u003Etoo\u003C/em\u003E responsive to be controllable, and therefore not the ideal maximum input (for rotational acceleration, at least)\u003Csup\u003E1\u003C/sup\u003E. This is why I propose letting the user set maximum responsiveness manually for angular and linear acceleration\u003Csup\u003E2\u003C/sup\u003E. Also, since N is not constant (it depends, for example, on whether you are translating and rotating at the same time), using it as the scaling factor may be unintuitive and difficult for the user to predict.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[1] Ever tried landing a lightweight lander without SAS and too many RCS thrusters for its own good?\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[2] The UI could allow configuration of different settings depending on the situation, e.g. docking or ascent, and the settings would persist with the vessel in KSPFields.\u003C/span\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-05-10T14:52:39Z\u0022 title=\u002205/10/2013 02:52  PM\u0022 data-short=\u002211 yr\u0022\u003EMay 10, 2013\u003C/time\u003E by ZRM\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-11T11:47:57Z","Content":"\n\u003Cp\u003EI have just learnt that MechJeb 2 already has an RCS balancing solver. I am still using MechJeb 1.x, so I have not noticed it before. It is even using the same numerical methods library and the same solving algorithm. However it does not use linear constraints to ensure a correct result - it relies on the optimiser for that. This means that it comes up with potentially invalid solutions, and it is probably slower due to the expanded search space. To counter this the solver is put in a separate thread and previous results of the solver are cached. Another drawback is that it only ensures that translation does not incur rotation, not vice versa, and you can\u0027t rotate while it is active (that last bit is speculation from looking at the source, and I have not installed MechJeb 2 yet to test this). It also relies on the inaccurate moment of inertia calculation that KSP provides. Possibly the most crucial deficiency is that it does not have control over individual ports - it only controls the overall thrust of a thruster block. Plus I don\u0027t think it provides responsiveness adjustment.\u003C/p\u003E\u003Cp\u003EFor these reasons, I am still developing my own plugin. I hope to include features such as setting a pivot point for rotations so that the RCS computer applies linear thrust with angular thrust to allow rotating about a docking port, or orbiting another vessel. I also want to extend it to include main engine thrust balancing for asymmetrical launch vehicles (think space shuttle) and VTOL craft with movable engines (think Prometheus).\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-05-11T12:06:36Z\u0022 title=\u002205/11/2013 12:06  PM\u0022 data-short=\u002211 yr\u0022\u003EMay 11, 2013\u003C/time\u003E by ZRM\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-14T19:47:05Z","Content":"\n\u003Cp\u003EProgress update: The core of the plugin is working perfectly now. I have complete control over every individual port, which is enabled by replacing instances of ModuleRCS with ModuleARCS automatically when a vessel loads or docks\u003Csup\u003E1\u003C/sup\u003E. The vessel is also correctly controlled by the results of the solver, which has negligible performance impact in my test cases. The only things missing before I publicly release a first version of this plugin are a GUI for selecting responsiveness, accurate inertia tensor calculation to replace the inaccurate value provided by the KSP API and ensuring that the plugin behaves properly in edge cases (such as when connected to launch supports and when only some RCS ports run out of fuel or break).\u003C/p\u003E\u003Cp\u003ETo speed things along I would be grateful for descriptions of the exact cases in which each callback (i.e. OnStart, OnAwake, OnActive) is called, and tips for implementing the GUI.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[1] Thus assimilating (or \u0022infecting\u0022) all RCS modules that the vessel comes into contact with.\u003C/span\u003E\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-16T19:08:17Z","Content":"\n\u003Cp\u003EI now have the plugin working well enough for a pre-release (IMO). The inertia tensor calculations will require more rigorous testing before I can be sure that they are correct, so the values provided by the KSP API are used in the interim.\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-16T19:25:23Z","Content":"\n\u003Cp\u003EUh, mods, I have just realised that this thread should be in plugin development. Please could you move it?\u003C/p\u003E\n"},{"CreatedByName":"pantheis","CreatedById":57108,"CreatedDateTime":"2013-05-16T20:23:35Z","Content":"\n\u003Cp\u003EThis sounds amazing! Any chance you could get with the Mechjeb folks and get this integrated in place of their RCS balancer? And maybe help them with some of the control issues 2.x has with always attempting to maintain a specific roll level? It will roll you to a specific value before pitching when trying to do things such as point from prograde to Orbit\u002B when it should just pitch, no roll needed.\u003C/p\u003E\n"},{"CreatedByName":"Conarr","CreatedById":60613,"CreatedDateTime":"2013-05-16T20:39:51Z","Content":"\n\u003Cp\u003EAnd do you have a location yet on where the pre-release can be downloaded?\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-16T20:46:40Z","Content":"\n\u003Cp\u003EHere is the link to the release thread\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/showthread.php/29387-0-19-1-KerbCom-Avionics-Coordinated-RCS\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://forum.kerbalspaceprogram.com/showthread.php/29387-0-19-1-KerbCom-Avionics-Coordinated-RCS\u003C/a\u003E\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-16T21:03:57Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022pantheis\u0022 data-cite=\u0022pantheis\u0022\u003E\u003Cdiv\u003EThis sounds amazing! Any chance you could get with the Mechjeb folks and get this integrated in place of their RCS balancer? And maybe help them with some of the control issues 2.x has with always attempting to maintain a specific roll level? It will roll you to a specific value before pitching when trying to do things such as point from prograde to Orbit\u002B when it should just pitch, no roll needed.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe MechJeb RCS balancer actually uses a very similar solving algorithm to my approach. I just use it in a different way. I\u0027m going to keep development separate for the time being, as it would take a while to get up to speed with the MechJeb code base, plus I have other things in mind than just RCS balancing, such as main engine balancing and VTOL balancing. I am also planning to later use an entirely different algorithm (a form of matrix decomposition) for the solving to improve robustness, performance and usability in one go.\u003C/p\u003E\n"},{"CreatedByName":"Conarr","CreatedById":60613,"CreatedDateTime":"2013-05-16T21:14:48Z","Content":"\n\u003Cp\u003EThanks ZRM, I\u0027ll give it a go tonight\u003C/p\u003E\n"},{"CreatedByName":"pantheis","CreatedById":57108,"CreatedDateTime":"2013-05-17T16:18:17Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022ZRM\u0022 data-cite=\u0022ZRM\u0022\u003E\u003Cdiv\u003EThe MechJeb RCS balancer actually uses a very similar solving algorithm to my approach. I just use it in a different way. I\u0027m going to keep development separate for the time being, as it would take a while to get up to speed with the MechJeb code base, plus I have other things in mind than just RCS balancing, such as main engine balancing and VTOL balancing. I am also planning to later use an entirely different algorithm (a form of matrix decomposition) for the solving to improve robustness, performance and usability in one go.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThat sounds great! On the engine/VTOL balancing, would your plugin be able to negotiate handling a set of active, thrusting engines rotating from vertical to horizontal? I would love something that could do automatic smooth take off/landing in VTOL mode. Even MechJeb just can\u0027t handle it, and it doesn\u0027t handle engines that rotate very well at all. Been rather annoying trying some interesting designs only to have it think forward needs to be up and tipping my craft all the way back.\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-20T14:10:10Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022pantheis\u0022 data-cite=\u0022pantheis\u0022\u003E\u003Cdiv\u003EThat sounds great! On the engine/VTOL balancing, would your plugin be able to negotiate handling a set of active, thrusting engines rotating from vertical to horizontal? I would love something that could do automatic smooth take off/landing in VTOL mode. Even MechJeb just can\u0027t handle it, and it doesn\u0027t handle engines that rotate very well at all. Been rather annoying trying some interesting designs only to have it think forward needs to be up and tipping my craft all the way back.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThat is exactly the sort of thing I have in mind. Hopefully it will be just like in the film Prometheus (for example). See the release thread for my current goals for the plugin. There are other plugins that claim to handle VTOL control, but they are not precise enough or general enough for my liking.\u003C/p\u003E\u003Cp\u003EDo you have any tips for making robust rotating engines? I tried damned robotics, but no matter how I tweaked the config file, I couldn\u0027t make the rotatron strong enough - it always flexes to the point that all of the engines are hanging down under the craft. I wouldn\u0027t mind some examples of good designs that I can use for testing purposes.\u003C/p\u003E\n"},{"CreatedByName":"Tallinu","CreatedById":57810,"CreatedDateTime":"2013-05-28T01:46:35Z","Content":"\n\u003Cp\u003EThe B9 Aerospace pack has swiveling VTOL engines. I think they only have two positions, but they should do the trick if you need engines that change their direction of thrust instead of just building with different engines pointing different directions.\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-28T16:53:53Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Tallinu\u0022 data-cite=\u0022Tallinu\u0022\u003E\u003Cdiv\u003EThe B9 Aerospace pack has swiveling VTOL engines. I think they only have two positions, but they should do the trick if you need engines that change their direction of thrust instead of just building with different engines pointing different directions.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI did look at the B9 VTOL engines, but like you say, they only have two settings - vertical or horizontal. This isn\u0027t very useful when you are trying to maintain altitude at low speed, for example. However it may be possible to use the models and animation from those engines to make a version with a continuous range of orientations.\u003C/p\u003E\n"},{"CreatedByName":"Hyratel","CreatedById":4486,"CreatedDateTime":"2013-05-31T05:18:34Z","Content":"\n\u003Cp\u003Ethis may need a recompile. my test cases with 0.20 were unable to come up with a solution for an Apollo-CSM type vehicle\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-05-31T16:26:07Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Hyratel\u0022 data-cite=\u0022Hyratel\u0022\u003E\u003Cdiv\u003Ethis may need a recompile. my test cases with 0.20 were unable to come up with a solution for an Apollo-CSM type vehicle\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThanks for the heads up. I am currently (literally right now) working on the next major version (1.0). It\u0027s a complete architectural redesign from the ground up, and shares no code with the original. It will hopefully also include most of the features I have alluded to in previous posts (on this and the other thread) and more. Once I get this to a testing phase, I will consider fixing the old version for 0.20.2, however it\u0027s unlikely as the original was really just a quickly prototyped proof-of-concept with no thought for code design, so it\u0027s pretty difficult to maintain.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-05-31T16:37:25Z\u0022 title=\u002205/31/2013 04:37  PM\u0022 data-short=\u002211 yr\u0022\u003EMay 31, 2013\u003C/time\u003E by ZRM\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"earth","CreatedById":18562,"CreatedDateTime":"2013-06-12T07:00:40Z","Content":"\n\u003Cp\u003ESo, what\u0027s up?\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-06-12T11:35:15Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022earth\u0022 data-cite=\u0022earth\u0022\u003E\u003Cdiv\u003ESo, what\u0027s up?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Cspan style=\u0022text-decoration:underline;\u0022\u003EThings I have implemented in the new system:\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003ERobust initialisation and ModuleRCS migration (so there should be no more FX glitches).\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EVessel command negotiation. This means that if a vessel has multiple parts that want to impose CRCS control on the system (e.g. on a vessel that is actually two docked vessels) the CRCS module that is given control over the entire vessel is determined cleanly so that modules do not conflict.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EMultithreading support to offload solver calculation to another thread which updates separate from the main thread. So the update rate is independent from the frame rate.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EModular control mode management system. This allows me to add new ways of controlling the vessel (such as VTOL mode, shuttle guidance etc.) easily. It also manages settings persistence of all control modes and provides a GUI environment for each mode so you can access its individual settings.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EAn example control mode that behaves like stock RCS control. However this version also allows you to change the RCS strength (for delicate maneuvering and saving fuel) and disable RCS rotation control (this is very useful when ASAS is enabled when docking).\u003Cbr\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022text-decoration:underline;\u0022\u003EWhat I am working on currently:\u003C/span\u003E\u003C/p\u003E\u003Cp\u003EThe new thrust solver. This is the solver that will be used for RCS balancing (useful for docking) and no-gimbal engine balancing (useful for VTOLs and STS-style vehicles). It uses a modified Simplex method that determines the maximum directional thrust of the system automatically. This means that you no longer need to manually tune the solver. It will always find a solution. Also, because it is a purely linear solver, it is 100% accurate\u003Csup\u003E1\u003C/sup\u003E, so no accuracy setting is required either.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022text-decoration:underline;\u0022\u003EThings I plan to do next for the next release:\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003EAdd an RCS mode and engine-balancing mode using the new solver.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EAdd accurate Inertia Tensor calculations.\u003Cbr\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022text-decoration:underline;\u0022\u003EThings I plan to work on in the immediate future after the release:\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003EImplement a nonlinear solver with nonlinear constraints that can solve QCQP problems efficiently. This will be used to balance vessels with engine gimballing, which requires a quadratic solver that handles quadratic constraints. Once this solver is implemented, the full range of VTOLs with gimballing/rotating engines will be supported.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EVTOL guidance - An ascent, landing and maneuvering computer for VTOLs.\u003Cbr\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E[1] Well, as accurate as floating point calculations can be.\u003C/span\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-06-12T11:42:15Z\u0022 title=\u002206/12/2013 11:42  AM\u0022 data-short=\u002211 yr\u0022\u003EJune 12, 2013\u003C/time\u003E by ZRM\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"afranius","CreatedById":70322,"CreatedDateTime":"2013-06-12T18:09:37Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EImplement a nonlinear solver with nonlinear constraints that can solve QCQP problems efficiently. This will be used to balance vessels with engine gimballing, which requires a quadratic solver that handles quadratic constraints.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EJust came here from my thread where you linked this, I guess you had the same idea about CP-based balancing \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EInstead of QCQP, why don\u0027t you use polygonal cone approximations (instead of a cone, use an n-sided polygonal pyramid basis with non-negative coefficients)? These are very commonly used in simulating frictional contacts, and they usually work well and keep the problem linear. That might make your life easier.\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-06-12T20:27:17Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022afranius\u0022 data-cite=\u0022afranius\u0022\u003E\u003Cdiv\u003EJust came here from my thread where you linked this, I guess you had the same idea about CP-based balancing \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003Cp\u003EInstead of QCQP, why don\u0027t you use polygonal cone approximations (instead of a cone, use an n-sided polygonal pyramid basis with non-negative coefficients)? These are very commonly used in simulating frictional contacts, and they usually work well and keep the problem linear. That might make your life easier.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI had thought about this (though I think you would need to approximate it with a pyramid that has a subdivided curved base, not just an n-sided pyramid). I wasn\u0027t sure whether it would be too costly (both in terms of modelling and computation) to be worth it compared to some of the good non-linear constrained optimisation algorithms out there.\u003C/p\u003E\u003Cp\u003EAnyway, engine gimballing doesn\u0027t fit a cone. Instead it\u0027s the spherically-bounded square frustum defined by the set of directions reached by rotating about the X axis by at most the gimbal limit then the same for the Y axis (Z is the starting direction).\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-06-12T20:34:37Z\u0022 title=\u002206/12/2013 08:34  PM\u0022 data-short=\u002211 yr\u0022\u003EJune 12, 2013\u003C/time\u003E by ZRM\u003C/strong\u003E\n\u003C/span\u003E\n"}]}