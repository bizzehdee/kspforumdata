{"TopicId":53938,"ForumId":29,"TopicTitle":"Flight Scene Render Texture","CreatedByName":"rejooh","CreatedById":36919,"CreatedDateTime":"2013-11-21T22:18:39Z","PageNum":1,"Articles":[{"CreatedByName":"rejooh","CreatedById":36919,"CreatedDateTime":"2013-11-21T22:18:39Z","Content":"\n\u003Cp\u003EHi, I\u0027m currently trying to implement some more realistic science. Particularly SSTV (Slow-Scan Television), as it was used in the early US Space Program. To do so I need to render the Screen to a RenderTexture to create the SSTV audio signal. Concerning the rendering to the RenderTexture I found \u003Ca href=\u0022https://forum.kerbalspaceprogram.com/threads/25674-Camera-question\u0022 rel=\u0022external nofollow\u0022\u003Ethis topic\u003C/a\u003E and looking at the Romfarer source helped a lot. But I\u0027m stuck with one problem. Every aspect of the flight scene renders well except the procedural quad sphere terrain. It\u0027s just plain white as can be seen in the following Texture2D\u0027s saved as .png.\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/xEnAR5F.png\u0022 alt=\u0022xEnAR5F.png\u0022\u003E\u003Cimg src=\u0022http://i.imgur.com/fetQuTV.png\u0022 alt=\u0022fetQuTV.png\u0022\u003E\u003Cimg src=\u0022http://i.imgur.com/4nn33Fd.png\u0022 alt=\u00224nn33Fd.png\u0022\u003E\u003C/p\u003E\u003Cp\u003EThats my source:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\t\u003Cbr\u003Epublic class SSTVCamera\u003Cbr\u003E\t{\u003Cbr\u003E\t\tprivate static string[] GameCameras = {\u003Cbr\u003E\t\t\t\u0022Camera ScaledSpace\u0022, \u0022Camera 01\u0022, \u0022Camera 00\u0022\u003Cbr\u003E\t\t};\u003Cbr\u003E\u003Cbr\u003E\t\tprivate static int ScaledSpaceCameraIndex =\t\t0;\u003Cbr\u003E\t\tprivate static int FarCameraIndex =\t\t\t\t1;\u003Cbr\u003E\t\tprivate static int NearCameraIndex =\t\t\t2;\u003Cbr\u003E\u003Cbr\u003E\t\tprivate GameObject[] gameObjects;\u003Cbr\u003E\t\tprivate Camera[] cameras;\u003Cbr\u003E\u003Cbr\u003E\t\tprivate RenderTexture renderTexture;\u003Cbr\u003E\u003Cbr\u003E\t\tpublic SSTVCamera(int width, int height, int depth, RenderTextureFormat format) {\u003Cbr\u003E\t\t\trenderTexture = new RenderTexture(width, height, depth, format);\u003Cbr\u003E\t\t\trenderTexture.Create();\u003Cbr\u003E\u003Cbr\u003E\t\t\tLoadCameras(60, 557059);\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tpublic Texture2D RenderToTexture(Vector3 position, Vector3 aim, Quaternion rotation, bool planetary) {\u003Cbr\u003E\t\t\tRenderTexture currentRenderTexture = RenderTexture.active;\u003Cbr\u003E\t\t\tRenderTexture.active = renderTexture;\u003Cbr\u003E\u003Cbr\u003E\t\t\tif(planetary) {\u003Cbr\u003E\t\t\t\tcameras[ScaledSpaceCameraIndex].transform.position = position;\u003Cbr\u003E\t\t\t\tcameras[ScaledSpaceCameraIndex].transform.forward = aim;\u003Cbr\u003E\t\t\t\tcameras[ScaledSpaceCameraIndex].transform.localRotation = rotation;\u003Cbr\u003E\t\t\t\tcameras[ScaledSpaceCameraIndex].Render();\u003Cbr\u003E\t\t\t} else {\u003Cbr\u003E\t\t\t\tcameras[NearCameraIndex].transform.position = position;\u003Cbr\u003E\t\t\t\tcameras[NearCameraIndex].transform.forward = aim;\u003Cbr\u003E\t\t\t\tcameras[NearCameraIndex].transform.localRotation = rotation;\u003Cbr\u003E\u003Cbr\u003E\t\t\t\tcameras[FarCameraIndex].transform.position = position;\u003Cbr\u003E\t\t\t\tcameras[FarCameraIndex].transform.forward = aim;\u003Cbr\u003E\t\t\t\tcameras[FarCameraIndex].transform.localRotation = rotation;\u003Cbr\u003E\u003Cbr\u003E\t\t\t\tcameras[ScaledSpaceCameraIndex].transform.rotation = cameras[NearCameraIndex].transform.rotation;\u003Cbr\u003E\u003Cbr\u003E\t\t\t\tcameras[ScaledSpaceCameraIndex].Render();\u003Cbr\u003E\t\t\t\tcameras[FarCameraIndex].Render();\u003Cbr\u003E\t\t\t\tcameras[NearCameraIndex].Render();\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\t\tTexture2D texture = new Texture2D(renderTexture.width, renderTexture.height);\u003Cbr\u003E\t\t\ttexture.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0);\u003Cbr\u003E\u003Cbr\u003E\t\t\tRenderTexture.active = currentRenderTexture;\u003Cbr\u003E\t\t\treturn texture;\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tprivate void LoadCameras(float fov, int cullingMask) {\u003Cbr\u003E\t\t\tgameObjects = new GameObject[GameCameras.Length];\u003Cbr\u003E\t\t\tcameras = new Camera[GameCameras.Length];\u003Cbr\u003E\u003Cbr\u003E\t\t\tfor(int i = 0; i \u0026lt; GameCameras.Length; i\u002B\u002B) {\u003Cbr\u003E\t\t\t\tLoadCamera(GameCameras[i], ref gameObjects[i], ref cameras[i]);\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\t\tcameras[ScaledSpaceCameraIndex].fov = fov;\u003Cbr\u003E\t\t\tcameras[FarCameraIndex].fov = fov;\u003Cbr\u003E\t\t\tcameras[NearCameraIndex].fov = fov;\u003Cbr\u003E\u003Cbr\u003E\t\t\tcameras[FarCameraIndex].cullingMask = cullingMask;\u003Cbr\u003E\t\t\tcameras[NearCameraIndex].cullingMask = cullingMask;\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tprivate void LoadCamera(string name, ref GameObject gameObject, ref Camera camera) {\u003Cbr\u003E\t\t\tgameObject = new GameObject();\u003Cbr\u003E\t\t\tgameObject.name = name \u002B \u0022 \u0022 \u002B gameObject.GetInstanceID();\u003Cbr\u003E\u003Cbr\u003E\t\t\tcamera = gameObject.AddComponent\u0026lt;Camera\u0026gt;();\u003Cbr\u003E\t\t\tcamera.CopyFrom(FindCamera(name));\u003Cbr\u003E\t\t\tcamera.targetTexture = renderTexture;\u003Cbr\u003E\t\t\tcamera.enabled = false;\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tprivate Camera FindCamera(string name) {\u003Cbr\u003E\t\t\tforeach(Camera camera in Camera.allCameras) {\u003Cbr\u003E\t\t\t\tif(camera.name == name)\u003Cbr\u003E\t\t\t\t\treturn camera;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t\treturn null;\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tprivate void DestroyCameras() {\u003Cbr\u003E\t\t\tforeach(GameObject gameObject in gameObjects) {\u003Cbr\u003E\t\t\t\tGameObject.Destroy(gameObject);\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t}\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EAny help is greatly appreciated.\u003C/p\u003E\n"},{"CreatedByName":"damny","CreatedById":78621,"CreatedDateTime":"2013-11-23T12:07:06Z","Content":"\n\u003Cp\u003EYour problem is probably that the terrain is transparent. You can use a texture format without alpha if you want to make it visible. If you\u0027re only using it as the input for some computation then maybe that\u0027s not even necessary.\u003C/p\u003E\u003Cp\u003EI\u0027ve used RenderTextureFormat.RGB565 successfully but I don\u0027t think it\u0027s necessarily the RenderTexture that has to be the one without alpha.\u003C/p\u003E\n"},{"CreatedByName":"rejooh","CreatedById":36919,"CreatedDateTime":"2013-11-23T16:29:02Z","Content":"\n\u003Cp\u003EThank you a lot! Works as expected. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"}]}