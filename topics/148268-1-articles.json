{"TopicId":148268,"ForumId":55,"TopicTitle":"Single ship seperate CPU\u0026#039;s(docking)","CreatedByName":"Arugela","CreatedById":133381,"CreatedDateTime":"2016-09-21T02:04:39Z","PageNum":1,"Articles":[{"CreatedByName":"Arugela","CreatedById":133381,"CreatedDateTime":"2016-09-21T02:04:39Z","Content":"\n\u003Cp\u003E\nIs there any way with the current game to make it so instead of becoming a single ship you can choose to have docked ships, or some other feature, separate parts of a ship into different CPU chunks? Say if you chose to you could have all docking connection maintain separate or create separate ships even when connected so it is processed separately in different CPU cores to help get larger ships? And then expend, or give the option too expend, more resources for this type of setup if desired or needed to process the connection between them?\n\u003C/p\u003E\n\u003Cp\u003E\nI personally have plenty of extra CPU and GPU to spare and would gladly use it to run larger ships.\n\u003C/p\u003E\n\u003Cp\u003E\nIf you could even have thing in game that lets you look at the ship parts and designate them as a processing chunk artificially and dictate how it works it would be nice. then we could build more interesting things. Hell, could a mod be made for this?\n\u003C/p\u003E\n\u003Cp\u003E\nEdit: I was reading something about multithreading issues with the game and unity. I was curious if this was a pure funding problem could they just do(or have the thought about) a kick starter to get the funding to fix it or do whatever work was needed?\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-09-21T12:06:11Z\u0022 title=\u002209/21/2016 12:06  PM\u0022 data-short=\u00227 yr\u0022\u003ESeptember 21, 2016\u003C/time\u003E by Arugela\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Wyzard","CreatedById":162363,"CreatedDateTime":"2016-09-22T03:49:34Z","Content":"\n\u003Cp\u003E\nPhysics is parallelizable, at least to some extent, but there\u0027s no need to manually divide a craft into \u0022chunks\u0022 as you describe.\u00A0 It can just be divided up automatically into all the individual parts.\n\u003C/p\u003E\n\u003Cp\u003E\nHowever, the physics simulator is part of Unity, not unique to KSP, so improvements would have to happen there.\u00A0 I\u0027ve done some reading and it\u0027s unclear whether the Unity 5 physics simulator is actually multi-threaded or not.\n\u003C/p\u003E\n\u003Cp\u003E\nUnfortunately, the way KSP uses physics is less likely to benefit from multi-threading anyway.\u00A0 The portion that\u0027s easily parallelizable is collision detection: checking whether any parts are bumping into other parts.\u00A0 Each pair of parts can be checked independently of all the others, so they can be done simultaneously in different threads.\u00A0 The portion that\u0027s not so parallelizable is applying forces to the parts, because they\u0027re interconnected so the force on one part can depend on the force applied to another part, meaning that they can\u0027t be computed simultaneously.\u00A0 Multi-threaded physics would provide a big benefit when there are lots of independent objects that only occasionally collide and briefly interact, like shrapnel bouncing around after an explosion, where the majority of the work is in collision detection.\u00A0 But spacecraft in KSP are made from parts that stay connected to each other, and I think collision detection is not done between parts in the same craft, so most of the work is in applying forces and propagating them through joints.\n\u003C/p\u003E\n\u003Cp\u003E\nThe only place I\u0027d expect multi-threaded physics to provide a big benefit in KSP is when one high-part-count craft is close to another, since that\u0027s the only time a lot of collision detection is needed.\u00A0 (Farther apart, bounding boxes can easily and quickly determine that the craft aren\u0027t colliding.)\n\u003C/p\u003E\n"},{"CreatedByName":"Arugela","CreatedById":133381,"CreatedDateTime":"2016-09-22T05:14:25Z","Content":"\n\u003Cp\u003E\nThat is why I asked if there is a way to use extra cpu/gpu power to do those parts connection calculations in separate thread and apply extra of the fairly decent amount of CPU getting it right. Or at least providing an option to the current game to extend parts. It would be nice if there was an option to at least try this for larger ships.\n\u003C/p\u003E\n\u003Cp\u003E\nThe other reason seperating manually could help would be to maintain independent ships intelligently for docking and making more complex ships potentially. Say if you want to reference shortcut of Ship A while docked to ship B. This could help with separating shortcuts(Currently the are mushed together upon docking) and possibly simultaneously processing if it used this reference at all. But anything automatic and under the hood would be great too. I\u0027m surprised they can\u0027t just use the rest of the system resources to try to allow it to automatically run on different threads. Even if it slows down the game a hair or uses excess resources, even badly... People with large ships are already used to this anyway. Usually that is a case of getting to 20 fps max or even 5 fps in some cases and not wanting the game to crash. As opposed to keeping 60 fps.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nI have an old computer and this game has plenty of extra resources to use on the CPU and most of the rest of the system. Anything to get more parts and use more of the system could be invaluable. Particularly for docking and large ships. I have at least 5 more cores with at least 66% headroom to use up each while the game is running. That could get a good amount of ship going. Even if it\u0027s slower or used fairly inefficiently.\n\u003C/p\u003E\n\u003Cp\u003E\nOr for something weirder. What about something that intelligently separates certain main parts connections in a separate thread but keeps other parts like struts in a main thread so struts are always holding things together better... Then if you know where the weakness will happen, assuming there is a relative weakness. you can strut it! \u0026gt;\u0026lt; (This is where knowing or dictating the weakpoint could help.) Either way, I still think doing the parts connection stuff in multiple threads, even if innefficient would be fantastic. Even if you loose exponential gain or more per core/thread in doing so.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027m always so surprised there aren\u0027t more software solution to these problems being implemented even if it\u0027s not ideal. Even just to give people the option to use the rest of the system to try stuff.\n\u003C/p\u003E\n\u003Cp\u003E\nMaybe in doing so they will find fun ways to make things like non stiff structures like string and long cords! \u0026gt;\u0026lt; Extra ways to simulate buildings being destroyed or having earthquakes on planets! 8D\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-09-22T05:47:44Z\u0022 title=\u002209/22/2016 05:47  AM\u0022 data-short=\u00227 yr\u0022\u003ESeptember 22, 2016\u003C/time\u003E by Arugela\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"cfds","CreatedById":82109,"CreatedDateTime":"2016-09-22T06:05:47Z","Content":"\n\u003Cp\u003E\nI am still not sure why KSP handles vessels as pile of parts connected by (more or less) flexible joints. The only use case I an imagine is \u0022It\u0027s the most simple way so implement part failure due to overstressing\u0022.\n\u003C/p\u003E\n"},{"CreatedByName":"Wyzard","CreatedById":162363,"CreatedDateTime":"2016-09-22T23:05:34Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222768649\u0022 data-ipsquote-contentid=\u0022148268\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221474521265\u0022 data-ipsquote-userid=\u0022133381\u0022 data-ipsquote-username=\u0022Arugela\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n17 hours ago, Arugela said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nEither way, I still think doing the parts connection stuff in multiple threads, even if innefficient would be fantastic. Even if you loose exponential gain or more per core/thread in doing so.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nI think you\u0027re missing the point.\u00A0 Threads let a program do several things simultaneously, which is faster than doing them one-after-the-other, but if calculation B depends on the result of calculation A, those two calculations \u003Cem\u003Ecannot\u003C/em\u003E be done simultaneously.\u00A0 Even if they\u0027re done in different threads, one thread will have to wait for the other, so there\u0027s no benefit.\u00A0 And I believe the \u0022applying forces\u0022 part of physics simulation falls in this category.\n\u003C/p\u003E\n\u003Cp\u003E\nSome kinds of computations can be parallelized; some cannot.\u00A0 Throwing cores at a non-parallelizable problem isn\u0027t going to help at all.\u00A0 Read about \u003Ca href=\u0022https://en.wikipedia.org/wiki/Amdahl%27s_law\u0022 rel=\u0022external nofollow\u0022\u003EAmdahl\u0027s Law\u003C/a\u003E for more information.\n\u003C/p\u003E\n"},{"CreatedByName":"Arugela","CreatedById":133381,"CreatedDateTime":"2016-09-23T01:01:45Z","Content":"\n\u003Cp\u003E\nNo, you could run it so they wait for each other with a little lag if it\u0027s less than the needed lag for the program. If it\u0027s divided up well it could be done.. You just have to do it right. It is possible to make something parralel and still time it.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-09-23T01:04:00Z\u0022 title=\u002209/23/2016 01:04  AM\u0022 data-short=\u00227 yr\u0022\u003ESeptember 23, 2016\u003C/time\u003E by Arugela\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"FS3D","CreatedById":73099,"CreatedDateTime":"2016-09-23T19:51:17Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222769955\u0022 data-ipsquote-contentid=\u0022148268\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221474592505\u0022 data-ipsquote-userid=\u0022133381\u0022 data-ipsquote-username=\u0022Arugela\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n18 hours ago, Arugela said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nNo, you could run it so they wait for each other with a little lag if it\u0027s less than the needed lag for the program. If it\u0027s divided up well it could be done.. You just have to do it right. It is possible to make something parralel and still time it.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nWrong... At least in this particular instance.\n\u003C/p\u003E\n\u003Cp\u003E\nEvery calculation on every part of a given object needs to rely on calculations performed on all connected parts in order for the results to be available. Let\u0027s try an example...\n\u003C/p\u003E\n\u003Cp\u003E\nA collidable object has 3 parts that all need to be checked for forces. Let\u0027s say that they are checked for forces from bottom to top.\n\u003C/p\u003E\n\u003Cp\u003E\nIn a single thread, which is where it has to be done, you pass calculation for part 1. The result of that force calculation is retained. Part 2 is then given the same calculation, with the difference being that part 1\u0027s results are also factored in. Then part 3, with all force calculation results for parts 1 and 2 already available.\n\u003C/p\u003E\n\u003Cp\u003E\nIn a multi-thread situation, you handle the calculation for part 1 to 1 thread. You hand the calculation for part 2 to the next thread, etc. The problem is this: Part 2 does not know what the result for part 1 was, because it was not available to the thread at the time of calculation.\n\u003C/p\u003E\n\u003Cp\u003E\nYour solution: \u0022 No, you could run it so they wait for each other with a little lag ...\u0022\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003ENow here\u0027s the problem with that solution...\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EYou are simply wasting valuable CPU cycles and instruction cache space by doing this. Imagine that the above scenarios is fixed by implementing wait states in each thread.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EThread 1 calculates OK.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EThread 2 has to wait for Thread 1 to finish what it\u0027s doing before it can calculate.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EThread 3 has to wait for Thread 1 AND Thread 2 to finish what it\u0027s doing before it can calculate.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003ESo in effect, all you\u0027ve done is to make all of those threads wait for each other to finish what they are doing before they can proceed.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EAnd no... The time lost to waiting for calculations is not reduced to below that of the time required for a single CPU core or thread to perform those same calculations. If anything... More time is lost because you are no longer able to take advantage of the aqdvanced CPU features such as data and instruction caching if the data you have cached has to be flushed as a result of a separate CPU thread giving an unexpected calculation result due to poor multi-threading practices like the one you think is going to work so fantastically.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003EFor the time being, calculating forces upon a body of objects connected to each other, and therefore dependant on each others\u0027 calculated forces, is best done in a single thread, sequentially, so that all of the prior results are available to THAT pipeline. All you are doing by splitting it up is adding a requirement that the results be duplicated once they are worked out, AND you are making the other threads wait, when they could be getting on with something more useful.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-09-23T19:51:54Z\u0022 title=\u002209/23/2016 07:51  PM\u0022 data-short=\u00227 yr\u0022\u003ESeptember 23, 2016\u003C/time\u003E by FS3D\u003C/strong\u003E\n\u003C/span\u003E\n"}]}