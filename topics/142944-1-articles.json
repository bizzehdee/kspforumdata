{"TopicId":142944,"ForumId":44,"TopicTitle":"Escape velocity calculated vs measured","CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-02T00:03:45Z","PageNum":1,"Articles":[{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-02T00:03:45Z","Content":"\n\u003Cp\u003E\nI\u0027m trying to calculate an escape from a moon with kOS. At the end of \u003Ca href=\u0022http://www.braeunig.us/space/orbmech.htm\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://www.braeunig.us/space/orbmech.htm \u003C/a\u003Ethere is an equation for escape velocity. As I understand it, doing such a burn (minus the current orbital speed) should result in a parabolic orbit with eccentricity of exactly 1. When I try it though, it\u0027s way too much. Where rb is the radius at the burn point, vb is the speed at the burn point, and _eta is time to the burn point, I have:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003E\u00A0\u00A0\u00A0 set vesc to sqrt(2*BODY:MU/rb).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022Total escape velocity required: \u0022 \u002Bround(vesc) \u002B\u0022m/s \u0022.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// lastly we subtract orbital velocity at that point to find \u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003Edv\u003C/abbr\u003E\u003C/abbr\u003E\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set \u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003Edv\u003C/abbr\u003E\u003C/abbr\u003E to vesc -vb.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003E\u00A0\u00A0\u00A0 set n to node(TIME:SECONDS \u002B_eta,0,0,\u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003Edv\u003C/abbr\u003E\u003C/abbr\u003E).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0add n.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nThis gives me a manuevre node for which:\n\u003C/p\u003E\n\u003Cp\u003E\n1) the ejection angle is not 90degrees from the burn point (which it should be, according to cos(n) = -1/e on the same page).\n\u003C/p\u003E\n\u003Cp\u003E\n2) I can manually take off nearly 1/2 of the \u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003Edv\u003C/abbr\u003E\u003C/abbr\u003E from the node and still get an ejection, (at which point the ejection point \u003Cstrong\u003Eis\u003C/strong\u003E 90degrees) so its clearly not a minimum.\n\u003C/p\u003E\n\u003Cp\u003E\nIs there some kind of fudge factor in KSP that I don\u0027t know about? Ive seen the equation on other websites, so it\u0027s probably not wrong. I can\u0027t think of any other reason it\u0027s not working other than I\u0027m misunderstanding something about the maths...\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-07-02T06:48:24Z\u0022 title=\u002207/02/2016 06:48  AM\u0022 data-short=\u00228 yr\u0022\u003EJuly 2, 2016\u003C/time\u003E by surge\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"pincushionman","CreatedById":98495,"CreatedDateTime":"2016-07-02T00:19:19Z","Content":"\n\u003Cp\u003E\nWhat do you mean by \u0022is way too much?\u0022 Is your measured e way off, or are you simply way past so-called\u00A0escape?\n\u003C/p\u003E\n\u003Cp\u003E\nKeep in mind, in KSP \u0022escape\u0022 isn\u0027t a paranolic orbit where e=1, it\u0027s an orbit such that \u003Cabbr title=\u0022Apoapsis\u0022\u003E\u003Cabbr title=\u0022Apoapsis\u0022\u003EAp\u003C/abbr\u003E\u003C/abbr\u003E is outside the (arbitrary) sphere of influence of the parent body, and as such is often still elliptical.\n\u003C/p\u003E\n\u003Cp\u003E\nThe game may not even have a special case for a parabolic escape orbit, since you have to go far out of your way to hit e=1 exactly. Rounding errors all but guarantee you\u0027re either in a really big ellipse or a really tight hyperbola. Both of which would be indistinguishable from a parabola over the short section rendered.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-07-02T00:19:59Z\u0022 title=\u002207/02/2016 12:19  AM\u0022 data-short=\u00228 yr\u0022\u003EJuly 2, 2016\u003C/time\u003E by pincushionman\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2016-07-02T00:55:08Z","Content":"\n\u003Cp\u003E\nIts not true, escape velocity from the surface is theoretical.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nCase 1: no atmosphere, v = a * t, peak efficiency is when v is at the surface, rotation\u00A0velocity at surface is pretty much trivial. since a is not inifinite you have gravity loses while accelerating. If it takes 5 minutes to raech MECO, then you are fighting and loosing energy due to \u0027hovering\u0027 over the lauchpad while trying to reach a velocity at that sltitude that allows escape.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nCase 2. Atmosphere, same acceleration constraints, but you ha a maximum dynamic pessure and at that you are losing x amount of energy to drag.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nSo lets say Vescape is 11500 to escape the total energy you have is 1/2 11500^2. You can add to that energy loses due tongravity which is going to be something like gh\u00A0for the period of time under acceleration, then the energy loses due to drag. You add that up multiply by two and take the square root and you get a delta v.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nIf you are in orbit escape energy is the circukar orbital energy times two. So that if you are in a circular orbit, a single ideal burn represents a \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E 0.414 x stable orbital velocity. So lets say you are orbiting the mun at 550 m/s and you want to leave the mun you need about 230 \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E to leave muns orbit. Now lets say you want a deep orbit, you don\u0027t burn all of that and you burn a few \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E to circularize to remain. Of course this is fantasy because you have la grange points and other troughs in the gravity wells you can slide through. So the n-body problem shifts this. The game it a bunch of serialized 2 body problems.\n\u003C/p\u003E\n"},{"CreatedByName":"Bill Phil","CreatedById":127797,"CreatedDateTime":"2016-07-02T05:41:59Z","Content":"\n\u003Cp\u003E\n\u003Ca href=\u0022https://en.wikipedia.org/wiki/Escape_velocity#Calculating_an_escape_velocity\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://en.wikipedia.org/wiki/Escape_velocity#Calculating_an_escape_velocity\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nYou could use the circular orbit velocity calculation and just multiply by sqrt(2). So, your equation should be fine, I think, but KSP is not that realistic.\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-02T06:47:57Z","Content":"\n\u003Cp\u003E\nHmm, so I actually did the calculated burn just for the hell of it, and lo and behold, it did end up with eccentricity 0.999. Close enough to 1 for my purposes. Clearly, the problem is that I\u0027m not understanding what they\u0027re talking about in the section about ejection angles and impact parameters at:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Ca href=\u0022http://www.braeunig.us/space/orbmech.htm\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://www.braeunig.us/space/orbmech.htm\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nWhat then, is cos(n) = -1/e meant to be representing, as I clearly have it wrong?\n\u003C/p\u003E\n\u003Cp\u003E\nFor e = 1, it\u0027s 180 degrees, which I thought meant the \u0027xxx escape\u0027 circle in the maneuvre is 90 degrees around the orbit from the burn point; essentially, it exits the moon going the opposite direction it would have came from if it was never in proper orbit. Why does it look more like 45 degrees? Is it some optical illusion? Who knows \\o/\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-07-02T06:51:23Z\u0022 title=\u002207/02/2016 06:51  AM\u0022 data-short=\u00228 yr\u0022\u003EJuly 2, 2016\u003C/time\u003E by surge\u003C/strong\u003E\n\u003Cbr\u003ECant \u0026#039;resolve\u0026#039; it, wrong thread. oops.\n\u003C/span\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2016-07-02T18:05:57Z","Content":"\n\u003Cp\u003E\nfor any given circular orbital velocity like he siad escape velocity is 1.4143 x that velocity but the deltaV needed is that velocity minus the circular orbital velocity. therefore the \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E needed is 0.4143 x orbital velocity in that circular orbit.\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"YNM","CreatedById":98447,"CreatedDateTime":"2016-07-03T12:34:18Z","Content":"\n\u003Cp\u003E\nOf course it\u0027s flawed - escape velocity as defined by sqrt(2) times circular orbital velocity assumes the end zero velocity to be located at infinity - we have finite SOIs in-game and even that\u0027s not really applicable IRL...\n\u003C/p\u003E\n\u003Cp\u003E\nAnother possible error is due to imperfection in continuity of the orbit. KSP, outside of warp and celestial bodies, slightly (hmm, not so sure the exact method) uses the euclidean integration, which over time results in errors in the velocity from perfect. It\u0027s also because of the slight phantom forces between attached parts. One way to tell this is to rotate a fairly one-side-heavy rocket around in space - you\u0027ll notice the \u003Cabbr title=\u0022Apoapsis\u0022\u003E\u003Cabbr title=\u0022Apoapsis\u0022\u003E\u003Cabbr title=\u0022Apoapsis\u0022\u003E\u003Cabbr title=\u0022Apoapsis\u0022\u003EAp\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E and \u003Cabbr title=\u0022Periapsis\u0022\u003E\u003Cabbr title=\u0022Periapsis\u0022\u003E\u003Cabbr title=\u0022Periapsis\u0022\u003E\u003Cabbr title=\u0022Periapsis\u0022\u003EPe\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E, as well as SMA, to change.\n\u003C/p\u003E\n\u003Cp\u003E\nYeah, it\u0027s not a perfect game. But the world isn\u0027t either - so just assume, like IRL, you gotta do the mid-course correction burns. (this part is why I refrain from using kOS. I tried but I\u0027m never coder. And then I can\u0027t imagine how guys IRL manages to do it !)\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-07-03T12:38:06Z\u0022 title=\u002207/03/2016 12:38  PM\u0022 data-short=\u00228 yr\u0022\u003EJuly 3, 2016\u003C/time\u003E by YNM\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-08T08:39:55Z","Content":"\n\u003Cp\u003E\nI see. Then does anyone know a way of calculating the (true|mean)anomaly at which to\u00A0 burn so that I end up going a particular direction (relative to the parent body) at \u003Cabbr title=\u0022Sphere of Influence\u0022\u003ESOI\u003C/abbr\u003E crossing? Obviously I have the speed nailed, but the weird direction that it crosses the boundary is making the point at which to start the burn hard. Since I know the \u003Cabbr title=\u0022Sphere of Influence\u0022\u003ESOI\u003C/abbr\u003E boundary radius, it must be doable, but I\u0027m waaay too dumb to figure out the equation for it. I suck at maths, and I suck even harder at polar geometry. In my head, I just turn all circles into squares\u00A0 - 0, 90, 180, 270, 360 \u003Cimg alt=\u0022:)\u0022 data-emoticon=\u0022\u0022 src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 title=\u0022:)\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nIn other words, I\u0027m trying to eject from the Muen and get into a specific orbit around Kerbin. Wildly gesticulating and yelling \u0022THAT WAY!!!\u0022 just wont cut it.\n\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2016-07-08T13:29:36Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222666463\u0022 data-ipsquote-contentid=\u0022142944\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221467967195\u0022 data-ipsquote-userid=\u0022136150\u0022 data-ipsquote-username=\u0022surge\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n4 hours ago, surge said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nI see. Then does anyone know a way of calculating the (true|mean)anomaly at which to\u00A0 burn so that I end up going a particular direction (relative to the parent body) at \u003Cabbr title=\u0022Sphere of Influence\u0022\u003E\u003Cabbr title=\u0022Sphere of Influence\u0022\u003ESOI\u003C/abbr\u003E\u003C/abbr\u003E crossing? Obviously I have the speed nailed, but the weird direction that it crosses the boundary is making the point at which to start the burn hard. Since I know the \u003Cabbr title=\u0022Sphere of Influence\u0022\u003E\u003Cabbr title=\u0022Sphere of Influence\u0022\u003ESOI\u003C/abbr\u003E\u003C/abbr\u003E boundary radius, it must be doable, but I\u0027m waaay too dumb to figure out the equation for it. I suck at maths, and I suck even harder at polar geometry. In my head, I just turn all circles into squares\u00A0 - 0, 90, 180, 270, 360 \u003Cimg alt=\u0022:)\u0022 data-emoticon=\u0022\u0022 src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 title=\u0022:)\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nIn other words, I\u0027m trying to eject from the Muen and get into a specific orbit around Kerbin. Wildly gesticulating and yelling \u0022THAT WAY!!!\u0022 just wont cut it.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nIf you want to go prograde burn at the sunrise termination, angle\u00A0to prograde for Kerbin is 180\u0027 ( in mechJeb)\u00A0for most of the outer planets, but you are only accurate to the \u003Cabbr title=\u0022Sphere of Influence\u0022\u003ESOI\u003C/abbr\u003E, if you want to create a holmann transfer from \u003Cabbr title=\u0022Low Kerbin Orbit\u0022\u003ELKO\u003C/abbr\u003E then you need to center your burn slightly after. The furher out in the system you want you apogee to be the later your burn. If you have some inclination corrections to make \u003Cabbr title=\u0022Low Kerbin Orbit\u0022\u003ELKO\u003C/abbr\u003E is a good place to \u0027start\u0027. If you really plan ahead you can launch with those inclinations and just expand upon them, in general however you will only be able to do a few degrees before the reward no longer pays off, this is because the sin aspect increases rapidly with only small changes in the cosine aspect, and also because there is a limit on how efficient the plane matching will be without an alignment of a transfer window start point time\u00A0and an inclination node.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nFor the inner planets or objects its a burn at angle to prograde of zero, in general, because the energy required to get to moho is so great and because its orbital period is so small you want to wait for a closer overlap of the inclination node, this then requires a inclination shift at launch and a considerable burn at sunset termination, AtP \u0026gt; 0, in this has you want to launch and not establish orbit but instead keep the verticle ascent positive until you have achieve your hohmann intercept preferably most below 75k alt.\u00A0Once established you then correct inclination to optimal and make final inclination corrections in the transit. Moho is hard, not because of the time, but because of the \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E required to transfer (you can use kerbins gravity well to improve) and moho has no atmosphere so you have to retro into moho at just about the lowest altitude posible, there is no way to soften this expense. So planning on the inclination side is the way to go, That 6 degree inclination change close to moho can be extremely costly.\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-09T03:10:03Z","Content":"\n\u003Cp\u003E\nPB666: launching from a surface is not relevant here, nor are hohmann transfers. If you\u0027re still having trouble:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nparameter talt, tinc, poang.\u003Cbr\u003E\n// Target Altitude, Target Inclination, Pitchover Angle\n\u003C/p\u003E\n\u003Cp\u003E\nclearscreen.\u003Cbr\u003E\nprint \u0022== Launch Ascent Guidance System (LAGS) ==\u0022.\n\u003C/p\u003E\n\u003Cp\u003E\nset talt to talt *1000. // target orbital perigee\u003Cbr\u003E\nset safetyspeed to 50. // speed at which safety turn ends.\u003Cbr\u003E\nset safestart to 20. // Altitude at which safety turn starts.\u003Cbr\u003E\nset pitchhold to 10. // halt zero-lift turn at this pitch\u003Cbr\u003E\nset debugmode to true.\n\u003C/p\u003E\n\u003Cp\u003E\nset critq to 15. // maxQ Not implemented yet.\u003Cbr\u003E\n// fudge factor - how \u0027pointy\u0027 rocket is\u003Cbr\u003E\nset dragf to 0.4. // Not implemented yet\n\u003C/p\u003E\n\u003Cp\u003E\n// ===END CONFIG OPTIONS===\n\u003C/p\u003E\n\u003Cp\u003E\n// release controls early in case we get interrupted.\u003Cbr\u003E\nSET SHIP:CONTROL:PILOTMAINTHROTTLE TO 0.\n\u003C/p\u003E\n\u003Cp\u003E\nlock LAc to 90 -vang(up:vector, ship:velocity:surface).\u003Cbr\u003E\nlock dynp to SHIP:DYNAMICPRESSURE *constant:AtmToKPa.\n\u003C/p\u003E\n\u003Cp\u003E\nfunction printscreen {\u003Cbr\u003E\n// were going to use a 15 line screen total.\u003Cbr\u003E\n// Debug messages start on line 20\u003Cbr\u003E\nprint \u0022 \u0022 at(0,1).\u003Cbr\u003E\nprint \u0022Target altitude: \u0022 \u002Bround(talt/1000, 1) \u002B\u0022km\u00A0\u00A0 \u0022 at(0,2).\u003Cbr\u003E\nprint \u0022Target inclination: \u0022 \u002Bround(tinc, 1) \u002B\u0022o\u00A0\u00A0 \u0022 at(25,2).\u003Cbr\u003E\n// Vector start, Vector end\u003Cbr\u003E\n// Launch mass, \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003Etwr\u003C/abbr\u003E\u003Cbr\u003E\nprint \u0022Apogee: \u0022 \u002Bround(SHIP:OBT:APOAPSIS/1000,1) \u002B\u0022km\u00A0\u00A0\u00A0\u00A0 \u0022at(0,6).\u003Cbr\u003E\nprint \u0022Perigee: \u0022 \u002Bround(SHIP:OBT:PERIAPSIS/1000,1) \u002B\u0022km\u00A0\u00A0\u00A0 \u0022at(25,6).\u003Cbr\u003E\nprint \u0022Time to apogee: \u0022 \u002Bround(ETA:APOAPSIS) \u002B\u0022s\u00A0\u00A0 \u0022at(0,7).\u003Cbr\u003E\nprint \u0022Ecc: \u0022 \u002Bround(SHIP:OBT:ECCENTRICITY,2) \u002B\u0022\u00A0\u00A0 \u0022 at(0,8).\u003Cbr\u003E\nprint \u0022Inc: \u0022 \u002Bround(SHIP:OBT:INCLINATION,2)\u00A0 \u002B\u0022\u00A0\u00A0 \u0022 at(25,8).\u003Cbr\u003E\nprint \u0022Dynamic pressure: \u0022 \u002Bround(dynp, 2) \u002B\u0022/\u0022 \u002Bround(critq, 2)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u002B\u0022kPa\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,9).\u003Cbr\u003E\nprint \u0022Flight path angle: \u0022 \u002Bround(LAc, 1) \u002B\u0022\u00A0\u00A0 \u0022 at(0,10).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,11).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,12).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,13).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,14).\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nwait 0.5.\u003Cbr\u003E\nprintscreen().\u003Cbr\u003E\nprint \u0022STATUS: calculating...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\n\u003C/p\u003E\n\u003Cp\u003E\nfunction clamped {\u003Cbr\u003E\n// returns stage number of clamps any\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local stagecmp to STAGE:number.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local highclamp to -1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if SHIP:STATUS \u0026lt;\u0026gt; \u0022PRELAUNCH\u0022 and SHIP:STATUS \u0026lt;\u0026gt; \u0022LANDED\u0022\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return -1.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local clamps to ship:partsnamed(\u0022launchClamp1\u0022).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0for c in clamps {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (c:stage \u0026gt; highclamp) set highclamp to c:stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return highclamp.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nset coremotors to list().\u003Cbr\u003E\nset boostmotors to list().\u003Cbr\u003E\nfunction detect_motors {\u003Cbr\u003E\n// parse and sort motors in current stage into\u003Cbr\u003E\n// globals coremotors and boostmotors\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local el to list().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0list engines in el.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set coremotors to list().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set boostmotors to list().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local stagehigh to STAGE:number.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local stagelow to clamped().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (SHIP:STATUS = \u0022PRELAUNCH\u0022) and (stagelow = -1) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set stagelow to stagehigh -1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0} else if (stagelow = -1)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set stagelow to stagehigh.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0for e in el {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// we have to detect if stage above has launch\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// clamps AND if we are in launch ready state\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (e:stage \u0026gt;= stagelow) and (e:stage \u0026lt;= stagehigh)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// Check if the engine is\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// on centre stack.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (e:tag = \u0022boostMotor\u0022) {\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0boostmotors:add(e).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0} else {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// everything else should be cores.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0coremotors:add(e).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return coremotors:LENGTH \u002Bboostmotors:LENGTH.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nfunction setcorethrottle {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter lvl.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0for e in coremotors {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set e:THRUSTLIMIT to lvl *100.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nfunction getcorethrottle {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (coremotors:length = 0) return 0.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return coremotors[0]:THRUSTLIMIT /100.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nfunction getctwr {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// returns current \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003ETWR\u003C/abbr\u003E.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// *sigh* :MAXTHRUST doesnt work unless the engine is\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// staged. This SHOULD return the \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003ETWR\u003C/abbr\u003E upon launch, so\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// we only have to calculate it once.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local gf to (SHIP:BODY:MU\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0/(SHIP:BODY:RADIUS \u002BSHIP:ALTITUDE)^2).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local thrust to 0.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0list engines in el.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0for e in el\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if e:IGNITION set thrust to thrust \u002Be:THRUST.\n\u003C/p\u003E\n\u003Cp\u003E\n//\u00A0\u00A0 \u00A0return SHIP:AVAILABLETHRUST /(SHIP:MASS*gf).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return thrust /(SHIP:MASS*gf).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nfunction inc2hdg {\u003Cbr\u003E\n// does the wierd maths when converting from an orbital inclination\u003Cbr\u003E\n// to a heading to fly for it.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter inc.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set rt to 180 -inc -90.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (rt \u0026lt; 0) set rt to 180 -rt.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return rt.\u003Cbr\u003E\n}\u003Cbr\u003E\nset thdg to inc2hdg(tinc).\n\u003C/p\u003E\n\u003Cp\u003E\nset east to up *R(0, -90, 0).\u003Cbr\u003E\nfunction getvhdg {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local r1 to vcrs(up:vector,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ship:velocity:orbit):normalized.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local vhdg to vang(r1, east:vector).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (r1:y) \u0026gt; 0.0 set vhdg to 360 -vhdg.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return vhdg.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nset laststage to STAGE:NUMBER.\u003Cbr\u003E\nfunction stagectl {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if not STAGE:READY return false.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if THROTTLE \u0026lt;= 0 return false.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// detect_motors() takes long and only needs to be\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// called once after staging has finished\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (laststage \u0026lt;\u0026gt; STAGE:NUMBER) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0detect_motors().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set laststage to STAGE:NUMBER.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return false.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// also check for no motors\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (coremotors:length = 0) and (boostmotors:length = 0){\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0lock throttle to 1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return true.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0for e in boostmotors {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (e:maxthrust \u0026lt;= 0) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0lock throttle to 1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return true.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0if (coremotors:length \u0026gt; 0) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// check that boost motors are gone.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// but still need to do the fuel check thing.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (boostmotors:length = 0) setcorethrottle(1).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0local corethrust to 0.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0for e in coremotors {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set corethrust to corethrust \u002Be:maxthrust.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (corethrust = 0) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return true.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return false.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nfunction hdgerr {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// Calculates the heading offset for the given orbital\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// inclination.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter targethdg.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// ffs. SHIP:OBT:INCLINATION doesnt do negatives?\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set shipinc to SHIP:OBT:INCLINATION.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local shiphdg to getvhdg().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (shiphdg \u0026gt; 90 and shiphdg \u0026lt; 270) set shipinc to -shipinc.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return targethdg -inc2hdg(shipinc).\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\ndetect_motors().\u003Cbr\u003E\nif boostmotors:LENGTH = 0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022WARNING NO BOOST MOTORS DETECTED!\u0022 at (0,14).\u003Cbr\u003E\n//\u00A0\u00A0 \u00A0exit.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n//\u003Cbr\u003E\n// ===GUIDANCE CALCULATION===\u003Cbr\u003E\n//\n\u003C/p\u003E\n\u003Cp\u003E\nset poalt to SHIP:BODY:ATM:HEIGHT/7.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// FIXME: This needs to settle faster.\u003Cbr\u003E\nSET thpid to PIDLOOP(0.1, 0.8, 0.15, 0, 1).\u003Cbr\u003E\nset thpid:setpoint to 0.0.\n\u003C/p\u003E\n\u003Cp\u003E\nSET pchpid to PIDLOOP(0.5, 0.05, 0.5, 0, 20).\u003Cbr\u003E\nset pchpid:setpoint to 15.\n\u003C/p\u003E\n\u003Cp\u003E\n//set STEERINGMANAGER:PITCHPID:KD to 0.5.\u003Cbr\u003E\n//set STEERINGMANAGER:YAWPID:KD to 0.5.\n\u003C/p\u003E\n\u003Cp\u003E\nFROM {local countdown is 5.}\u003Cbr\u003E\nUNTIL countdown = 0 STEP {SET countdown to countdown - 1.} DO {\u003Cbr\u003E\n\u00A0\u00A0\u00A0 PRINT \u0022STATUS: pre-launch... T-\u0022\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u002B countdown \u002B\u0022s\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\n\u00A0\u00A0\u00A0 WAIT 1.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: Launch...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock throttle to 1.\u003Cbr\u003E\nlock steering to up.\u003Cbr\u003E\n// Since engine:MAXTHRUST is broken, we have to actually fire\u003Cbr\u003E\n// up the engines (possibly launch if no clamps) to get a value.\u003Cbr\u003E\nset launchtwr to 0.\u003Cbr\u003E\nset sa to SHIP:ALTITUDE -SHIP:GEOPOSITION:TERRAINHEIGHT.\u003Cbr\u003E\nuntil SHIP:ALTITUDE -SHIP:GEOPOSITION:TERRAINHEIGHT-sa \u0026gt; safestart {\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0set launchtwr to getctwr().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local dTWR to getctwr() -1.3.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0setcorethrottle(thpid:update(TIME:SECONDS*10, dTWR)).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022Launch \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003ETWR\u003C/abbr\u003E: \u0022 \u002Bround(launchtwr, 2) \u002B\u0022\u00A0\u00A0\u00A0\u00A0 \u0022 at(25,3).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022Launch Mass: \u0022 \u002Bround(SHIP:MASS, 2) \u002B\u0022\u00A0\u00A0\u00A0 \u0022 at(0,3).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.1.\u003Cbr\u003E\n}\u003Cbr\u003E\nunset sa.\u003Cbr\u003E\n//set poang to 90-(-100*(1/dragf*0.2)*(launchtwr -1.8)).\u003Cbr\u003E\nprint \u0022Zero-lift start: \u0022 \u002Bround(poalt) \u002B\u0022m\u00A0\u00A0 \u0022 at(0,4).\u003Cbr\u003E\nprint \u0022Vectoring angle: \u0022 \u002Bround(poang, 1) \u002B\u0022o\u00A0\u00A0\u00A0 \u0022at(25,4).\u003Cbr\u003E\nunset startalt.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: safety turn...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock steering to heading(thdg, 85).\u003Cbr\u003E\nset \u003Cabbr title=\u0022Reaction Control System\u0022\u003Ercs\u003C/abbr\u003E to true.\u003Cbr\u003E\nuntil (SHIP:VELOCITY:SURFACE:MAG \u0026gt;= safetyspeed) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: vector guidance...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock pitcherr to SHIP:ALTITUDE *(90-poang)/poalt.\u003Cbr\u003E\nlock steering to heading(thdg, 90 -pitcherr).\u003Cbr\u003E\nuntil (SHIP:ALTITUDE \u0026gt; poalt)\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: zero-lift turn...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock steering to heading(thdg, LAc).\u003Cbr\u003E\n// FIXME: do throttle control\u003Cbr\u003E\nlock steering to heading(thdg \u002Bhdgerr(thdg), LAc).\u003Cbr\u003E\nuntil (LAc \u0026lt;= pitchhold) or (SHIP:APOAPSIS \u0026gt;= talt) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: pitch hold...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock steering to heading(thdg \u002Bhdgerr(thdg), pitchhold).\u003Cbr\u003E\nuntil (SHIP:ALTITUDE \u0026gt;= SHIP:BODY:ATM:HEIGHT) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0lock throttle to thpid:update(TIME:SECONDS,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0SHIP:APOAPSIS -talt).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local pitchang to pchpid:update(TIME:SECONDS*10, LAc).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0lock steering to heading(thdg \u002Bhdgerr(thdg), pitchang).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\u003Cbr\u003E\nlock throttle to 0.\u003Cbr\u003E\nunlock steering.\u003Cbr\u003E\nunlock LAc.\u003Cbr\u003E\nunlock dynp.\u003Cbr\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003ERCS\u003C/abbr\u003E off.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: Orbital Insertion...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nset apR to APOAPSIS \u002BBODY:RADIUS.\u003Cbr\u003E\nset \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E to sqrt(BODY:MU /apR)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0-sqrt(BODY:MU* (2/apR -1/OBT:SEMIMAJORAXIS)).\u003Cbr\u003E\nset circNode to node(TIME:SECONDS \u002BETA:APOAPSIS, 0, 0, \u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E).\u003Cbr\u003E\nadd circNode.\n\u003C/p\u003E\n\u003Cp\u003E\n// we could check the node is correct by comparing\u003Cbr\u003E\n// circNode:ORBIT:APOAPSIS and circNode:ORBIT:PERIAPSIS\u003Cbr\u003E\n// to make sure they are a) nearly equal, and b) close to talt\n\u003C/p\u003E\n\u003Cp\u003E\nrun xnode(1, 0).\u003Cbr\u003E\nprint \u0022STATUS: Program ended.\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-21T06:45:09Z","Content":"\n\u003Cp\u003E\nFor the googlers: since \u0027escaped\u0027 is mathematically just an elliptical orbit, to calculate KSP escape velocity is then:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003Ev = sqrt(BODY:MU *(2/r -1/(r \u002BBODY:SOIRADIUS)/2)) \u002B0.01.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nwhere r is BODY:RADIUS \u002BSHIP:ALTITUDE (or whatever altitude you want to launch from)\n\u003C/p\u003E\n\u003Cp\u003E\nThe 0.01 is not mathematically correct, but just to \u0027nudge\u0027 it over the line.\n\u003C/p\u003E\n\u003Cp\u003E\nStill working on figuring out the transit angle so I can figure out *when* to burn, but this is a start.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-07-21T14:40:15Z\u0022 title=\u002207/21/2016 02:40  PM\u0022 data-short=\u00227 yr\u0022\u003EJuly 21, 2016\u003C/time\u003E by surge\u003C/strong\u003E\n\u003C/span\u003E\n"}]}