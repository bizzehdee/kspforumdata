{"TopicId":9385,"ForumId":36,"TopicTitle":"One Attitude Controller to Rule Them All","CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-09T17:08:09Z","PageNum":1,"Articles":[{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-09T17:08:09Z","Content":"\n\u003Cp\u003E(\u003Ca href=\u0022https://en.wikipedia.org/wiki/Black_speech\u0022 rel=\u0022external nofollow\u0022\u003EI couldn\\\u0027t help the puns.\u003C/a\u003E)\u003C/p\u003E\u003Cp\u003ESome of the most popular plugins seem to be autopilots. Whatever these plugins do, they all share at least one common component: an attitude controller. Why? Because if you\\\u0027re an autopilot, you need to be able to \u003Cem\u003Esteer\u003C/em\u003E!\u003C/p\u003E\u003Cp\u003EWhile working on an autopilot plugin of my own (precision descent controller) I found that the attitude control problem is much more complicated than I had originally expected. It\\\u0027s easy to come up with primitive solutions, but these have problems that seriously limit their potential uses. The following is a (probably incomplete) list of features than an ideal attitude controller has:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003E\u003Cbr\u003E[li]\u003Cstrong\u003EOrientation control\u003C/strong\u003E - This is the core function of an attitude controller. The user (which is usually some other code) tells the attitude controller to put the ship at a specified orientation.[/li]\u003Cbr\u003E[li]\u003Cstrong\u003EStability\u003C/strong\u003E - There are various mathematical definitions of controller stability, and they\\\u0027re important. We don\\\u0027t want our ships to oscillate or spin out of control.[/li]\u003Cbr\u003E[li]\u003Cstrong\u003EDisturbance rejection\u003C/strong\u003E - KSP is a simple simulator, but there are still some disturbances to account for. Angular drag can be accounted for ahead of time, but things like collisions or floating-point errors can\\\u0027t be predicted.[/li]\u003Cbr\u003E[li]\u003Cstrong\u003EDisturbance compensation\u003C/strong\u003E - I put this in a different category because it\\\u0027s a slightly different problem. Imagine you grapple another ship with some lander legs, and then you make an orbital burn. The second ship is slightly off-center. A plugin can\\\u0027t compensate for the offset center of mass, so your attitude will always be slightly off. A proper attitude controller will detect (usually through error integration) that it must apply additional torque in order to stay on course.[/li]\u003Cbr\u003E[li]\u003Cstrong\u003EOptimal pathing\u003C/strong\u003E - This is where simple (usually Euler angle-based) attitude controllers really fall short. When we\\\u0027re adjusting the orientation of the ship, we want to take the shortest path to get there. It\\\u0027s quicker, which is always good, but it\\\u0027s also more stable. If you\\\u0027re launching and you want to roll your ship 180 degrees, a simple attitude controller might pitch you 90 degrees forward, yaw around 180 degrees, and then pitch 90 degrees up. That\\\u0027ll crash your ship.[/li]\u003Cbr\u003E[li]\u003Cstrong\u003ESpeed\u003C/strong\u003E - Some maneuvers require a quick attitude change, so our controller should make reasonable use of available torque.[/li]\u003Cbr\u003E[li]\u003Cstrong\u003ERate control\u003C/strong\u003E - Suppose you want to spin in a controlled way. The user code might set a moving orientation target, but many controllers will lag a set distance behind, depending on how fast the target is moving. An ideal controller allows the user to specify a target rate.[/li]\u003Cbr\u003E[li]\u003Cstrong\u003ERoll ambivalence\u003C/strong\u003E - Sometimes, we only care about where we are on the navball, and we\\\u0027re happy to let our roll do whatever we (or the pilot) want. I believe this is a minimization problem, and that we can\\\u0027t simply ignore the roll commands. (More details in \u003C/li\u003E\u003C/ul\u003E\u003Ca href=\u0022http://kerbalspaceprogram.com/forum/index.php?topic=10326.msg155208#msg155208\u0022 rel=\u0022external nofollow\u0022\u003Ethis post\u003C/a\u003E. Thanks The_Duck for reminding me of this issue.)[/li]\u003Cbr\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENow, let me be clear: this is only a wish list. Even to get just a few of these, we need to dig into some pretty heady academic papers. I\\\u0027ve read through a few myself, but unfortunately I don\\\u0027t have any formal training in control systems, so some of it goes over my head.\u003C/p\u003E\u003Cp\u003ELet\\\u0027s take a look at an existing (KSP) attitude controller and see how it stacks up. (If none of this paragraph makes sense, just skip to the last sentence.) Since MechJeb is pretty popular, I\\\u0027m going to pick on it. The MechJeb \u0027Smart A.S.S.\u0027 accepts a target orientation (as a quaternion) and computes the orientation change required to move from the ship\\\u0027s current orientation to the desired orientation. After this, it breaks down a little; Euler angles, angular velocity and angular acceleration are combined in an attitude-control PID, with some special cases where the error quaternion is slerp\\\u0027d. The result is that MechJeb can make large-angle changes, but it can be unstable and makes a convoluted path.\u003C/p\u003E\u003Cp\u003EI tried my hand at something smoother. (I can\\\u0027t find the paper I derived the control law from, but I\\\u0027ll grab it from my laptop sometime.) This control law was quaternion-based and avoided Euler angles completely. It also made \u003Cem\u003Eabsolutely no sense\u003C/em\u003E to me. I don\\\u0027t know how or why it works, but it does. The pathing isn\\\u0027t completely optimal (I don\\\u0027t think) but it\\\u0027s pretty damn near close. It\\\u0027s fast. It\\\u0027s stable, both subjectively and in at least one mathematical sense. I didn\\\u0027t understand enough of the paper to properly calibrate the controller for the ship\\\u0027s moment of inertia, but the results were pretty good even so.\u003C/p\u003E\u003Cp\u003EI think MechJeb and some other plugins would immediately benefit by implementing the controller as-is, but I think we can do better. As a first milestone, I propose creating an attitude controller with the following of the above features:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cul\u003E\u003Cli\u003E\u003Cbr\u003E[li]Quaternion-based orientation control[/li]\u003Cbr\u003E[li]Disturbance rejection (in other words, don\\\u0027t pilot blindly)[/li]\u003Cbr\u003E[li]Optimal pathing[/li]\u003Cbr\u003E[li]Optimal settling speed, within a threshold (this means our controller should measure available torque and the ship\\\u0027s moment of inertia and fly accordingly).[/li]\u003Cbr\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe first two are easy; a simple PID can do it. The second two are much more challenging, and will require some math-fu. I think it\\\u0027ll pay off, though. Who\\\u0027s up for helping? 8)\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-09T21:40:34Z","Content":"\n\u003Cp\u003EAlright, I found the paper. I took equation (10) from this paper: \u003Ca href=\u0022http://www.ajc.org.tw/pages/paper/5.3PD/9FR-02-18.pdf\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://www.ajc.org.tw/pages/paper/5.3PD/9FR-02-18.pdf\u003C/a\u003E\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C!%5Cunderline%7Bu%7D%20%3D%20-%5Cfrac%7B2%7D%7B%5Crho%5E2%7D%20%28a%5Cunderline%7B%5Comega%7D%20%2B%20b_1%5Cunderline%7B%5Cvarepsilon%7D%20%2B%20b_2%5Ceta%5Cunderline%7B%5Cvarepsilon%7D%29.gif\u0022 alt=\u0022%5CLARGE%5C!%5Cunderline%7Bu%7D%20%3D%20-%5Cfrac%7B2%7D%7B%5Crho%5E2%7D%20%28a%5Cunderline%7B%5Comega%7D%20%2B%20b_1%5Cunderline%7B%5Cvarepsilon%7D%20%2B%20b_2%5Ceta%5Cunderline%7B%5Cvarepsilon%7D%29.gif\u0022\u003E\u003C/p\u003E\u003Cp\u003ENow, I\\\u0027m definitely missing a \u003Cem\u003Elot\u003C/em\u003E of the insights from that paper, but it\\\u0027s still progress! There are four constants (?, a, b1, b2). ? is angular velocity, ? is the vector part of the error quaternion, and ? is the scalar part. \u003Cem\u003EFor some reason, this works really well.\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EI\\\u0027m working on compiling a list of some more resources that might help us here.\u003C/p\u003E\n"},{"CreatedByName":"drewmacrae","CreatedById":7532,"CreatedDateTime":"2012-04-09T22:05:02Z","Content":"\n\u003Cp\u003EI\\\u0027d love to help. I\\\u0027ll keep an eye on this and I\\\u0027ll let you know if I feel able to make a substantive contribution.\u003C/p\u003E\n"},{"CreatedByName":"thorfinn","CreatedById":8349,"CreatedDateTime":"2012-04-09T22:07:17Z","Content":"\n\u003Cp\u003EYou know, I\\\u0027d like to expand my little ASAS hack that I published before Easter with some of the same things you mention in your list \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E Seems like we have a common interest... though I\\\u0027m more interested in \u0027pilot assistance\u0027 devices, while you seem to be more interested in autopilots.\u003C/p\u003E\u003Cp\u003EA better algorithm for RCS was one of the things I wanted to try and make; but right now we have a big limitation... we can\\\u0027t split RCS control from SAS and fin control; and the correct algos for each of these systems are different. Do you have any idea for a workaround?\u003C/p\u003E\u003Cp\u003EI don\\\u0027t know how much free time I will have to put into this, but I\\\u0027m game.\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-09T22:21:14Z","Content":"\n\u003Cp\u003E\u003Ca href=\u0022http://www.nt.ntnu.no/users/skoge/prost/proceedings/acc05/PDFs/Papers/0165_WeB11_4.pdf\u0022 rel=\u0022external nofollow\u0022\u003EThis paper\u003C/a\u003E seems to imply that an asymptotically stable controller will necessarily follow an optimal path. I don\\\u0027t really see how that\\\u0027s true, but it\\\u0027s worth noting anyway. Most literature seems to stress various kinds of stability, and doesn\\\u0027t make much reference to pathing.\u003C/p\u003E\u003Cp\u003EIt occurred to me that there\\\u0027s at least one easy way to implement rate control as I described it. If we already have a linear controller where ? (angular velocity) is one of the components, we can substitute ??, the difference between the current and desired angular velocity. If the controller has the right angular velocity but lags behind, the error quaternion component(s) should correct it as normal. If the target orientation isn\\\u0027t actually moving, the controller will pull in the direction of the target angular velocity, but this is a user (and by that I mean user code) error. Such a construction would, however, probably invalidate any assumptions of stability that we can derive from literature.\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-09T22:29:18Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EYou know, I\\\u0027d like to expand my little ASAS hack that I published before Easter with some of the same things you mention in your list \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E Seems like we have a common interest... though I\\\u0027m more interested in \u0027pilot assistance\u0027 devices, while you seem to be more interested in autopilots.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI\\\u0027m interested in both, but you can\\\u0027t have either without a solid foundation. I spent a couple weeks working on a landing computer, but I got very frustrated that some things (attitude control, drag modeling, etc.) were so complex. The community at large seems only to have scratched the surface of these core components.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EA better algorithm for RCS was one of the things I wanted to try and make; but right now we have a big limitation... we can\\\u0027t split RCS control from SAS and fin control; and the correct algos for each of these systems are different. Do you have any idea for a workaround?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThat depends. If there\\\u0027s a way to manually fire RCS without using the fly-by-wire controls, then yes, I think it can be done. (By the way, I strongly suspect it\\\u0027s possible to do exactly what, since the RCS thruster class exposes thrust levels for each of its axes. At the very least, a replacement RCS class could do it.) Plugins can both monitor user input and override it, so you could split off the RCS logic and only use the fly-by-wire controls for capsule SAS, which is a much simpler model. You might run into trouble if your part\\\u0027s fly-by-wire delegate runs after some other autopilot\\\u0027s, but since there are only a handful of autopilot plugins anyway, it should be pretty easy to have them integrate with your plugin when it\\\u0027s present.\u003C/p\u003E\u003Cp\u003EOut of curiosity, in what ways do SAS, RCS and fins need to be treated differently? (I mean, not flapping fins around while in orbit would be great, but that\\\u0027s sort of harmless.)\u003C/p\u003E\n"},{"CreatedByName":"The_Duck","CreatedById":1156,"CreatedDateTime":"2012-04-09T22:38:42Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Majiir\u0022 data-cite=\u0022Majiir\u0022\u003E\u003Cdiv\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C!%5Cunderline%7Bu%7D%20%3D%20-%5Cfrac%7B2%7D%7B%5Crho%5E2%7D%20%28a%5Cunderline%7B%5Comega%7D%20%2B%20b_1%5Cunderline%7B%5Cvarepsilon%7D%20%2B%20b_2%5Ceta%5Cunderline%7B%5Cvarepsilon%7D%29.gif\u0022 alt=\u0022%5CLARGE%5C!%5Cunderline%7Bu%7D%20%3D%20-%5Cfrac%7B2%7D%7B%5Crho%5E2%7D%20%28a%5Cunderline%7B%5Comega%7D%20%2B%20b_1%5Cunderline%7B%5Cvarepsilon%7D%20%2B%20b_2%5Ceta%5Cunderline%7B%5Cvarepsilon%7D%29.gif\u0022\u003E\u003Cp\u003ENow, I\\\u0027m definitely missing a \u003Cem\u003Elot\u003C/em\u003E of the insights from that paper, but it\\\u0027s still progress! There are four constants (?, a, b1, b2). ? is angular velocity, ? is the vector part of the error quaternion, and ? is the scalar part. \u003Cem\u003EFor some reason, this works really well.\u003C/em\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI\\\u0027ve only spent about 5 minutes looking at that paper, and I\\\u0027m not very familiar with quaternions, but it seems to me that this is more or less a PD controller? If I understand things correctly then\u003C/p\u003E\u003Cp\u003E-The omega term says to apply a torque opposite the current angular velocity (like a PID\\\u0027s D term).\u003C/p\u003E\u003Cp\u003E-the two epsilon terms say to apply a torque opposite the current angular error (like a PID\\\u0027s P term). For small errors the torque is indeed proportional to the error, if I understand quaternions correctly. \u003C/p\u003E\u003Cp\u003EOne thing to consider in an attitude controller for KSP is that often we only care about the pointing direction and not the roll around the pointing direction. I\\\u0027m not sure how easy it is to be disentangle the two when using quaternions?\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-09T22:47:37Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022The_Duck\u0022 data-cite=\u0022The_Duck\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EI\\\u0027ve only spent about 5 minutes looking at that paper, and I\\\u0027m not very familiar with quaternions, but it seems to me that this is more or less a PD controller? If I understand things correctly then\u003C/p\u003E\u003Cp\u003E-The u term says to apply a torque opposite the current angular velocity (like a PID\\\u0027s D term).\u003C/p\u003E\u003Cp\u003E-the two epsilon terms say to apply a torque opposite the current angular error (like a PID\\\u0027s P term). For small errors the torque is indeed proportional to the error, if I understand quaternions correctly.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYes, it\\\u0027s much like a PD. I think the eta term (the second epsilon term) is important, though. Somehow. Don\\\u0027t ask me how. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E\u003C/p\u003E\u003Cp\u003E[EDIT] I should mention that only the part I\\\u0027ve pulled out resembles a PD. There\\\u0027s a lot more in there that I completely ignored (for lack of understanding it) which I believe makes the controller aware of the spacecraft\\\u0027s torque and inertia characteristics.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022The_Duck\u0022 data-cite=\u0022The_Duck\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EOne thing to consider in an attitude controller for KSP is that often we only care about the pointing direction and not the roll around the pointing direction. I\\\u0027m not sure how easy it is to be disentangle the two when using quaternions?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThanks for reminding me of this; I need to include this in my original post.\u003C/p\u003E\u003Cp\u003EI think we need to approach this from the math side. We don\\\u0027t want to approach a given quaternion and simply ignore the roll commands; that could lead to instability (as I\\\u0027ve found out the hard way). What we\\\u0027re really doing is specifying an entire \u003Cem\u003Eset\u003C/em\u003E of quaternions, any of which we\\\u0027d be happy with. This set is essentially any of the quaternions that result when the desired quaternion is rolled any which way. Now we need a way to determine which quaternion(s) in that set are \u0027easiest\u0027 to reach. This may be a simple minimization problem, but without a good understanding of optimal pathing, I\\\u0027m not sure we can tackle this quite yet.\u003C/p\u003E\u003Cp\u003E[EDIT] I\\\u0027ve got a working list of sources I\\\u0027ve been looking at \u003Ca href=\u0022https://gist.github.com/2345297\u0022 rel=\u0022external nofollow\u0022\u003Ehere\u003C/a\u003E. I\\\u0027ll throw up good PDF links later, but Google should be able to find those.\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-10T00:55:47Z","Content":"\n\u003Cp\u003EOkay, I\\\u0027m digging into this rolling thing a bit.\u003C/p\u003E\u003Cp\u003EThe Wikipedia article on \u003Ca href=\u0022https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\u0022 rel=\u0022external nofollow\u0022\u003Econversion between quaternions and Euler angles\u003C/a\u003E, the following equations are given:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C%21%5Clarge%5Cbegin%7Beqnarray%2A%7D%5Cmathbf%7Bq%7D_0%20%26%3D%26%20%5Ccos%28%5Calpha/2%29%5C%5C%5Cmathbf%7Bq%7D_1%20%26%3D%26%20%5Csin%28%5Calpha/2%29%5Ccos%28%5Cbeta_x%29%5C%5C%5Cmathbf%7Bq%7D_2%20%26%3D%26%20%5Csin%28%5Calpha/2%29%5Ccos%28%5Cbeta_y%29%5C%5C%5Cmathbf%7Bq%7D_3%20%26%3D%26%20%5Csin%28%5Calpha/2%29%5Ccos%28%5Cbeta_z%29%5Cend%7Beqnarray%2A%7D.gif\u0022 alt=\u00222%29%5Ccos%28%5Cbeta_z%29%5Cend%7Beqnarray%2A%7D.gif\u0022\u003E\u003C/p\u003E\u003Cp\u003EI think our axis for a roll would be [0, 1, 0] giving us the following:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C%21%5Clarge%5Cbegin%7Beqnarray%2A%7D%5Cmathbf%7Bq%7D_0%20%26%3D%26%20%5Ccos%28%5Calpha/2%29%5C%5C%5Cmathbf%7Bq%7D_1%20%26%3D%26%200%5C%5C%5Cmathbf%7Bq%7D_2%20%26%3D%26%20%5Csin%28%5Calpha/2%29%5C%5C%5Cmathbf%7Bq%7D_3%20%26%3D%26%200%5C%5C%5Calpha%20%26%3D%26%20%5B0%2C%204%5Cpi%29%5Cend%7Beqnarray%2A%7D.gif\u0022 alt=\u00222%29%5C%5C%5Cmathbf%7Bq%7D_3%20%26%3D%26%200%5C%5C%5Calpha%20%26%3D%26%20%5B0%2C%204%5Cpi%29%5Cend%7Beqnarray%2A%7D.gif\u0022\u003E\u003C/p\u003E\u003Cp\u003EThe angle range is double what you might expect because there are two quaternion representations for any given rotation. Now, since we don\\\u0027t care about roll, we can feel free to apply any rotation from this set to our quaternion setpoint.\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C%21%5Clarge%5Cmathbf%7Bq%7D%20%3D%20q_rq_s.gif\u0022 alt=\u0022%5CLARGE%5C%21%5Clarge%5Cmathbf%7Bq%7D%20%3D%20q_rq_s.gif\u0022\u003E\u003C/p\u003E\u003Cp\u003EOur goal is to find a q_r such that the \u003Cem\u003Eangular distance\u003C/em\u003E between \u003Cstrong\u003Eq\u003C/strong\u003E (above) and q_v (the current orientation of our vessel) is minimized. Stated a different way, we want to minimize the following quaternion product:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C%21%5Clarge%7Bq_v%7D%5E%7B-1%7D%5Cmathbf%7Bq%7D%20%3D%20%7Bq_v%7D%5E%7B-1%7Dq_rq_s.gif\u0022 alt=\u0022%5CLARGE%5C%21%5Clarge%7Bq_v%7D%5E%7B-1%7D%5Cmathbf%7Bq%7D%20%3D%20%7Bq_v%7D%5E%7B-1%7Dq_rq_s.gif\u0022\u003E\u003C/p\u003E\u003Cp\u003EI\\\u0027m just not sure how to determine the \u0027distance\u0027 between two quaternions, or a meaningful \u0027angular magnitude\u0027 of a quaternion. Various sources indicate that the dot product is or isn\\\u0027t acceptable. Any ideas?\u003C/p\u003E\n"},{"CreatedByName":"CAPFlyer","CreatedById":8575,"CreatedDateTime":"2012-04-10T16:27:20Z","Content":"\n\u003Cp\u003EThank you for looking into this.\u003C/p\u003E\u003Cp\u003EHere\\\u0027s something that kinda irritates me with MechJeb but not to a huge extent because we\\\u0027re still waiting on the full rebuild of the atmospheric flight model(s).\u003C/p\u003E\u003Cp\u003ERoll should not be ignored or left to pilot input. The moment you put lifting surfaces on a rocket you \u003Cstrong\u003Emust\u003C/strong\u003E control roll as part of maintaining its proper path. Imagine if NASA tried to launch the shuttle and instead of pitching head\\\u0027s down they rolled only 90 degrees and had the ship essentially flying on it\\\u0027s side. Now try to maintain the pitch attitude \u003Cstrong\u003Eand\u003C/strong\u003E yaw it along the path. You\\\u0027re fighting a lot more resistance to movement doing it that way because you have a lot less control authority. By pitching \\\u0027heads down\\\u0027, you not only increase the comfort of the crew, you also put all the control authority on your side. The upward-canted SSME\\\u0027s have the most movement available when on the bottom of the stack, you have the body flap, the elevons, and the SRB gimbals all working for you. Additionally, the lifting surface of the wing and the combined SRB/ET stack helps to stabilize the entire stack by pushing it forward.\u003C/p\u003E\u003Cp\u003EPeople seem to think that a rocket can really launch in any direction. There\\\u0027s a reason that the designers always have the rockets roll \u0027heads down\u0027. There\\\u0027s a function to it. It not only minimizes the felt acceleration for the payload (whether human or mechanical) but it also makes sure that on those vehicles that have lifting surfaces they\\\u0027re used to the maximum effect.\u003C/p\u003E\n"},{"CreatedByName":"semininja","CreatedById":3837,"CreatedDateTime":"2012-04-10T17:15:18Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022CAPFlyer\u0022 data-cite=\u0022CAPFlyer\u0022\u003E\u003Cdiv\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003EThank you for looking into this.\u003C/p\u003E\u003Cp\u003EHere\\\u0027s something that kinda irritates me with MechJeb but not to a huge extent because we\\\u0027re still waiting on the full rebuild of the atmospheric flight model(s).\u003C/p\u003E\u003Cp\u003ERoll should not be ignored or left to pilot input. The moment you put lifting surfaces on a rocket you \u003Cstrong\u003Emust\u003C/strong\u003E control roll as part of maintaining its proper path. Imagine if NASA tried to launch the shuttle and instead of pitching head\\\u0027s down they rolled only 90 degrees and had the ship essentially flying on it\\\u0027s side. Now try to maintain the pitch attitude \u003Cstrong\u003Eand\u003C/strong\u003E yaw it along the path. You\\\u0027re fighting a lot more resistance to movement doing it that way because you have a lot less control authority. By pitching \\\u0027heads down\\\u0027, you not only increase the comfort of the crew, you also put all the control authority on your side. The upward-canted SSME\\\u0027s have the most movement available when on the bottom of the stack, you have the body flap, the elevons, and the SRB gimbals all working for you. Additionally, the lifting surface of the wing and the combined SRB/ET stack helps to stabilize the entire stack by pushing it forward.\u003C/p\u003E\u003Cp\u003EPeople seem to think that a rocket can really launch in any direction. There\\\u0027s a reason that the designers always have the rockets roll \u0027heads down\u0027. There\\\u0027s a function to it. It not only minimizes the felt acceleration for the payload (whether human or mechanical) but it also makes sure that on those vehicles that have lifting surfaces they\\\u0027re used to the maximum effect.\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI think I\\\u0027m gonna make a suggestion of a roll setting in the ascent autopilot and in the SASS.\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-11T21:17:51Z","Content":"\n\u003Cp\u003ESo I don\\\u0027t think the dot product can help us with the roll-minimization problem.\u003C/p\u003E\u003Cp\u003EYou can use a quaternion dot product to find the angle between two quaternions, but roll doesn\\\u0027t change the angle, it changes the \u003Cem\u003Edirection of the vector component\u003C/em\u003E. I\\\u0027ll have to think about this in a different way.\u003C/p\u003E\n"},{"CreatedByName":"thorfinn","CreatedById":8349,"CreatedDateTime":"2012-04-11T21:45:38Z","Content":"\n\u003Cp\u003EI think I don\\\u0027t really understand what you mean by \u0027shortest path\u0027. You\\\u0027re thinking at rolling the ship to bring one axis in the plane of the required maneuver, and then do a pitch or yaw to the new attitude, instead of maneuvering the two axes simutaneously?\u003C/p\u003E\u003Cp\u003EYes, with a long and thin ship, the difference in moments of inertia should make that economical in terms of fuel expenditure or speed over a considerable range; \u003Cem\u003Epersonally\u003C/em\u003E, I wouldn\\\u0027t want the craft to roll if I have not commanded it, unless the scenario is punching some numbers in the computer for a large attitude change. But I suppose you meant just that... (it should roll back to the original angle at the end of the maneuver, though)\u003C/p\u003E\u003Cp\u003ERe. the algorithms for RCS and fins: well, maneuvers with reaction controls should be done as acceleration-coast-deceleration, while the aerodynamic surfaces generally need a constant input to mantain rate (since you\\\u0027re counteracting the natural stability of the craft). SAS is a middle ground, in that it behaves sorta like RCS, but you don\\\u0027t have to worry about not wasting fuel.\u003C/p\u003E\u003Cp\u003EAs for what we have now, the ASAS oscillations are due to\u003Cem\u003E integral windup\u003C/em\u003E.\u003C/p\u003E\u003Cp\u003EThe ASAS PID tries to bring angular momentum to zero, plain and simple... since when the value actually crosses zero, the integral term still \u0027remembers\u0027 the precedent offset, the ASAS keeps thrusting/torquing until the error in the opposite direction cancels the integral, then it starts bouncing back (at reduced amplitude).\u003C/p\u003E\u003Cp\u003EMy first fix would be shortening the \u0027memory span\u0027 of the ASAS: I\\\u0027d try to add an exponential decay to the integral value, with a time constant of... uhm... 500 msec? Does that make any sense for you? If I don\\\u0027t hear objections, I\\\u0027ll try it in my modded ASAS and see how it goes \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E\u003C/p\u003E\u003Cp\u003EAs for the Shuttle attitude at launch: I think that the heads down attitude wasn\\\u0027t particularly more stable, but since the SSMEs need to be angled upwards to have their thrust going through the center of gravity, in this way the sideways thrust component is directed up, where it\\\u0027s useful... flying in normal attitude would mean pushing downwards.\u003C/p\u003E\u003Cp\u003EAnybody knows which way the Energija/Buran pitched? Or even better, the cargo version of Energija (the Polyus launch, for example)?\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-11T22:05:17Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EI think I don\\\u0027t really understand what you mean by \u0027shortest path\u0027. You\\\u0027re thinking at rolling the ship to bring one axis in the plane of the required maneuver, and then do a pitch or yaw to the new attitude, instead of maneuvering the two axes simutaneously?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EImagine that you trace a marker along the navball whenever you rotate. The most efficient rotation will appear to be a straight line on the ball. Some control laws, especially those that use Euler angles, will make a meandering path.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EYes, with a long and thin ship, the difference in moments of inertia should make that economical in terms of fuel expenditure or speed over a considerable range; \u003Cem\u003Epersonally\u003C/em\u003E, I wouldn\\\u0027t want the craft to roll if I have not commanded it, unless the scenario is punching some numbers in the computer for a large attitude change. But I suppose you meant just that... (it should roll back to the original angle at the end of the maneuver, though)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe roll problem is something else entirely. Imagine you have a symmetrical ship and you want an autopilot to hold it at 5 degrees pitching north. That\\\u0027s a pretty small change, and you don\\\u0027t want the autopilot to also roll your ship all the way around to align with some arbitrary horizon that it picked. You just care about the pitch and heading. I\\\u0027m trying to figure out a way to analytically find a setpoint that won\\\u0027t issue a roll command.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003E\u003Cp\u003ERe. the algorithms for RCS and fins: well, maneuvers with reaction controls should be done as acceleration-coast-deceleration, while the aerodynamic surfaces generally need a constant input to mantain rate (since you\\\u0027re counteracting the natural stability of the craft). SAS is a middle ground, in that it behaves sorta like RCS, but you don\\\u0027t have to worry about not wasting fuel.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EOne thing you can do is only activate RCS thrusters if the attitude controller wants more torque than the SAS or fins can provide. You could also supply the attitude controller with some parameters for how it should behave, since the fastest control action isn\\\u0027t usually as fuel-efficient.\u003C/p\u003E\u003Cp\u003ERegarding fins, I think you need a constant input because you\\\u0027re in atmosphere, not because you\\\u0027re controlling fins. Imagine using fixed fins and SAS to keep the ship pitched over slightly; you\\\u0027ll still need a constant torque because your heading and velocity are different, and the fins are torquing you back. All that said, it wouldn\\\u0027t hurt to give fins the same treatment as RCS, and only move them when SAS isn\\\u0027t enough. (You could even attempt to move fins as few times as possible, or as smoothly as possible, using SAS torque to cover the difference. It would make a big visual impact, since fins currently jerk all over the place.)\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EAs for what we have now, the ASAS oscillations are due to\u003Cem\u003E integral windup\u003C/em\u003E.\u003C/p\u003E\u003Cp\u003EThe ASAS PID tries to bring angular momentum to zero, plain and simple... since when the value actually crosses zero, the integral term still \u0027remembers\u0027 the precedent offset, the ASAS keeps thrusting/torquing until the error in the opposite direction cancels the integral, then it starts bouncing back (at reduced amplitude).\u003C/p\u003E\u003Cp\u003EMy first fix would be shortening the \u0027memory span\u0027 of the ASAS: I\\\u0027d try to add an exponential decay to the integral value, with a time constant of... uhm... 500 msec? Does that make any sense for you? If I don\\\u0027t hear objections, I\\\u0027ll try it in my modded ASAS and see how it goes \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif\u0022 alt=\u0022;)\u0022\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EActually, I\\\u0027m not sure integral windup is the problem. Remember, when the ship is approaching the ASAS target point, the error in angular momentum is the \u003Cem\u003Eopposite sign\u003C/em\u003E of the integral. In other words, as you get closer, you\\\u0027re already ticking down the integral. The moment you hit where you want to be, the integral term is already zero. Most of the oscillation problems are actually caused by the proportional term, since the PID\\\u0027s constants aren\\\u0027t tuned to account for the torque or inertia of the vessel. They\\\u0027re just some arbitrary constants that Harvester determined were \u0027good enough\u0027 for most ships. There are also problems caused by the derivative term; most notably, if you\\\u0027re only spinning slightly and you activate ASAS, you\\\u0027ll \u0027jerk\u0027 in a random direction for a moment.\u003C/p\u003E\u003Cp\u003EIntegral windup is a problem when you\\\u0027re spinning very quickly in a heavy ship with little torque. When you activate the ASAS, you might actually spin around a few times before it slows you all the way down, and now the integral term has accumulated \u003Cem\u003Eseveral revolutions\u003C/em\u003E worth of angular momentum change. In order to wind that down, it needs to make a few revolutions back, and since the ship is heavy and the PID isn\\\u0027t tuned for the ship\\\u0027s characteristics, you get integral windup in the other direction for a while. Eventually, the proportional term and angular drag work it all out, but it can make already difficult-to-control ships a real challenge to fly.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EAs for the Shuttle attitude at launch: I think that the heads down attitude wasn\\\u0027t particularly more stable, but since the SSMEs need to be angled upwards to have their thrust going through the center of gravity, in this way the sideways thrust component is directed up, where it\\\u0027s useful... flying in normal attitude would mean pushing downwards.\u003C/p\u003E\u003Cp\u003EAnybody knows which way the Energija/Buran pitched? Or even better, the cargo version of Energija (the Polyus launch, for example)?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI think you\\\u0027re right about this; the SSME gimbals couldn\\\u0027t angle \u0027down\u0027 in the same way. I don\\\u0027t know about the Energia, but it was sufficiently different. (It had two engines, and its carrier rocket had eight, some/all of which were liquid.)\u003C/p\u003E\n"},{"CreatedByName":"CAPFlyer","CreatedById":8575,"CreatedDateTime":"2012-04-11T22:40:50Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022thorfinn\u0022 data-cite=\u0022thorfinn\u0022\u003E\u003Cdiv\u003EAs for the Shuttle attitude at launch: I think that the heads down attitude wasn\\\u0027t particularly more stable, but since the SSMEs need to be angled upwards to have their thrust going through the center of gravity, in this way the sideways thrust component is directed up, where it\\\u0027s useful... flying in normal attitude would mean pushing downwards.\u003Cp\u003EAnybody knows which way the Energija/Buran pitched? Or even better, the cargo version of Energija (the Polyus launch, for example)?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe engines of the shuttle were angled the way they were to ensure that sufficient thrust offset was created to balance the asymmetric drag and lift of the combined vehicle stack. No matter which way you pointed the ship, the shuttle would tend to \u0027pull\u0027 the stack. The head down position was to maximize leverage of that asymmetric drag to help with the gravity turn so that you were spending the least amount of fuel in maintaining the ship\\\u0027s attitude possible and thus wasted energy. The proof of this is that later in the program, they began rolling the shuttle \u0027heads up\u0027 about 5 minutes into the flight to allow them to utilize satellites to communicate and track the shuttle\\\u0027s ascent as it passed out of range of the tracking station in Bermuda. As the shuttle was no longer having to offset the thrust of the SRB\\\u0027s, there was also a net \u0027push\u0027 to the stack as the ET drag in the atmosphere would tend to require an \u0027up\u0027 thrust component to offset, even if minor, again, to the advantage of a heads-down shuttle until high enough that atmospheric drag was no longer a major component.\u003C/p\u003E\u003Cp\u003EAs for Energia/Buran, it also rolled heads down, just as the Soyuz stack does. It\\\u0027s a fairly \u0027universal\u0027 maneuver.\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-12T00:16:15Z","Content":"\n\u003Cp\u003EI made a custom RCS block which ignores control input and accepts commands from plugin code. You\\\u0027ve got to extend RCSModule, override onCtrlUpd() and be sure to \u003Cem\u003Enot\u003C/em\u003E call the base method. Also override onPartFixedUpdate(), and in this method construct a fresh FlightCtrlState object with your desired controls. (These can be stored in properties or something.) Call base.onCtrlUpd() with that state, and then call base.onPartFixedUpdate(). I think the same will work for the stabilizer fins.\u003C/p\u003E\u003Cp\u003E[EDIT] Success! Take a look:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cimg src=\u0022http://nabaal.net/files/screenshot10.png\u0022 alt=\u0022screenshot10.png\u0022\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EIf you look closely (it\\\u0027s a bad shot, I know) you can see that the pitch/yaw/roll controls are all zero, the RCS thrusters are pitching the ship, and the fins are rolling it. This, of course, left the ship nearly impossible to control even with my flight computer, but I think it\\\u0027s a sound proof of concept. Currently, this is my code for issuing the commands:\u003C/p\u003E\u003Cp\u003E(Ignore the vessel.transform.rotation bit for now.)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eforeach (var part in vessel.parts)\u003Cbr\u003E{\u003Cbr\u003E  if (part is SmartRCSModule)\u003Cbr\u003E  {\u003Cbr\u003E    ((SmartRCSModule)part).InputRotation = vessel.transform.rotation * new Vector3(0.5f, 0, 0);\u003Cbr\u003E  }\u003Cbr\u003E  if (part is SmartControlSurface)\u003Cbr\u003E  {\u003Cbr\u003E    ((SmartControlSurface)part).InputRotation = vessel.transform.rotation * new Vector3(0, -0.5f, 0);\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"semininja","CreatedById":3837,"CreatedDateTime":"2012-04-12T01:00:10Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Majiir\u0022 data-cite=\u0022Majiir\u0022\u003E\u003Cdiv\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003EI made a custom RCS block which ignores control input and accepts commands from plugin code. You\\\u0027ve got to extend RCSModule, override onCtrlUpd() and be sure to \u003Cem\u003Enot\u003C/em\u003E call the base method. Also override onPartFixedUpdate(), and in this method construct a fresh FlightCtrlState object with your desired controls. (These can be stored in properties or something.) Call base.onCtrlUpd() with that state, and then call base.onPartFixedUpdate(). I think the same will work for the stabilizer fins.\u003C/p\u003E\u003Cp\u003E[EDIT] Success! Take a look:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://nabaal.net/files/screenshot10.png\u0022 alt=\u0022screenshot10.png\u0022\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003C/blockquote\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EIf you look closely (it\\\u0027s a bad shot, I know) you can see that the pitch/yaw/roll controls are all zero, the RCS thrusters are pitching the ship, and the fins are rolling it. This, of course, left the ship nearly impossible to control even with my flight computer, but I think it\\\u0027s a sound proof of concept. Currently, this is my code for issuing the commands:\u003C/p\u003E\u003Cp\u003E(Ignore the vessel.transform.rotation bit for now.)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eforeach (var part in vessel.parts)\u003Cbr\u003E{\u003Cbr\u003E  if (part is SmartRCSModule)\u003Cbr\u003E  {\u003Cbr\u003E    ((SmartRCSModule)part).InputRotation = vessel.transform.rotation * new Vector3(0.5f, 0, 0);\u003Cbr\u003E  }\u003Cbr\u003E  if (part is SmartControlSurface)\u003Cbr\u003E  {\u003Cbr\u003E    ((SmartControlSurface)part).InputRotation = vessel.transform.rotation * new Vector3(0, -0.5f, 0);\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Cspan style=\u0022text-decoration:line-through;\u0022\u003ELooks to me like the RCS thrusters are only applying roll...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003ENever mind, there\\\u0027s some yaw, too. It looks like it\\\u0027s mostly roll, though.\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-12T01:04:29Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022semininja\u0022 data-cite=\u0022semininja\u0022\u003E\u003Cdiv\u003E\u003Cp\u003E\u003Cspan style=\u0022text-decoration:line-through;\u0022\u003ELooks to me like the RCS thrusters are only applying roll...\u003C/span\u003E\u003C/p\u003E\u003Cp\u003ENever mind, there\\\u0027s some yaw, too. It looks like it\\\u0027s mostly roll, though.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIt\\\u0027s a bad picture, but it\\\u0027s working properly. The top and bottom thrusters (relative to the picture) are both thrusting left. The left one is thrusting down, and the right one is thrusting up. There\\\u0027s a little erroneous thrust showing up in other places because the parts jostle around a little bit and their positions don\\\u0027t stay perfectly static.\u003C/p\u003E\u003Cp\u003E[EDIT] I had a thought about the winglets. They could \u003Cspan style=\u0022text-decoration:line-through;\u0022\u003Eeasily\u003C/span\u003E be modified to react to the translation inputs. Stick a set of winglets at the top and bottom of the ship, and you\\\u0027ve got lateral force. The plugin would need to check that enough winglets exist in the right places, because you don\\\u0027t want a translation command to flip the vessel over, but I think I can cook something up. This might be turning into a distinct plugin...\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-16T04:57:49Z","Content":"\n\u003Cp\u003EI\\\u0027m a little frustrated that I can\\\u0027t figure this whole no-roll-control thing, but I had some ideas. First things first: you definitely can\\\u0027t just disable roll torque and expect it to do the same thing. You get instabilities and maybe even singularities. Now, the optimal path from one rotation to another is \u003Cem\u003Eabout the eigenaxis of rotation\u003C/em\u003E. So, if you want to minimize the amount of rotating, you need to minimize the angle (?) of rotation about the axis.\u003C/p\u003E\u003Cp\u003EReviewing the problem for a moment: we\\\u0027re given a target orientation (the setpoint) and our current orientation. Normally, we\\\u0027d match the setpoint exactly, but we don\\\u0027t care about our roll (in this particular case). So, we want to apply a \u0027roll compensation\u0027 to our setpoint such that the \u003Cem\u003Eerror\u003C/em\u003E between the setpoint and our current orientation is minimized.\u003C/p\u003E\u003Cp\u003E[EDIT] Removed derivation.\u003C/p\u003E\n"},{"CreatedByName":"Majiir","CreatedById":7550,"CreatedDateTime":"2012-04-24T18:23:11Z","Content":"\n\u003Cp\u003EAlright, I \u003Cstrong\u003Efigured it out\u003C/strong\u003E. I even found a way to allow freedom of rotation around any arbitrary axis, so you can pitch, yaw, or roll freely, or even rotate freely around some offset axis.\u003C/p\u003E\u003Cp\u003EThe derivation is a bit long, though, and I\\\u0027d like to figure out a way to allow freedom of rotation around multiple axes. (I\\\u0027m not even sure if that makes sense in terms of rotation, but I\\\u0027ll give it a try anyway. An example would be \u0027keep me at 25 degrees pitch, but do whatever you want with roll and heading.\u0027) Currently, the axis of freedom is given as a unit vector; I suspect multiple axes would be specified in a matrix.\u003C/p\u003E\u003Cp\u003EOn the controller front, I\\\u0027m still looking for a control law that accounts for the ship moment of inertia \u003Cem\u003Eand\u003C/em\u003E the available torque. A time-optimal controller may end up being too computationally expensive, so eigenaxis slew maneuvers are fine. It\\\u0027s difficult to find applicable literature since everyone assumes you have real-world problems like imperfect instruments and magnetic fields. :\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E (We \u003Cem\u003Edo\u003C/em\u003E have to cope with angular drag, which we\\\u0027ll want to account for to make the controller faster. I think a more basic, working controller is important first.)\u003C/p\u003E\u003Cp\u003E[EDIT] Here are the setpoint-adjustment equations:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C%21%5Clarge%5Cbegin%7Beqnarray%7D%5Cmathbf%7Bs%7D%20%26%3A%26%20%5Ctext%7Bsetpoint%7D%5C%5C%5Cmathbf%7Bq%7D%20%26%3A%26%20%5Ctext%7Bship%20rotation%7D%5C%5C%5Cvec%7Bu%7D%20%20%20%20%26%3A%26%20%5Ctext%7Baxis%20of%20freedom%20%28unit%20vector%29%7D%5C%5C%5Cmathbf%7Bn%7D%20%26%3A%26%20%5Ctext%7Bnew%20setpoint%7D%5C%5C%5Cend%7Beqnarray%7D.gif\u0022 alt=\u0022%5CLARGE%5C%21%5Clarge%5Cbegin%7Beqnarray%7D%5Cmathbf%7Bs%7D%20%26%3A%26%20%5Ctext%7Bsetpoint%7D%5C%5C%5Cmathbf%7Bq%7D%20%26%3A%26%20%5Ctext%7Bship%20rotation%7D%5C%5C%5Cvec%7Bu%7D%20%20%20%20%26%3A%26%20%5Ctext%7Baxis%20of%20freedom%20%28unit%20vector%29%7D%5C%5C%5Cmathbf%7Bn%7D%20%26%3A%26%20%5Ctext%7Bnew%20setpoint%7D%5C%5C%5Cend%7Beqnarray%7D.gif\u0022\u003E\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://www.texify.com/img/%5CLARGE%5C%21%5Cbegin%7Barray%7D%7Brcl%7D%5Cmathbf%7Bu%7D%20%26%3D%26%20%5Cleft%280%2C%5C%2C%5Cvec%7Bu%7D%5Cright%29%5C%5C%20%20%20%20%5Calpha%20%26%3D%26%20%5Cmathbf%7Bq%7D%5Ccdot%28%5Cmathbf%7Bs%7D%5Cmathbf%7Bu%7D%29%5C%5C%20%20%20%20%20%5Cbeta%20%26%3D%26%20%5Cleft%5C%7B%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cbegin%7Barray%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cfrac%7B%5Cmathbf%7Bq%7D%5Ccdot%5Cmathbf%7Bs%7D%7D%7B%5Calpha%7D%20%5Cqquad%20%26%5Calpha%26%20%26%5Cnot%3D%26%20%260%26%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cfrac%7B%5Cmathbf%7Bq%7D%5Ccdot%5Cmathbf%7Bs%7D%7D%7B%7C%5Cmathbf%7Bq%7D%5Ccdot%5Cmathbf%7Bs%7D%7C%7D%20%5Cqquad%20%26%5Calpha%26%20%26%3D%26%20%260%26%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Barray%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cright.%5C%5C%20%20%20%20%5Cgamma%20%26%3D%26%20%5Cfrac%7B%5Cbeta%7D%7B%5Csqrt%7B%5Cbeta%5E2%20%2B%201%7D%7D%5C%5C%5Cmathbf%7Bn%7D%20%26%3D%26%20%5Cmathbf%7Bs%7D%5Cleft%28%5Csqrt%7B1-%5Cgamma%5E2%7D%2C%5C%2C%5Cgamma%5Cvec%7Bu%7D%5Cright%29%5C%5C%5Cend%7Barray%7D.gif\u0022 alt=\u0022%5CLARGE%5C%21%5Cbegin%7Barray%7D%7Brcl%7D%5Cmathbf%7Bu%7D%20%26%3D%26%20%5Cleft%280%2C%5C%2C%5Cvec%7Bu%7D%5Cright%29%5C%5C%20%20%20%20%5Calpha%20%26%3D%26%20%5Cmathbf%7Bq%7D%5Ccdot%28%5Cmathbf%7Bs%7D%5Cmathbf%7Bu%7D%29%5C%5C%20%20%20%20%20%5Cbeta%20%26%3D%26%20%5Cleft%5C%7B%7B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cbegin%7Barray%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cfrac%7B%5Cmathbf%7Bq%7D%5Ccdot%5Cmathbf%7Bs%7D%7D%7B%5Calpha%7D%20%5Cqquad%20%26%5Calpha%26%20%26%5Cnot%3D%26%20%260%26%20%5C%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cfrac%7B%5Cmathbf%7Bq%7D%5Ccdot%5Cmathbf%7Bs%7D%7D%7B%7C%5Cmathbf%7Bq%7D%5Ccdot%5Cmathbf%7Bs%7D%7C%7D%20%5Cqquad%20%26%5Calpha%26%20%26%3D%26%20%260%26%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Barray%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cright.%5C%5C%20%20%20%20%5Cgamma%20%26%3D%26%20%5Cfrac%7B%5Cbeta%7D%7B%5Csqrt%7B%5Cbeta%5E2%20%2B%201%7D%7D%5C%5C%5Cmathbf%7Bn%7D%20%26%3D%26%20%5Cmathbf%7Bs%7D%5Cleft%28%5Csqrt%7B1-%5Cgamma%5E2%7D%2C%5C%2C%5Cgamma%5Cvec%7Bu%7D%5Cright%29%5C%5C%5Cend%7Barray%7D.gif\u0022\u003E\u003C/p\u003E\u003Cp\u003E[EDIT 2] Here\\\u0027s a working snippet of code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Evar u = new Vector3(0, 1, 0);\u003Cbr\u003E\u003Cbr\u003Evar q = FlightGlobals.ship_rotation;\u003Cbr\u003Evar q_s = attitudeController.Setpoint;\u003Cbr\u003E\u003Cbr\u003Evar q_u = new Quaternion(u.x, u.y, u.z, 0);\u003Cbr\u003Evar a = Quaternion.Dot(q, q_s * q_u);\u003Cbr\u003Evar q_qs = Quaternion.Dot(q, q_s);\u003Cbr\u003Evar b = (a == 0) ? Math.Sign(q_qs) : (q_qs / a);\u003Cbr\u003Evar g = b / Mathf.Sqrt((b *  \u002B 1);\u003Cbr\u003Evar gu = Mathf.Sqrt(1 - (g * g)) * u;\u003Cbr\u003Evar q_d = new Quaternion()\u003Cbr\u003E{\u003Cbr\u003E  w = g,\u003Cbr\u003E  x = gu.x,\u003Cbr\u003E  y = gu.y,\u003Cbr\u003E  z = gu.z\u003Cbr\u003E};\u003Cbr\u003Evar n = q_s * q_d;\u003Cbr\u003E\u003Cbr\u003EattitudeController.Setpoint = n;\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe axis of freedom is set on the first line. In this case, it allows free rolling. Non-basis vectors do work, but they behave a bit counterintuitively since our controls work on the basis vectors. There\\\u0027s definitely some kind of geometric significance in this solution, but I couldn\\\u0027t tell you what it is. I just got a huge mess of component terms and pulled out dot products until it looked all cleaned up. For the parametrized version (where you supply the vector, instead of it being built-in to the equation) I just sort of... guessed. Funny how that works out.\u003C/p\u003E\u003Cp\u003EI guess ? is the \u0027distance\u0027 between your current rotation and a \u0027rolled-over\u0027 setpoint, and ? is the distance between the current rotation and the real setpoint \u003Cem\u003Edivided by\u003C/em\u003E ?. So the further you get from the real setpoint in some way that gets you toward the flipped setpoint, the more the controller adjusts your setpoint so you don\\\u0027t perform a roll. Yeah? Yeah.\u003C/p\u003E\u003Cp\u003EThat was a fun detour. Back to eigenaxis slewing...\u003C/p\u003E\n"},{"CreatedByName":"AltRocketeer","CreatedById":22667,"CreatedDateTime":"2012-04-28T11:49:06Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Majiir\u0022 data-cite=\u0022Majiir\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EI think a more basic, working controller is important first.)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI\\\u0027ve been working on a basic closed-loop controller, using the quaternions as states and applying a full state feedback. I\\\u0027ve also read some papers (which I cannot link to here, you\\\u0027ll need a subscription to various journals) about the subject. The basics are easy to understand: you measure the position (quaternions obviously), calculate the error, derive the required angular velocity, use that in a feedback controller to actually try to achieve that angular velocity (using the angular velocities around the principle axis as states and use those in feedback). In short: you need two feedback controllers.\u003C/p\u003E\u003Cp\u003EAbove is theoretical. I have no idea yet if one is able to measure the moments of inertia around the center of mass in KSP. If you want a high performance controller, you\\\u0027ll probably need a good model of the flight dynamics. I\\\u0027m currently working on the identification of flight dynamics, and the (hopefully) low complexity of the physics engine used should yield a pretty accurate model.\u003C/p\u003E\u003Cp\u003EAnyway, I\\\u0027ve actually implemented a very basic controller, which currently is lacking the angular velocity feedback loop (that\\\u0027s where flight dynamics come in). The controller currently assumes the vessel is able to achieve the required angular velocity instantaneously. I did calculate the error a bit differently, and I don\\\u0027t have an axis of freedom, just the shortest path. But that\\\u0027s how I defined performance in this case. I did analyse the controller in Matlab and turns out it performs pretty well (just need to get a better settling time, but that is just tuning).\u003C/p\u003E\n"},{"CreatedByName":"Madact","CreatedById":64182,"CreatedDateTime":"2013-05-14T10:20:48Z","Content":"\n\u003Cp\u003EThe RCS system as it stands has also been, umm, sugaring me to tears...\u003C/p\u003E\u003Cp\u003EMy biggest annoyance is that it doesn\u0027t seem to have any concept of zero-torque translations - attach a tiny tug to one end of a big, dumb long thing (e.g. a stack o\u0027 big fuel tanks), and thrust \u0022up\u0022, and it just sets you tumbling. Various tutorials suggest placing your thrusters symmetrically about the centre of mass, but no, just NO. - this is SPACE, and that\u0027s just silly in this context. Leverage - it\u0027s not rocket science (well...), it\u0027s primary school science...\u003C/p\u003E\u003Cp\u003EThis scenario:\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Fixedsys;\u0022\u003EV 10N\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Fixedsys;\u0022\u003E|------------------------------|\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Fixedsys;\u0022\u003E|--------------0---------------|\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Fixedsys;\u0022\u003E|------------------------------|\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-family:Fixedsys;\u0022\u003E------/\\ 20 N\u003C/span\u003E\u003C/p\u003E\u003Cp\u003Eyields 10N in the upwards direction, and no torque. You\u0027d think this would be what happens when you\u0027re in docking mode and press shift for \u0027up\u0027, but apparently \u0027up\u0027 actually just means \u0027fire all thrusters that point down\u0027, which is, as previously noted, just silly.\u003C/p\u003E\u003Cp\u003ELooking at the MechJeb 2 source, they have code for an \u0027RCS balancer\u0027, which sets RCS throttles individually - so, it\u0027s not too hard to do. The algorithm implemented, however, is currently pretty poor though - better can be done. On the question of quaternions - yes, they can be used to model either a change in direction only or a change in direction and roll.\u003C/p\u003E\u003Cp\u003EI\u0027m going to try putting together a better \u0027balancer\u0027, which allows angular control with or without net linear effects, and linear control without angular effects (as per the lever above).\u003C/p\u003E\u003Cp\u003EOther things I\u0027d like to do / have in an RCS system:\u003C/p\u003E\u003Cp\u003E - Angular velocity limiter - all that wasted monoprop trying to swing a ship around as fast as mechanically possible makes my inner dolphin cry.\u003C/p\u003E\u003Cp\u003E - better handling of rate and direction when performing a large maneuver, e.g. a PID for movement along the shortest path, and a damper (just the \u0027D\u0027 of a PID) for movement perpendicular, so the perpendicular error can damp out early, leaving the ship headed towards the right direction. Currently it appears to be treated as a single-axis system, just thrusting \u0027towards\u0027 or \u0027away from\u0027 the target, resulting in some nasty seeking behaviour (e.g. spiralling around the target).\u003C/p\u003E\u003Cp\u003EOne thing which I\u0027m not sure about either is getting the moment of inertia (not that it matters for my immediate purposes) - the Vessel class (in Assembly-CSharp.dll) has a \u0022Vector3 MOI\u0022, but I don\u0027t see the principal axes anywhere - they could just be using moments about the x, y, and z axes, but that\u0027s not just wrong, it\u0027s wronggitty wronggity wrong - I choose to think better of the devs, but I\u0027m not sure where to look.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-05-14T15:23:38Z\u0022 title=\u002205/14/2013 03:23  PM\u0022 data-short=\u002211 yr\u0022\u003EMay 14, 2013\u003C/time\u003E by Madact\u003C/strong\u003E\n\u003C/span\u003E\n"}]}