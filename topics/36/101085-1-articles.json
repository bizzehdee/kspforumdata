{"TopicId":101085,"ForumId":36,"TopicTitle":"[WIP] Concept magnetohydrodynamic solar sails","CreatedByName":"C.A.Sizemore","CreatedById":111232,"CreatedDateTime":"2015-03-02T12:52:13Z","PageNum":1,"Articles":[{"CreatedByName":"C.A.Sizemore","CreatedById":111232,"CreatedDateTime":"2015-03-02T12:52:13Z","Content":"So I want to build an add on that models magnetohydrodynamic solar sail. This is a field of plasma that catches the solar wind and uses that pressure to provide a vessel with thrust. These sails are like the solar sails that have been talk about before but they have an advantage over a standard solar sail, being a plasma field they are not restricted to the mass you can lift into orbit. A field can be kilometers across without having to lift that mass into orbit.\n\nThe hard part I see is that thrust is still very small, in the real world you would open the sails and leave them open for weeks to move a vehicle from Earth to the Mars. That does not really work in KSP you can not (without more mods that allow for independent actions) set the sails on a ship to Jool and then leave. You have to stay with the vessel while under thrust.\n\nTo work within the game limitations I think that the engine would work more like a thruster, It would have to have a significant Thrust but consume no fuel. To balance this engine against the rest of the game I would set up a couple of limitations; First it could not be activated inside the SOI of any planet or moon (this is a real world limitation as you would not want to drag a multi-kilometer electromagnet through the magnetosphere of a planet), Second limitation would be based on the solar panel model (the more sunlight your sail gets the more thrust you get). \n\nAs for a model I do not have one yet what I would like is an aurora borealis effect over an area around the ship. My thought on an easy early mock up would be using a stock fuel tank and 3 or 4 of the Giant solar panels. The tank would stand in for the field generator and the solar panels for the field. \n\nPlease tell me what you think."},{"CreatedByName":"nothingSpecial","CreatedById":118683,"CreatedDateTime":"2015-03-02T13:29:36Z","Content":"You can also add a capacitor-part for balance. It was possible in KSP Interstellar to charge up part with custom resource during timewarp, so while you can\u0027t sit through week-long burn, you can wrap for week-long recharge (also only in sun SOI), deploy magnetic field and then have thrust based on distance to Sun for time based on stored energy capacity. Maybe not realistic in process, but more bearable gameplay-wise and for the state of bodies the result will be almost the same."},{"CreatedByName":"noonespecial","CreatedById":81942,"CreatedDateTime":"2015-03-03T01:34:07Z","Content":"There is a working solar sail in the Interstellar Mod. Take a look to see how he did it. It also works through timewarp."},{"CreatedByName":"wasml","CreatedById":120438,"CreatedDateTime":"2015-03-03T02:41:45Z","Content":"First thing that popped into my mind when you mentioned the modeling part was that the effect RoverDude used for his Alcubierre drive would be perfect for this [http://forum.kerbalspaceprogram.com/threads/100798](https://forum.kerbalspaceprogram.com/threads/100798)."},{"CreatedByName":"C.A.Sizemore","CreatedById":111232,"CreatedDateTime":"2015-03-03T15:08:49Z","Content":"The Alcubierre drives are far to fast, any drive that can instantly push you to a significant percentage of lightspeed is just way over powered. In reality those drives will require the same amount of power generation as a medium sized star. I want something that is less Star Trek than a warp drive. I was thinking of something with a power out put more like that of Skipper or maybe a Mainsail. I do like the effect rover dude uses though that is what I was looking for. I could not find anyone using the interstellar solar sails so I will have to down load them and check them out. although the sail they are talking about is a physical sail not a field."},{"CreatedByName":"RoverDude","CreatedById":105198,"CreatedDateTime":"2015-03-03T15:35:47Z","Content":"Actually I think they have the Alcubierre power requirements down now with some changes to the shape of a drive ![;)](//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_wink.gif) But for 90,000 science it\u0027s a nice capstone."},{"CreatedByName":"C.A.Sizemore","CreatedById":111232,"CreatedDateTime":"2015-03-04T15:27:42Z","Content":"I Just built my Mark 0.1 of the Solar Sail, I used the FL-R1 RCS Fuel Tank with the Yellow Tanks recolored to blue, (I have no modeling skills). I placed it in the Specialized Electrics for now I think maybe it should be its own tech node eventually. I launched it in a Sandbox and used the Infinite fuel cheat to boost the unit into space. Once I got the unit into space it worked perfectly until I turned off Infinite Fuel then no thrust. The unit had full electrical charge and even with the solar panels retracted it was not using any charge.\n\nMy process;\n\nCopied and edited the Mainsails config, \n\nUsed the FL-R1 RCS Fuel Tank\u0027s mesh, node definitions and attachment rules.\n\nCopied over and edited the images for FL-R1 RCS Fuel Tank.\n\nTo do: \n\nNeed to figure out why the sail does not work, I will post the config file in another post. \n\nNeed to add sensing of sunlight pressure, for realism. \n\nNeed to add SOI sensing. \n\nNeed to get better visual effect for sails. \n\nNeed to find a better sound files I just used the stock sound effects for the Mainsail.\n\n[https://s-media-cache-ak0.pinimg.com/originals/e6/c0/36/e6c03645b9da411dbcf222306719c9fd.jpg](https://s-media-cache-ak0.pinimg.com/originals/e6/c0/36/e6c03645b9da411dbcf222306719c9fd.jpg)\n\nhttps://s-media-cache-ak0.pinimg.com/originals/75/c6/9b/75c69b3776348bee43007961a3203078.jpg\n\nhttps://s-media-cache-ak0.pinimg.com/originals/75/c6/9b/75c69b3776348bee43007961a3203078.jpg\n\n- - - Updated - - -\n\nSpoiler alert this is the config file.\n\n\u003E \n\u003E PART{\n\u003E // Solar Clipper\n\u003E \n\u003E // Clipper Sail\n\u003E \n\u003E // \n\u003E \n\u003E // --- general parameters ---\n\u003E \n\u003E name = Clipper Sail\n\u003E \n\u003E module = Part\n\u003E \n\u003E author = C.A.Sizemore\n\u003E \n\u003E // --- asset parameters ---\n\u003E \n\u003E mesh = model.mu\n\u003E \n\u003E scale = 1\n\u003E \n\u003E rescaleFactor = 1\n\u003E \n\u003E // --- node definitions ---\n\u003E \n\u003E node\\_stack\\_top = 0.0, 0.5, 0.0, 0.0, 1.0, 0.0, 2\n\u003E \n\u003E node\\_stack\\_bottom = 0.0, -0.5, 0.0, 0.0, 1.0, 0.0, 2\n\u003E \n\u003E // --- FX definitions ---\n\u003E \n\u003E // --- Sound FX definition ---\n\u003E \n\u003E sound\\_vent\\_medium = engage\n\u003E \n\u003E sound\\_rocket\\_hard = running\n\u003E \n\u003E sound\\_vent\\_soft = disengage\n\u003E \n\u003E sound\\_explosion\\_low = flameout\n\u003E \n\u003E // --- editor parameters ---\n\u003E \n\u003E TechRequired = SpecializedElectrics\n\u003E \n\u003E entryCost = 24000\n\u003E \n\u003E cost = 6000\n\u003E \n\u003E category = Engine\n\u003E \n\u003E subcategory = 0\n\u003E \n\u003E title = Solar Clipper Solar Sail\n\u003E \n\u003E manufacturer = Kerchester Shipworks\n\u003E \n\u003E description = An engine that drives your ship on nothing but Kerbols solar wind.\n\u003E \n\u003E // attachment rules: stack, srfAttach, allowStack, allowSrfAttach, allowCollision\n\u003E \n\u003E attachRules = 1,0,1,1,0\n\u003E \n\u003E // --- standard part parameters ---\n\u003E \n\u003E mass = 6\n\u003E \n\u003E dragModelType = default\n\u003E \n\u003E maximum\\_drag = 0.2\n\u003E \n\u003E minimum\\_drag = 0.2\n\u003E \n\u003E angularDrag = 2\n\u003E \n\u003E crashTolerance = 7\n\u003E \n\u003E breakingForce = 200\n\u003E \n\u003E breakingTorque = 200\n\u003E \n\u003E maxTemp = 3600\n\u003E \n\u003E MODULE\n\u003E \n\u003E {\n\u003E \n\u003E  name = ModuleEngines\n\u003E \n\u003E  thrustVectorTransformName = thrustTransform\n\u003E \n\u003E  exhaustDamage = False\n\u003E \n\u003E  ignitionThreshold = 0.1\n\u003E \n\u003E  minThrust = 0\n\u003E \n\u003E  maxThrust = 1500\n\u003E \n\u003E  heatProduction = 0\n\u003E \n\u003E  fxOffset = 0, 0, 0.02\n\u003E \n\u003E  PROPELLANT\n\u003E \n\u003E  {\n\u003E \n\u003E  name = ElectricCharge\n\u003E \n\u003E  ratio = 1.8\n\u003E \n\u003E  DrawGauge = True\n\u003E \n\u003E  }\n\u003E \n\u003E  atmosphereCurve\n\u003E \n\u003E  {\n\u003E \n\u003E  key = 0 4200 \n\u003E \n\u003E }\n\u003E \n\u003E MODULE\n\u003E \n\u003E {\n\u003E \n\u003E  name = ModuleGimbal\n\u003E \n\u003E  gimbalTransformName = thrustTransform\n\u003E \n\u003E  gimbalRange = 1\n\u003E \n\u003E }\n\u003E \n\u003E MODULE\n\u003E \n\u003E {\n\u003E \n\u003E EFFECTS\n\u003E \n\u003E {\n\u003E \n\u003E  Thrust\n\u003E \n\u003E  {\n\u003E \n\u003E  AUDIO\n\u003E \n\u003E  {\n\u003E \n\u003E  clip = Squad/Sounds/sound\\_rocket\\_mini\n\u003E \n\u003E  volume = 0.0 0.0\n\u003E \n\u003E  volume = 1.0 1.0\n\u003E \n\u003E  pitch = 0.0 0.8\n\u003E \n\u003E  pitch = 1.0 1.0\n\u003E \n\u003E  loop = true\n\u003E \n\u003E  } \n\u003E \n\u003E  }\n\u003E \n\u003E }"},{"CreatedByName":"RoverDude","CreatedById":105198,"CreatedDateTime":"2015-03-04T15:38:57Z","Content":"Engines require something with mass in order to work."},{"CreatedByName":"Beale","CreatedById":70533,"CreatedDateTime":"2015-03-04T15:46:12Z","Content":"[You might find this two year old thread of mine helpful!](https://forum.kerbalspaceprogram.com/threads/35620-Engine-Part-With-No-Propellants)\n\nYep, you will need a \u0022pseudo propellant\u0022."},{"CreatedByName":"Mecripp","CreatedById":181994,"CreatedDateTime":"2015-03-04T15:52:50Z","Content":"Think it was .25 they fixed it, And think it still work that ElectricCharge can be used as a PROPELLANT by it self where before you couldn\u0027t."},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2015-03-04T16:21:37Z","Content":"\u003E \n\u003E You can also add a capacitor-part for balance. It was possible in KSP Interstellar to charge up part with custom resource during timewarp, so while you can\u0027t sit through week-long burn, you can wrap for week-long recharge (also only in sun SOI), deploy magnetic field and then have thrust based on distance to Sun for time based on stored energy capacity. Maybe not realistic in process, but more bearable gameplay-wise and for the state of bodies the result will be almost the same.\n\nI find KSPI Solar Sails Ideal for low solar orbits, where the precise orbit, did not matter much. Going anywhere else takes too long or too difficult"},{"CreatedByName":"C.A.Sizemore","CreatedById":111232,"CreatedDateTime":"2015-03-05T05:24:10Z","Content":"Okay my solar sails need solar wind, So I will need to add a resource, Solar Wind and the Solar Sails will have to collect and use that resource. I am going to have to write my own plugin? Yikes more work but fun. \n\nSo where would I learn to write a plugin and I guess if I make it so that the solar wind is only available in Kerbols SOI and not any Planet or Moons that would give it the realism I would want.\n\n**Edited \u003Ctime datetime=\u00222015-03-05T05:28:17Z\u0022 title=\u002203/05/2015 05:28  AM\u0022 data-short=\u00229 yr\u0022\u003EMarch 5, 2015\u003C/time\u003E by C.A.Sizemore**"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2015-03-05T06:52:58Z","Content":"I would strongly advice not to use any resources as they do not behave well with high time warp.\n\nIf I were you, I would simply extend Interstellar Solar Sails. The code is stand alone enough to turn it into a separate Mod\n\nFirst try to understand the code\n\n    using System;using System.Collections.Generic;using System.Linq;using System.Text;using UnityEngine;namespace FNPlugin {    class ModuleSolarSail : PartModule {        // Persistent True        [KSPField(isPersistant = true)]        public bool IsEnabled = false;        // Persistent False        [KSPField]        public float reflectedPhotonRatio = 1f;        [KSPField]        public float surfaceArea; // Surface area of the panel.        [KSPField]        public string animName;        // GUI        [KSPField(guiActive = true, guiName = \u0022Force\u0022)]        protected string forceAcquired = \u0022\u0022;        [KSPField(guiActive = true, guiName = \u0022Acceleration\u0022)]        protected string solarAcc = \u0022\u0022;        protected Transform surfaceTransform = null;        protected Animation solarSailAnim = null;        const double kerbin_distance = 13599840256;        const double thrust_coeff = 9.08e-6;        protected double solar_force_d = 0;        protected double solar_acc_d = 0;        protected long count = 0;        [KSPEvent(guiActive = true, guiName = \u0022Deploy Sail\u0022, active = true)]        public void DeploySail() {            if (animName != null \u0026\u0026 solarSailAnim != null) {                solarSailAnim[animName].speed = 1f;                solarSailAnim[animName].normalizedTime = 0f;                solarSailAnim.Blend(animName, 2f);            }            IsEnabled = true;        }        [KSPEvent(guiActive = true, guiName = \u0022Retract Sail\u0022, active = false)]        public void RetractSail() {            if (animName != null \u0026\u0026 solarSailAnim != null) {                solarSailAnim[animName].speed = -1f;                solarSailAnim[animName].normalizedTime = 1f;                solarSailAnim.Blend(animName, 2f);            }            IsEnabled = false;        }        public override void OnStart(StartState state) {            if (state != StartState.None \u0026\u0026 state != StartState.Editor) {                //surfaceTransform = part.FindModelTransform(surfaceTransformName);                //solarSailAnim = (ModuleAnimateGeneric)part.Modules[\u0022ModuleAnimateGeneric\u0022];                if (animName != null) {                    solarSailAnim = part.FindModelAnimators(animName).FirstOrDefault();                }                if (IsEnabled) {                    solarSailAnim[animName].speed = 1f;                    solarSailAnim[animName].normalizedTime = 0f;                    solarSailAnim.Blend(animName, 0.1f);                }                this.part.force_activate();            }        }        public override void OnUpdate() {            Events[\u0022DeploySail\u0022].active = !IsEnabled;            Events[\u0022RetractSail\u0022].active = IsEnabled;            Fields[\u0022solarAcc\u0022].guiActive = IsEnabled;            Fields[\u0022forceAcquired\u0022].guiActive = IsEnabled;            forceAcquired = solar_force_d.ToString(\u0022E\u0022) \u002B \u0022 N\u0022;            solarAcc = solar_acc_d.ToString(\u0022E\u0022) \u002B \u0022 m/s\u0022;        }        public override void OnFixedUpdate() {            if (FlightGlobals.fetch != null) {                solar_force_d = 0;                if (!IsEnabled) { return; }                double sunlightFactor = 1.0;                Vector3 sunVector = FlightGlobals.fetch.bodies[0].position - part.orgPos;                if (!PluginHelper.lineOfSightToSun(vessel)) {                    sunlightFactor = 0.0f;                }                //Debug.Log(\u0022Detecting sunlight: \u0022 \u002B sunlightFactor.ToString());                Vector3d solarForce = CalculateSolarForce() * sunlightFactor;                //print(surfaceArea);                Vector3d solar_accel = solarForce / vessel.GetTotalMass() / 1000.0 * TimeWarp.fixedDeltaTime;                if (!this.vessel.packed) {                    vessel.ChangeWorldVelocity(solar_accel);                } else {                    if (sunlightFactor \u003E 0) {                        double temp1 = solar_accel.y;                        solar_accel.y = solar_accel.z;                        solar_accel.z = temp1;                        Vector3d position = vessel.orbit.getRelativePositionAtUT(Planetarium.GetUniversalTime());                        Orbit orbit2 = new Orbit(vessel.orbit.inclination, vessel.orbit.eccentricity, vessel.orbit.semiMajorAxis, vessel.orbit.LAN, vessel.orbit.argumentOfPeriapsis, vessel.orbit.meanAnomalyAtEpoch, vessel.orbit.epoch, vessel.orbit.referenceBody);                        orbit2.UpdateFromStateVectors(position, vessel.orbit.vel \u002B solar_accel, vessel.orbit.referenceBody, Planetarium.GetUniversalTime());                        //print(orbit2.timeToAp);                        if (!double.IsNaN(orbit2.inclination) \u0026\u0026 !double.IsNaN(orbit2.eccentricity) \u0026\u0026 !double.IsNaN(orbit2.semiMajorAxis) \u0026\u0026 orbit2.timeToAp \u003E TimeWarp.fixedDeltaTime) {                            vessel.orbit.inclination = orbit2.inclination;                            vessel.orbit.eccentricity = orbit2.eccentricity;                            vessel.orbit.semiMajorAxis = orbit2.semiMajorAxis;                            vessel.orbit.LAN = orbit2.LAN;                            vessel.orbit.argumentOfPeriapsis = orbit2.argumentOfPeriapsis;                            vessel.orbit.meanAnomalyAtEpoch = orbit2.meanAnomalyAtEpoch;                            vessel.orbit.epoch = orbit2.epoch;                            vessel.orbit.referenceBody = orbit2.referenceBody;                            vessel.orbit.Init();                            //vessel.orbit.UpdateFromOrbitAtUT(orbit2, Planetarium.GetUniversalTime(), orbit2.referenceBody);                            vessel.orbit.UpdateFromUT(Planetarium.GetUniversalTime());                        }                    }                }                solar_force_d = solarForce.magnitude;                solar_acc_d = solar_accel.magnitude / TimeWarp.fixedDeltaTime;                //print(solarForce.x.ToString() \u002B \u0022, \u0022 \u002B solarForce.y.ToString() \u002B \u0022, \u0022 \u002B solarForce.z.ToString());            }            count\u002B\u002B;        }        private Vector3d CalculateSolarForce() {            if (this.part != null) {                Vector3d sunPosition = FlightGlobals.fetch.bodies[0].position;                Vector3d ownPosition = this.part.transform.position;                Vector3d normal = this.part.transform.up;                if (surfaceTransform != null) {                    normal = surfaceTransform.forward;                }                Vector3d force = normal * Vector3d.Dot((ownPosition - sunPosition).normalized, normal);                return force * surfaceArea * reflectedPhotonRatio * solarForceAtDistance();            } else {                return Vector3d.zero;            }        }        private double solarForceAtDistance() {            double distance_from_sun = Vector3.Distance(FlightGlobals.Bodies[PluginHelper.REF_BODY_KERBOL].transform.position, vessel.transform.position);            double force_to_return = thrust_coeff * kerbin_distance * kerbin_distance / distance_from_sun / distance_from_sun;            return force_to_return;        }    }}\n\nand the part file:\n\n    PART  {  // --- general parameters ---name = SM-Solar-Sailmodule = Partauthor = SasquatchMarmalade// --- asset parameters ---mesh = model.muscale = 1rescaleFactor = 1.25// --- node definitions ---node_stack_top = 0.0, 1.001, 0.0, 0.0, 1.0, 0.0node_stack_bottom = 0.0, -1.001, 0.0, 0.0, 1.0, 0.0// --- FX definitions ---//fx_exhaustFlame_blue = 0.0, -10.3, 0.0, 0.0, 1.0, 0.0, running//fx_gasJet_white = 0.0, -10.3, 0.0, 0.0, 1.0, 0.0, running// --- Sound FX definition ---//sound_vent_medium = engage//sound_rocket_hard = running//sound_vent_soft = disengage//sound_explosion_low = flameout// --- editor parameters ---TechRequired = metaMaterialsentryCost = 2500cost = 10000category = Enginesubcategory = 0title = Solar Sailmanufacturer = SM Aeronauticsdescription = Solar sails (also called light sails or photon sails) are a form of spacecraft propulsion using the radiation pressure (also called solar pressure) from stars to push large ultra-thin mirrors to high speeds.// attachment rules: stack, srfAttach, allowStack, allowSrfAttach, allowCollisionattachRules = 1,0,1,0,0// --- standard part parameters ---mass = 1dragModelType = defaultmaximum_drag = 0.2minimum_drag = 0.2angularDrag = 2crashTolerance = 7maxTemp = 2500breakingForce = 200breakingTorque = 200MODULE{    name = ModuleSolarSail    surfaceArea = 144400    animName = Default Take}}\n\n**Edited \u003Ctime datetime=\u00222015-03-05T06:55:23Z\u0022 title=\u002203/05/2015 06:55  AM\u0022 data-short=\u00229 yr\u0022\u003EMarch 5, 2015\u003C/time\u003E by FreeThinker**"},{"CreatedByName":"C.A.Sizemore","CreatedById":111232,"CreatedDateTime":"2015-03-09T05:08:00Z","Content":"FreeThinker your saying I should copy the module from the Interstellar, which works and is stable and use my own part for the magnetohydrodynamic solar sail. \n\nI am not a programer and I get lost easily in the code.\n\nI am okay with learning to code, my problem with the interstellar solar sail is its mechanic. A magnetohydrodynamic solar sail would not need to be at a 45 degree angle to the sun neither would a true solar sail. You would tack like a sail boat either with wind to go faster or against the wind to slow. A solar sail with the solar wind directly astern would be gaining a lot of deltaV."}]}