{"TopicId":32564,"ForumId":36,"TopicTitle":"Code for moving fuel to place center of mass over center of thrust","CreatedByName":"afranius","CreatedById":70322,"CreatedDateTime":"2013-06-12T06:08:07Z","PageNum":1,"Articles":[{"CreatedByName":"afranius","CreatedById":70322,"CreatedDateTime":"2013-06-12T06:08:07Z","Content":"\n\u003Cp\u003EI coded up a little script to rebalance fuel tanks so that the center of mass is centered over the center of thrust, which is pretty useful for VTOL planes or asymmetric rockets. I didn\u0027t find anything else that has quite this functionality. It\u0027s kind of a cute problem, technically its a quadratic program, but I implemented a very simplified variant of projected Gauss Seidel that seems to more or less do the job. I just integrated it into Kerbal Engineering (since I didn\u0027t want to add yet another part to all my ships), but I thought I would post the code in case anyone found it useful. It\u0027s pretty simple, just a static function that takes a vessel as input. In my implementation, I just hooked it up to a UI button.\u003C/p\u003E\u003Cp\u003EIf anyone wants to take this and integrate it into a proper mod, please be my guest, I\u0027m releasing this as public domain (anyone can do anything they want with it). It might make a nice addition to something like MechJeb or one of those fuel balancing mods.\u003C/p\u003E\u003Cp\u003EThere are a few shortcomings. For example, fuel is transferred instantly, it might be nice to have some delay for the sake of realism. Also, I can\u0027t seem to figure out a good way to figure out the direction an engine fires. I use the engine rotation as a proxy, but I don\u0027t think this is the best way to do it (it probably won\u0027t handle things like the B9 VTOL engines). I tried using thrustTransforms, but I think those are mainly for the VFX, as they are very inaccurate (I get thrust lines that point way off at a diagonal, resulting in very inaccurate balance).\u003C/p\u003E\u003Cp\u003EHere is a screenshot of me flying some monstrosity with this thing. It doesn\u0027t really fly without automatic fuel balancing, for obvious reasons... not that I have any idea why anyone would want something like that to fly:\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/QNtGjJo.jpg\u0022 alt=\u0022QNtGjJo.jpg\u0022\u003E\u003C/p\u003E\u003Cp\u003EHere is the code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003Enamespace Engineer\u003Cbr\u003E{\u003Cbr\u003E    public class FuelBalancer\u003Cbr\u003E    {\u003Cbr\u003E        // Set this to true to enable debugging printouts.\u003Cbr\u003E        private static bool debugging = false;\u003Cbr\u003E\u003Cbr\u003E        public static void BalanceFuel(bool value, Vessel vessel)\u003Cbr\u003E        {\u003Cbr\u003E            // Only execute if button is pressed.\u003Cbr\u003E            if (!value) return;\u003Cbr\u003E\u003Cbr\u003E            // Go through current engines and computer center of thrust.\u003Cbr\u003E            Vector3 thrustCenter = new Vector3(0,0,0);\u003Cbr\u003E            Vector3 thrustVector = new Vector3(0,0,0);\u003Cbr\u003E            bool bEngineFound = false;\u003Cbr\u003E            foreach(Part part in vessel.Parts)\u003Cbr\u003E            {\u003Cbr\u003E\t\t\t\tforeach(PartModule module in part.Modules)\u003Cbr\u003E                {\u003Cbr\u003E\t\t\t\t\tif(module is ModuleEngines)\u003Cbr\u003E                    {\u003Cbr\u003E                        ModuleEngines engine = (ModuleEngines)module;\u003Cbr\u003E                        if (engine.EngineIgnited)\u003Cbr\u003E                        {\u003Cbr\u003E                            // Found at least one engine.\u003Cbr\u003E                            bEngineFound = true;\u003Cbr\u003E\u003Cbr\u003E                            // Get thrust position.\u003Cbr\u003E                            Vector3 eCenter = vessel.transform.InverseTransformPoint(engine.transform.position);\u003Cbr\u003E\u003Cbr\u003E                            // Figure out the thrust direction... there has got to be a better way to do this.\u003Cbr\u003E                            Vector3 eVector = engine.transform.up;\u003Cbr\u003E\u003Cbr\u003E                            // Undo ship rotation and apply maximum thrust.\u003Cbr\u003E                            eVector = vessel.transform.InverseTransformDirection(eVector)*engine.maxThrust;\u003Cbr\u003E\u003Cbr\u003E                            // Compute new thrust center.\u003Cbr\u003E                            Vector3 numerator = Vector3.Cross(thrustCenter, thrustVector) \u002B Vector3d.Cross(eCenter, eVector) - Vector3.Cross(eCenter, eVector \u002B thrustVector);\u003Cbr\u003E                            Vector3 denominator = Vector3.Cross(thrustCenter, thrustVector \u002B eVector) - Vector3.Cross(eCenter, thrustVector \u002B eVector);\u003Cbr\u003E                            float u = 0;\u003Cbr\u003E                            if (Math.Abs(denominator.x) \u0026gt;= 1e-8)\u003Cbr\u003E                                u = numerator.x / denominator.x;\u003Cbr\u003E                            else if (Math.Abs(denominator.y) \u0026gt;= 1e-8)\u003Cbr\u003E                                u = numerator.y / denominator.y;\u003Cbr\u003E                            else if (Math.Abs(denominator.z) \u0026gt;= 1e-8)\u003Cbr\u003E                                u = numerator.z / denominator.z;\u003Cbr\u003E                            else\u003Cbr\u003E                                u = 0.5f;\u003Cbr\u003E                            thrustCenter = Vector3.Lerp(eCenter, thrustCenter, u);\u003Cbr\u003E                            // Add the values together to get the thrust vector.\u003Cbr\u003E                            thrustVector = thrustVector \u002B eVector;\u003Cbr\u003E                        }\u003Cbr\u003E                    }\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E            if (bEngineFound)\u003Cbr\u003E            { // Only rebalance if we have at least one active engine.\u003Cbr\u003E                // Get center of mass.\u003Cbr\u003E                Vector3 centerOfMass = vessel.findLocalCenterOfMass();\u003Cbr\u003E                if (debugging) Debug.Log(\u0022Initial center of mass: \u0022 \u002B (centerOfMass*100.0f).ToString());\u003Cbr\u003E\u003Cbr\u003E                // Move the fuel.\u003Cbr\u003E                centerOfMass = MoveFuel(vessel, centerOfMass, thrustCenter, thrustVector, true);\u003Cbr\u003E\u003Cbr\u003E                // Debug printout to specify the current center of thrust and thrust vector.\u003Cbr\u003E                if (debugging) Debug.Log(\u0022Center of thrust: \u0022 \u002B (thrustCenter*100.0f).ToString() \u002B \u0022 thrust vector: \u0022 \u002B thrustVector.ToString() \u002B \u0022 center of mass: \u0022 \u002B (centerOfMass * 100.0f).ToString());\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Transfer fuel to move the center of mass from current position to target.\u003Cbr\u003E        public static Vector3 MoveFuel(Vessel vessel, Vector3 centerOfMass, Vector3 targetPosition, Vector3 targetNormal, bool bProject)\u003Cbr\u003E        {\u003Cbr\u003E            float mass = vessel.GetTotalMass(); // Get total mass.\u003Cbr\u003E            int ITERATIONS = 2; // Number of PGS iterations.\u003Cbr\u003E\u003Cbr\u003E            for (int i = 0; i \u0026lt; ITERATIONS; i\u002B\u002B)\u003Cbr\u003E            {\u003Cbr\u003E                // Now step over all tanks and see if we need to transfer.\u003Cbr\u003E                foreach (Part part in vessel.parts)\u003Cbr\u003E                {\u003Cbr\u003E                    // Step over all resources in this tank.\u003Cbr\u003E                    foreach (PartResource resource in part.Resources)\u003Cbr\u003E                    {\u003Cbr\u003E                        // Only process nonempty tanks.\u003Cbr\u003E                        if (resource.info.density \u0026gt; 0)\u003Cbr\u003E                        { // Only move resources that have mass (don\u0027t move electricity!)\u003Cbr\u003E                            // Read position.\u003Cbr\u003E                            Vector3 sourceFullPos = vessel.transform.InverseTransformPoint(part.transform.position);\u003Cbr\u003E                            Vector3 sourcePos = sourceFullPos;\u003Cbr\u003E                            if (bProject) sourcePos = sourcePos - Vector3.Project(sourcePos, targetNormal);\u003Cbr\u003E\u003Cbr\u003E                            // Step through all other parts for this resource.\u003Cbr\u003E                            foreach (Part part2 in vessel.parts)\u003Cbr\u003E                            {\u003Cbr\u003E                                if (part != part2)\u003Cbr\u003E                                {\u003Cbr\u003E                                    foreach (PartResource resource2 in part2.Resources)\u003Cbr\u003E                                    {\u003Cbr\u003E                                        if (resource2.resourceName == resource.resourceName)\u003Cbr\u003E                                        { // Only consider parts with the same type of resource.\u003Cbr\u003E                                            // Read position.\u003Cbr\u003E                                            Vector3 destFullPos = vessel.transform.InverseTransformPoint(part2.transform.position);\u003Cbr\u003E                                            Vector3 destPos = destFullPos;\u003Cbr\u003E                                            if (bProject) destPos = destPos - Vector3.Project(destPos, targetNormal);\u003Cbr\u003E                                            Vector3 normalizedDiff = destPos - sourcePos;\u003Cbr\u003E                                            normalizedDiff = normalizedDiff.normalized;\u003Cbr\u003E\u003Cbr\u003E                                            // Formulate equation so that p2*moveAmount - p1*moveAmount \u002B CoMprojection = CoM\u003Cbr\u003E                                            double p1 = Vector3.Dot(sourcePos, normalizedDiff);\u003Cbr\u003E                                            double p2 = Vector3.Dot(destPos, normalizedDiff);\u003Cbr\u003E                                            double CoMprojection = Vector3.Dot(centerOfMass, normalizedDiff);\u003Cbr\u003E\u003Cbr\u003E                                            // Solve for c = CoT_projection - CoMprojection\u003Cbr\u003E                                            double CoTprojection = Vector3.Dot(targetPosition, normalizedDiff);\u003Cbr\u003E                                            double c = CoTprojection - CoMprojection;\u003Cbr\u003E\u003Cbr\u003E                                            // Compute optimal resource quantity.\u003Cbr\u003E                                            double moveAmount = 0.0;\u003Cbr\u003E                                            double denominator = p2 - p1;\u003Cbr\u003E                                            if (denominator != 0)\u003Cbr\u003E                                                moveAmount = c / denominator;\u003Cbr\u003E\u003Cbr\u003E                                            // Modify by resource density.\u003Cbr\u003E                                            moveAmount = moveAmount * mass / resource.info.density;\u003Cbr\u003E\u003Cbr\u003E                                            // Clamp resource quantity by the amount available in the two tanks.\u003Cbr\u003E                                            moveAmount = Math.Min(moveAmount, resource.amount);\u003Cbr\u003E                                            moveAmount = Math.Max(moveAmount, -(resource.maxAmount - resource.amount));\u003Cbr\u003E                                            moveAmount = Math.Max(moveAmount, -resource2.amount);\u003Cbr\u003E                                            moveAmount = Math.Min(moveAmount, resource2.maxAmount - resource2.amount);\u003Cbr\u003E\u003Cbr\u003E                                            // Move the resource.\u003Cbr\u003E                                            resource.amount -= moveAmount;\u003Cbr\u003E                                            resource2.amount \u002B= moveAmount;\u003Cbr\u003E\u003Cbr\u003E                                            // Modify the center of mass.\u003Cbr\u003E                                            centerOfMass = (centerOfMass * mass - sourceFullPos * ((float)(moveAmount * resource.info.density)) \u002B destFullPos * ((float)(moveAmount * resource.info.density))) * (1 / mass);\u003Cbr\u003E\u003Cbr\u003E                                            // Print result.\u003Cbr\u003E                                            if (debugging) Debug.Log(\u0022Transferred \u0022 \u002B moveAmount.ToString() \u002B \u0022 units of \u0022 \u002B resource.resourceName \u002B \u0022 from \u0022 \u002B part.ToString() \u002B \u0022 to \u0022 \u002B part2.ToString());\u003Cbr\u003E                                            if (debugging) Debug.Log(\u0022New projected error: \u0022 \u002B Vector3.Exclude(targetNormal,centerOfMass-targetPosition).magnitude.ToString());\u003Cbr\u003E                                        }\u003Cbr\u003E                                    }\u003Cbr\u003E                                }\u003Cbr\u003E                            }\u003Cbr\u003E                        }\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            // Return the center of mass.\u003Cbr\u003E            return centerOfMass;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"sjwt","CreatedById":9268,"CreatedDateTime":"2013-06-12T07:31:02Z","Content":"\n\u003Cp\u003EI can see *SO* many applications for this!\u003C/p\u003E\u003Cp\u003EWell done!\u003C/p\u003E\n"},{"CreatedByName":"EndlessWaves","CreatedById":41302,"CreatedDateTime":"2013-06-12T09:46:18Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022afranius\u0022 data-cite=\u0022afranius\u0022\u003E\u003Cdiv\u003EI tried using thrustTransforms, but I think those are mainly for the VFX, as they are very inaccurate (I get thrust lines that point way off at a diagonal, resulting in very inaccurate balance).\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThust is applied to the position of that transform in the direction of it\u0027s -Z axis so that definitely determines it. You may have got the reference space wrong, being a transform it does have it\u0027s own co-ordinates so you need to use that transform\u0027s TransformDirection method rather than the top level part transform\u0027s.\u003C/p\u003E\n"},{"CreatedByName":"Mekan1k","CreatedById":48750,"CreatedDateTime":"2013-06-12T10:04:39Z","Content":"\n\u003Cp\u003EThe MechJeb/Fuelballence Guys had better take notice of this!\u003C/p\u003E\u003Cp\u003EAlso, \u002BRep for cleverness!\u003C/p\u003E\n"},{"CreatedByName":"Lucid Hills","CreatedById":66394,"CreatedDateTime":"2013-06-12T10:31:08Z","Content":"\n\u003Cp\u003ECan you have this balance to center of lift?\u003C/p\u003E\n"},{"CreatedByName":"ZRM","CreatedById":64626,"CreatedDateTime":"2013-06-12T12:01:18Z","Content":"\n\u003Cp\u003EThis looks like a very nice additional component for my project, KerbCom Avionics CRCS, which is aiming in the next release to provide VTOL support. I had forgotten the fuel distribution aspect of VTOL balancing. See \u003Ca href=\u0022https://forum.kerbalspaceprogram.com/showthread.php/28044-WIP-Analytical-RCS-thrust-balancing?p=446015\u0026amp;viewfull=1#post446015\u0022 rel=\u0022external nofollow\u0022\u003Emy last post in the dev thread\u003C/a\u003E for details.\u003C/p\u003E\n"},{"CreatedByName":"afranius","CreatedById":70322,"CreatedDateTime":"2013-06-12T17:59:37Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003EThust is applied to the position of that transform in the direction of it\u0027s -Z axis so that definitely determines it. You may have got the reference space wrong, being a transform it does have it\u0027s own co-ordinates so you need to use that transform\u0027s TransformDirection method rather than the top level part transform\u0027s.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou mean thrustTransforms? Hmm... What I did was thrustTransforms.forward and transformed it by the inverse ship transform to place it in ship coordinates (like the rest of the quantities). I gathered from the Unity documentation that thrustTransforms.forward is in world space. It\u0027s actually very close to the part transform transform.up, but off by a few degrees, which actually makes a big difference. I wonder if thrust vectoring is part of the issue? I\u0027m guessing thrustTransforms.forward gives the actual (vectored) thrust direction, and balancing the fuel to that has a nasty positive feedback effect -- the engine gimbals to stay balanced, fuel is rebalanced so that is the new set point, drains a little, and the engine has to gimbal even more, so the fuel is rebalanced to be even more uneven. In that case, any thoughts on how to get non-vectored thrust direction?\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003ECan you have this balance to center of lift?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe MoveFuel function simply moves fuel so that the center of mass is aligned with the target position (center of thrust) on a plane defined by a specified normal (thrust direction). If you have a way to compute CoL, you could very easily use the same function. You can also turn off projection, in which case it will ignore the thrust direction and just align CoM and target in 3D. This might be useful if you want to move the CoM to match the initial CoM position for example (if you balanced your aircraft just right in the SPH and want to rebalance in flight to match).\u003C/p\u003E\n"},{"CreatedByName":"EndlessWaves","CreatedById":41302,"CreatedDateTime":"2013-06-12T18:58:44Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022afranius\u0022 data-cite=\u0022afranius\u0022\u003E\u003Cdiv\u003EIt\u0027s actually very close to the part transform transform.up, but off by a few degrees, which actually makes a big difference. I wonder if thrust vectoring is part of the issue? I\u0027m guessing thrustTransforms.forward gives the actual (vectored) thrust direction, and balancing the fuel to that has a nasty positive feedback effect -- the engine gimbals to stay balanced, fuel is rebalanced so that is the new set point, drains a little, and the engine has to gimbal even more, so the fuel is rebalanced to be even more uneven. In that case, any thoughts on how to get non-vectored thrust direction?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYeah, ModuleGimbal rotates the thrustTransform object as it\u0027s the engine module that applies the thrust. Starting (neutral) rotations are stored in initRots of ModuleGimbal. Although if it\u0027s linear you may be able to simple work backwards; angle = current angle - maximum gimbal * steering (-1 to 1).\u003C/p\u003E\n"}]}