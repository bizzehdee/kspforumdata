{"TopicId":161531,"ForumId":36,"TopicTitle":"KSP Interstellar Extended Continued Development Thread","CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2015-02-20T10:23:31Z","PageNum":180,"Articles":[{"CreatedByName":"Rabada","CreatedById":66044,"CreatedDateTime":"2016-03-14T20:32:21Z","Content":"\n\u003Cp\u003E\nI have been using the motlen salt reactors for a couple hours in game, and\u00A0I have some\u00A0suggestions. I think that the upgraded molten salt reactors should be an entirely different part than the base molten salt reactor. I often times use that reactor as a power source for my stations, my long distance probes, and my mining craft. However, the upgraded reactor uses up its fuel at a much faster rate than the base reactor. I think the base reactor using Uranium lasts something like 3 or 4 times longer before it runs out of fuel compared to the upgraded reactor, and I still have yet to unlock the advanced molten salt reactors. The problem is that once I unlock the upgrade to the molten salt reactor, I cannot place the base reactor on my craft. This breaks some of my old craft files because they did not have enough radiators, and I cannot launch them with the old reactor.\n\u003C/p\u003E\n\u003Cp\u003E\nI think that this would also be a good opportunity to make a compromise with the players who did not like the integrated generator in the molten salt reactor. I would suggest that only the low tech reactor should have the integrated generator. Also, perhaps we could limit its maximum size via tweak scale to something like 2.5m. Perhaps the old model could be used for the low tech reactor, and roverdudes model could be used for the advanced reactors.\n\u003C/p\u003E\n\u003Cp\u003E\nOr I guess another way to solve this would be to let us toggle the tech level of the reactors in the VAB, I remember there were many requests for this in the old Interstellar thread ran by Fractal, however I cannot remember why this could not be easily implemented.\n\u003C/p\u003E\n"},{"CreatedByName":"RzTen1","CreatedById":159570,"CreatedDateTime":"2016-03-15T07:15:19Z","Content":"\n\u003Cp\u003E\nI think I\u0027ve found the issue with KER/MechJeb not displaying the correct Delta-V and thrust numbers.\u00A0 It appears according to the following posts that the thrust calculation changed in 1.0 to use maxFuelFlow:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/index.php?/topic/105996-ksp-10-isp-engine-values/\u0022\u003Ehttp://forum.kerbalspaceprogram.com/index.php?/topic/105996-ksp-10-isp-engine-values/\u003C/a\u003E\u003Cbr\u003E\u003Ca href=\u0022http://bugs.kerbalspaceprogram.com/issues/4937\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://bugs.kerbalspaceprogram.com/issues/4937\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027ve modified the code for the thermal nozzles as follows and I\u0027m seeing expected values in KER again.\u00A0 This is for ThermalNozzleController.cs at line 847 and includes the entire first part of the if block (everything between the brackets):\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint prettyprinted\u0022\u003E\n\u003Cspan\u003E            \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//if (myAttachedReactor is IUpgradeableModule) {\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//    IUpgradeableModule upmod = myAttachedReactor as IUpgradeableModule;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//    if (upmod.HasTechsRequiredToUpgrade()) {\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//        attached_reactor_upgraded = true;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//    }\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//}\u003C/span\u003E\u003Cspan\u003E\n\n                _maxISP \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)(\u003C/span\u003E\u003Cspan\u003EMath\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ESqrt\u003C/span\u003E\u003Cspan\u003E((\u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EAttachedReactor\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ECoreTemperature\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EPluginHelper\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EIspCoreTempMult\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E\u002B\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EIspTempMultOffset\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EGetIspPropellantModifier\u003C/span\u003E\u003Cspan\u003E());\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//_minISP = _maxISP * 0.4f;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//atmospherecurve.Add(0, _maxISP, 0, 0);\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//atmospherecurve.Add(1, _minISP, 0, 0);\u003C/span\u003E\u003Cspan\u003E\n\n                \u003C/span\u003E\u003Cspan\u003E//thrust = (float)(AttachedReactor.MaximumPower * GetPowerThrustModifier() * GetHeatThrustModifier() / PluginHelper.GravityConstant / _maxISP);\u003C/span\u003E\u003Cspan\u003E\n                thrust \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E((\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetPowerThrustModifier\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetHeatThrustModifier\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EAttachedReactor\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EMaximumThermalPower\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E _maxISP \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EPluginHelper\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGravityConstant\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetHeatExchangerThrustDivisor\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E _thrustPropellantMultiplier\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n                myAttachedEngine\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EmaxFuelFlow \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E thrust \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EPluginHelper\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGravityConstant\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E _maxISP\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n                myAttachedEngine\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EmaxThrust \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E thrust\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n\n                _minISP \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E _maxISP \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E((\u003C/span\u003E\u003Cspan\u003Ethrust \u003C/span\u003E\u003Cspan\u003E-\u003C/span\u003E\u003Cspan\u003E maxPressureThresholdAtKerbinSurface\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E thrust\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetHeatExchangerThrustDivisor\u003C/span\u003E\u003Cspan\u003E();\u003C/span\u003E\u003Cspan\u003E\n                atmospherecurve\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EAdd\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E _maxISP\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n                atmospherecurve\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EAdd\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003E1\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E _minISP\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\n                myAttachedEngine\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EatmosphereCurve \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E atmospherecurve\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003E}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-15T10:40:13Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222457088\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221457987541\u0022 data-ipsquote-userid=\u002266044\u0022 data-ipsquote-username=\u0022Rabada\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n14 hours ago, Rabada said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nI have been using the motlen salt reactors for a couple hours in game, and\u00A0I have some\u00A0suggestions. I think that the upgraded molten salt reactors should be an entirely different part than the base molten salt reactor. I often times use that reactor as a power source for my stations, my long distance probes, and my mining craft. However, the upgraded reactor uses up its fuel at a much faster rate than the base reactor. I think the base reactor using Uranium lasts something like 3 or 4 times longer before it runs out of fuel compared to the upgraded reactor, and I still have yet to unlock the advanced molten salt reactors. The problem is that once I unlock the upgrade to the molten salt reactor, I cannot place the base reactor on my craft. This breaks some of my old craft files because they did not have enough radiators, and I cannot launch them with the old reactor.\n\u003C/p\u003E\n\u003Cp\u003E\nI think that this would also be a good opportunity to make a compromise with the players who did not like the integrated generator in the molten salt reactor. I would suggest that only the low tech reactor should have the integrated generator. Also, perhaps we could limit its maximum size via tweak scale to something like 2.5m. Perhaps the old model could be used for the low tech reactor, and roverdudes model could be used for the advanced reactors.\n\u003C/p\u003E\n\u003Cp\u003E\nOr I guess another way to solve this would be to let us toggle the tech level of the reactors in the VAB, I remember there were many requests for this in the old Interstellar thread ran by Fractal, however I cannot remember why this could not be easily implemented.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nAlright, there seems to be several problems here.\n\u003C/p\u003E\n\u003Cp\u003E\nProblem\u00A0 A Upgraded reactor doesn\u0027t last as long, This is the result of the overal power improving while the minimum utilisation remains the same. The resutt is that more power is wasted and there they don\u0027t last not as long. Did\u00A0 you know that the Upgraded version allows Uranium Reprocessing? However, you need a Lab on board which might not always desired, therefore I plan to reuse the old Reactor model to act as a automated nuclear fuel reprocessor, allowing you to reprecess fuel without a Lab. Another thing that will help is that the amount of molten salt will be restored to it\u0027s original amount (3 times as much) which will significantly improve durability.\n\u003C/p\u003E\n\u003Cp\u003E\nProblem B is the desire to select a specific version, in both SandBox and Compagin mode. It would be helpfull to allow playesr to test a vessel first\u00A0 before they dedicate to it in their campagin. This is a valid point. I want to give the possiblity to select the avialabe Generation level in the VAB and allow it to be upgraded in space with an Engeneer and RocketParts resources.\n\u003C/p\u003E\n\u003Cp\u003E\nThe idea of not fitting the Salt Core Reactor with build in Thermal Electric Generator seems like a bad idea as it is confusing and the Salt Core reacor main purpose if electric power production, not propulsion, for that use the Sold Core Reacor (NERVA).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222457802\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221458026119\u0022 data-ipsquote-userid=\u0022159570\u0022 data-ipsquote-username=\u0022RzTen1\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n4 hours ago, RzTen1 said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nI think I\u0027ve found the issue with KER/MechJeb not displaying the correct Delta-V and thrust numbers.\u00A0 It appears according to the following posts that the thrust calculation changed in 1.0 to use maxFuelFlow:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/index.php?/topic/105996-ksp-10-isp-engine-values/\u0022\u003Ehttp://forum.kerbalspaceprogram.com/index.php?/topic/105996-ksp-10-isp-engine-values/\u003C/a\u003E\u003Cbr\u003E\u003Ca href=\u0022http://bugs.kerbalspaceprogram.com/issues/4937\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://bugs.kerbalspaceprogram.com/issues/4937\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027ve modified the code for the thermal nozzles as follows and I\u0027m seeing expected values in KER again.\u00A0 This is for ThermalNozzleController.cs at line 847 and includes the entire first part of the if block (everything between the brackets):\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint prettyprinted\u0022\u003E\n\n\u003Cspan\u003E            \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//if (myAttachedReactor is IUpgradeableModule) {\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//    IUpgradeableModule upmod = myAttachedReactor as IUpgradeableModule;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//    if (upmod.HasTechsRequiredToUpgrade()) {\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//        attached_reactor_upgraded = true;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//    }\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//}\u003C/span\u003E\u003Cspan\u003E\n\n                _maxISP \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)(\u003C/span\u003E\u003Cspan\u003EMath\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ESqrt\u003C/span\u003E\u003Cspan\u003E((\u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EAttachedReactor\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ECoreTemperature\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EPluginHelper\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EIspCoreTempMult\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E\u002B\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EIspTempMultOffset\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EGetIspPropellantModifier\u003C/span\u003E\u003Cspan\u003E());\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//_minISP = _maxISP * 0.4f;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//atmospherecurve.Add(0, _maxISP, 0, 0);\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E//atmospherecurve.Add(1, _minISP, 0, 0);\u003C/span\u003E\u003Cspan\u003E\n\n                \u003C/span\u003E\u003Cspan\u003E//thrust = (float)(AttachedReactor.MaximumPower * GetPowerThrustModifier() * GetHeatThrustModifier() / PluginHelper.GravityConstant / _maxISP);\u003C/span\u003E\u003Cspan\u003E\n                thrust \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E((\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetPowerThrustModifier\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetHeatThrustModifier\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EAttachedReactor\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EMaximumThermalPower\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E _maxISP \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EPluginHelper\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGravityConstant\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetHeatExchangerThrustDivisor\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E _thrustPropellantMultiplier\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n                myAttachedEngine\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EmaxFuelFlow \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E thrust \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EPluginHelper\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGravityConstant\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E _maxISP\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n                myAttachedEngine\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EmaxThrust \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E thrust\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n\n                _minISP \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E _maxISP \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E((\u003C/span\u003E\u003Cspan\u003Ethrust \u003C/span\u003E\u003Cspan\u003E-\u003C/span\u003E\u003Cspan\u003E maxPressureThresholdAtKerbinSurface\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E thrust\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003EGetHeatExchangerThrustDivisor\u003C/span\u003E\u003Cspan\u003E();\u003C/span\u003E\u003Cspan\u003E\n                atmospherecurve\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EAdd\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E _maxISP\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n                atmospherecurve\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EAdd\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003E1\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E _minISP\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\n                myAttachedEngine\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EatmosphereCurve \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E atmospherecurve\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003E}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nexcept for some minor details it is looking good. It appears I haven\u0027t maintained this part of the code for quite some time. If it doesn\u0027t break anything, I will integrrate it in the code for next release\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-15T11:25:36Z\u0022 title=\u002203/15/2016 11:25  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 15, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Kill_off","CreatedById":159468,"CreatedDateTime":"2016-03-15T14:44:50Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222456832\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221457980679\u0022 data-ipsquote-userid=\u0022137922\u0022 data-ipsquote-username=\u0022olekopyto\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n20 hours ago, olekopyto said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nGuys!\n\u003C/p\u003E\n\u003Cp\u003E\nHow to operate a science lab, i have my Generators, Reactors, Radiators and Mangoes in Syrup, but poor labby just wont generate any science. I pushed every button, but Kerbals wouldn\u0027t do nothing but clap and move their mouth silently. I think they are plotting on me!\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nyou need to have 2 kerbals in there, i think one must be a scientist at least.Have enough electricity and of course you need data. Do some sience experiment on the vessel with the lab and then there is a 4th button - besides recycle, keep and transmit - it\u00A0 will give you data from the experiment. right click the Lab and you will see how much data you got and how much science/day will be produced\n\u003C/p\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-15T15:51:51Z","Content":"\n\u003Cp\u003E\nNote that gathering research data can be done by any kerbal, but it realy helps to be scientific (scientist) or\u00A0 at least technical (engineer) and the level of expertise , also it matters how close you are to the body you are reseaching. Landed Labs (except on kerbin) recieve double reseach bonus.\n\u003C/p\u003E\n\u003Cp\u003E\nThe actual processing can only be done by Professional, like in stock, they KSPI version only do it more effectivly at the cost of significantly more power to crunch the data on the onboard super computer.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-15T16:34:41Z\u0022 title=\u002203/15/2016 04:34  PM\u0022 data-short=\u00228 yr\u0022\u003EMarch 15, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"ss8913","CreatedById":94747,"CreatedDateTime":"2016-03-15T21:14:21Z","Content":"\n\u003Cp\u003E\nIt should be noted that the KSPIE science lab is the best one available that I\u0027ve found.\u00A0 Processing science data this way can yield you enough science to completely open the CTT (~120,000 science) without going past the orbit of Minmus.\u00A0 You can do this with any science lab, but the KSPIE one holds a lot more data, so you can do it in fewer launches.\u00A0 Just set up an orbital science station in Kerbin orbit, have your craft dock and drop off science on their way back to Kerbin, and then you transmit data back down from the station after it\u0027s been researched into science points.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-15T21:15:53Z\u0022 title=\u002203/15/2016 09:15  PM\u0022 data-short=\u00228 yr\u0022\u003EMarch 15, 2016\u003C/time\u003E by ss8913\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-15T22:42:00Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222458661\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221458076461\u0022 data-ipsquote-userid=\u002294747\u0022 data-ipsquote-username=\u0022ss8913\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n1 hour ago, ss8913 said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nIt should be noted that the KSPIE science lab is the best one available that I\u0027ve found.\u00A0 Processing science data this way can yield you enough science to completely open the CTT (~120,000 science) without going past the orbit of Minmus.\u00A0 You can do this with any science lab, but the KSPIE one holds a lot more data, so you can do it in fewer launches.\u00A0 Just set up an orbital science station in Kerbin orbit, have your craft dock and drop off science on their way back to Kerbin, and then you transmit data back down from the station after it\u0027s been researched into science points.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nPersonally, I think Squad made this mechanism too exploitable. How can repeatedly reprocessing the same data multiple times over give so much data? Imho this kind of defeats the reason to explore and collect science in the rest of the solar system.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-15T22:43:28Z\u0022 title=\u002203/15/2016 10:43  PM\u0022 data-short=\u00228 yr\u0022\u003EMarch 15, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"RzTen1","CreatedById":159570,"CreatedDateTime":"2016-03-16T01:50:36Z","Content":"\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222457903\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221458038413\u0022 data-ipsquote-userid=\u0022117389\u0022 data-ipsquote-username=\u0022FreeThinker\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n14 hours ago, FreeThinker said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nexcept for some minor details it is looking good. It appears I haven\u0027t maintained this part of the code for quite some time. If it doesn\u0027t break anything, I will integrrate it in the code for next release\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThanks!\u00A0 I\u0027ve been playing with that new code and swapping out different reactors and I\u0027ve come across two things of note:\n\u003C/p\u003E\n\u003Cp\u003E\n1. reactor / thermal nozzle combinations that have no thrust at sealevel can cause minISP to go negative.\u00A0 It looks like the correct way to fix it would be to add another atmospherecurve with the altitude where the engine actually hit\u0027s 0.1isp and clamp sealevel to zero, but it may just be a visual problem and not game impacting as negative values don\u0027t seem to break anything.\n\u003C/p\u003E\n\u003Cp\u003E\n2. the \u0027gas core\u0027 reactor.\u00A0 The buoyancy effect causes weird things to happen, even with stock code.\u00A0 100% throttle actually produces slightly less engine thrust then when set to around 60%.\u00A0 The reactor control window also seems off, thermal power is lower at 60% (as expected) even though more of it seems to be hitting the engine.\u00A0 There really needs to be a readout on the buoyancy impact.\u00A0 I also feel like the reactor needs a tiny boost in total thermal power as you lose a pretty large chunk of it while accelerating, which seems odd for a reactor that looks to be designed for thermal nozzles.\n\u003C/p\u003E\n\u003Cp\u003E\nAll of this also means that the thrust estimate is still way off on the gas core: 371kN vac is reported on the engine and in KER with the new code, but in space it\u0027s usually quite a bit lower.\u00A0 I\u0027m not sure how to calculate the thrust for this engine as it\u0027ll need to take into account both stage mass and throttle position, but I\u0027ll keep poking at it.\n\u003C/p\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-16T10:12:22Z","Content":"\n\u003Cp\u003E\nCalculating effective thrust for Gas Core Reactor is currently indeed very hard, because as you observed, the Reactor is starving itself under acceleration. On way we might solve this problem is to make the boyancy effect more forgiving (clamping it a 0.5 g) and Increase ISP making it accelerate less. That way it will be less likely to starve itself durring burns and therefore more prodictable.\n\u003C/p\u003E\n\u003Cp\u003E\nNotice that\u00A0 already planned to do the last as part of Realsim rebalancing, as I moved the Open Cycle Gas Core Reacor Higher in the Techtree and make it more competive compaired to early Fusion Reactor technology which as in reality are much Larger and Havier.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-16T10:14:15Z\u0022 title=\u002203/16/2016 10:14  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 16, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"kurdain","CreatedById":154984,"CreatedDateTime":"2016-03-16T16:56:27Z","Content":"\n\u003Cp\u003E\nHello,\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027ve had some troubles with parts from this mod, specifically parts disappearing. I\u0027ve searched around and I see some other people having similar issues but I haven\u0027t seen any fixes or conclusive information on what could be causing it.\u003Cbr\u003E\u003Cbr\u003E\nBasically I have noticed that the Magnetic Nozzle and Orbital Supercollider have vanished from the VAB in career mode; probably other parts as well but I have noticed these 2 things for certain.\u003Cbr\u003E\nI know for certain that the parts were researched and purchased, because I had vehicles with these parts that suddenly became invalid.\u003Cbr\u003E\nThis didn\u0027t appear to be related to any specific update.\u003Cbr\u003E\nSometimes the part will come back for a time then vanish again.\u003Cbr\u003E\nThe parts appear and function just fine in sandbox mode.\u003Cbr\u003E\nI am running in 64-bit mode, but I feel this isn\u0027t a factor.\u003Cbr\u003E\nI have a lot of mods, I can list them if needed.\u003Cbr\u003E\nI\u0027ve tried reinstalling KSPI without success.\u003Cbr\u003E\nI\u0027ve wiped all mods, reinstalled without success.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nWhat other information and I provide that could help you to\u00A0help me?\u003Cbr\u003E\u003Cbr\u003E\nThank you,\n\u003C/p\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-16T18:46:03Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222459862\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221458147387\u0022 data-ipsquote-userid=\u0022154984\u0022 data-ipsquote-username=\u0022kurdain\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n1 hour ago, kurdain said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nHello,\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027ve had some troubles with parts from this mod, specifically parts disappearing. I\u0027ve searched around and I see some other people having similar issues but I haven\u0027t seen any fixes or conclusive information on what could be causing it.\u003Cbr\u003E\u003Cbr\u003E\nBasically I have noticed that the Magnetic Nozzle and Orbital Supercollider have vanished from the VAB in career mode; probably other parts as well but I have noticed these 2 things for certain.\u003Cbr\u003E\nI know for certain that the parts were researched and purchased, because I had vehicles with these parts that suddenly became invalid.\u003Cbr\u003E\nThis didn\u0027t appear to be related to any specific update.\u003Cbr\u003E\nSometimes the part will come back for a time then vanish again.\u003Cbr\u003E\nThe parts appear and function just fine in sandbox mode.\u003Cbr\u003E\nI am running in 64-bit mode, but I feel this isn\u0027t a factor.\u003Cbr\u003E\nI have a lot of mods, I can list them if needed.\u003Cbr\u003E\nI\u0027ve tried reinstalling KSPI without success.\u003Cbr\u003E\nI\u0027ve wiped all mods, reinstalled without success.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nWhat other information and I provide that could help you to\u00A0help me?\u003Cbr\u003E\u003Cbr\u003E\nThank you,\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nWeird, you should check your logs they often contain very important clues why part are not showing up.\n\u003C/p\u003E\n\u003Cp\u003E\nThere could be a number of reason why part aren\u0027t showing, including other parts having the same name, double installs but also removal due to replacement ( in the case of magnetic nozzle) or because KSP 1.0.5 suddenly limiting the number op polygons in a game.\n\u003C/p\u003E\n"},{"CreatedByName":"kurdain","CreatedById":154984,"CreatedDateTime":"2016-03-16T19:05:36Z","Content":"\n\u003Cp\u003E\nI am familiar with where the crash logs are, but what other logs are you referring to?\n\u003C/p\u003E\n\u003Cp\u003E\nIf it was a rendering, naming or similar issue why do they appear in sandbox mode?\n\u003C/p\u003E\n\u003Cp\u003E\nThanks for the reply too by the way!\n\u003C/p\u003E\n\u003Cp\u003E\nAny known mods that don\u0027t get along with KSPI that I could see if I have installed or try uninstalling?\n\u003C/p\u003E\n\u003Cp\u003E\nThank\u00A0you.\n\u003C/p\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-16T20:18:11Z","Content":"\n\u003Cp\u003E\nI\u0027m refering to the KSP.log next to the KSP.exe.\n\u003C/p\u003E\n\u003Cp\u003E\nexcept an incorrectly installed version of KSPI, no.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-16T20:28:24Z\u0022 title=\u002203/16/2016 08:28  PM\u0022 data-short=\u00228 yr\u0022\u003EMarch 16, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-16T20:24:09Z","Content":"\n\u003Cp\u003E\nBtw, for those intrested, I\u0027m working on a new Engine, the Magneto Inertial Fusion Confinement Engine made by \u003Cstrong\u003E\u003Ca data-ipshover=\u0022\u0022 data-ipshover-target=\u0022http://forum.kerbalspaceprogram.com/index.php?/profile/106805-nli2work/\u0026amp;do=hovercard\u0026amp;referrer=http%253A%252F%252Fforum.kerbalspaceprogram.com%252Findex.php%253F%252Ftopic%252F133623-request-for-magneto-inertial-fusion-engine-model%252F\u0022 href=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/106805-nli2work/\u0022 title=\u0022Go to nli2work\u0027s profile\u0022\u003Enli2work\u003C/a\u003E\u003C/strong\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022IS2JF3t.jpg\u0022 class=\u0022ipsImage\u0022 src=\u0022http://i.imgur.com/IS2JF3t.jpg\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nIt will be a VISTA light engine, with fixed ISP and uses Lithium instead of Hydrogen as a propellant, but it has the benefit of running at much lower power requirements\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-17T08:46:38Z\u0022 title=\u002203/17/2016 08:46  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 17, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"RzTen1","CreatedById":159570,"CreatedDateTime":"2016-03-16T23:52:18Z","Content":"\n\u003Cp\u003E\nI have a bug in the code I posted, I was using AttachedReactor.MaximumThermalPower in the thrust calculation instead of AttachedReactor.MaximumPower.\u00A0 That was skewing reactors with charged particles.\n\u003C/p\u003E\n\u003Cp\u003E\nFixing that puts everything pretty close to the editor estimate:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nthis is in the format \u0022alt amount shown in editor :: actual in game amount measured by KER\u0022\u003Cbr\u003E\nall numbers with liquid fuel\n\u003C/p\u003E\n\u003Cp\u003E\nomega\u003Cbr\u003E\nvac 2209.6 isp - 3115.13kN :: 2209.5 isp - 3049.80kN\u003Cbr\u003E\nsea 1994.0 isp - 2811.94kN :: 1992.2 isp - 2749.29kN\n\u003C/p\u003E\n\u003Cp\u003E\npebble\u003Cbr\u003E\nvac 781.2 - 1566.38 :: 781.2 - 1566.29\u003Cbr\u003E\nsea 629.6 - 1262.41 :: 631.6 - 1266.33\n\u003C/p\u003E\n\u003Cp\u003E\ndumbo\u003Cbr\u003E\nvac 781.2 - 3132.77 :: 781.2 - 3132.60\u003Cbr\u003E\nsea 705.4 - 2828.79 :: 706.4 - 2832.71\n\u003C/p\u003E\n\u003Cp\u003E\nsalt\u003Cbr\u003E\nsea 199.2 - 113.44 :: 206.1 - 117.35\n\u003C/p\u003E\n\u003Cp\u003E\ndusty\u003Cbr\u003E\nsea 627.5 - 511.45 :: 632.4 - 515.44\n\u003C/p\u003E\n\u003Cp\u003E\nantimater\u003Cbr\u003E\nsea 6082.9 - 3388.03 :: 6090.2 - 3392.05\u003Cbr\u003E\nvac 6628.7 - 3692.00 :: 6628.7 - 3690.56\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"Steel Chicken","CreatedById":89928,"CreatedDateTime":"2016-03-17T00:03:20Z","Content":"\n\u003Cp\u003E\nIn 1.6.9 noticing that Inertial Confinement Reactors will do something odd when hooked up to a thermal ram jet, basically too much thrust causes them starve themselves and shutdown.\u00A0 This happens in vacuum, atmosphere, etc.\u00A0 Apologies if this was already discussed.\n\u003C/p\u003E\n"},{"CreatedByName":"RzTen1","CreatedById":159570,"CreatedDateTime":"2016-03-17T00:58:07Z","Content":"\n\u003Cp\u003E\nOn a related note, BetterBurnTime was also throwing incorrect numbers.\u00A0 It looks like it depends on engine.MaxThrust to calculate the burn time and it\u0027s\u00A0 just pulled out of the engine config file and never updated.\u00A0 Since this already getting calculated while the engine is running I just added it into OnFixedUpdate for ThermalNozzleController.cs:\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint prettyprinted\u0022\u003E\n\u003Cspan\u003E                expectedMaxThrust \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Efloat\u003C/span\u003E\u003Cspan\u003E)(\u003C/span\u003E\u003Cspan\u003EAttachedReactor\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EMaximumPower\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EGetPowerThrustModifier\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EGetHeatThrustModifier\u003C/span\u003E\u003Cspan\u003E()\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EPluginHelper\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGravityConstant\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E _maxISP\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\n                expectedMaxThrust \u003C/span\u003E\u003Cspan\u003E*=\u003C/span\u003E\u003Cspan\u003E _thrustPropellantMultiplier \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003E1f\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E-\u003C/span\u003E\u003Cspan\u003E sootAccumulationPercentage \u003C/span\u003E\u003Cspan\u003E/\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E200f\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\n                myAttachedEngine\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EmaxThrust \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E expectedMaxThrust\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nThe last line is the only change.\u00A0 Here\u0027s a diff of the changes I\u0027ve made so far compared to the latest from github:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\ndiff ThermalNozzleController.cs.old ThermalNozzleController.cs -b\u003Cbr\u003E\n885c885,894\u003Cbr\u003E\n\u0026lt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _minISP = _maxISP * 0.4f;\u003Cbr\u003E\n---\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //_minISP = _maxISP * 0.4f;\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //atmospherecurve.Add(0, _maxISP, 0, 0);\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //atmospherecurve.Add(1, _minISP, 0, 0);\u003Cbr\u003E\n\u0026gt;\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //thrust = (float)(AttachedReactor.MaximumPower * GetPowerThrustModifier() * GetHeatThrustModifier() / PluginHelper.GravityConstant / _maxISP);\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 thrust = ((float)GetPowerThrustModifier() * (float)GetHeatThrustModifier() * AttachedReactor.MaximumPower / _maxISP / PluginHelper.GravityConstant * (float)GetHeatExchangerThrustDivisor() * _thrustPropellantMultiplier);\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxFuelFlow = thrust / (PluginHelper.GravityConstant * _maxISP);\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = thrust;\u003Cbr\u003E\n\u0026gt;\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _minISP = _maxISP * ((thrust - maxPressureThresholdAtKerbinSurface) / thrust) * (float)GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n889,890d897\u003Cbr\u003E\n\u0026lt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 thrust = (float)(AttachedReactor.MaximumPower * GetPowerThrustModifier() * GetHeatThrustModifier() / PluginHelper.GravityConstant / _maxISP);\u003Cbr\u003E\n\u0026lt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = thrust;\u003Cbr\u003E\n999a1007,1008\u003Cbr\u003E\n\u0026gt;\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = expectedMaxThrust;\u003Cbr\u003E\n\u0026gt;\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-17T01:18:59Z\u0022 title=\u002203/17/2016 01:18  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 17, 2016\u003C/time\u003E by RzTen1\u003C/strong\u003E\n\u003Cbr\u003Eadded a diff\n\u003C/span\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-17T06:31:47Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222460571\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221458172338\u0022 data-ipsquote-userid=\u0022159570\u0022 data-ipsquote-username=\u0022RzTen1\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n6 hours ago, RzTen1 said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nI have a bug in the code I posted, I was using AttachedReactor.MaximumThermalPower in the thrust calculation instead of AttachedReactor.MaximumPower.\u00A0 That was skewing reactors with charged particles.\n\u003C/p\u003E\n\u003Cp\u003E\nFixing that puts everything pretty close to the editor estimate:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Ca href=\u0022#\u0022 rel=\u0022external\u0022\u003E\u00A0\u003C/a\u003E \u003Cspan\u003EReveal hidden contents\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nthis is in the format \u0022alt amount shown in editor :: actual in game amount measured by KER\u0022\u003Cbr\u003E\nall numbers with liquid fuel\n\u003C/p\u003E\n\u003Cp\u003E\nomega\u003Cbr\u003E\nvac 2209.6 isp - 3115.13kN :: 2209.5 isp - 3049.80kN\u003Cbr\u003E\nsea 1994.0 isp - 2811.94kN :: 1992.2 isp - 2749.29kN\n\u003C/p\u003E\n\u003Cp\u003E\npebble\u003Cbr\u003E\nvac 781.2 - 1566.38 :: 781.2 - 1566.29\u003Cbr\u003E\nsea 629.6 - 1262.41 :: 631.6 - 1266.33\n\u003C/p\u003E\n\u003Cp\u003E\ndumbo\u003Cbr\u003E\nvac 781.2 - 3132.77 :: 781.2 - 3132.60\u003Cbr\u003E\nsea 705.4 - 2828.79 :: 706.4 - 2832.71\n\u003C/p\u003E\n\u003Cp\u003E\nsalt\u003Cbr\u003E\nsea 199.2 - 113.44 :: 206.1 - 117.35\n\u003C/p\u003E\n\u003Cp\u003E\ndusty\u003Cbr\u003E\nsea 627.5 - 511.45 :: 632.4 - 515.44\n\u003C/p\u003E\n\u003Cp\u003E\nantimater\u003Cbr\u003E\nsea 6082.9 - 3388.03 :: 6090.2 - 3392.05\u003Cbr\u003E\nvac 6628.7 - 3692.00 :: 6628.7 - 3690.56\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nCorrect. this was the minor mistake I was referring to\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-17T06:39:55Z\u0022 title=\u002203/17/2016 06:39  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 17, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-17T20:43:06Z","Content":"\n\u003Cp\u003E\nMagneto Inertial Confinement Fusion Engine in space\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022uRiBHrF.jpg\u0022 class=\u0022ipsImage\u0022 height=\u0022750\u0022 src=\u0022http://i.imgur.com/uRiBHrF.jpg\u0022 width=\u0022945\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"Table","CreatedById":158269,"CreatedDateTime":"2016-03-18T03:19:46Z","Content":"\n\u003Cp\u003E\nWhy am I missing some parts?\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nOh and I just found out that some parts of this mod are the same textures in Porkjet\u0027s atomic age.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\ntf\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-18T03:23:24Z\u0022 title=\u002203/18/2016 03:23  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 18, 2016\u003C/time\u003E by Table\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"RzTen1","CreatedById":159570,"CreatedDateTime":"2016-03-18T05:18:09Z","Content":"\n\u003Cp\u003E\nI wasn\u0027t all that happy with the prior code I submitted, it was close but still off in odd ways depending on engine/reactor combo, so I\u0027ve redone all of it.\u00A0 Orbital thrust and isp now match exactly with actual in game values.\u00A0 Atmospheric readings are still off by a couple of percent, but that seems to be due to the EarthAtmospherePressureAtSeaLevel constant reading 101.325 while I get closer to 100 on the pad.\u00A0 In any case, atmospheric is much better and actually usable for orbital insertion calculations.\n\u003C/p\u003E\n\u003Cp\u003E\nI also redid the section for BetterBurnTime to accurately calculate the actual maximum thrust so that it matches in flight values exactly.\n\u003C/p\u003E\n\u003Cp\u003E\nBuoyancy calculations are still missing, so the open gas core reactor\u0027s numbers are optimistic at best.\n\u003C/p\u003E\n\u003Cp\u003E\nHere is a diff compared to the current version in github (the last commit added my first patch attempt).\u00A0 A new vairable has been added to both in-flight sections to avoid stepping on other code, calculatedMaxThrust.\u00A0 This will contain the maximum thrust at full throttle for the engine at the current altitude both while running and idle, as long as the engine is active.\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\ndiff -ub ThermalNozzleController.cs ThermalNozzleController.cs.new\u003Cbr\u003E\n--- ThermalNozzleController.cs\u00A0 2016-03-17 23:26:59.994654300 -0600\u003Cbr\u003E\n\u002B\u002B\u002B ThermalNozzleController.cs.new\u00A0\u00A0\u00A0\u00A0\u00A0 2016-03-17 23:27:04.141891500 -0600\u003Cbr\u003E\n@@ -875,11 \u002B875,33 @@\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _maxISP = Mathf.Sqrt(AttachedReactor.CoreTemperature) * (PluginHelper.IspCoreTempMult \u002B IspTempMultOffset) * GetIspPropellantModifier();\n\u003C/p\u003E\n\u003Cp\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float thrust = GetPowerThrustModifier() * GetHeatThrustModifier() * AttachedReactor.MaximumPower / _maxISP / PluginHelper.GravityConstant * GetHeatExchangerThrustDivisor() * _thrustPropellantMultiplier;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float thrust = GetPowerThrustModifier() * GetHeatThrustModifier() * AttachedReactor.MaximumPower / _maxISP / PluginHelper.GravityConstant * GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float max_thrust_in_space = thrust;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 thrust *= _thrustPropellantMultiplier;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxFuelFlow = thrust / (PluginHelper.GravityConstant * _maxISP);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = thrust;\n\u003C/p\u003E\n\u003Cp\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _minISP = _maxISP * ((thrust - maxPressureThresholdAtKerbinSurface) / thrust) * GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //_minISP = _maxISP * ((thrust - maxPressureThresholdAtKerbinSurface) / thrust) * GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //atmospherecurve.Add(0, _maxISP, 0, 0);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //atmospherecurve.Add(1, _minISP, 0, 0);\u003Cbr\u003E\n\u002B\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float max_thrust_in_current_atmosphere = max_thrust_in_space;\u003Cbr\u003E\n\u002B\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // update engine thrust/ISP for thermal noozle\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!_currentpropellant_is_jet)\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = exitArea * (float)GameConstants.EarthAtmospherePressureAtSeaLevel;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_maxISP \u0026gt; GameConstants.MaxThermalNozzleIsp )\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold *= 10;\u003Cbr\u003E\n\u002B\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_thrust_in_current_atmosphere = max_thrust_in_space - pressureTreshold;\u003Cbr\u003E\n\u002B\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustAtmosphereRatio = max_thrust_in_space \u0026gt; 0 ? Math.Max(max_thrust_in_current_atmosphere / max_thrust_in_space, 0.01 ) : 0.01;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _minISP = _maxISP * (float)thrustAtmosphereRatio;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _minISP = _maxISP;\u003Cbr\u003E\n\u002B\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 atmospherecurve.Add(0, _maxISP, 0, 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 atmospherecurve.Add(1, _minISP, 0, 0);\n\u003C/p\u003E\n\u003Cp\u003E\n@@ -988,19 \u002B1010,26 @@\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _maxISP = (float)(Math.Sqrt((double)AttachedReactor.CoreTemperature) * (PluginHelper.IspCoreTempMult \u002B IspTempMultOffset) * GetIspPropellantModifier());\n\u003C/p\u003E\n\u003Cp\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 expectedMaxThrust = (float)(AttachedReactor.MaximumPower * GetPowerThrustModifier() * GetHeatThrustModifier() / PluginHelper.GravityConstant / _maxISP);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 expectedMaxThrust = (float)(AttachedReactor.MaximumPower * GetPowerThrustModifier() * GetHeatThrustModifier() / PluginHelper.GravityConstant / _maxISP * (float)GetHeatExchangerThrustDivisor());\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float calculatedMaxThrust = expectedMaxThrust;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 expectedMaxThrust *= _thrustPropellantMultiplier * (1f - sootAccumulationPercentage / 200f);\n\u003C/p\u003E\n\u003Cp\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = expectedMaxThrust;\u003Cbr\u003E\n-\u003Cbr\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // suggested by RzTen1 to improve compatibility with BetterBurnTime\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = (float)(expectedMaxThrust / _maxISP / PluginHelper.GravityConstant);\n\u003C/p\u003E\n\u003Cp\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = _currentpropellant_is_jet ? 0 : exitArea * (float)FlightGlobals.getStaticPressure(vessel.transform.position);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!_currentpropellant_is_jet)\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = exitArea * (float)FlightGlobals.getStaticPressure(vessel.transform.position);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_maxISP \u0026gt; GameConstants.MaxThermalNozzleIsp)\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold *= 10;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = 0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustAtmosphereRatio = expectedMaxThrust \u0026lt;= 0 ? 0 : Math.Max(0, expectedMaxThrust - pressureTreshold) / expectedMaxThrust;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 current_isp = _maxISP * (float)thrustAtmosphereRatio;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust -= pressureTreshold;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust *= (float)_thrustPropellantMultiplier * (1f - sootAccumulationPercentage / sootThrustDivider);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 FloatCurve newISP = new FloatCurve();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var effectiveIsp = isJet ? Mathf.Min(current_isp, PluginHelper.MaxThermalNozzleIsp) : current_isp;\u003Cbr\u003E\n@@ -1012,8 \u002B1041,12 @@\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 double vcurve_at_current_velocity = myAttachedEngine.velCurve.Evaluate((float)vessel.srf_velocity.magnitude);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (vcurve_at_current_velocity \u0026gt; 0 \u0026amp;\u0026amp; !double.IsInfinity(vcurve_at_current_velocity) \u0026amp;\u0026amp; !double.IsNaN(vcurve_at_current_velocity))\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = (float)(max_fuel_flow_rate / vcurve_at_current_velocity);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = calculatedMaxThrust / (float)vcurve_at_current_velocity;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = calculatedMaxThrust \u0026gt; 0 ? calculatedMaxThrust : 0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // set engines maximum fuel flow\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxFuelFlow = Math.Min(1000f, (float)max_fuel_flow_rate);\u003Cbr\u003E\n@@ -1072,11 \u002B1105,13 @@\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 heatExchangerThrustDivisor = (float)GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 radiusModifier = (heatExchangerThrustDivisor * 100).ToString(\u00220.00\u0022) \u002B \u0022%\u0022;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 engineMaxThrust = 0.01f;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float calculatedMaxThrust = 0;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_availableThermalPower \u0026gt; 0)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var ispRatio = _currentpropellant_is_jet ? current_isp / _maxISP : 1;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustLimit = myAttachedEngine.thrustPercentage / 100.0f;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 engineMaxThrust = (float)Math.Max(thrustLimit * GetPowerThrustModifier() * GetHeatThrustModifier() * thermal_power_received / _maxISP / PluginHelper.GravityConstant * heatExchangerThrustDivisor * ispRatio / myAttachedEngine.currentThrottle, 0.01);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = GetPowerThrustModifier() * GetHeatThrustModifier() * AttachedReactor.MaximumPower / _maxISP / PluginHelper.GravityConstant * heatExchangerThrustDivisor * ispRatio;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_thrust_in_space = engineMaxThrust / myAttachedEngine.thrustPercentage * 100;\u003Cbr\u003E\n@@ -1097,13 \u002B1132,21 @@\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustAtmosphereRatio = max_thrust_in_space \u0026gt; 0 ? Math.Max(max_thrust_in_current_atmosphere / max_thrust_in_space, 0.01 ) : 0.01;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 UpdateIspEngineParams(thrustAtmosphereRatio);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 current_isp = _maxISP * (float)thrustAtmosphereRatio;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust -= pressureTreshold;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 current_isp = _maxISP;\n\u003C/p\u003E\n\u003Cp\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 final_max_engine_thrust = !Single.IsInfinity(max_thrust_in_current_atmosphere) \u0026amp;\u0026amp; !Single.IsNaN(max_thrust_in_current_atmosphere)\u003Cbr\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 ? max_thrust_in_current_atmosphere * _thrustPropellantMultiplier * (1f - sootAccumulationPercentage / sootThrustDivider)\u003Cbr\u003E\n-\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 : 0.000001f;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!Single.IsInfinity(max_thrust_in_current_atmosphere) \u0026amp;\u0026amp; !Single.IsNaN(max_thrust_in_current_atmosphere))\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 final_max_engine_thrust = max_thrust_in_current_atmosphere * _thrustPropellantMultiplier * (1f - sootAccumulationPercentage / sootThrustDivider);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust *= (float)_thrustPropellantMultiplier * (1f - sootAccumulationPercentage / sootThrustDivider);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 final_max_engine_thrust = 0.000001f;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = final_max_engine_thrust;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // amount of fuel being used at max throttle with no atmospheric limits\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_maxISP \u0026lt;= 0) return;\u003Cbr\u003E\n@@ -1116,10 \u002B1159,17 @@\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 vcurveAtCurrentVelocity = myAttachedEngine.velCurve.Evaluate((float)(vessel.speed / vessel.speedOfSound));\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (vcurveAtCurrentVelocity \u0026gt; 0 \u0026amp;\u0026amp; !double.IsInfinity(vcurveAtCurrentVelocity) \u0026amp;\u0026amp; !double.IsNaN(vcurveAtCurrentVelocity))\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = (float)(max_fuel_flow_rate * vcurveAtCurrentVelocity);\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust *= (float)vcurveAtCurrentVelocity;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = 0.000001f;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = 0;\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u002B\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = calculatedMaxThrust \u0026gt; 0 ? calculatedMaxThrust : 0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (atmospheric_limit \u0026gt; 0 \u0026amp;\u0026amp; atmospheric_limit != 1 \u0026amp;\u0026amp; !double.IsInfinity(atmospheric_limit) \u0026amp;\u0026amp; !double.IsNaN(atmospheric_limit))\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = max_fuel_flow_rate * atmospheric_limit;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\nIn case that\u0027s hard to read, here are the changed functions in their entirety.\n\u003C/p\u003E\n\u003Cp\u003E\nEstimateEditorPerformance:\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 public void EstimateEditorPerformance()\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 FloatCurve atmospherecurve = new FloatCurve();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 UpdateRadiusModifier();\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (AttachedReactor != null)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _maxISP = Mathf.Sqrt(AttachedReactor.CoreTemperature) * (PluginHelper.IspCoreTempMult \u002B IspTempMultOffset) * GetIspPropellantModifier();\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float thrust = GetPowerThrustModifier() * GetHeatThrustModifier() * AttachedReactor.MaximumPower / _maxISP / PluginHelper.GravityConstant * GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float max_thrust_in_space = thrust;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 thrust *= _thrustPropellantMultiplier;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxFuelFlow = thrust / (PluginHelper.GravityConstant * _maxISP);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = thrust;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //_minISP = _maxISP * ((thrust - maxPressureThresholdAtKerbinSurface) / thrust) * GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //atmospherecurve.Add(0, _maxISP, 0, 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //atmospherecurve.Add(1, _minISP, 0, 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float max_thrust_in_current_atmosphere = max_thrust_in_space;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // update engine thrust/ISP for thermal noozle\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!_currentpropellant_is_jet)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = exitArea * (float)GameConstants.EarthAtmospherePressureAtSeaLevel;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_maxISP \u0026gt; GameConstants.MaxThermalNozzleIsp )\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold *= 10;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_thrust_in_current_atmosphere = max_thrust_in_space - pressureTreshold;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustAtmosphereRatio = max_thrust_in_space \u0026gt; 0 ? Math.Max(max_thrust_in_current_atmosphere / max_thrust_in_space, 0.01 ) : 0.01;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _minISP = _maxISP * (float)thrustAtmosphereRatio;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _minISP = _maxISP;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 atmospherecurve.Add(0, _maxISP, 0, 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 atmospherecurve.Add(1, _minISP, 0, 0);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.atmosphereCurve = atmospherecurve;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 atmospherecurve.Add(0, 0.00001f, 0, 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = 0;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.atmosphereCurve = atmospherecurve;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\nOnFixedUpdate - \u00A0if myAttachedEngine.isOperational block:\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (myAttachedEngine.isOperational \u0026amp;\u0026amp; myAttachedEngine.currentThrottle \u0026gt; 0)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 GenerateThrustFromReactorHeat();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //requestedReactorThermalPower = String.Empty;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //requestedReactorChargedPower = String.Empty;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 //recievedReactorPower = String.Empty;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 consumedWasteHeat = 0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 atmospheric_limit = GetAtmosphericLimit();\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _maxISP = (float)(Math.Sqrt((double)AttachedReactor.CoreTemperature) * (PluginHelper.IspCoreTempMult \u002B IspTempMultOffset) * GetIspPropellantModifier());\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 expectedMaxThrust = (float)(AttachedReactor.MaximumPower * GetPowerThrustModifier() * GetHeatThrustModifier() / PluginHelper.GravityConstant / _maxISP * (float)GetHeatExchangerThrustDivisor());\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float calculatedMaxThrust = expectedMaxThrust;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 expectedMaxThrust *= _thrustPropellantMultiplier * (1f - sootAccumulationPercentage / 200f);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = (float)(expectedMaxThrust / _maxISP / PluginHelper.GravityConstant);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!_currentpropellant_is_jet)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = exitArea * (float)FlightGlobals.getStaticPressure(vessel.transform.position);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_maxISP \u0026gt; GameConstants.MaxThermalNozzleIsp)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold *= 10;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = 0;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustAtmosphereRatio = expectedMaxThrust \u0026lt;= 0 ? 0 : Math.Max(0, expectedMaxThrust - pressureTreshold) / expectedMaxThrust;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 current_isp = _maxISP * (float)thrustAtmosphereRatio;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust -= pressureTreshold;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust *= (float)_thrustPropellantMultiplier * (1f - sootAccumulationPercentage / sootThrustDivider);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 FloatCurve newISP = new FloatCurve();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var effectiveIsp = isJet ? Mathf.Min(current_isp, PluginHelper.MaxThermalNozzleIsp) : current_isp;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 newISP.Add(0, effectiveIsp, 0, 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.atmosphereCurve = newISP;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (myAttachedEngine.useVelCurve)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 double vcurve_at_current_velocity = myAttachedEngine.velCurve.Evaluate((float)vessel.srf_velocity.magnitude);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (vcurve_at_current_velocity \u0026gt; 0 \u0026amp;\u0026amp; !double.IsInfinity(vcurve_at_current_velocity) \u0026amp;\u0026amp; !double.IsNaN(vcurve_at_current_velocity))\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = (float)(max_fuel_flow_rate / vcurve_at_current_velocity);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = calculatedMaxThrust / (float)vcurve_at_current_velocity;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = calculatedMaxThrust \u0026gt; 0 ? calculatedMaxThrust : 0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // set engines maximum fuel flow\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxFuelFlow = Math.Min(1000f, (float)max_fuel_flow_rate);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (myAttachedEngine is ModuleEnginesFX \u0026amp;\u0026amp; !String.IsNullOrEmpty(_particleFXName))\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 part.Effect(_particleFXName, 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\nGenerateThrustFromReactorHeat:\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\nprivate void GenerateThrustFromReactorHeat()\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!AttachedReactor.IsActive)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 AttachedReactor.EnableIfPossible();\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 GetMaximumIspAndThrustMultiplier();\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float chargedPowerModifier = _isNeutronAbsorber ? 1 : (AttachedReactor.FullPowerForNonNeutronAbsorbants ? 1 : (float)_myAttachedReactor.ChargedPowerRatio);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 thermal_modifiers = myAttachedEngine.currentThrottle * GetAtmosphericLimit() * _myAttachedReactor.GetFractionThermalReciever(id) * chargedPowerModifier;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var maximum_requested_thermal_power = _currentMaximumPower * thermal_modifiers;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var neutronAbsorbingModifier = _isNeutronAbsorber ? 1 : (AttachedReactor.FullPowerForNonNeutronAbsorbants ? 1 : 0);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 requested_thermal_power = Math.Min(_availableThermalPower * thermal_modifiers, AttachedReactor.MaximumThermalPower * delayedThrottle * neutronAbsorbingModifier);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 thermal_power_received = consumeFNResource(requested_thermal_power * TimeWarp.fixedDeltaTime, FNResourceManager.FNRESOURCE_THERMALPOWER) * _myAttachedReactor.ThermalPropulsionEfficiency / TimeWarp.fixedDeltaTime;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (thermal_power_received \u0026lt; maximum_requested_thermal_power)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var chargedParticleRatio = (float)Math.Pow(getResourceBarRatio(FNResourceManager.FNRESOURCE_CHARGED_PARTICLES), 2);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 requested_charge_particles = Math.Min((maximum_requested_thermal_power - thermal_power_received), AttachedReactor.MaximumChargedPower) * chargedParticleRatio;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 thermal_power_received \u002B= consumeFNResource(requested_charge_particles * TimeWarp.fixedDeltaTime, FNResourceManager.FNRESOURCE_CHARGED_PARTICLES) / TimeWarp.fixedDeltaTime;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 UpdateSootAccumulation();\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var extraWasteheatRedution = AttachedReactor.FullPowerForNonNeutronAbsorbants\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 ? TimeWarp.fixedDeltaTime * getResourceAvailability(FNResourceManager.FNRESOURCE_WASTEHEAT) * myAttachedEngine.currentThrottle\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 : 0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var sootModifier = 1f - (sootAccumulationPercentage / sootHeatDivider);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 consumedWasteHeat = sootModifier * (float)Math.Max(AttachedReactor.ProducedWasteHeat \u002B extraWasteheatRedution, thermal_power_received);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // consume wasteheat\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 consumeFNResource(consumedWasteHeat * TimeWarp.fixedDeltaTime, FNResourceManager.FNRESOURCE_WASTEHEAT);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // calculate max thrust\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 heatExchangerThrustDivisor = (float)GetHeatExchangerThrustDivisor();\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 radiusModifier = (heatExchangerThrustDivisor * 100).ToString(\u00220.00\u0022) \u002B \u0022%\u0022;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 engineMaxThrust = 0.01f;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float calculatedMaxThrust = 0;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_availableThermalPower \u0026gt; 0)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var ispRatio = _currentpropellant_is_jet ? current_isp / _maxISP : 1;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustLimit = myAttachedEngine.thrustPercentage / 100.0f;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 engineMaxThrust = (float)Math.Max(thrustLimit * GetPowerThrustModifier() * GetHeatThrustModifier() * thermal_power_received / _maxISP / PluginHelper.GravityConstant * heatExchangerThrustDivisor * ispRatio / myAttachedEngine.currentThrottle, 0.01);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = GetPowerThrustModifier() * GetHeatThrustModifier() * AttachedReactor.MaximumPower / _maxISP / PluginHelper.GravityConstant * heatExchangerThrustDivisor * ispRatio;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_thrust_in_space = engineMaxThrust / myAttachedEngine.thrustPercentage * 100;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var nozzleStaticPresure = (float)FlightGlobals.getStaticPressure(vessel.transform.position);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_thrust_in_current_atmosphere = max_thrust_in_space;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // update engine thrust/ISP for thermal noozle\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!_currentpropellant_is_jet)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold = exitArea * nozzleStaticPresure;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_maxISP \u0026gt; GameConstants.MaxThermalNozzleIsp )\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 pressureTreshold *= 10;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_thrust_in_current_atmosphere = Mathf.Max(max_thrust_in_space - pressureTreshold, Mathf.Max(myAttachedEngine.currentThrottle * 0.01f, 0.0001f));\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 var thrustAtmosphereRatio = max_thrust_in_space \u0026gt; 0 ? Math.Max(max_thrust_in_current_atmosphere / max_thrust_in_space, 0.01 ) : 0.01;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 UpdateIspEngineParams(thrustAtmosphereRatio);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 current_isp = _maxISP * (float)thrustAtmosphereRatio;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust -= pressureTreshold;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 current_isp = _maxISP;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (!Single.IsInfinity(max_thrust_in_current_atmosphere) \u0026amp;\u0026amp; !Single.IsNaN(max_thrust_in_current_atmosphere))\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 final_max_engine_thrust = max_thrust_in_current_atmosphere * _thrustPropellantMultiplier * (1f - sootAccumulationPercentage / sootThrustDivider);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust *= (float)_thrustPropellantMultiplier * (1f - sootAccumulationPercentage / sootThrustDivider);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 final_max_engine_thrust = 0.000001f;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = final_max_engine_thrust;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 // amount of fuel being used at max throttle with no atmospheric limits\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_maxISP \u0026lt;= 0) return;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// calculate maximum fuel flow rate\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = final_max_engine_thrust / current_isp / PluginHelper.GravityConstant / myAttachedEngine.currentThrottle;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (myAttachedEngine.useVelCurve \u0026amp;\u0026amp; myAttachedEngine.velCurve != null)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 vcurveAtCurrentVelocity = myAttachedEngine.velCurve.Evaluate((float)(vessel.speed / vessel.speedOfSound));\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (vcurveAtCurrentVelocity \u0026gt; 0 \u0026amp;\u0026amp; !double.IsInfinity(vcurveAtCurrentVelocity) \u0026amp;\u0026amp; !double.IsNaN(vcurveAtCurrentVelocity))\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = (float)(max_fuel_flow_rate * vcurveAtCurrentVelocity);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust *= (float)vcurveAtCurrentVelocity;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = 0.000001f;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 calculatedMaxThrust = 0;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxThrust = calculatedMaxThrust \u0026gt; 0 ? calculatedMaxThrust : 0;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (atmospheric_limit \u0026gt; 0 \u0026amp;\u0026amp; atmospheric_limit != 1 \u0026amp;\u0026amp; !double.IsInfinity(atmospheric_limit) \u0026amp;\u0026amp; !double.IsNaN(atmospheric_limit))\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 max_fuel_flow_rate = max_fuel_flow_rate * atmospheric_limit;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 engineHeatProduction = (max_fuel_flow_rate \u0026gt;= 0.0001) ? baseHeatProduction * 350 / max_fuel_flow_rate /(float)Math.Pow(_maxISP, 0.8)\u00A0 : baseHeatProduction;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.heatProduction = engineHeatProduction;\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// set engines maximum fuel flow\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 myAttachedEngine.maxFuelFlow = Math.Min(1000, max_fuel_flow_rate);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (myAttachedEngine is ModuleEnginesFX \u0026amp;\u0026amp; !String.IsNullOrEmpty(_particleFXName))\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 part.Effect(_particleFXName, Mathf.Max(0.1f * myAttachedEngine.currentThrottle,\u00A0 Mathf.Min((float)Math.Pow(thermal_power_received / requested_thermal_power, 0.5), delayedThrottle)));\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_fuelToxicity \u0026gt; 0 \u0026amp;\u0026amp; max_fuel_flow_rate \u0026gt; 0 \u0026amp;\u0026amp; nozzleStaticPresure \u0026gt; 1)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _savedReputationCost \u002B= (float)(max_fuel_flow_rate * _fuelToxicity * TimeWarp.fixedDeltaTime * Math.Pow(nozzleStaticPresure / 100, 3));\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (_savedReputationCost \u0026gt; 1)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 {\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 float flooredReputationCost = (int)Math.Floor(_savedReputationCost);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 if (Reputation.Instance != null)\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 Reputation.Instance.addReputation_discrete(-flooredReputationCost, TransactionReasons.None);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 else\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 UnityEngine.Debug.Log(\u0022[KSPI] - ThermalNozzleController - No Reputation found, was not able to reduce reputation by \u0022 \u002B flooredReputationCost);\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 ScreenMessages.PostScreenMessage(\u0022You are poisoning the environment with \u0022 \u002B _fuelmode \u002B \u0022 from your exhaust!\u0022, 5.0f, ScreenMessageStyle.LOWER_CENTER);\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 _savedReputationCost -= flooredReputationCost;\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\u003Cbr\u003E\n\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 }\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-18T05:29:55Z\u0022 title=\u002203/18/2016 05:29  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 18, 2016\u003C/time\u003E by RzTen1\u003C/strong\u003E\n\u003Cbr\u003Eswitched to a unified diff\n\u003C/span\u003E\n"},{"CreatedByName":"RzTen1","CreatedById":159570,"CreatedDateTime":"2016-03-18T06:49:49Z","Content":"\n\u003Cp\u003E\nI noticed some weirdness in the current build.\u00A0 I\u0027m getting correct thrust numbers for everything I\u0027ve thrown at it, but three reactors are acting up:\n\u003C/p\u003E\n\u003Cp\u003E\n1. The \u0027Reactor: Antimatter\u0027 reactor is only generating 480KW of power.\u00A0 The thermal mechanics helper and the reactor control panel both show the same numbers.\u003Cbr\u003E\n2. The \u0027Antimatter Initiated Fusion Reactor\u0027 is only generating 81KW.\u00A0 Same as above in the helper/panel.\u003Cbr\u003E\n3. The \u0027Magneto Internal Fusion Reactor\u0027 is generating 13.5MW, which seems correct, but the thermal nozzle will only accept Lithium as the fuel source.\u00A0 I can\u0027t get the Lithium cans to attach for some reason, so I can\u0027t test with it.\n\u003C/p\u003E\n\u003Cp\u003E\nThe \u0027Magnetic Confinement Fusion Reactor\u0027 seems unaffected and is generating an expected 27MW.\n\u003C/p\u003E\n\u003Cp\u003E\nAlso both generators seem to have issues attaching to the rocket:\u003Cbr\u003E\u003Cimg class=\u0022ipsImage\u0022 src=\u0022http://www.powercpu.net/ksp-testing/floaty.png\u0022 alt=\u0022floaty.png\u0022\u003E\u003Cbr\u003E\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-18T06:58:29Z","Content":"\n\u003Cp\u003E\nGreat stuff, but Why don\u0027t you commit in github?\n\u003C/p\u003E\n"},{"CreatedByName":"RzTen1","CreatedById":159570,"CreatedDateTime":"2016-03-18T07:08:35Z","Content":"\n\u003Cp\u003E\nI just created an account under the same ID as here.\u00A0 I\u0027ll muddle around there and try to get my stuff uploaded.\n\u003C/p\u003E\n"},{"CreatedByName":"FreeThinker","CreatedById":117389,"CreatedDateTime":"2016-03-18T09:06:03Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222462386\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221458283789\u0022 data-ipsquote-userid=\u0022159570\u0022 data-ipsquote-username=\u0022RzTen1\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n2 hours ago, RzTen1 said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0noticed some weirdness in the current build.\u00A0 I\u0027m getting correct thrust numbers for everything I\u0027ve thrown at it, but three reactors are acting up:\n\u003C/p\u003E\n\u003Cp\u003E\n1. The \u0027Reactor: Antimatter\u0027 reactor is only generating 480KW of power.\u00A0 The thermal mechanics helper and the reactor control panel both show the same numbers.\u003Cbr\u003E\n2. The \u0027Antimatter Initiated Fusion Reactor\u0027 is only generating 81KW.\u00A0 Same as above in the helper/panel.\u003Cbr\u003E\n3. The \u0027Magneto Internal Fusion Reactor\u0027 is generating 13.5MW, which seems correct, but the thermal nozzle will only accept Lithium as the fuel source.\u00A0 I can\u0027t get the Lithium cans to attach for some reason, so I can\u0027t test with it.\n\u003C/p\u003E\n\u003Cp\u003E\nThe \u0027Magnetic Confinement Fusion Reactor\u0027 seems unaffected and is generating an expected 27MW.\n\u003C/p\u003E\n\u003Cp\u003E\nAlso both generators seem to have issues attaching to the rocket:\u003Cbr\u003E\u003Ca href=\u0022http://www.powercpu.net/ksp-testing/floaty.png\u0022 rel=\u0022external nofollow\u0022 title=\u0022Enlarge image\u0022\u003E\u003Cimg alt=\u0022floaty.png\u0022 class=\u0022ipsImage ipsImage_thumbnailed\u0022 src=\u0022http://www.powercpu.net/ksp-testing/floaty.png\u0022\u003E\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222462386\u0022 data-ipsquote-contentid=\u0022100190\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221458283789\u0022 data-ipsquote-userid=\u0022159570\u0022 data-ipsquote-username=\u0022RzTen1\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n2 hours ago, RzTen1 said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nI noticed some weirdness in the current build.\u00A0 I\u0027m getting correct thrust numbers for everything I\u0027ve thrown at it, but three reactors are acting up:\n\u003C/p\u003E\n\u003Cp\u003E\n1. The \u0027Reactor: Antimatter\u0027 reactor is only generating 480KW of power.\u00A0 The thermal mechanics helper and the reactor control panel both show the same numbers.\u003Cbr\u003E\n2. The \u0027Antimatter Initiated Fusion Reactor\u0027 is only generating 81KW.\u00A0 Same as above in the helper/panel.\u003Cbr\u003E\n3. The \u0027Magneto Internal Fusion Reactor\u0027 is generating 13.5MW, which seems correct, but the thermal nozzle will only accept Lithium as the fuel source.\u00A0 I can\u0027t get the Lithium cans to attach for some reason, so I can\u0027t test with it.\n\u003C/p\u003E\n\u003Cp\u003E\nThe \u0027Magnetic Confinement Fusion Reactor\u0027 seems unaffected and is generating an expected 27MW.\n\u003C/p\u003E\n\u003Cp\u003E\nAlso both generators seem to have issues attaching to the rocket:\u003Cbr\u003E\u003Ca href=\u0022http://www.powercpu.net/ksp-testing/floaty.png\u0022 rel=\u0022external nofollow\u0022 title=\u0022Enlarge image\u0022\u003E\u003Cimg alt=\u0022floaty.png\u0022 class=\u0022ipsImage ipsImage_thumbnailed\u0022 src=\u0022http://www.powercpu.net/ksp-testing/floaty.png\u0022\u003E\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nAre you sure you haven\u0027t installed NFT-E or SETI? it reduces all reactors power by a factor 500. But I will verify the 2 Antimatter reactor still work. Something might have broken\n\u003C/p\u003E\n\u003Cp\u003E\nAlso it is correct that the Magneto Internal Fusion Reactor / Engine can only us lithium, this is intended.The lithrium function both a method of achieving inertial confinment, act as neutron energy conversion medium and propellant to generate thrust. No other \u0027propellant\u0027 can do all this so well.Because it does not need any heat exchange , the temperature can go much higher and therefre achieve higher effective Isp.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-03-18T09:28:51Z\u0022 title=\u002203/18/2016 09:28  AM\u0022 data-short=\u00228 yr\u0022\u003EMarch 18, 2016\u003C/time\u003E by FreeThinker\u003C/strong\u003E\n\u003C/span\u003E\n"}]}