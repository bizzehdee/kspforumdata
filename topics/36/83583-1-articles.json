{"TopicId":83583,"ForumId":36,"TopicTitle":"Official PartModule Documentation","CreatedByName":"Mu.","CreatedById":15543,"CreatedDateTime":"2012-05-07T13:31:40Z","PageNum":1,"Articles":[{"CreatedByName":"Mu.","CreatedById":15543,"CreatedDateTime":"2012-05-07T13:31:40Z","Content":"\n\u003Cp\u003EWelcome to the 0.15 patch. I want to outline a number of new bits that have come in and show you how to use them. These bits have filtered down from the new code which has been written to be easier to work with and easier to expand.\u003C/p\u003E\u003Cp\u003EPlease note that modding functionality has not changed at all. You can continue to use whatever interface you were doing and everything currently should be backwards compatible. However we are moving away from functional code in Part for reasons outlined below.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EWhat and why\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EFirstly however I want to talk about the reasons for the change so you can understand (and comment on) the direction moving to 0.16 and beyond. \u003C/p\u003E\u003Cp\u003EOriginally KSP was designed as a single-vessel orbital physics game. As the success of the project increased people obviously wanted more and so more features were added into the code. Multiple vessels, etc. The community plugin development also wasnt originally planned and was tacked on at some point. All these factors combined means that the core code is not easy for us to expand upon or easy for you lot to write plugins for. No doubt we all have big plans for KSP and to implement them properly we need to expand the base and make it fit for purpose.\u003C/p\u003E\u003Cp\u003ESo the plan has been to abstract what a Part and a Vessel actually are. A vessel is a collection of connected parts, but with some orbit stuff tacked on. A part is a physical object which can be connected to another, also has some code tacked on too. \u003C/p\u003E\u003Cp\u003ETherefore..\u003C/p\u003E\u003Cp\u003E- Part gets split into \u003Cem\u003EPart\u003C/em\u003E (model \u0026amp; physical connection) and \u003Cem\u003EPartModule\u003C/em\u003E (functional code).\u003C/p\u003E\u003Cp\u003E- Vessel gets split into \u003Cem\u003EPartAssembly\u003C/em\u003E (a list of Parts) and \u003Cem\u003EVessel\u003C/em\u003E (some orbit stuff).\u003C/p\u003E\u003Cp\u003EHaving PartAssembly seperate from Vessel means that we can create other types of groups of parts. Internal spaces, virtual cockpits, kerbal personalities, buildings, etc. Thus one editor screen can function as an editor for all types of assembly.\u003C/p\u003E\u003Cp\u003EHaving PartModule seperate from Part means we get to a smaller group of core parts which just define types of attachment logic and they can be have many (or none) code behaviours layered onto it.\u003C/p\u003E\u003Cp\u003E\u0027All very well and good\u0027, you say, \u0027but its a complicated horrible mess of interconnectedness how are we gonna deal with that? Eh? Eh?!\u0027. A fine question, ignorance is bliss, data and structure should be on a need to know basis. Having to learn how a specific thing works is a chore. \u003C/p\u003E\u003Cp\u003ESo to deal with this is an in built event messaging system. It deals, from your point of view, in strings. (It doesnt ofc, it uses pre-reflection and ints for lil extra performance). Basically a PartModule, Part or Vessel can send messages to things and recieve events from things. A code module ideally should be coded that it is ignorant of anything outside it. There are cases where you may want a group of modules to communicate with eachother, these can either be done with the messaging or ofc through direct references as before.\u003C/p\u003E\u003Cp\u003EDefining attributes in your module code of \u003Cem\u003EKSPEvent\u003C/em\u003E (on methods) or \u003Cem\u003EKSPField\u003C/em\u003E (on fields) exposes that event/field to the internal reflection. These attributes also contain data for linking the event/field to the part action gui. You can also alter the values for your event and field attributes at runtime to control the flow of your code.\u003C/p\u003E\u003Cp\u003EThat last bit sounds confusing. When you see it in action later it\\\u0027ll sink in.\u003C/p\u003E\u003Cp\u003ELastly we need a simple, easy and powerful way of defining configuration files. For this purpose \u003Cem\u003EConfigNode\u003C/em\u003E was born. Its an incredibly simple recursive node/value list and can be used a few ways. It contains all the code for reading and writing all the config files for the game. \u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EPartModule\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003ESo, the long awaited PartModule class. \u003C/p\u003E\u003Cp\u003EThis is a piece of code which can be attached to any Part in its config file. You can add as many as you like and add multiple of the same type should you need to. They are added to the Part GameObject itself and you still have access to part and vessel directly from PartModule.\u003C/p\u003E\u003Cp\u003EPartModules are very simple and currently contain only 6 overrides (compared to Part\\\u0027s.. err.. 34). Here is a PartModule showing all of its overrides in place...\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ModuleTest : PartModule\u003Cbr\u003E{\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Constructor style setup.\u003Cbr\u003E /// Called in the Part\\\u0027s Awake method. \u003Cbr\u003E /// The model may not be built by this point.\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public override void OnAwake()\u003Cbr\u003E {\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Called during the Part startup.\u003Cbr\u003E /// StartState gives flag values of initial state\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public override void OnStart(StartState state)\u003Cbr\u003E {\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Per-frame update\u003Cbr\u003E /// Called ONLY when Part is ACTIVE!\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public override void OnUpdate()\u003Cbr\u003E {\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Per-physx-frame update\u003Cbr\u003E /// Called ONLY when Part is ACTIVE!\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public override void OnFixedUpdate()\u003Cbr\u003E {\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Called when PartModule is asked to save its values.\u003Cbr\u003E /// Can save additional data here.\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E /// \u0026lt;param name=\u0027node\u0027\u0026gt;The node to save in to\u0026lt;/param\u0026gt;\u003Cbr\u003E public override void OnSave(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Called when PartModule is asked to load its values.\u003Cbr\u003E /// Can load additional data here.\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E /// \u0026lt;param name=\u0027node\u0027\u0026gt;The node to load from\u0026lt;/param\u0026gt;\u003Cbr\u003E public override void OnLoad(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003ELooks rather simple doesnt it and thats because it is. Its not set in stone and if we need more we can add them.\u003C/p\u003E\u003Cp\u003EIn reality I hope you only have to use very few of those overrides for any given module. Most of the loading and saving will be taken care of KSPField attributes unless you want to save complicated stuff.\u003C/p\u003E\u003Cp\u003E\u003Cem\u003EYou can use any Unity MonoBehaviour method apart from Awake.\u003C/em\u003E You can use OnDestroy as a destructor. Update and FixedUpdate are perfectly fine (you should check if the part is controllable first). There is no guarantee of having a rigidbody attached in the standard FixedUpdate.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EExample #1 - KSPEvents and KSPFields\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003ESo lets look a more complicated example with communication between two modules and some KSPEvent/KSPField malarky.\u003C/p\u003E\u003Cp\u003EHere is ModuleCommand. It would sit on a command pod and scream orders to everything else. In this case it just screams one order, InputGearToggle.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ModuleCommand : PartModule\u003Cbr\u003E{\u003Cbr\u003E public override void OnUpdate()\u003Cbr\u003E {\u003Cbr\u003E if (FlightInputHandler.state.gearDown || FlightInputHandler.state.gearUp)\u003Cbr\u003E {\u003Cbr\u003E part.SendEvent(\u0027InputGearToggle\u0027);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EThe key feature of ModuleCommand is \u003Cem\u003Epart.SendEvent(evtName)\u003C/em\u003E this tells its host part to send an event into the assembly. The Part sends the event to all of its modules and all of its attached neighbours, who in turn send it to their modules, ad infinitum.\u003C/p\u003E\u003Cp\u003ESo we need something to respond to that order. Here is ModuleAnimatorLandingGear. Technically it doesnt animate anything. It just changes a float from 0 to 1 and renames its gui event to reflect its current state.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ModuleAnimatorLandingGear : PartModule\u003Cbr\u003E{\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float gearExtension = 0f;\u003Cbr\u003E\u003Cbr\u003E [KSPEvent(guiActive = true, guiName = \u0027Toggle Gear\u0027)]\u003Cbr\u003E public void InputGearToggle()\u003Cbr\u003E {\u003Cbr\u003E if (gearExtension == 0f)\u003Cbr\u003E {\u003Cbr\u003E gearExtension = 1f;\u003Cbr\u003E\u003Cbr\u003E Events[\u0027InputGearToggle\u0027].guiName = \u0027Retract gear\u0027;\u003Cbr\u003E }\u003Cbr\u003E else\u003Cbr\u003E {\u003Cbr\u003E gearExtension = 0f;\u003Cbr\u003E\u003Cbr\u003E Events[\u0027InputGearToggle\u0027].guiName = \u0027Extend gear\u0027;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public override void OnLoad(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E if (gearExtension == 0f)\u003Cbr\u003E {\u003Cbr\u003E Events[\u0027InputGearToggle\u0027].guiName = \u0027Extend gear\u0027;\u003Cbr\u003E }\u003Cbr\u003E else\u003Cbr\u003E {\u003Cbr\u003E Events[\u0027InputGearToggle\u0027].guiName = \u0027Retract gear\u0027;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EPlenty new going on here!\u003C/p\u003E\u003Cp\u003EWe have one field, gearExtension which has the \u003Cem\u003EKSPField\u003C/em\u003E attribute applied. This makes this field persistant and it will be written to/from any saves as required. \u003C/p\u003E\u003Cp\u003EAfter KSPFields are parsed by PartModule then the OnLoad method is fired. As we have nothing else to load, we use OnLoad as a method for working out what to do with our data. In this instance that means setting the event gui name to be correct.\u003C/p\u003E\u003Cp\u003EThe limitation for adding the KSPField attribute is that it can only be applied to classes which implement the \u003Cem\u003EIConfigNode\u003C/em\u003E interface (more on this later) or one of the types; \u003Cem\u003Estring, bool, int, float, Vector2, Vector3, Vector4 or Quaternion\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EHere \u003Cstrong\u003EKSPField\u003C/strong\u003E attribute from the game source..\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003E/// \u0026lt;summary\u0026gt;\u003Cbr\u003E/// Attribute applied to fields to make them persistant or available to the part action GUI\u003Cbr\u003E/// \u003Cbr\u003E/// Automatic persistance can only be applied to types which implement the IConfigNode interface or\u003Cbr\u003E/// one of the following..\u003Cbr\u003E/// string, bool, int, float, Vector2, Vector3, Vector4 or Quaternion\u003Cbr\u003E/// \u0026lt;/summary\u0026gt;\u003Cbr\u003E[System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Property, AllowMultiple = false)]\u003Cbr\u003Epublic class KSPField : System.Attribute\u003Cbr\u003E{\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Is this field persistant?\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public bool isPersistant;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Is this field active on gui\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public bool guiActive;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Is this field active on gui\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string guiName;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Is this field active on gui\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string guiUnits;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// The gui format string for this field (D4, F2, N0, etc). Blank if none\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string guiFormat;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// string category id\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string category;\u003Cbr\u003E\u003Cbr\u003E public KSPField()\u003Cbr\u003E {\u003Cbr\u003E this.isPersistant = true;\u003Cbr\u003E this.guiName = \u0027\u0027;\u003Cbr\u003E this.guiUnits = \u0027\u0027;\u003Cbr\u003E this.guiFormat = \u0027\u0027;\u003Cbr\u003E this.category = \u0027\u0027;\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EThe method InputGearToggle has the \u003Cem\u003EKSPEvent\u003C/em\u003E attribute applied. This makes this event able to be internally reflected and recieve events thus is the entry point for most functionality. It will be fired in response to the ModuleCommand\\\u0027s part.SendEvent. KSPEvent also makes this method available to the gui in form of a labelled button. You can change the guiActive, guiName or any other KSPEvent value at run time by using the Events list.\u003C/p\u003E\u003Cp\u003EHere is the \u003Cstrong\u003EKSPEvent\u003C/strong\u003E attribute from the game source..\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003E/// \u0026lt;summary\u0026gt;\u003Cbr\u003E/// Tells the compiler that this method is an action and allows you to set up\u003Cbr\u003E/// the KSP specific stuff. \u003Cbr\u003E/// ** REQUIRED BY ALL ACTION METHODS **\u003Cbr\u003E/// \u0026lt;/summary\u0026gt;\u003Cbr\u003E[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple = true)]\u003Cbr\u003Epublic class KSPEvent : System.Attribute\u003Cbr\u003E{\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// The external name of this action\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string name;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Is this action assigned as the part\\\u0027s default? \u003Cbr\u003E /// * Will override any previous default *\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public bool isDefault;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Is this action initially active?\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public bool active;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Is this action available to the user?\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public bool guiActive;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// The guiIcon name (guiAction must be true)\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string guiIcon;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// The gui name for this action (userAction must be true)\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string guiName;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// A string category id so can display all actions of certain types\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public string category;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E public KSPEvent()\u003Cbr\u003E {\u003Cbr\u003E this.name = \u0027\u0027;\u003Cbr\u003E\u003Cbr\u003E this.isDefault = false;\u003Cbr\u003E this.active = true;\u003Cbr\u003E this.allowStaging = false;\u003Cbr\u003E this.autoStaging = false;\u003Cbr\u003E this.guiActive = false;\u003Cbr\u003E this.guiIcon = \u0027\u0027;\u003Cbr\u003E this.guiName = \u0027\u0027;\u003Cbr\u003E this.category = \u0027\u0027;\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-09-01T03:00:22Z\u0022 title=\u002209/01/2014 03:00  AM\u0022 data-short=\u00229 yr\u0022\u003ESeptember 1, 2014\u003C/time\u003E by stupid_chris\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Mu.","CreatedById":15543,"CreatedDateTime":"2012-05-07T13:31:52Z","Content":"\n\u003Cp\u003E\u003Cstrong\u003EExample #2 - IConfigNode and ConfigNode\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EOk so time for something more meaty. Here is my take on an aerodynamic lift module. It uses a class called FloatCurve to create the lift/drag vs angle of attack graphs for standard aerofoils. FloatCurve also implements IConfigNode so it can be used with KSPField.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ModuleAerodynamicLift : PartModule\u003Cbr\u003E{\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Planform area of lifting surface in m^2\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float planformArea = 10f;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Overall lift factor for this wing\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float liftFactor = 1f;\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Overall drag factor for this wing\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float dragFactor = 1f;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// FloatCurve of lift vs angle of attack. Angle is abs cosine of angle (0 -\u0026gt; 1)\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E [KSPField]\u003Cbr\u003E public FloatCurve liftAoA;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// FloatCurve of drag vs angle of attack. Angle is abs cosine of angle (0 -\u0026gt; 1)\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E [KSPField]\u003Cbr\u003E public FloatCurve dragAoA;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Model transform name for center of lift\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E [KSPField]\u003Cbr\u003E public string centerOfLiftTransformName;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// grabbed OnStart from the model transform named liftTransformName\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public Transform centerOfLiftTransform;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Sets up the float curves if they\\\u0027re not already set up\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public override void OnAwake()\u003Cbr\u003E {\u003Cbr\u003E if (liftAoA == null)\u003Cbr\u003E liftAoA = new FloatCurve();\u003Cbr\u003E if (dragAoA == null)\u003Cbr\u003E dragAoA = new FloatCurve();\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Grabs center of lift transform from model\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E /// \u0026lt;param name=\u0027state\u0027\u0026gt;\u0026lt;/param\u0026gt;\u003Cbr\u003E public override void OnStart(StartState state)\u003Cbr\u003E {\u003Cbr\u003E if (centerOfLiftTransform == null)\u003Cbr\u003E {\u003Cbr\u003E centerOfLiftTransform = part.FindModelTransform(centerOfLiftTransformName);\u003Cbr\u003E\u003Cbr\u003E if (centerOfLiftTransform == null)\u003Cbr\u003E Debug.LogError(\u0027ModuleAerodynamicLift: liftTransform is null!\u0027);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Calculates and applied the lift/drag force from the aerofoil\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E public override void OnFixedUpdate()\u003Cbr\u003E {\u003Cbr\u003E if (centerOfLiftTransform == null)\u003Cbr\u003E return;\u003Cbr\u003E\u003Cbr\u003E Vector3 force = CalculateForce();\u003Cbr\u003E\u003Cbr\u003E part.Rigidbody.AddForceAtPosition(force, centerOfLiftTransform.position, ForceMode.Force);\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E /// \u0026lt;summary\u0026gt;\u003Cbr\u003E /// Calculates lift/drag according the simple aerofoil equations...\u003Cbr\u003E /// Lift: L = (CL)(1/2)(dens)(V^2)(area) or L = (CL)(q)(S) q(dyn pressure) = (1/2)(dens)(V^2)\u003Cbr\u003E /// Drag: D = (CD)(1/2)(dens)(V^2)(area) or D = (CD)(q)(S)\u003Cbr\u003E /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E /// \u0026lt;returns\u0026gt;Overall force vector\u0026lt;/returns\u0026gt;\u003Cbr\u003E private Vector3 CalculateForce()\u003Cbr\u003E {\u003Cbr\u003E // grab world point and relative velocity\u003Cbr\u003E Vector3 worldVelocity = part.Rigidbody.GetPointVelocity(centerOfLiftTransform.position);\u003Cbr\u003E\u003Cbr\u003E // note we use centerOfLiftTransfrom from the model to calculate relative. This will take into account any part mirroring \u003Cbr\u003E Vector3 relativeVelocity = centerOfLiftTransform.InverseTransformDirection(worldVelocity);\u003Cbr\u003E Vector3 velocityNorm = relativeVelocity.normalized;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E // only need the speed squared - saves us a square root\u003Cbr\u003E float speedSqr = relativeVelocity.sqrMagnitude;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E // calc the angle of attack\u003Cbr\u003E float vDot = Vector3.Dot(velocityNorm, centerOfLiftTransform.up.normalized);\u003Cbr\u003E float vDotNorm = (vDot \u002B 1f) * 0.5f;\u003Cbr\u003E\u003Cbr\u003E float absVDot = Mathf.Abs(vDot);\u003Cbr\u003E float abs1MVDot = 1f - absVDot;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E // dynamic pressure \u003Cbr\u003E float dynPressure = 0.5f * (float)vessel.atmDensity * speedSqr;\u003Cbr\u003E\u003Cbr\u003E // calc coefficient of lift and drag from the factors and the float curves\u003Cbr\u003E float cL = liftFactor * liftAoA.Evaluate(abs1MVDot);\u003Cbr\u003E float cD = dragFactor * dragAoA.Evaluate(abs1MVDot);\u003Cbr\u003E\u003Cbr\u003E // calc lift, drag and add to get overall\u003Cbr\u003E Vector3 lift = centerOfLiftTransform.up * (cL * dynPressure * planformArea);\u003Cbr\u003E Vector3 drag = -(worldVelocity.normalized) * (cD * dynPressure * planformArea);\u003Cbr\u003E Vector3 force = lift \u002B drag;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E // some debug stuff\u003Cbr\u003E string str = \u0027\u0027;\u003Cbr\u003E str \u002B= \u0027AoA: \u0027 \u002B abs1MVDot;\u003Cbr\u003E str \u002B= \u0027 cL: \u0027 \u002B cL;\u003Cbr\u003E str \u002B= \u0027 cD: \u0027 \u002B cD;\u003Cbr\u003E Debug.Log(str);\u003Cbr\u003E\u003Cbr\u003E Debug.DrawLine(centerOfLiftTransform.position, centerOfLiftTransform.position \u002B lift * 100f, Color.green);\u003Cbr\u003E Debug.DrawLine(centerOfLiftTransform.position, centerOfLiftTransform.position \u002B drag * 100f, Color.cyan);\u003Cbr\u003E Debug.DrawLine(centerOfLiftTransform.position, centerOfLiftTransform.position \u002B worldVelocity * 100f, Color.magenta);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E // et voila\u003Cbr\u003E return force;\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EReally its a very simple module. All of its persistance is handled by its KSPFields and it basically adds lift/drag based on standard aerofoil model.\u003C/p\u003E\u003Cp\u003EThe FloatCurve class is a Unity AnimationCurve wrapped up in an IConfigNode extending interface. Remember in order to use KSPField on a class successfully it needs to implement IConfigNode. \u003C/p\u003E\u003Cp\u003EHere is the \u003Cstrong\u003EIConfigNode\u003C/strong\u003E interface.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003E/// \u0026lt;summary\u0026gt;\u003Cbr\u003E/// Can this item be saved using a KSPField persitance object. KSPField creates a subnode for this type\u003Cbr\u003E/// \u0026lt;/summary\u0026gt;\u003Cbr\u003Epublic interface IConfigNode\u003Cbr\u003E{\u003Cbr\u003E void Load(ConfigNode node);\u003Cbr\u003E\u003Cbr\u003E void Save(ConfigNode node);\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EIt requires two methods, Load(ConfigNode) and Save(ConfigNode). The implementing class must be able to be instantiated blind and then have OnLoad called to load its values in.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EConfigNode\u003C/strong\u003E consists of a recursive node/value list.\u003C/p\u003E\u003Cp\u003EIn essence it looks like this..\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ConfigNode\u003Cbr\u003E{\u003Cbr\u003E public string name;\u003Cbr\u003E public List\u0026lt;ConfigNode\u0026gt; nodes;\u003Cbr\u003E public List\u0026lt;ConfigNode.Value\u0026gt; values;\u003Cbr\u003E\u003Cbr\u003E public class Value\u003Cbr\u003E {\u003Cbr\u003E public string name;\u003Cbr\u003E public string value;\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EFor loading use; \u003Cem\u003EHasValue, GetValue, GetValues, HasNode, GetNode \u0026amp; GetNodes\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EFor saving use; \u003Cem\u003EAddValue or AddNode\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EEvery value you add is a string and should be parsable to/from what you set it to.\u003C/p\u003E\u003Cp\u003ENow lets have a look in \u003Cstrong\u003EFloatCurve\u003C/strong\u003E to see that in action..\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003E[System.Serializable]\u003Cbr\u003Epublic class FloatCurve : IConfigNode\u003Cbr\u003E{\u003Cbr\u003E [SerializeField]\u003Cbr\u003E private AnimationCurve fCurve;\u003Cbr\u003E\u003Cbr\u003E public float minTime { get; private set; }\u003Cbr\u003E public float maxTime { get; private set; }\u003Cbr\u003E\u003Cbr\u003E public FloatCurve()\u003Cbr\u003E {\u003Cbr\u003E fCurve = new AnimationCurve();\u003Cbr\u003E\u003Cbr\u003E minTime = float.MaxValue;\u003Cbr\u003E maxTime = float.MinValue;\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public void Add(float time, float value)\u003Cbr\u003E {\u003Cbr\u003E fCurve.AddKey(time, value);\u003Cbr\u003E\u003Cbr\u003E minTime = Mathf.Min(minTime, time);\u003Cbr\u003E maxTime = Mathf.Max(maxTime, time);\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public float Evaluate(float time)\u003Cbr\u003E {\u003Cbr\u003E return fCurve.Evaluate(time);\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private static char[] delimiters = new char[] { \\\u0027 \\\u0027, \\\u0027,\\\u0027, \\\u0027;\\\u0027, \\\u0027\\t\\\u0027 };\u003Cbr\u003E\u003Cbr\u003E public void Load(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E string[] values = node.GetValues(\u0027key\u0027);\u003Cbr\u003E\u003Cbr\u003E int vCount = values.Length;\u003Cbr\u003E\u003Cbr\u003E string[] valueSplit;\u003Cbr\u003E for (int i = 0; i \u0026lt; vCount; i\u002B\u002B)\u003Cbr\u003E {\u003Cbr\u003E valueSplit = values[i].Split(delimiters, System.StringSplitOptions.RemoveEmptyEntries);\u003Cbr\u003E\u003Cbr\u003E if (valueSplit.Length \u0026lt; 2)\u003Cbr\u003E {\u003Cbr\u003E Debug.LogError(\u0027FloatCurve: Invalid line. Requires two values, \\\u0027time\\\u0027 and \\\u0027value\\\u0027\u0027);\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E Add(float.Parse(valueSplit[0]), float.Parse(valueSplit[1]));\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public void Save(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E for (int i = 0; i \u0026lt; fCurve.keys.Length; i\u002B\u002B)\u003Cbr\u003E {\u003Cbr\u003E node.AddValue(\u0027key\u0027, fCurve.keys[i].time \u002B \u0027 \u0027 \u002B fCurve.keys[i].value);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EAs you can see it has a list of values called \\\u0027key\\\u0027 and each value is made up of a space seperated time/value pair. I\\\u0027ve added extra delimiters into the code cuz you/I might forget and comma seperate them or something.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EExample #3 - part.cfg\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003ESo now we get to the point of adding these things into a part\\\u0027s config file. You should know that every config file is parsed by ConfigNode now so can be considered in the node/value list paradigm.\u003C/p\u003E\u003Cp\u003EHere is ModuleAerodynamicLift module from example #2 added to the end of DeltaWing\\\u0027s part.cfg\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003EMODULE\u003Cbr\u003E{\u003Cbr\u003E name = ModuleAerodynamicLift\u003Cbr\u003E liftFactor = 0.001\u003Cbr\u003E dragFactor = 0.001\u003Cbr\u003E liftTransformName = CenterOfLift\u003Cbr\u003E\u003Cbr\u003E liftAoA\u003Cbr\u003E {\u003Cbr\u003E key = 0.0 1\u003Cbr\u003E key = 0.2 3\u003Cbr\u003E key = 0.4 4\u003Cbr\u003E key = 0.6 1\u003Cbr\u003E key = 0.7 0\u003Cbr\u003E key = 1.0 -1\u003Cbr\u003E }\u003Cbr\u003E dragAoA\u003Cbr\u003E {\u003Cbr\u003E key = 0.0 1\u003Cbr\u003E key = 0.2 3\u003Cbr\u003E key = 0.5 5\u003Cbr\u003E key = 0.7 6\u003Cbr\u003E key = 1.0 7\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EMODULE is a subnode of Part and you can have as many as you like.\u003C/p\u003E\u003Cp\u003EThis particular module relys on you having the transform named \u0027CenterOfLift\u0027 somewhere in the DeltaWing heirarchy, which it may not when we go to press. Most of the KSPField values are in the usual style of \u003Cem\u003EvalueName=value\u003C/em\u003E however you can see how the two IConfigNode implementing FloatCurves are represented as subnodes of the module node. KSPField will make any IConfigNode implementing class a subnode. Alternatively you can add/find your own subnodes in the OnLoad or OnSave methods.\u003C/p\u003E\u003Cp\u003EIn this next example we\\\u0027ll add two modules, ModuleAnimatorLandingGear (from Example #1) and an as yet unknown module called ModuleAnimateHeat.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003EMODULE\u003Cbr\u003E{\u003Cbr\u003E name = ModuleAnimatorLandingGear\u003Cbr\u003E}\u003Cbr\u003EMODULE\u003Cbr\u003E{\u003Cbr\u003E name = ModuleAnimateHeat\u003Cbr\u003E ThermalAnim = HeatAnimationEmissive;\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EHere is ModuleAnimateHeat. This was written to handle all of emissive heat glowing by heated parts. The heat is represented in the models as animations going from 0-\u0026gt;1 (none to full heat)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ModuleAnimateHeat : PartModule\u003Cbr\u003E{\u003Cbr\u003E [KSPField]\u003Cbr\u003E public string ThermalAnim = \u0027HeatAnimationEmissive\u0027;\u003Cbr\u003E\u003Cbr\u003E public float draperPoint = 525f; // Draper point is when solid objects begin to emit heat.\u003Cbr\u003E\u003Cbr\u003E public AnimationState[] heatAnimStates;\u003Cbr\u003E\u003Cbr\u003E public override void OnStart(StartState state)\u003Cbr\u003E {\u003Cbr\u003E HeatEffectStartup();\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public void Update()\u003Cbr\u003E {\u003Cbr\u003E UpdateHeatEffect();\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private void HeatEffectStartup()\u003Cbr\u003E {\u003Cbr\u003E Animation[] heatAnims = part.FindModelAnimators(ThermalAnim);\u003Cbr\u003E heatAnimStates = new AnimationState[heatAnims.Length];\u003Cbr\u003E\u003Cbr\u003E int i = 0;\u003Cbr\u003E foreach (Animation a in heatAnims)\u003Cbr\u003E {\u003Cbr\u003E AnimationState aState = a[ThermalAnim];\u003Cbr\u003E aState.speed = 0;\u003Cbr\u003E aState.enabled = true;\u003Cbr\u003E\u003Cbr\u003E a.Play(ThermalAnim);\u003Cbr\u003E\u003Cbr\u003E heatAnimStates[i\u002B\u002B] = aState;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E private void UpdateHeatEffect()\u003Cbr\u003E {\u003Cbr\u003E float temperatureValue = Mathf.Clamp01((part.temperature - draperPoint) / (part.maxTemp - draperPoint));\u003Cbr\u003E\u003Cbr\u003E foreach (AnimationState a in heatAnimStates)\u003Cbr\u003E {\u003Cbr\u003E a.normalizedTime = temperatureValue;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003Cstrong\u003EConclusion\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EWell hopefully you learned vaguely how to use PartModule and ConfigNode from all that. It was all written to be really simple and thus I hope it turns out to be. I\\\u0027m always open to questions and feedback, send me a mail if you really need to. I will hold a few dev sessions over the coming weeks to get some feedback and answer more detailed questions.\u003C/p\u003E\u003Cp\u003EIn part #2 i\\\u0027ll talk about resources, how to define them and how to use them.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-09-01T03:01:41Z\u0022 title=\u002209/01/2014 03:01  AM\u0022 data-short=\u00229 yr\u0022\u003ESeptember 1, 2014\u003C/time\u003E by stupid_chris\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Mu.","CreatedById":15543,"CreatedDateTime":"2012-05-08T14:29:21Z","Content":"\n\u003Cp\u003E\u003Cstrong\u003EPartResources\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EThe PartResources system is fairly simple. Its all fairly simple. Its designed to allow many addon devs to use a few core resource definitions, add them to parts easily and also retrieve them easily.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EResource definitions\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EResourceDefinitions define a resource, in name and a few physical values. Resource definitions are currently defined in .cfg files in the /resources directory. It parses all .cfg files in resources at startup so filename is unimportant. As far as I know, no stock .cfg files come with KSP so lets look at mine.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003ERESOURCE_DEFINITION\u003Cbr\u003E{\u003Cbr\u003E name = LiquidOxygen\u003Cbr\u003E density = 1.5\u003Cbr\u003E}\u003Cbr\u003ERESOURCE_DEFINITION\u003Cbr\u003E{\u003Cbr\u003E name = LiquidHydrogen\u003Cbr\u003E density = 1.5\u003Cbr\u003E}\u003Cbr\u003ERESOURCE_DEFINITION\u003Cbr\u003E{\u003Cbr\u003E name = LiquidHydrazine\u003Cbr\u003E density = 1.5\u003Cbr\u003E}\u003Cbr\u003ERESOURCE_DEFINITION\u003Cbr\u003E{\u003Cbr\u003E name = AtmosphereKerbin\u003Cbr\u003E density = 0.1\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003ESo we have four resource definitions there. All pretty simple. \u003C/p\u003E\u003Cp\u003ENone of the densities are to scale, they\\\u0027re just for idle testing. The density should be in kg/m^3 but i\\\u0027m afraid KSP\\\u0027s mass units make no sence so they\\\u0027re in tonnes/m^3 I think (12 kilobanana per m^3). Going forward I would like to agree some standard units.\u003C/p\u003E\u003Cp\u003EOk mass confusion (pun intended) over.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003ETanks for the resources\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003ETo create a volume of resource on a part you can do it through the part.cfg file. Here is the cfg for a hydrazine fuel tank.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003Cbr\u003ERESOURCE\u003Cbr\u003E{\u003Cbr\u003E name = LiquidHydrazine\u003Cbr\u003E amount = 2\u003Cbr\u003E maxAmount = 2\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EThus this part contains a node called RESOURCE which has a name, an amount value and a maxAmount value. The name should match the one in your resource definition and the amount/max are in units of volume. The mass increase on the part is calculated from the amount*density. Amount should be less than or equal to the max. \u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003ECrossfeeding\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EIf a part contains a resource with a maxAmount of zero then this allows the part to act as a crossfeed for this resource. Alternatively, the standard \u0027fuelCrossFeed\u0027 acts as a master crossfeed switch. This was purely to ensure backward compatability with crossfeeding mods should we have upgraded our parts to use PartResource.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003ERequestResource\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EParts have a method called RequestResource. This is the main method you will use to request or produce resources.\u003C/p\u003E\u003Cp\u003E\u003Cem\u003Epublic float RequestResource(string resourceName, float demand)\u003C/em\u003E\u003C/p\u003E\u003Cp\u003EAny part can request fuel in this way. A PartModule must use \u003Cem\u003Epart.RequestResource\u003C/em\u003E but the operation is exactly the same. This method will return you an amount drawn through the system, if the amount is available. If the demand is negative then you are producing the resource and it will start to fill up reservoirs connected to the system. As the system is not balanced you must first create an amount somewhere in order to fill it up.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EExample #1 - Generic rocket module\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EThis is a rocket engine module that can run on any number of any propellants. Calling it a rocket is a bit of a misnomer, really its a generic reaction engine.\u003C/p\u003E\u003Cp\u003EThe list of Propellant subclasses is loaded/saved manually in the OnLoad and OnSave. (I do hope you\\\u0027ve followed the PartModule tutorial above!)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ModuleEngineRocketLiquid : PartModule\u003Cbr\u003E{\u003Cbr\u003E [System.Serializable]\u003Cbr\u003E public class Propellant\u003Cbr\u003E {\u003Cbr\u003E public string name;\u003Cbr\u003E\u003Cbr\u003E public int id;\u003Cbr\u003E\u003Cbr\u003E public float requirementMax;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E public float currentRequirement;\u003Cbr\u003E\u003Cbr\u003E public float currentAmount;\u003Cbr\u003E\u003Cbr\u003E public float currentPotential;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E public Propellant()\u003Cbr\u003E {\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public void Load(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E name = node.GetValue(\u0027name\u0027);\u003Cbr\u003E id = name.GetHashCode();\u003Cbr\u003E\u003Cbr\u003E if (node.HasValue(\u0027requirementMax\u0027))\u003Cbr\u003E requirementMax = float.Parse(node.GetValue(\u0027requirementMax\u0027));\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public void Save(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E node.AddValue(\u0027name\u0027, name);\u003Cbr\u003E node.AddValue(\u0027requirementMax\u0027, requirementMax);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float thrustMax;\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public string thrustVectorTransformName;\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float currentThrottle;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E public List\u0026lt;Propellant\u0026gt; propellants;\u003Cbr\u003E\u003Cbr\u003E public Transform thrustTransform;\u003Cbr\u003E public float currentThrust;\u003Cbr\u003E public float currentPower;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E public override void OnAwake()\u003Cbr\u003E {\u003Cbr\u003E if (propellants == null)\u003Cbr\u003E propellants = new List\u0026lt;Propellant\u0026gt;();\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public override void OnStart(StartState state)\u003Cbr\u003E {\u003Cbr\u003E if (thrustTransform == null)\u003Cbr\u003E {\u003Cbr\u003E thrustTransform = part.FindModelTransform(thrustVectorTransformName);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E // calculate current output thrust as factor of fuel requirements met\u003Cbr\u003E public override void OnUpdate()\u003Cbr\u003E {\u003Cbr\u003E //string str = \u0027\u0027;\u003Cbr\u003E if (part.isControllable)\u003Cbr\u003E {\u003Cbr\u003E currentThrottle = FlightInputHandler.state.mainThrottle;\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E float throttle = currentThrottle;\u003Cbr\u003E currentPower = throttle;\u003Cbr\u003E\u003Cbr\u003E foreach (Propellant p in propellants)\u003Cbr\u003E {\u003Cbr\u003E p.currentRequirement = (p.requirementMax * throttle * Time.deltaTime);\u003Cbr\u003E\u003Cbr\u003E p.currentAmount = part.RequestResource(p.id, p.currentRequirement);\u003Cbr\u003E\u003Cbr\u003E p.currentPotential = p.currentAmount / p.currentRequirement;\u003Cbr\u003E\u003Cbr\u003E currentPower = Mathf.Min(currentPower, p.currentPotential);\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E currentThrust = thrustMax * currentPower;\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public override void OnFixedUpdate()\u003Cbr\u003E {\u003Cbr\u003E if (thrustTransform != null \u0026amp;\u0026amp; part.Rigidbody != null)\u003Cbr\u003E {\u003Cbr\u003E part.Rigidbody.AddForceAtPosition(-thrustTransform.forward * currentThrust, thrustTransform.position);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E public override void OnSave(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E foreach (Propellant p in propellants)\u003Cbr\u003E {\u003Cbr\u003E p.Save(node.AddNode(\u0027PROPELLANT\u0027));\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public override void OnLoad(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E foreach (ConfigNode subNode in node.nodes)\u003Cbr\u003E {\u003Cbr\u003E switch (subNode.name)\u003Cbr\u003E {\u003Cbr\u003E case \u0027PROPELLANT\u0027:\u003Cbr\u003E if (!subNode.HasValue(\u0027name\u0027))\u003Cbr\u003E {\u003Cbr\u003E Debug.Log(\u0027Propellant must have value \\\u0027name\\\u0027\u0027);\u003Cbr\u003E continue;\u003Cbr\u003E }\u003Cbr\u003E Propellant newProp = new Propellant();\u003Cbr\u003E newProp.Load(subNode);\u003Cbr\u003E propellants.Add(newProp);\u003Cbr\u003E break;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EThe key line in all that is \u0027\u003Cem\u003Ep.currentAmount = part.RequestResource(p.id, p.currentRequirement);\u003C/em\u003E\u0027 It requests a resource from its id (the GetHashCode of the resource name). \u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EExample #2 - Air intake module\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EFor the air-breathing engines to work properly here is a PartModule to do so. It creates an amount of resource per frame depending on forward velocity of the intake and also a mechanical suction effect.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cdiv\u003E\u003Cbr\u003Epublic class ModuleResourceIntake : PartModule\u003Cbr\u003E{\u003Cbr\u003E [KSPField]\u003Cbr\u003E public string resourceName = \u0027AtmosphereKerbin\u0027;\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float area;\u003Cbr\u003E public float airSpeed;\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public string intakeTransformName = \u0027Intake\u0027;\u003Cbr\u003E public Transform intakeTransform;\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public bool intakeEnabled = true;\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float intakeSpeed;\u003Cbr\u003E\u003Cbr\u003E [KSPField]\u003Cbr\u003E public float intakePower = 75;\u003Cbr\u003E\u003Cbr\u003E public override void OnStart(StartState state)\u003Cbr\u003E {\u003Cbr\u003E if (intakeTransform == null)\u003Cbr\u003E {\u003Cbr\u003E intakeTransform = part.FindModelTransform(intakeTransformName);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E [KSPEvent(guiActive = true, guiName = \u0027Deactivate\u0027)]\u003Cbr\u003E public void Deactivate()\u003Cbr\u003E {\u003Cbr\u003E Events[\u0027Deactivate\u0027].active = false;\u003Cbr\u003E Events[\u0027Activate\u0027].active = true;\u003Cbr\u003E\u003Cbr\u003E intakeEnabled = false;\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E [KSPEvent(guiActive = true, guiName = \u0027Activate\u0027)]\u003Cbr\u003E public void Activate()\u003Cbr\u003E {\u003Cbr\u003E Events[\u0027Deactivate\u0027].active = true;\u003Cbr\u003E Events[\u0027Activate\u0027].active = false;\u003Cbr\u003E\u003Cbr\u003E intakeEnabled = true;\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public override void OnFixedUpdate()\u003Cbr\u003E {\u003Cbr\u003E if (intakeEnabled)\u003Cbr\u003E {\u003Cbr\u003E if (part.isControllable)\u003Cbr\u003E {\u003Cbr\u003E intakeSpeed = FlightInputHandler.state.mainThrottle * intakePower;\u003Cbr\u003E }\u003Cbr\u003E airSpeed = (float)vessel.srf_velocity.magnitude;\u003Cbr\u003E float aoa = Vector3.Dot(vessel.srf_velocity.normalized, intakeTransform.forward.normalized);\u003Cbr\u003E float airVolume = (aoa * area * (airSpeed \u002B intakeSpeed) * Time.fixedDeltaTime);\u003Cbr\u003E float airMass = (float)vessel.atmDensity * airVolume;\u003Cbr\u003E airMass = Mathf.Max(0f, airMass);\u003Cbr\u003E\u003Cbr\u003E part.RequestResource(resourceName, -airMass);\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E\u003Cbr\u003E public override void OnLoad(ConfigNode node)\u003Cbr\u003E {\u003Cbr\u003E if (intakeEnabled)\u003Cbr\u003E {\u003Cbr\u003E Events[\u0027Deactivate\u0027].active = false;\u003Cbr\u003E Events[\u0027Activate\u0027].active = true;\u003Cbr\u003E }\u003Cbr\u003E }\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003ENote is uses a transform inside model to calculate relative velocities, this will take into account any mirroring that happens.\u003C/p\u003E\u003Cp\u003EA part.cfg using this module looks like this..\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cdiv\u003E\u003Cbr\u003EMODULE\u003Cbr\u003E{\u003Cbr\u003E name = ModuleResourceIntake\u003Cbr\u003E resourceName = AtmosphereKerbin\u003Cbr\u003E area = 2\u003Cbr\u003E intakeTransformName = Intake\u003Cbr\u003E intakeEnabled = True\u003Cbr\u003E intakePower = 75\u003Cbr\u003E}\u003Cbr\u003ERESOURCE\u003Cbr\u003E{\u003Cbr\u003E name = AtmosphereKerbin\u003Cbr\u003E maxAmount = 2\u003Cbr\u003E}\u003Cbr\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EWe have created a resource tank on the part. This is akin to the compression chamber, it is constantly topped up with air (assuming engine is running or we have forward velocity).\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EConclusion\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003ESo the resources system is incredibly simple at the moment. Really we need nothing more complicated however I would like to expand it to include flow, pressure, etc but have not had the time or the maths skills to do it. If anyone has any experience with iterative analysis of pipe networks and electrical circuits then give me a shout.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-09-01T03:02:22Z\u0022 title=\u002209/01/2014 03:02  AM\u0022 data-short=\u00229 yr\u0022\u003ESeptember 1, 2014\u003C/time\u003E by stupid_chris\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"N3X15","CreatedById":12073,"CreatedDateTime":"2012-05-17T22:57:25Z","Content":"\n\u003Cp\u003ESo, here we are again, another update behind us. Despite the fact that a lot of stuff got fixed, you\\\u0027re probably wondering why your plugins are starting to screech about namespaces being forbidden or something. Some of you are also probably about to write an angry post in the development forums regarding this; If you are, please stand back from the keyboard until you\\\u0027re through reading this post.\u003C/p\u003E\u003Cp\u003EFirst, a short explanation.\u003C/p\u003E\u003Cp\u003EWhen I first sent Squad the plugin loading code, I had intended it as a mere proof of concept. It was simple, and I fully expected Squad to change it and improve the various glaring security problems with it. It was changed so it would work with KSP, but the security problems were not addressed, primarily because Squad was in the middle of all the work for 0.14 and didn\\\u0027t have time to mess with it. Fortunately, we have not had any problems with malware yet, but we\\\u0027d rather not hold our breath, and we\\\u0027ve made security a priority. \u003C/p\u003E\u003Cp\u003EStarting in 0.15, specific namespaces will be forbidden at the bytecode level and plugins will fail to load if they use these namespaces. At the moment, the blacklist consists of System.IO and System.Xml, and this is to prevent plugins from accessing files outside of the KSP install folder. However, we realize that you all need to use persistant settings, so we\\\u0027ve made a really easy-to-use settings system available in the KSP.IO namespace. It uses XML at the moment, so it\\\u0027s not very fast, and it\\\u0027s clunky. It\\\u0027s more for serialization of simple values. I have also made file streams available for those of you who need the additional performance and flexibility. Everything ends up in the PluginData/yourplugindllname/ folder (PluginConfiguration uses config.xml, everything else is user-defined). \u003C/p\u003E\u003Cp\u003EWe realize this isn\\\u0027t ideal, but this is the best we can do at the moment, and we will be iterating on it to improve it and add stuff you guys need for your plugins. Lots of stuff is planned for 0.16, including a bunch of changes to make flight association easier.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EIn short\u003C/strong\u003E, we\\\u0027ve added some security systems to KSP that will throw a fit when your plugin uses anything in System.IO or System.Xml. Use KSP.IO instead of System.IO and it should work again. Stop screaming, it\\\u0027ll get better.\u003C/p\u003E\u003Cp\u003EIf you need any additional interfaces (such as the aforementioned streams), please let me know either by starting a development thread, or by bugging me in IRC.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EDocumentation is available \u003C/strong\u003E\u003Ca href=\u0022http://kspwiki.nexisonline.net/wiki/Category:KSP.IO_Namespace\u0022 rel=\u0022external nofollow\u0022\u003E\u003Cstrong\u003Ehere\u003C/strong\u003E\u003C/a\u003E\u003Cstrong\u003E.\u003C/strong\u003E\u003C/p\u003E\n"}]}