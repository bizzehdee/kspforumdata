{"TopicId":113951,"ForumId":29,"TopicTitle":"Trying to control WHERE a sound plays...","CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T05:31:23Z","PageNum":1,"Articles":[{"CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T05:31:23Z","Content":"\n\u003Cp\u003ESo while I sleep tonight a pray for some sort of a moment of clarity I thought I\u0027d drop this here in the hope that in my quite likely failure, some good a knowledgeable soul might offer me some insight...\u003C/p\u003E\u003Cp\u003EI made a mod for docking sounds, it looks like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eusing System;using System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Enamespace DockingSounds\u003Cbr\u003E{\u003Cbr\u003E\tclass DPSoundFX : PartModule\u003Cbr\u003E\t{\u003Cbr\u003E\t\t[KSPField]\u003Cbr\u003E\t\tpublic string sound_docking = \u0022DPSoundFX/Sounds/dock\u0022;\u003Cbr\u003E\t\t[KSPField]\u003Cbr\u003E\t\tpublic string sound_undocking = \u0022DPSoundFX/Sounds/undock\u0022;\u003Cbr\u003E\t\tstatic bool eventAddedDocking = false;\u003Cbr\u003E\t\tstatic bool eventAddedUndocking = false;\u003Cbr\u003E\t\tstatic bool groupCreatedDocking = false;\u003Cbr\u003E\t\tstatic bool groupCreatedUndocking = false;\u003Cbr\u003E\t\tpublic FXGroup dockSound = null;\u003Cbr\u003E\t\tpublic FXGroup undockSound = null;\u003Cbr\u003E\u003Cbr\u003E\t\tpublic bool createGroup (FXGroup group, string name, bool loop)\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tif (name != string.Empty) {\u003Cbr\u003E\t\t\t\tif (!GameDatabase.Instance.ExistsAudioClip (name)) {\u003Cbr\u003E\t\t\t\t\tDebug.LogError (\u0022[DPSoundFX]ERROR - file \u0022 \u002B name \u002B \u0022.* not found!\u0022);\u003Cbr\u003E\t\t\t\t\treturn false;\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t\tgroup.audio = gameObject.AddComponent\u0026lt;AudioSource\u0026gt; ();\u003Cbr\u003E\t\t\t\tgroup.audio.volume = GameSettings.SHIP_VOLUME;\u003Cbr\u003E\t\t\t\tgroup.audio.rolloffMode = AudioRolloffMode.Logarithmic;\u003Cbr\u003E\t\t\t\tgroup.audio.dopplerLevel = 0f;\u003Cbr\u003E\t\t\t\tgroup.audio.panLevel = 1f;\u003Cbr\u003E\t\t\t\tgroup.audio.clip = GameDatabase.Instance.GetAudioClip (name);\u003Cbr\u003E\t\t\t\tgroup.audio.loop = loop;\u003Cbr\u003E\t\t\t\tgroup.audio.playOnAwake = false;             \u003Cbr\u003E\t\t\t\treturn true;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t\treturn false;\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\t\tpublic void DPFXdock (GameEvents.FromToAction\u0026lt;Part, Part\u0026gt; partAction)\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\t//Debug.LogError (\u0022[DPSoundFX] Docking\u0022);\u003Cbr\u003E\t\t\t//Debug.LogError (\u0022               Docked FROM   : \u0022 \u002B partAction.from.vessel.vesselName);\u003Cbr\u003E\t\t\t//Debug.LogError (\u0022               Docked TO     : \u0022 \u002B partAction.to.vessel.vesselName);\u003Cbr\u003E\t\t\t//Debug.LogError (\u0022               Docked FROM ID: \u0022 \u002B partAction.from.vessel.id.ToString ());\u003Cbr\u003E\t\t\t//Debug.LogError (\u0022               Docked TO ID  : \u0022 \u002B partAction.to.vessel.id.ToString ());\u003Cbr\u003E\u003Cbr\u003E\t\t\tDebug.LogError (\u0022[DPSoundFX] Docking \u0022 \u002B partAction.from \u002B \u0022 -\u0026gt; \u0022 \u002B partAction.to);\u003Cbr\u003E\t\t\tDebug.LogError (\u0022[DPSoundFX] Playing: \u0022 \u002B sound_docking);\u003Cbr\u003E\u003Cbr\u003E\t\t\tif (!partAction.from.Modules.Contains (\u0022DPSoundFX\u0022))\u003Cbr\u003E\t\t\t\treturn;\u003Cbr\u003E\u003Cbr\u003E\t\t\tif (!this.dockSound.audio.isPlaying) { \u003Cbr\u003E\t\t\t\tthis.dockSound.audio.Play ();\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tpublic void DPFXundock (Part part)\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tDebug.LogError (\u0022[DPSoundFX] Undocking \u0022 \u002B part);\u003Cbr\u003E\t\t\tDebug.LogError (\u0022[DPSoundFX] Playing: \u0022 \u002B sound_undocking);\u003Cbr\u003E\u003Cbr\u003E\t\t\tif (!part.Modules.Contains (\u0022DPSoundFX\u0022))\u003Cbr\u003E\t\t\t\treturn;\u003Cbr\u003E\u003Cbr\u003E\t\t\tif (!this.dockSound.audio.isPlaying) {\u003Cbr\u003E\t\t\t\tthis.undockSound.audio.Play ();\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tpublic override void OnStart (PartModule.StartState state)\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tDebug.LogError (\u0022[DPSoundFX] OnStart Called: State is \u0022 \u002B state);\u003Cbr\u003E\u003Cbr\u003E\t\t\tif (HighLogic.LoadedScene != GameScenes.FLIGHT)\u003Cbr\u003E\t\t\t\treturn;\u003Cbr\u003E\u003Cbr\u003E\t\t\tbase.OnStart (state);\u003Cbr\u003E\u003Cbr\u003E\t\t\tgroupCreatedDocking = createGroup (dockSound, sound_docking, false);\u003Cbr\u003E\t\t\tgroupCreatedUndocking = createGroup (undockSound, sound_undocking, false);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\t\t\tif (groupCreatedDocking \u0026amp;\u0026amp; !eventAddedDocking) {\u003Cbr\u003E\t\t\t\tGameEvents.onPartCouple.Add (DPFXdock);\u003Cbr\u003E\t\t\t\teventAddedDocking = true;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\t\t\tif (groupCreatedUndocking \u0026amp;\u0026amp; !eventAddedUndocking) {\u003Cbr\u003E\t\t\t\tGameEvents.onPartUndock.Add (DPFXundock);\u003Cbr\u003E\t\t\t\teventAddedUndocking = true;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\t\tDebug.LogError (\u0022[DPSoundFX] OnStart Executed: State was \u0022 \u002B state);\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\tvoid OnDestroy ()\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\tGameEvents.onPartUndock.Remove (DPFXundock);\u003Cbr\u003E\t\t\teventAddedUndocking = false;\u003Cbr\u003E\t\t\tgroupCreatedUndocking = false;\u003Cbr\u003E\u003Cbr\u003E\t\t\tGameEvents.onPartCouple.Remove (DPFXdock);\u003Cbr\u003E\t\t\teventAddedDocking = false;\u003Cbr\u003E\t\t\tgroupCreatedDocking = false;\u003Cbr\u003E\t\t}\u003Cbr\u003E\t}\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ETrouble is this, I took out 4 rovers and placed them so that 2 were near one another in one location, and 2 were near one another but 500m away from the first 2.\u003C/p\u003E\u003Cp\u003EI then couple the first two. \u0022Cha-CHUNK!!\u0022 the docking sound plays, as expected.\u003C/p\u003E\u003Cp\u003EI hit the \u0022[\u0022 key and jump to one of the other pair of rovers and couple them. \u0022Cha-CHUNK!!\u0022 the docking port sound plays, softly, 500m away at the location of the first pair of docked rovers. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_sad.gif\u0022 alt=\u0022:(\u0022\u003E\u003C/p\u003E\u003Cp\u003EI tried a number of ideas. No joy.\u003C/p\u003E\u003Cp\u003EOne thing I tried was printing the UID of \u0022gameObject\u0022 and \u0022partAction.to\u0022 and \u0022partAction.from\u0022 in the DPFXdock routine. On the first docking the gameObject UID and partAction.from UID matched (which I expected), on the second docking, the gameObject UID was the same as the first docking, while the partAction.to and partAction.from were unique UIDs as one would expect.\u003C/p\u003E\u003Cp\u003EThis leads me to think that it has to do with the \u0022gameObject\u0022 as it exists when DPFXdock is called, but that value (which I readonly) seems to get set and then stuck after the first time DPFXdock is called.\u003C/p\u003E\u003Cp\u003EI\u0027m rather stuck. I *think* my only option is going to be to create an empty gameObject, position it at the docking port, make the docking port it\u0027s parent, set an audio source to that object, set all the audio.property values, play() the clip, and then destroy the empty game object every time a port docks or undocks - but that seems wasteful...\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-06-24T06:25:38Z","Content":"\n\u003Cp\u003EThis is probably my fault for getting myself tied in a knot last time you asked for help. Your issue is that the part that responds is always the one which added the event, when there should be an event callback for each and every docking port in the scene.\u003C/p\u003E\u003Cp\u003Etl;dr\u003C/p\u003E\u003Cp\u003ERemove the bits that make only a single subscription to the docking GameEvent. That will give you a callback for each docking part. Inside that callback, only do something if this part is the initiator. That will probably fix it (your initial issue was the combination of not checking if it was the target part and not removing the callback in OnDestroy)\u003C/p\u003E\n"},{"CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T15:08:07Z","Content":"\n\u003Cp\u003ESonuva.... I pulled the conditional statements \u0022\u003Cspan style=\u0022color:#333333;\u0022\u003Eif (groupCreatedDocking \u0026amp;\u0026amp; !eventAddedDocking) {\u0022 and now I get sounds from all locations - only trouble is that now I get sound from all locations all the time LOL... now I have to sort out a conditional that inhibits all but the docked part from firing... \u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022color:#333333;\u0022\u003EStill, it\u0027s progress!\u003C/span\u003E\u003C/p\u003E\n"},{"CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T16:14:56Z","Content":"\n\u003Cp\u003EFinal solution soon to be released:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E//*******************************// Title: DPSoundFX\u003Cbr\u003E// Author: Ted Thompson\u003Cbr\u003E// License: CC BY-SA 4.0\u003Cbr\u003E// Created: June 19, 2015\u003Cbr\u003E//*******************************\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Enamespace DockingSounds\u003Cbr\u003E{\u003Cbr\u003E    class DPSoundFX : PartModule\u003Cbr\u003E    {\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public string sound_docking = \u0022DPSoundFX/Sounds/dock\u0022;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public string sound_undocking = \u0022DPSoundFX/Sounds/undock\u0022;\u003Cbr\u003E        public FXGroup dockSound = null;\u003Cbr\u003E        public FXGroup undockSound = null;\u003Cbr\u003E\u003Cbr\u003E        //Create FX group for sounds\u003Cbr\u003E        public bool createGroup (FXGroup group, string name, bool loop)\u003Cbr\u003E        {\u003Cbr\u003E            if (name != string.Empty) {\u003Cbr\u003E                if (!GameDatabase.Instance.ExistsAudioClip (name)) {\u003Cbr\u003E                    Debug.LogError (\u0022[DPSoundFX]ERROR - file \u0022 \u002B name \u002B \u0022.* not found!\u0022);\u003Cbr\u003E                    return false;\u003Cbr\u003E                }\u003Cbr\u003E                group.audio = gameObject.AddComponent\u0026lt;AudioSource\u0026gt; ();\u003Cbr\u003E                group.audio.volume = GameSettings.SHIP_VOLUME;\u003Cbr\u003E                group.audio.rolloffMode = AudioRolloffMode.Logarithmic;\u003Cbr\u003E                group.audio.dopplerLevel = 0f;\u003Cbr\u003E                group.audio.panLevel = 1f;\u003Cbr\u003E                group.audio.clip = GameDatabase.Instance.GetAudioClip (name);\u003Cbr\u003E                group.audio.loop = loop;\u003Cbr\u003E                group.audio.playOnAwake = false;             \u003Cbr\u003E                return true;\u003Cbr\u003E            }\u003Cbr\u003E            return false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Play docking sound\u003Cbr\u003E        public void DPFXdock (GameEvents.FromToAction\u0026lt;Part, Part\u0026gt; partAction)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log (\u0022[DPSoundFX] Docking\u0022);\u003Cbr\u003E            //Debug.Log (\u0022               Docked FROM   : \u0022 \u002B partAction.from.vessel.vesselName);\u003Cbr\u003E            //Debug.Log (\u0022               Docked TO     : \u0022 \u002B partAction.to.vessel.vesselName);\u003Cbr\u003E            //Debug.Log (\u0022               Docked FROM ID: \u0022 \u002B partAction.from.vessel.id.ToString ());\u003Cbr\u003E            //Debug.Log (\u0022               Docked TO ID  : \u0022 \u002B partAction.to.vessel.id.ToString ());\u003Cbr\u003E\u003Cbr\u003E            // Does the \u0022caller\u0022 even have a DPSoundFX entry in it\u0027s config?  (KIS trigger workaround)\u003Cbr\u003E            if (!partAction.from.Modules.Contains (\u0022DPSoundFX\u0022))\u003Cbr\u003E                return;\u003Cbr\u003E\u003Cbr\u003E            // Is the \u0022caller\u0022 the one that just docked?  If not go away, you\u0027re not welcome here!!\u003Cbr\u003E            if (Part.FromGO (gameObject).flightID != partAction.from.flightID)\u003Cbr\u003E                return;\u003Cbr\u003E\u003Cbr\u003E            if (!this.dockSound.audio.isPlaying) { \u003Cbr\u003E                this.dockSound.audio.Play ();\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void DPFXundock (Part part)\u003Cbr\u003E        {\u003Cbr\u003E            // Does the \u0022caller\u0022 even have a DPSoundFX entry in it\u0027s config?  (KIS didn\u0027t seem to trigger this, but it might avoid a false trigger from elsewhere)\u003Cbr\u003E            if (!part.Modules.Contains (\u0022DPSoundFX\u0022))\u003Cbr\u003E                return;\u003Cbr\u003E\u003Cbr\u003E            // Did the caller just undock?  If not go home caller, your drunk.\u003Cbr\u003E            if (Part.FromGO (gameObject).flightID != part.flightID)\u003Cbr\u003E                return;\u003Cbr\u003E\u003Cbr\u003E            if (!this.dockSound.audio.isPlaying) {\u003Cbr\u003E                this.undockSound.audio.Play ();\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public override void OnStart (PartModule.StartState state)\u003Cbr\u003E        {\u003Cbr\u003E            Debug.Log (\u0022[DPSoundFX] OnStart Called: State is \u0022 \u002B state);\u003Cbr\u003E\u003Cbr\u003E            if (HighLogic.LoadedScene != GameScenes.FLIGHT)\u003Cbr\u003E                return;\u003Cbr\u003E\u003Cbr\u003E            base.OnStart (state);\u003Cbr\u003E\u003Cbr\u003E            createGroup (dockSound, sound_docking, false);\u003Cbr\u003E            createGroup (undockSound, sound_undocking, false);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            GameEvents.onPartCouple.Add (DPFXdock);\u003Cbr\u003E            GameEvents.onPartUndock.Add (DPFXundock);\u003Cbr\u003E\u003Cbr\u003E            Debug.Log (\u0022[DPSoundFX] OnStart Executed: State was \u0022 \u002B state);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        void OnDestroy ()\u003Cbr\u003E        {\u003Cbr\u003E            GameEvents.onPartUndock.Remove (DPFXundock);\u003Cbr\u003E            GameEvents.onPartCouple.Remove (DPFXdock);\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENow gameobject behaves as I expected it to, it\u0027s the object that caused the call to start with. So checking it\u0027s UID (flightID in the code) against the part UID lets me eliminate all but the part that actually triggered the call. Problem solved.\u003C/p\u003E\n"}]}