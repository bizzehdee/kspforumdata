{"TopicId":113951,"ForumId":29,"TopicTitle":"Trying to control WHERE a sound plays...","CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T05:31:23Z","PageNum":1,"Articles":[{"CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T05:31:23Z","Content":"So while I sleep tonight a pray for some sort of a moment of clarity I thought I\u0027d drop this here in the hope that in my quite likely failure, some good a knowledgeable soul might offer me some insight...\n\nI made a mod for docking sounds, it looks like this:\n\n    using System;using System.Collections.Generic;using System.Linq;using System.Text;using UnityEngine;namespace DockingSounds{\tclass DPSoundFX : PartModule\t{\t\t[KSPField]\t\tpublic string sound_docking = \u0022DPSoundFX/Sounds/dock\u0022;\t\t[KSPField]\t\tpublic string sound_undocking = \u0022DPSoundFX/Sounds/undock\u0022;\t\tstatic bool eventAddedDocking = false;\t\tstatic bool eventAddedUndocking = false;\t\tstatic bool groupCreatedDocking = false;\t\tstatic bool groupCreatedUndocking = false;\t\tpublic FXGroup dockSound = null;\t\tpublic FXGroup undockSound = null;\t\tpublic bool createGroup (FXGroup group, string name, bool loop)\t\t{\t\t\tif (name != string.Empty) {\t\t\t\tif (!GameDatabase.Instance.ExistsAudioClip (name)) {\t\t\t\t\tDebug.LogError (\u0022[DPSoundFX]ERROR - file \u0022 \u002B name \u002B \u0022.* not found!\u0022);\t\t\t\t\treturn false;\t\t\t\t}\t\t\t\tgroup.audio = gameObject.AddComponent ();\t\t\t\tgroup.audio.volume = GameSettings.SHIP_VOLUME;\t\t\t\tgroup.audio.rolloffMode = AudioRolloffMode.Logarithmic;\t\t\t\tgroup.audio.dopplerLevel = 0f;\t\t\t\tgroup.audio.panLevel = 1f;\t\t\t\tgroup.audio.clip = GameDatabase.Instance.GetAudioClip (name);\t\t\t\tgroup.audio.loop = loop;\t\t\t\tgroup.audio.playOnAwake = false;             \t\t\t\treturn true;\t\t\t}\t\t\treturn false;\t\t}\t\tpublic void DPFXdock (GameEvents.FromToAction partAction)\t\t{\t\t\t//Debug.LogError (\u0022[DPSoundFX] Docking\u0022);\t\t\t//Debug.LogError (\u0022               Docked FROM   : \u0022 \u002B partAction.from.vessel.vesselName);\t\t\t//Debug.LogError (\u0022               Docked TO     : \u0022 \u002B partAction.to.vessel.vesselName);\t\t\t//Debug.LogError (\u0022               Docked FROM ID: \u0022 \u002B partAction.from.vessel.id.ToString ());\t\t\t//Debug.LogError (\u0022               Docked TO ID  : \u0022 \u002B partAction.to.vessel.id.ToString ());\t\t\tDebug.LogError (\u0022[DPSoundFX] Docking \u0022 \u002B partAction.from \u002B \u0022 -\u003E \u0022 \u002B partAction.to);\t\t\tDebug.LogError (\u0022[DPSoundFX] Playing: \u0022 \u002B sound_docking);\t\t\tif (!partAction.from.Modules.Contains (\u0022DPSoundFX\u0022))\t\t\t\treturn;\t\t\tif (!this.dockSound.audio.isPlaying) { \t\t\t\tthis.dockSound.audio.Play ();\t\t\t}\t\t}\t\tpublic void DPFXundock (Part part)\t\t{\t\t\tDebug.LogError (\u0022[DPSoundFX] Undocking \u0022 \u002B part);\t\t\tDebug.LogError (\u0022[DPSoundFX] Playing: \u0022 \u002B sound_undocking);\t\t\tif (!part.Modules.Contains (\u0022DPSoundFX\u0022))\t\t\t\treturn;\t\t\tif (!this.dockSound.audio.isPlaying) {\t\t\t\tthis.undockSound.audio.Play ();\t\t\t}\t\t}\t\tpublic override void OnStart (PartModule.StartState state)\t\t{\t\t\tDebug.LogError (\u0022[DPSoundFX] OnStart Called: State is \u0022 \u002B state);\t\t\tif (HighLogic.LoadedScene != GameScenes.FLIGHT)\t\t\t\treturn;\t\t\tbase.OnStart (state);\t\t\tgroupCreatedDocking = createGroup (dockSound, sound_docking, false);\t\t\tgroupCreatedUndocking = createGroup (undockSound, sound_undocking, false);\t\t\tif (groupCreatedDocking \u0026\u0026 !eventAddedDocking) {\t\t\t\tGameEvents.onPartCouple.Add (DPFXdock);\t\t\t\teventAddedDocking = true;\t\t\t}\t\t\tif (groupCreatedUndocking \u0026\u0026 !eventAddedUndocking) {\t\t\t\tGameEvents.onPartUndock.Add (DPFXundock);\t\t\t\teventAddedUndocking = true;\t\t\t}\t\t\tDebug.LogError (\u0022[DPSoundFX] OnStart Executed: State was \u0022 \u002B state);\t\t}\t\tvoid OnDestroy ()\t\t{\t\t\tGameEvents.onPartUndock.Remove (DPFXundock);\t\t\teventAddedUndocking = false;\t\t\tgroupCreatedUndocking = false;\t\t\tGameEvents.onPartCouple.Remove (DPFXdock);\t\t\teventAddedDocking = false;\t\t\tgroupCreatedDocking = false;\t\t}\t}}\n\nTrouble is this, I took out 4 rovers and placed them so that 2 were near one another in one location, and 2 were near one another but 500m away from the first 2.\n\nI then couple the first two. \u0022Cha-CHUNK!!\u0022 the docking sound plays, as expected.\n\nI hit the \u0022[\u0022 key and jump to one of the other pair of rovers and couple them. \u0022Cha-CHUNK!!\u0022 the docking port sound plays, softly, 500m away at the location of the first pair of docked rovers. ![:(](//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_sad.gif)\n\nI tried a number of ideas. No joy.\n\nOne thing I tried was printing the UID of \u0022gameObject\u0022 and \u0022partAction.to\u0022 and \u0022partAction.from\u0022 in the DPFXdock routine. On the first docking the gameObject UID and partAction.from UID matched (which I expected), on the second docking, the gameObject UID was the same as the first docking, while the partAction.to and partAction.from were unique UIDs as one would expect.\n\nThis leads me to think that it has to do with the \u0022gameObject\u0022 as it exists when DPFXdock is called, but that value (which I readonly) seems to get set and then stuck after the first time DPFXdock is called.\n\nI\u0027m rather stuck. I \\*think\\* my only option is going to be to create an empty gameObject, position it at the docking port, make the docking port it\u0027s parent, set an audio source to that object, set all the audio.property values, play() the clip, and then destroy the empty game object every time a port docks or undocks - but that seems wasteful..."},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2015-06-24T06:25:38Z","Content":"This is probably my fault for getting myself tied in a knot last time you asked for help. Your issue is that the part that responds is always the one which added the event, when there should be an event callback for each and every docking port in the scene.\n\ntl;dr\n\nRemove the bits that make only a single subscription to the docking GameEvent. That will give you a callback for each docking part. Inside that callback, only do something if this part is the initiator. That will probably fix it (your initial issue was the combination of not checking if it was the target part and not removing the callback in OnDestroy)"},{"CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T15:08:07Z","Content":"Sonuva.... I pulled the conditional statements \u0022if (groupCreatedDocking \u0026\u0026 !eventAddedDocking) {\u0022 and now I get sounds from all locations - only trouble is that now I get sound from all locations all the time LOL... now I have to sort out a conditional that inhibits all but the docked part from firing... \n\nStill, it\u0027s progress!"},{"CreatedByName":"tg626","CreatedById":112361,"CreatedDateTime":"2015-06-24T16:14:56Z","Content":"Final solution soon to be released:\n\n    //*******************************// Title: DPSoundFX// Author: Ted Thompson// License: CC BY-SA 4.0// Created: June 19, 2015//*******************************using System;using System.Collections.Generic;using System.Linq;using System.Text;using UnityEngine;namespace DockingSounds{    class DPSoundFX : PartModule    {        [KSPField]        public string sound_docking = \u0022DPSoundFX/Sounds/dock\u0022;        [KSPField]        public string sound_undocking = \u0022DPSoundFX/Sounds/undock\u0022;        public FXGroup dockSound = null;        public FXGroup undockSound = null;        //Create FX group for sounds        public bool createGroup (FXGroup group, string name, bool loop)        {            if (name != string.Empty) {                if (!GameDatabase.Instance.ExistsAudioClip (name)) {                    Debug.LogError (\u0022[DPSoundFX]ERROR - file \u0022 \u002B name \u002B \u0022.* not found!\u0022);                    return false;                }                group.audio = gameObject.AddComponent ();                group.audio.volume = GameSettings.SHIP_VOLUME;                group.audio.rolloffMode = AudioRolloffMode.Logarithmic;                group.audio.dopplerLevel = 0f;                group.audio.panLevel = 1f;                group.audio.clip = GameDatabase.Instance.GetAudioClip (name);                group.audio.loop = loop;                group.audio.playOnAwake = false;                             return true;            }            return false;        }        // Play docking sound        public void DPFXdock (GameEvents.FromToAction partAction)        {            //Debug.Log (\u0022[DPSoundFX] Docking\u0022);            //Debug.Log (\u0022               Docked FROM   : \u0022 \u002B partAction.from.vessel.vesselName);            //Debug.Log (\u0022               Docked TO     : \u0022 \u002B partAction.to.vessel.vesselName);            //Debug.Log (\u0022               Docked FROM ID: \u0022 \u002B partAction.from.vessel.id.ToString ());            //Debug.Log (\u0022               Docked TO ID  : \u0022 \u002B partAction.to.vessel.id.ToString ());            // Does the \u0022caller\u0022 even have a DPSoundFX entry in it\u0027s config?  (KIS trigger workaround)            if (!partAction.from.Modules.Contains (\u0022DPSoundFX\u0022))                return;            // Is the \u0022caller\u0022 the one that just docked?  If not go away, you\u0027re not welcome here!!            if (Part.FromGO (gameObject).flightID != partAction.from.flightID)                return;            if (!this.dockSound.audio.isPlaying) {                 this.dockSound.audio.Play ();            }        }        public void DPFXundock (Part part)        {            // Does the \u0022caller\u0022 even have a DPSoundFX entry in it\u0027s config?  (KIS didn\u0027t seem to trigger this, but it might avoid a false trigger from elsewhere)            if (!part.Modules.Contains (\u0022DPSoundFX\u0022))                return;            // Did the caller just undock?  If not go home caller, your drunk.            if (Part.FromGO (gameObject).flightID != part.flightID)                return;            if (!this.dockSound.audio.isPlaying) {                this.undockSound.audio.Play ();            }        }        public override void OnStart (PartModule.StartState state)        {            Debug.Log (\u0022[DPSoundFX] OnStart Called: State is \u0022 \u002B state);            if (HighLogic.LoadedScene != GameScenes.FLIGHT)                return;            base.OnStart (state);            createGroup (dockSound, sound_docking, false);            createGroup (undockSound, sound_undocking, false);            GameEvents.onPartCouple.Add (DPFXdock);            GameEvents.onPartUndock.Add (DPFXundock);            Debug.Log (\u0022[DPSoundFX] OnStart Executed: State was \u0022 \u002B state);        }        void OnDestroy ()        {            GameEvents.onPartUndock.Remove (DPFXundock);            GameEvents.onPartCouple.Remove (DPFXdock);        }    }}\n\nNow gameobject behaves as I expected it to, it\u0027s the object that caused the call to start with. So checking it\u0027s UID (flightID in the code) against the part UID lets me eliminate all but the part that actually triggered the call. Problem solved."}]}