{"TopicId":104912,"ForumId":44,"TopicTitle":"Usefulness of Ackermann Function as Computer Benchmarker?","CreatedByName":"Themohawkninja","CreatedById":9628,"CreatedDateTime":"2015-04-25T07:05:18Z","PageNum":1,"Articles":[{"CreatedByName":"Themohawkninja","CreatedById":9628,"CreatedDateTime":"2015-04-25T07:05:18Z","Content":"\n\u003Cp\u003EHello,\u003C/p\u003E\u003Cp\u003EIn addition to my interests in all manner of computers, I also am quite interested in mathematics, and I recently discovered a highly recursive mathematical function called the \u003Ca href=\u0022https://en.wikipedia.org/wiki/Ackermann_function\u0022 rel=\u0022external nofollow\u0022\u003EAckermann function\u003C/a\u003E.\u003C/p\u003E\u003Cp\u003EAs you can see in the article, there is a brief mention of this function being a useful tool for benchmarking computer performance, however when I looked up Ackermann-based benchmarks, only academic papers about the subject seemed to show up in Google. As a result, I ended up programming my own in C\u002B\u002B. Once it was up-and-running, I tested in on both my computer (i7-2600k w/ GTX 580), and my roommate\u0027s (i7-4790k w/ ASUS Hero VII on-board graphics), and my roommate\u0027s computer scored about 25% higher. I\u0027m not really sure if that accurately displays the difference in performance, because I can\u0027t seem to find consistent information on the GFLOP count of my roommate\u0027s processor.\u003C/p\u003E\u003Cp\u003EIs this function an accurate way of measuring either CPU, GPU, or total computer performance?\u003C/p\u003E\u003Cp\u003EIn-case anyone wants to try this on their own computer, the .exe application and the source code in .h format are linked below. Ignore the broken \u0022how it works\u0022 function. I have yet to get it to properly display the message that you can read in the source code, so if any programmers want to tell me how to fix it, that would be nice.\u003C/p\u003E\u003Cp\u003EApplication (EXE): \u003Ca href=\u0022https://www.dropbox.com/s/bh5c72j395xz1m7/A44.exe?dl=0\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://www.dropbox.com/s/bh5c72j395xz1m7/A44.exe?dl=0\u003C/a\u003E\u003C/p\u003E\u003Cp\u003ESource (H): \u003Ca href=\u0022https://www.dropbox.com/s/guavn0c364w97hz/Form1.h?dl=0\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://www.dropbox.com/s/guavn0c364w97hz/Form1.h?dl=0\u003C/a\u003E\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-04-25T09:11:29Z","Content":"\n\u003Cp\u003ELets start with the fact that A(4,4) is far outside the int range. And why, exactly, are you passing 64 bit integers to it as parameters, but return just a 32 bit int? But that\u0027s just minor gripes. Then there is your implementation with forms, which is going to prevent you from running a clean, well optimized code. If you want to write efficient code, write it in C. Finally, the only thing you are really \u0022testing\u0022 with this implementation is the stack.\u003C/p\u003E\u003Cp\u003EEdit: All of the references talk about Ackermann as the benchmark of \u003Cem\u003Eoptimizer\u003C/em\u003E, not benchmark of the computer.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-25T09:15:58Z\u0022 title=\u002204/25/2015 09:15  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 25, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"ZetaX","CreatedById":60692,"CreatedDateTime":"2015-04-25T09:43:21Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Themohawkninja\u0022 data-cite=\u0022Themohawkninja\u0022\u003E\u003Cdiv\u003EIs this function an accurate way of measuring either CPU, GPU, or total computer performance?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EUnless you do weird things, all you will test is your CPU\u0027s arithmetics and maybe memory and busses. Why would you expect a purely arithmetical thing to test a GPU\u00C3\u201A\u00C2\u00BF\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-04-25T10:49:11Z","Content":"\n\u003Cp\u003EModern GPUs are just general vector processors. Lots and lots of arithmetic operations are precisely how you test them. What GPUs are really bad at is any sort of branching, which would make Ackermann absolutely the worst thing to use a GPU for.\u003C/p\u003E\n"},{"CreatedByName":"Themohawkninja","CreatedById":9628,"CreatedDateTime":"2015-04-25T18:01:44Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022ZetaX\u0022 data-cite=\u0022ZetaX\u0022\u003E\u003Cdiv\u003EUnless you do weird things, all you will test is your CPU\u0027s arithmetics and maybe memory and busses. Why would you expect a purely arithmetical thing to test a GPU\u00C3\u201A\u00C2\u00BF\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI don\u0027t. I have a pretty limited knowledge of computer science at the moment, which is why I asked what this would ACTUALLY test.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E\u003Cspan style=\u0022color:#C0C0C0;\u0022\u003E- - - Updated - - -\u003C/span\u003E\u003C/span\u003E\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003ELets start with the fact that A(4,4) is far outside the int range. And why, exactly, are you passing 64 bit integers to it as parameters, but return just a 32 bit int? But that\u0027s just minor gripes. Then there is your implementation with forms, which is going to prevent you from running a clean, well optimized code. If you want to write efficient code, write it in C. Finally, the only thing you are really \u0022testing\u0022 with this implementation is the stack.\u003Cp\u003EEdit: All of the references talk about Ackermann as the benchmark of \u003Cem\u003Eoptimizer\u003C/em\u003E, not benchmark of the computer.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe program was meant to do the exact opposite of what it does (run for a given period of time, and count the number of times it called the function), but I was having issues with it either breaking a 64-bit integer, or calculating for such a short period of time that I couldn\u0027t get any real data from it. The code would look nicer if it wasn\u0027t for the fact that this isn\u0027t so much of a serious program that I would put in a portfolio for a job, so much so as it is a little experiment in mathematics and computer science. It gave me quite the eye-opener as to just how fast current processors are when I had to tell the computer to run 100 million iterations to get a decent number of milliseconds to go off of.\u003C/p\u003E\u003Cp\u003EAlso, what is the \u0022stack\u0022 with reference to computer science here? Is that the order/speed in which instructions are carried out, or something completely different?\u003C/p\u003E\n"},{"CreatedByName":"andrewas","CreatedById":24662,"CreatedDateTime":"2015-04-25T19:19:14Z","Content":"\n\u003Cp\u003EThe stack is an area of memory to which the current contents of the processor registers are pushed every time you do a function call.\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-04-26T00:16:03Z","Content":"\n\u003Cp\u003EYou don\u0027t usually push all the registers. Just the \u0022relevant\u0022 ones. (TBD by the compiler.) Unoptimized code will almost never push any working registers to the stack. What always goes onto the stack is the return address and almost always a base pointer. But stack is used for a lot more than that. Stack is used to pass variables to a function, it is used for nearly all local variables within a function, and it is used in intermediate operations of complicated algebraic expressions.\u003C/p\u003E\u003Cp\u003EFor example. Consider a very simple function.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eint sum(int a, int \u003Cbr\u003E{\u003Cbr\u003E\tint c = a \u002B b;\u003Cbr\u003E\treturn c;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EIf you compile it without optimization and call sum(3,4) from main, the stack will get the following workout.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Col style=\u0022list-style-type:decimal;\u0022\u003E\u003Cli\u003EPush 4 to the stack.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EPush 3 to the stack.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EPush return address in main to the stack. (Followed by jump to address of sum function in memory.)\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EPush current base pointer (belonging to main) to the stack.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003ESet base pointer to match stack pointer.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EDecrement stack pointer by 4 to create space for c on the stack.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EUse base pointer to read values of a and b, compute the sum, and use base pointer again to store it in c.\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003ECopy answer from c to return register. (Usually eax)\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EPop base pointer from stack. (Returns it to base of main.)\u003Cbr\u003E\u003C/li\u003E\u003Cli\u003EPop return address from stack, and return to main function.\u003C/li\u003E\u003C/ol\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ENow imagine all of that on top of your A(m,n) function. Basically, all it does is stack operations simply because of the way you\u0027ve set up recursion. Processor does very little of actual algebra. It will spend, maybe, one cycle in a hundred doing math, and the rest of the time will be wasted on branching, function calls, stack operations, and all of the mess associated with it. (Branch predictions, cache predictions, etc.)\u003C/p\u003E\u003Cp\u003EWhen you want to test computational capabilities of the CPU, you really want to avoid all of that nonsense. You want to serve mathematical operations in as predictable a manner as possible, making sure that cache remains consistent, and any branches you must have are very well predicted. Then all the CPU is doing is pulling values out of cache, does math, puts them back into cache, and it can do this very, very fast. That\u0027s where you can get tens of billions of operations per second.\u003C/p\u003E\u003Cp\u003EGPU is kind of a different story. It\u0027s really bad at general computing. Especially branching. You generally want to pull as much of that out of GPU code as possible and have CPU look after it. If you can reduce your math problem to \u0022Do this set of operations a million times,\u0022 you can get a good GPU give you \u003Cem\u003Etrillions\u003C/em\u003E of operations per second. That\u0027s why GPU is so awesome at image processing, numerical integration, and artificial neural networks. And, of course, actual rendering. All of these problems are reduced to, \u0022Here is the math you have to do for each point, now do this lots.\u0022\u003C/p\u003E\u003Cp\u003EEdit: If you can read assembly, the sum(a,\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_cool.png\u0022 alt=\u0022B)\u0022\u003E compiles to the following on x86. (Again, unoptimized)\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Epush ebp\u003Cbr\u003Emov ebp, esp\u003Cbr\u003Esub esp, 4\u003Cbr\u003Emov eax, [ebp\u002B8]\u003Cbr\u003Eadd eax, [ebp\u002B12]\u003Cbr\u003Emov [ebp-4], eax\u003Cbr\u003Emov eax, [ebp-4]\u003Cbr\u003Emov esp, ebp\u003Cbr\u003Epop ebp\u003Cbr\u003Eret\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-04-26T00:27:59Z\u0022 title=\u002204/26/2015 12:27  AM\u0022 data-short=\u00229 yr\u0022\u003EApril 26, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Camacha","CreatedById":59088,"CreatedDateTime":"2015-04-26T02:39:34Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Themohawkninja\u0022 data-cite=\u0022Themohawkninja\u0022\u003E\u003Cdiv\u003EIs this function an accurate way of measuring either CPU, GPU, or total computer performance?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENo, for the simple reason that computer performance in dependant on so many factors, of which a major one is what you are actually trying to do. So even if you might be measuring a computer\u0027s capability to solve Ackermann Functions to perfection, any other task will be less accurately gauged. Many components are slightly or even very specialised towards their final purpose.\u003C/p\u003E\n"}]}