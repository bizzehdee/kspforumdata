{"TopicId":92781,"ForumId":29,"TopicTitle":"[answered] Documentation on what can and can\u0026#039;t go in a string value of ConfigNode?","CreatedByName":"Dunbaratu","CreatedById":63481,"CreatedDateTime":"2014-12-14T02:53:35Z","PageNum":1,"Articles":[{"CreatedByName":"Dunbaratu","CreatedById":63481,"CreatedDateTime":"2014-12-14T02:53:35Z","Content":"\n\u003Cp\u003EI\u0027m having a heck of a hard time diagnosing a problem with Base64 encoded content stored inside a ConfigNode of the persistent.sfs file getting mangled. It would help if I could find actual hard facts about the syntax of the persistent.sfs file and what is and isn\u0027t allowed in it. For example, when the file has a line like so:\u003C/p\u003E\u003Cp\u003Ename = someValue\u003C/p\u003E\u003Cp\u003EWhen what is the regular expression that defines what is legal and illegal for someValue?\u003C/p\u003E\u003Cp\u003EI\u0027m getting the characters \u0027=\u0027. \u0027_\u0027, and \u0027,\u0027 being stripped off of someValue if they happen to occur at the end of the string, but not if they occur in the middle of the string.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-12-15T02:17:55Z\u0022 title=\u002212/15/2014 02:17  AM\u0022 data-short=\u00229 yr\u0022\u003EDecember 15, 2014\u003C/time\u003E by Steven Mading\u003C/strong\u003E\n\u003Cbr\u003Eadded \u0026#039;[answered]\u0026#039; prefix to subject\n\u003C/span\u003E\n"},{"CreatedByName":"jamespicone","CreatedById":125714,"CreatedDateTime":"2014-12-14T05:10:24Z","Content":"\n\u003Cp\u003EAs far as I can tell, ConfigNode parsing tokenizes on newline, followed by removing any token that starts with \u0022//\u0022 and removing parts of tokens following \u0022//\u0022, then it tokenises on \u0022{\u0022 and \u0022}\u0022, then it splits tokens into two around the first \u0022=\u0022 character, and finally it trims whitespace on either side of the token. I don\u0027t think it strips \u0022_\u0022 or \u0022,\u0022. How are you actually getting the ConfigNode?\u003C/p\u003E\n"},{"CreatedByName":"Dunbaratu","CreatedById":63481,"CreatedDateTime":"2014-12-14T06:47:04Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022jamespicone\u0022 data-cite=\u0022jamespicone\u0022\u003E\u003Cdiv\u003EAs far as I can tell, ConfigNode parsing tokenizes on newline, followed by removing any token that starts with \u0022//\u0022 and removing parts of tokens following \u0022//\u0022, then it tokenises on \u0022{\u0022 and \u0022}\u0022, then it splits tokens into two around the first \u0022=\u0022 character, and finally it trims whitespace on either side of the token. I don\u0027t think it strips \u0022_\u0022 or \u0022,\u0022. How are you actually getting the ConfigNode?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThis is the sequence of events I\u0027m getting:\u003C/p\u003E\u003Cp\u003E1: I leave the scene of the ship, and go back to the space center. Knowing this will write persistent.sfs, I pause the game and view the persitence file in a text editor, and confirm that my value is in it, and ends with \u0022__\u0022.\u003C/p\u003E\u003Cp\u003E2: I quit the editor (not saving anything) and then in the game, exit the game nicely.\u003C/p\u003E\u003Cp\u003E3: I look at the persistence file again, now the value is missing the trailing \u0022__\u0022.\u003C/p\u003E\u003Cp\u003EThe *FIRST* time it writes it out, it writes it correctly. Then after a complete quit of the game it\u0027s gone again.\u003C/p\u003E\n"},{"CreatedByName":"Diazo","CreatedById":81549,"CreatedDateTime":"2014-12-14T16:31:15Z","Content":"\n\u003Cp\u003EThis intrigued me and I did some reading. I did not run any tests or anything but I found the Base64 wiki article that was an interesting read. \u003Ca href=\u0022https://en.wikipedia.org/wiki/Base64\u0022 rel=\u0022external nofollow\u0022\u003EThis page specifically.\u003C/a\u003E\u003C/p\u003E\u003Cp\u003ENotably is the fact that base64 uses = symbols as padding at the end of the string if it needs to add characters to line up. I can easily see this messing KSP up with having a second = sign on the value line.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EvalueName = valueStrint==\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThat is a valid base64 string and I could see the fact that it is a second equals sign messing things up. I could also see the fact that it is an equals sign with nothing after it and I could also see the fact it is two equals signs in a row being the issue.\u003C/p\u003E\u003Cp\u003EOne workaround that I did come across was rather then letting the Base64 do the padding itself, add the padding yourself before calling Base64 and then stripping the padding out yourself after converting back from base64.\u003C/p\u003E\u003Cp\u003EHaving said that, it seems not all Base64 implementations use the = for padding. If you stick a print() into your save code and dump the base64 string to the output_log.txt, does it match what you see in the persistent.sfs? And is there padding being added?\u003C/p\u003E\u003Cp\u003ED.\u003C/p\u003E\u003Cp\u003Eedit: Seeing philotical\u0027s post below, I did something similar for ship names in AGext to ensure all ship names would be acceptable to save, even if the player used funky symbols.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Eforeach (Char ch in name)\u003Cbr\u003E            {\u003Cbr\u003E                hashedName = hashedName \u002B (int)ch;\u003Cbr\u003E            }\u003C/pre\u003E\u003Cp\u003E \u003C/p\u003E\u003Cp\u003Ecreates a string of numbers that represent the ship name. I never had an issue saving hashedName as it was guaranteed to only contain the numbers 0 through 9.\u003C/p\u003E\u003Cp\u003ENote that I simply used hashedName as the ship identifer, I never converted it back so error check for things such as character 1 that might save as \u00221\u0022 instead of \u002201\u0022 is not present.\u003C/p\u003E\u003Cp\u003ED.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-12-14T17:18:34Z\u0022 title=\u002212/14/2014 05:18  PM\u0022 data-short=\u00229 yr\u0022\u003EDecember 14, 2014\u003C/time\u003E by Diazo\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"philotical","CreatedById":109390,"CreatedDateTime":"2014-12-14T17:10:17Z","Content":"\n\u003Cp\u003EI\u0027ve had similiar problems and skipped base64 for KSP..\u003C/p\u003E\u003Cp\u003EI use binary now..\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        // found here http://www.fluxbytes.com/csharp/convert-string-to-binary-and-binary-to-string-in-c/\u003Cbr\u003E        private string StringToBinary(string data)\u003Cbr\u003E        {\u003Cbr\u003E            UnityEngine.Debug.Log(\u0022### LCARS_Message_Type StringToBinary data=\u0022 \u002B data);\u003Cbr\u003E            //return data;\u003Cbr\u003E            StringBuilder sb = new StringBuilder();\u003Cbr\u003E            foreach (char c in data.ToCharArray())\u003Cbr\u003E            {\u003Cbr\u003E                sb.Append(Convert.ToString(c, 2).PadLeft(8, \u00270\u0027));\u003Cbr\u003E            }\u003Cbr\u003E            return sb.ToString();\u003Cbr\u003E        }\u003Cbr\u003E        private string BinaryToString(string data)\u003Cbr\u003E        {\u003Cbr\u003E            UnityEngine.Debug.Log(\u0022### LCARS_Message_Type BinaryToString data=\u0022 \u002B data);\u003Cbr\u003E            //return data;\u003Cbr\u003E            List\u0026lt;Byte\u0026gt; byteList = new List\u0026lt;Byte\u0026gt;();\u003Cbr\u003E            for (int i = 0; i \u0026lt; data.Length; i \u002B= 8)\u003Cbr\u003E            {\u003Cbr\u003E                byteList.Add(Convert.ToByte(data.Substring(i, 8), 2));\u003Cbr\u003E            }\u003Cbr\u003E            return Encoding.ASCII.GetString(byteList.ToArray());\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eso far it works well..\u003C/p\u003E\u003Cp\u003Ehth\u003C/p\u003E\n"},{"CreatedByName":"xEvilReeperx","CreatedById":75857,"CreatedDateTime":"2014-12-14T19:55:21Z","Content":"\n\u003Cp\u003EIt looks like ConfigNode is capable of handling both cases:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E[KSPAddon(KSPAddon.Startup.Instantly, true)]\u003Cbr\u003Eclass Base64Test : MonoBehaviour\u003Cbr\u003E{\u003Cbr\u003E    class TestSave\u003Cbr\u003E    {\u003Cbr\u003E        [Persistent]\u003Cbr\u003E        public string Base64Underscore = \u0022someValue1__\u0022;\u003Cbr\u003E        [Persistent]\u003Cbr\u003E        public string Base64EqualsEquals = \u0022someValue2==\u0022;\u003Cbr\u003E\u003Cbr\u003E        [Persistent] public string RandomGarbage = \u0022__==__\u0022;\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    void Start()\u003Cbr\u003E    {\u003Cbr\u003E        var testSave = new TestSave();\u003Cbr\u003E\u003Cbr\u003E        var test = ConfigNode.CreateConfigFromObject(testSave);\u003Cbr\u003E        print(\u0022To configNode: \u0022 \u002B test);\u003Cbr\u003E\u003Cbr\u003E        var loadTest = new TestSave {Base64EqualsEquals = \u0022\u0022, Base64Underscore = \u0022\u0022};\u003Cbr\u003E        ConfigNode.LoadObjectFromConfig(loadTest, test);\u003Cbr\u003E\u003Cbr\u003E        // check to see maybe if it\u0027s getting stripped on file load instead\u003Cbr\u003E        test.Save(KSPUtil.ApplicationRootPath \u002B \u0022/testBase64.cfg\u0022);\u003Cbr\u003E        var fromDisk = ConfigNode.Load(KSPUtil.ApplicationRootPath \u002B \u0022/testBase64.cfg\u0022);\u003Cbr\u003E        print(\u0022from disk: \u0022 \u002B fromDisk);\u003Cbr\u003E\u003Cbr\u003E        loadTest.GetType().GetFields().ToList().ForEach(fi =\u0026gt; print(string.Format(\u0022{0} = {1}\u0022, fi.Name, fi.GetValue(loadTest))));\u003Cbr\u003E    }\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E[LOG 11:50:52.424] To configNode: DebugTools.Base64Test\u002BTestSave\u003Cbr\u003E{\u003Cbr\u003E\tBase64Underscore = someValue1__\u003Cbr\u003E\tBase64EqualsEquals = someValue2==\u003Cbr\u003E\tRandomGarbage = __==__\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E[LOG 11:50:52.430] from disk: root\u003Cbr\u003E{\u003Cbr\u003E\tBase64Underscore = someValue1__\u003Cbr\u003E\tBase64EqualsEquals = someValue2==\u003Cbr\u003E\tRandomGarbage = __==__\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E[LOG 11:50:52.432] Base64Underscore = someValue1__\u003Cbr\u003E[LOG 11:50:52.432] Base64EqualsEquals = someValue2==\u003Cbr\u003E[LOG 11:50:52.433] RandomGarbage = __==__\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ESince you mentioned persistent file, I tried a ScenarioModule as well:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E[KSPScenario(ScenarioCreationOptions.AddToAllGames, GameScenes.SPACECENTER, GameScenes.FLIGHT)]\u003Cbr\u003Eclass Base64Scenario : ScenarioModule\u003Cbr\u003E{\u003Cbr\u003E    [KSPField (isPersistant = true)] public string ControlValue = \u0022TestValue\u0022;\u003Cbr\u003E    [KSPField(isPersistant = true)]\u003Cbr\u003E    public string EqualsEquals = \u0022TestValue==\u0022;\u003Cbr\u003E    [KSPField(isPersistant = true)]\u003Cbr\u003E    public string UnderscoreUnderscore = \u0022TestValue__\u0022;\u003Cbr\u003E    [KSPField(isPersistant = true)]\u003Cbr\u003E    public string TestComma = \u0022test,\u0022;\u003Cbr\u003E    [KSPField(isPersistant = true)]\u003Cbr\u003E    public string TestPeriod = \u0022test...\u0022;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public override void OnLoad(ConfigNode node)\u003Cbr\u003E    {\u003Cbr\u003E        print(\u0022Loaded from: \u0022 \u002B node);\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    public override void OnSave(ConfigNode node)\u003Cbr\u003E    {\u003Cbr\u003E        // and manual values too, just in case\u003Cbr\u003E        node.AddValue(\u0022eqeq\u0022, \u0022manual__\u0022);\u003Cbr\u003E        node.AddValue(\u0022com\u0022, \u0022check for comma,,,\u0022);\u003Cbr\u003E        node.AddValue(\u0022period\u0022, \u0022This is a sentence.\u0022);\u003Cbr\u003E\u003Cbr\u003E        print(\u0022Saved into: \u0022 \u002B node);\u003Cbr\u003E    }\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\tSCENARIO\u003Cbr\u003E\t{\u003Cbr\u003E\t\tname = Base64Scenario\u003Cbr\u003E\t\tscene = 5\u003Cbr\u003E\t\tControlValue = TestValue\u003Cbr\u003E\t\tEqualsEquals = TestValue==\u003Cbr\u003E\t\tUnderscoreUnderscore = TestValue__\u003Cbr\u003E\t\tTestComma = test,\u003Cbr\u003E\t\tTestPeriod = test...\u003Cbr\u003E\t\teqeq = manual__\u003Cbr\u003E\t\tcom = check for comma,,,\u003Cbr\u003E\t\tperiod = This is a sentence.\u003Cbr\u003E\t}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI couldn\u0027t reproduce your problem. What does your save/load code look like?\u003C/p\u003E\n"},{"CreatedByName":"Dunbaratu","CreatedById":63481,"CreatedDateTime":"2014-12-14T23:46:41Z","Content":"\n\u003Cp\u003EI\u0027m aware of the \u0027==\u0027 at the end of base64 already. I already tried replacing the \u0027==\u0027 at the end with \u0027__\u0027 or \u0027,,\u0027 and it *still* strips them off at some point during the save.\u003C/p\u003E\u003Cp\u003ENow I\u0027m suspecting that I\u0027ll have to dig through the code to find somewhere *else* that the saving is also occurring. That\u0027s the problem with picking up mods someone else wrote and continuing with them. Things often occur in places in the code that make no sense and so you don\u0027t catch them. If this problem isn\u0027t universal then that has to mean the code is trying to manipulate the same data in the save file from *more* than one location in the code, because I verified that it works right in the one place I edited it. There must be some other location where it\u0027s repeating the same work, in a very not-object-oriented way.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-12-14T23:49:46Z\u0022 title=\u002212/14/2014 11:49  PM\u0022 data-short=\u00229 yr\u0022\u003EDecember 14, 2014\u003C/time\u003E by Steven Mading\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Dunbaratu","CreatedById":63481,"CreatedDateTime":"2014-12-15T02:17:01Z","Content":"\n\u003Cp\u003Eyeah definitely it\u0027s NOT a problem with what the low level persistence file is doing.\u003C/p\u003E\u003Cp\u003EI was able to make a dumb test to do this:\u003C/p\u003E\u003Cp\u003Enode.AddValue(\u0022testaa\u0022,\u0022aaaaa==\u0022);\u003C/p\u003E\u003Cp\u003Enode.AddValue(\u0022testbb\u0022,\u0022bbbbb__\u0022);\u003C/p\u003E\u003Cp\u003Enode.AddValue(\u0022testcc\u0022,\u0022ccccc,,\u0022);\u003C/p\u003E\u003Cp\u003EAnd then later, this:\u003C/p\u003E\u003Cp\u003E UnityEngine.Debug.Log(\u0022reading back in: testaa=\u0022\u002BconfigNode.GetValue(\u0022testaa\u0022));\u003C/p\u003E\u003Cp\u003E UnityEngine.Debug.Log(\u0022reading back in: testbb=\u0022\u002BconfigNode.GetValue(\u0022testbb\u0022));\u003C/p\u003E\u003Cp\u003E UnityEngine.Debug.Log(\u0022reading back in: testcc=\u0022\u002BconfigNode.GetValue(\u0022testcc\u0022));\u003C/p\u003E\u003Cp\u003EAnd that proved that the file is perfectly capable of storing values with \u0022__\u0022, \u0022==\u0022, or \u0022,,\u0022 at the end of them without stripping them off.\u003C/p\u003E\u003Cp\u003ESo whatever is happening in the code that\u0027s causing them to be stripped off, it\u0027s happening elsewhere, which is utterly confusing to me. Oh well, I\u0027ll have to keep looking.\u003C/p\u003E\n"},{"CreatedByName":"Dunbaratu","CreatedById":63481,"CreatedDateTime":"2014-12-15T02:58:14Z","Content":"\n\u003Cp\u003EActual Problem Found. Oh god this whole thing was one massive red herring.\u003C/p\u003E\u003Cp\u003EThe actual Problem: The slash (\u0027/\u0027) is a valid Base64 character. It represents the bit pattern 111111 (dec 63). It\u0027s therefore possible if you have a lot of bits of \u00271\u0027 in a row, to get two contiguous slashes in the base64 string. Two contiguous slashes forms a comment (\u0027//\u0027) in the persistence file and thus causes the value to be truncated at that point.\u003C/p\u003E\u003Cp\u003EIt always got truncated when the content had \u0027=\u0027 in it and was not truncated when it did, purely because of the sheer coincidence that in my test cases when the content had \u0027=\u0027 in it, it also happened to have double-slashes (\u0027//\u0027) in it. There\u0027s no causal relationship between those two conditions - it was just a random fluke of the data I was testing with.\u003C/p\u003E\n"},{"CreatedByName":"ratchet freak","CreatedById":119895,"CreatedDateTime":"2014-12-15T10:00:34Z","Content":"\n\u003Cp\u003Eyou should be able to choose the 2 non alpha numberic chars used in base 64, - and _ are typically used in URI compatible outputs instead of \u002B and /\u003C/p\u003E\n"}]}