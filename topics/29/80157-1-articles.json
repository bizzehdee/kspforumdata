{"TopicId":80157,"ForumId":29,"TopicTitle":"The Fault in our NODE{}s","CreatedByName":"Greys","CreatedById":57109,"CreatedDateTime":"2014-07-30T18:29:01Z","PageNum":1,"Articles":[{"CreatedByName":"Greys","CreatedById":57109,"CreatedDateTime":"2014-07-30T18:29:01Z","Content":"\n\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003EPART\u003Cbr\u003E{\u003Cbr\u003E    NODE\u003Cbr\u003E    {\u003Cbr\u003E        name      = something\u003Cbr\u003E        transform = NameOfTransformInModel\u003Cbr\u003E        size      = 1\u003Cbr\u003E        method    = FIXED_JOINT\u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis is PART.NODE, it was introduced in 0.20, and nobody could make it work. Part of this was because it was announced as PART.ATTACH, which doesn\u0027t exist. Now, it was figured out that this was wrong and that announcement has been corrected.\u003C/p\u003E\u003Cp\u003EWhat PART.NODE is supposed to do is allow you to define an AttachNode on a part via specifying a transform in the .mu 3D asset file, instead of using PART.node_ and specifying a vector with a series of numbers which are frequently difficult to adjust. For instance node_ specifies orientation as the average of 3 one dimensional vectors where the only thing you can impact is the vector\u0027s magnitude, not by degrees, but the average of Z=6, Y=0, X=1 composited into a single vector.\u003C/p\u003E\u003Cp\u003EUnfortunately knowing of NODE is not simply enough. The depths of faults in the code of this node have become reasonably insurmountable. The first problem with it was that NODE.size was ignored, this has been fixed as of 0.24, Thanks to Mu.\u003C/p\u003E\u003Cp\u003EFollowing that it was discovered that PART.NODE lacked any code permitting it to define a node to be a part\u0027s part.srfAttachNode. This has not been fixed but I have been able to correct it with a plugin which iterates over all the AvailableParts and applies the same logic as the base game to select a node to be the srfAttachNode, if a qualified node exists.\u003C/p\u003E\u003Cp\u003EDLL: \u003Ca href=\u0022https://github.com/Greys0/Virgin-Kalactic/blob/master/Build/srFix.dll\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://github.com/Greys0/Virgin-Kalactic/blob/master/Build/srFix.dll\u003C/a\u003E\u003C/p\u003E\u003Cp\u003ESRC: \u003Ca href=\u0022https://github.com/Greys0/Virgin-Kalactic/blob/master/Source/Virgin_Kalactic/srFix/FixSurfaceNodes.cs\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://github.com/Greys0/Virgin-Kalactic/blob/master/Source/Virgin_Kalactic/srFix/FixSurfaceNodes.cs\u003C/a\u003E\u003C/p\u003E\u003Cp\u003ELicense: MIT\u003C/p\u003E\u003Cp\u003EHowever, there remains a greater beast. NODE{} definitions are fully exempt from all scale factors applied to the part. PART.scale, PART.rescaleFactor, PART.MODEL.scale; all of it ignored.\u003C/p\u003E\u003Cp\u003EThis can\u0027t easily be fixed from the outside because there\u0027s no way after the fact to tell if an AttachNode was defined by PART.NODE or PART.node_. The logical thing to do would be to crossreference the AvailablePart pool at PartLoader.Instance.parts against GameDatabase.Instance.GetNodes(\u0022PART\u0022), and then apply the rescaleFactor which is stored in the AvailablePart to any matching nodes; But during the loading process all the PART nodes stored in the GameDatabase are striped of string values, or rather, values that are actually supposed to be text instead of numbers, enums, etc. To say that differently, there is no way to determine what part any given instance of PART in the gamedatabase was originally intended to define, all identifying information has been removed.\u003C/p\u003E\u003Cp\u003EThis is a problem I\u0027ve rammed into several times in trying to fix things which get loaded incorrectly and it\u0027s really aggravating because the only other option is to load the files again myself and create my own gamedatabase, which would also mean finding some way to apply ModuleManager patches to my duplicate, and that\u0027s getting crazy.\u003C/p\u003E\u003Cp\u003EAs it stands NODE{} is functional, you can define everything about it, there\u0027s a fix for the one problem with it; but you Can Not Scale Parts that use NODE{}\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/YHmBqli.png\u0022 alt=\u0022YHmBqli.png\u0022\u003E\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022http://i.imgur.com/hSVoLly.png\u0022 alt=\u0022hSVoLly.png\u0022\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003EGlossary\u003Cbr\u003EPART  The structure in a cfg file which KSP uses to define an instance of Part\u003Cbr\u003EPart   The class in the code which is instantiated to define a part\u003Cbr\u003Epart   The instance of Part filled with the values from PART\u003Cbr\u003EPartLoader   The class which is responsible for loading parts\u003Cbr\u003EGameDatabase  The repository of confignodes parsed from cfg files\u003Cbr\u003EAvailablePart   An object type used as a precurser to individual instances of Part on vessels; these define the parts as they are shown in the editor before you pick them out of the sidebar\u003Cbr\u003EAttachNode   An object type used to define all \u0027nodes\u0027 on all parts; \u0027node balls\u0027 are based on these and they define part snapping and define some attributes of the joint that is made there\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-07-30T18:43:16Z\u0022 title=\u002207/30/2014 06:43  PM\u0022 data-short=\u00229 yr\u0022\u003EJuly 30, 2014\u003C/time\u003E by Greys\u003C/strong\u003E\n\u003C/span\u003E\n"}]}