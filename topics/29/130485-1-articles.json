{"TopicId":130485,"ForumId":29,"TopicTitle":"Problems getting relative pitch and yaw from vessel heading","CreatedByName":"stibbons","CreatedById":57865,"CreatedDateTime":"2016-01-22T15:56:44Z","PageNum":1,"Articles":[{"CreatedByName":"stibbons","CreatedById":57865,"CreatedDateTime":"2016-01-22T15:56:44Z","Content":"\n\u003Cp\u003E\nI\u0027m currently trying to add relative pitch and heading of the various orbital vectors to\u00A0\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/index.php?/topic/60281-hardware-plugin-arduino-based-physical-display-serial-port-io-tutorial-06-jun/\u0022\u003EKSPSerialIO\u003C/a\u003E, so I can render them on an external navball display.\n\u003C/p\u003E\n\u003Cp\u003E\nSome research dug up a\u00A0\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/index.php?/topic/84921-prograde-and-several-other-grades/\u0022\u003Euseful discussion\u003C/a\u003E\u00A0on calculating pitch and heading, and using that as I reference I have the following functions to calculate relative pitch and heading of a Vector from the current vessel.\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint prettyprinted\u0022\u003E\n\u003Cspan\u003E        \u003C/span\u003E\u003Cspan\u003Eprivate\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E[]\u003C/span\u003E\u003Cspan\u003E getOffsetFromHeading\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EVessel\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E targetVector\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E\n        \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E yawComponent \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EExclude\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGetTransform\u003C/span\u003E\u003Cspan\u003E().\u003C/span\u003E\u003Cspan\u003Eforward\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E targetVector\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E yawCross \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ECross\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EyawComponent\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGetTransform\u003C/span\u003E\u003Cspan\u003E().\u003C/span\u003E\u003Cspan\u003Eright\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E yaw \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003ESignedVectorAngle\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EyawComponent\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGetTransform\u003C/span\u003E\u003Cspan\u003E().\u003C/span\u003E\u003Cspan\u003Eup\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E yawCross\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\n            \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E pitchComponent \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EExclude\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGetTransform\u003C/span\u003E\u003Cspan\u003E().\u003C/span\u003E\u003Cspan\u003Eright\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E targetVector\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E pitchCross \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ECross\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EpitchComponent\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGetTransform\u003C/span\u003E\u003Cspan\u003E().\u003C/span\u003E\u003Cspan\u003Eforward\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E pitch \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003ESignedVectorAngle\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EpitchComponent\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGetTransform\u003C/span\u003E\u003Cspan\u003E().\u003C/span\u003E\u003Cspan\u003Eup\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E pitchCross\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\n            \u003C/span\u003E\u003Cspan\u003Eif\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EMath\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EAbs\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Eyaw\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E\u0026gt;\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E90\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003E\n                yaw \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E-\u003C/span\u003E\u003Cspan\u003Eyaw\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E// This condition makes sure progradePitch doesn\u0027t wrap from -x to 360-x\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003Eif\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Epitch \u003C/span\u003E\u003Cspan\u003E\u0026gt;\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003E\n                    pitch \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E pitch \u003C/span\u003E\u003Cspan\u003E-\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E180\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E}\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003Eelse\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003E\n                    pitch \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E pitch \u003C/span\u003E\u003Cspan\u003E\u002B\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E180\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n                \u003C/span\u003E\u003Cspan\u003E}\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003E}\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003Ereturn\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003Enew\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E[]\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003Epitch\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E yaw\u003C/span\u003E\u003Cspan\u003E};\u003C/span\u003E\u003Cspan\u003E\n        \u003C/span\u003E\u003Cspan\u003E}\u003C/span\u003E\u003Cspan\u003E\n\n        \u003C/span\u003E\u003Cspan\u003Eprivate\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003ESignedVectorAngle\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E referenceVector\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E otherVector\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E normal\u003C/span\u003E\u003Cspan\u003E)\u003C/span\u003E\u003Cspan\u003E\n        \u003C/span\u003E\u003Cspan\u003E{\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E perpVector\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E angle\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003E//Use the geometry object normal and one of the input vectors to calculate the perpendicular vector\u003C/span\u003E\u003Cspan\u003E\n            perpVector \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ECross\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Enormal\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E referenceVector\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n            \u003C/span\u003E\u003Cspan\u003E//Now calculate the dot product between the perpendicular vector (perpVector) and the other input vector\u003C/span\u003E\u003Cspan\u003E\n            angle \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EAngle\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EreferenceVector\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E otherVector\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n            angle \u003C/span\u003E\u003Cspan\u003E*=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EMath\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ESign\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EDot\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EperpVector\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E otherVector\u003C/span\u003E\u003Cspan\u003E));\u003C/span\u003E\u003Cspan\u003E\n\n            \u003C/span\u003E\u003Cspan\u003Ereturn\u003C/span\u003E\u003Cspan\u003E angle\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n        \u003C/span\u003E\u003Cspan\u003E}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nAnd I\u0027m now trying to use it to calculate the position of orbital prograde by doing this\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint prettyprinted\u0022\u003E\n\u003Cspan\u003EVector3\u003C/span\u003E\u003Cspan\u003E progradeVector \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EGetObtVelocity\u003C/span\u003E\u003Cspan\u003E().\u003C/span\u003E\u003Cspan\u003Enormalized\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003Edouble\u003C/span\u003E\u003Cspan\u003E[]\u003C/span\u003E\u003Cspan\u003E progradeHeading \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E getOffsetFromHeading\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EActiveVessel\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E progradeVector\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003EDebug\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003ELog\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003EString\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EFormat\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003E\u0022Prograde pitch: {0:F2} heading: {1:F2}\u0022\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E progradeHeading\u003C/span\u003E\u003Cspan\u003E[\u003C/span\u003E\u003Cspan\u003E0\u003C/span\u003E\u003Cspan\u003E],\u003C/span\u003E\u003Cspan\u003E progradeHeading\u003C/span\u003E\u003Cspan\u003E[\u003C/span\u003E\u003Cspan\u003E1\u003C/span\u003E\u003Cspan\u003E]));\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nThis code seems to work properly when the heading is around 0 (or 180). But I\u0027m seeing very unexpected behaviour with the reported pitch varying drastically as the heading gets close to \u002B/- 90 degrees. I tested by lining up with prograde and then pitching down slightly so the prograde marker was above my heading. Then started yawing to the left.\u00A0\u003Ca href=\u0022https://bitbucket.org/snippets/pjhardy/y8zxn\u0022 rel=\u0022external nofollow\u0022\u003EHere\u0027s a log of a full rotation\u003C/a\u003E. It shows the heading (yaw) increasing fairly linearly, and I would expect the pitch to remain close to constant. Instead it gets very high, peaking at -90 degrees yaw, dropping lower than the original pitch at 180, and then climbing to another peak at 90 degrees yaw.\n\u003C/p\u003E\n\u003Cp\u003E\nThe only rational explanation I\u0027ve come up with that might explain it is that I need to apply the pitch number first, then the roll, and I\u0027ll end up with the vector in the right place. So I tried doing that on my display, and it still doesn\u0027t look right. This is from a different run of the same test, but with similar results.\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsEmbeddedVideo\u0022 contenteditable=\u0022false\u0022\u003E\n\u003Cdiv\u003E\n\u003Ciframe allowfullscreen=\u0022true\u0022 frameborder=\u00220\u0022 height=\u0022270\u0022 src=\u0022https://www.youtube.com/embed/KKmnhtnKL_Y?feature=oembed\u0022 width=\u0022480\u0022\u003E\u003C/iframe\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\nAny other suggestions for what I might be doing wrong here? Do I need to transform the prograde vector? I assumed it was already in the right reference frame.\n\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2016-01-22T17:48:16Z","Content":"\n\u003Cp\u003E\nWhen you say relative pitch and heading from prograde, I assume you\u0027re trying to calculate yaw and AoA which Pilot Assistant does \u003Ca href=\u0022https://github.com/Crzyrndm/Pilot-Assistant/blob/master/PilotAssistant/FlightModules/VesselData.cs#L83-L87\u0022 rel=\u0022external nofollow\u0022\u003Ehere\u003C/a\u003E. (I don\u0027t see any obvious errors, but maybe another example will shed some light) (\u003Ca href=\u0022https://github.com/Crzyrndm/Pilot-Assistant/blob/master/PilotAssistant/Utility/Utils.cs#L132\u0022 rel=\u0022external nofollow\u0022\u003EProjectOnPlane\u003C/a\u003E)\n\u003C/p\u003E\n\u003Cp\u003E\nEDIT\n\u003C/p\u003E\n\u003Cp\u003E\nWhat on earth is that limit section doing. Vector3d.Angle will always be inside \u002B/- 180 degrees, and since it\u0027s relative, shouldn\u0027t be exactly what you want?\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-01-22T17:57:45Z\u0022 title=\u002201/22/2016 05:57  PM\u0022 data-short=\u00228 yr\u0022\u003EJanuary 22, 2016\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"stibbons","CreatedById":57865,"CreatedDateTime":"2016-01-23T04:50:06Z","Content":"\n\u003Cp\u003E\nI should apologise now - I\u0027ve never done any 3D programming before, and am struggling to get my head around it.\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222374341\u0022 data-ipsquote-contentid=\u0022130485\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221453484896\u0022 data-ipsquote-userid=\u002292871\u0022 data-ipsquote-username=\u0022Crzyrndm\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n10 hours ago, Crzyrndm said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nWhen you say relative pitch and heading from prograde, I assume you\u0027re trying to calculate yaw and AoA which Pilot Assistant does \u003Ca href=\u0022https://github.com/Crzyrndm/Pilot-Assistant/blob/master/PilotAssistant/FlightModules/VesselData.cs#L83-L87\u0022 rel=\u0022external nofollow\u0022\u003Ehere\u003C/a\u003E. (I don\u0027t see any obvious errors, but maybe another example will shed some light) (\u003Ca href=\u0022https://github.com/Crzyrndm/Pilot-Assistant/blob/master/PilotAssistant/Utility/Utils.cs#L132\u0022 rel=\u0022external nofollow\u0022\u003EProjectOnPlane\u003C/a\u003E)\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThinking it over some more last night, I\u0027m suspecting I\u0027ve been calculating this the wrong way, and yaw and AoA aren\u0027t actually want I want. To draw the prograde marker I\u0027m taking a point on the surface of the navball representing the up vector, and doing a 3D transform to rotate it to the prograde vector. My current understanding is that I need the Euler angles for that, not yaw and AoA. Does that make sense?\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222374341\u0022 data-ipsquote-contentid=\u0022130485\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221453484896\u0022 data-ipsquote-userid=\u002292871\u0022 data-ipsquote-username=\u0022Crzyrndm\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n10 hours ago, Crzyrndm said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nWhat on earth is that limit section doing. Vector3d.Angle will always be inside \u002B/- 180 degrees, and since it\u0027s relative, shouldn\u0027t be exactly what you want?\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nI didn\u0027t find anything about the limits of Angle (although, looking again, the\u00A0\u003Ca href=\u0022http://docs.unity3d.com/ScriptReference/Vector3.Angle.html\u0022 rel=\u0022external nofollow\u0022\u003EVector3.Angle\u003C/a\u003E\u00A0docs are pretty clear about it always returning the smaller angle) so was just being super guarded.\n\u003C/p\u003E\n"},{"CreatedByName":"Crzyrndm","CreatedById":92871,"CreatedDateTime":"2016-01-23T08:17:55Z","Content":"\n\u003Cp\u003E\nNo worries, I was in the same position about twelve months ago when I started on PA. Just have to keep working at it...\n\u003C/p\u003E\n\u003Cp\u003E\nSo to define what you have and what you want:\n\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003E\nyou have a navball reference direction of up / pitch 90 (relative to your navball I\u0027m assuming? ie. it rotates with everything else)\n\u003C/li\u003E\n\u003Cli\u003E\nyou have a KSP vector that corresponds to your navball reference (eg. surface normal)\n\u003C/li\u003E\n\u003Cli\u003E\nyou want to create a vector that matches a KSP vector on the navball (navball space)\n\u003C/li\u003E\n\u003C/ul\u003E\u003Cp\u003E\nIf ^^ is correct, things are about to get a little curly (in a nice way hopefully...). Transforming one direction to another by a rotation is normally done using Quaternions, and Quat\u0027s aren\u0027t nice things to try and imagine (particularly if you\u0027re already having fun with vectors...). This should be a fairly simple application though\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint prettyprinted\u0022\u003E\n\u003Cspan\u003E// First, calculate the rotation required to go from up to prograde in game space\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003E// From: vector from the center of the body through the vessel (up)\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003E// To: vessel surface prograde\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003EQuaternion\u003C/span\u003E\u003Cspan\u003E progradeRot \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EQuaternion\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EFromToRotation\u003C/span\u003E\u003Cspan\u003E(\u003C/span\u003E\u003Cspan\u003Evessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003Etransform\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003Eposition \u003C/span\u003E\u003Cspan\u003E-\u003C/span\u003E\u003Cspan\u003E vessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003Emainbody\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003Etransform\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003Eposition\u003C/span\u003E\u003Cspan\u003E,\u003C/span\u003E\u003Cspan\u003E vessel\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003Esrf_velocity\u003C/span\u003E\u003Cspan\u003E);\u003C/span\u003E\u003Cspan\u003E\n\n\u003C/span\u003E\u003Cspan\u003E// Second, use that rotation to translate your *navball* up reference around to the prograde direction in navball space\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003E// Quaterion * Vector3 gives a new vector3 which is the original rotated by the rotation the Quaterion defines\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003EVector3\u003C/span\u003E\u003Cspan\u003E navballPrograde \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E progradeRot \u003C/span\u003E\u003Cspan\u003E*\u003C/span\u003E\u003Cspan\u003E navballUp\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003Cspan\u003E\n\n\u003C/span\u003E\u003Cspan\u003E// You can also get a Euler representation of the Quat (just be aware it\u0027s only accurate to about 1 decimal place, eg. 180.5 degrees)\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003E// from memory it\u0027s x: pitch, y: yaw, z:roll, but you will want to check that since KSP is often wierd on that front\u003C/span\u003E\u003Cspan\u003E\n\u003C/span\u003E\u003Cspan\u003EVector3\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003EEulerRot\u003C/span\u003E\u003Cspan\u003E \u003C/span\u003E\u003Cspan\u003E=\u003C/span\u003E\u003Cspan\u003E progradeRot\u003C/span\u003E\u003Cspan\u003E.\u003C/span\u003E\u003Cspan\u003EeulerAngles\u003C/span\u003E\u003Cspan\u003E;\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nEDIT\n\u003C/p\u003E\n\u003Cp\u003E\nIf you just want the vector in navball space and don\u0027t actually care about the angles, there\u0027s a better way than the above. A rotation which can be used for any KSP vector you wish to show in navball space\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint\u0022\u003E\n// Calculate the rotation which transforms KSP up to navball up\n// From: the planet surface normal (ie. planet up / KSP up)\n// To: navball up / navball reference vector\nQuaternion navballTransformRot = Quaternion.FromToRotation(planetUp, navballUp);\n\n// now we can multiply any KSP vector by that rotation to get the vector in navball space\nVector3 navballPrograde = navballTransformRot * vessel.srf_prograde;\nVector3 navballRight = navballTransformRot * vessel.transform.right;\n// etc.\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-01-23T10:29:09Z\u0022 title=\u002201/23/2016 10:29  AM\u0022 data-short=\u00228 yr\u0022\u003EJanuary 23, 2016\u003C/time\u003E by Crzyrndm\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"stibbons","CreatedById":57865,"CreatedDateTime":"2016-01-28T15:04:54Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222375423\u0022 data-ipsquote-contentid=\u0022130485\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221453537075\u0022 data-ipsquote-userid=\u002292871\u0022 data-ipsquote-username=\u0022Crzyrndm\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nOn 1/23/2016 at 7:17 PM, Crzyrndm said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cul\u003E\u003Cli\u003E\nyou have a navball reference direction of up / pitch 90 (relative to your navball I\u0027m assuming? ie. it rotates with everything else)\n\u003C/li\u003E\n\u003Cli\u003E\nyou have a KSP vector that corresponds to your navball reference (eg. surface normal)\n\u003C/li\u003E\n\u003Cli\u003E\nyou want to create a vector that matches a KSP vector on the navball (navball space)\n\u003C/li\u003E\n\u003C/ul\u003E\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nIt\u0027s actually slightly easier than this, because I\u0027m already transforming the navball up to match vessel up (see\u00A0\u003Ca href=\u0022https://github.com/zitron-git/KSPSerialIO/blob/master/KSPSerialIO/KSPIO.cs#L1557\u0022 rel=\u0022external nofollow\u0022\u003EupdateHeadingPitchRollField()\u003C/a\u003E). That should mean I can ignore the world reference and just calculate the rotation relative to the vessel position.\u00A0So it seems to me that for surface prograde progradeRot would be more like\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint\u0022\u003E\nQuaternion progradeRot = Quaternion.FromToRotation(vessel.transform.position, vessel.srf_velocity);\u003C/pre\u003E\n\u003Cp\u003E\nAnd I definitely do need the euler rotation, but it looks like I can easily reuse existing plugin code to convert that Quat.\n\u003C/p\u003E\n\u003Cp\u003E\nThanks very much for the advice and code, \u003Ca contenteditable=\u0022false\u0022 data-ipshover=\u0022\u0022 data-ipshover-target=\u0022http://forum.kerbalspaceprogram.com/index.php?/profile/92871-crzyrndm/\u0026amp;do=hovercard\u0022 data-mentionid=\u002292871\u0022 href=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/92871-crzyrndm/\u0022\u003E@Crzyrndm\u003C/a\u003E. Knowing how to calculate rotations like that has really helped illuminate how transforms and quaternions work. I think I\u0027ve got a handle on how it needs to be done now, but it\u0027ll be a little while longer before I\u0027ve got time to properly test it.\n\u003C/p\u003E\n"}]}