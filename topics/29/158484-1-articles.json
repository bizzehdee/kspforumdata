{"TopicId":158484,"ForumId":29,"TopicTitle":"Orbit.getOrbitalVelocityAtUT()\u00A0 returns rotated vector after each Quickload, with the same argument","CreatedByName":"Kobymaru","CreatedById":107372,"CreatedDateTime":"2017-03-31T18:37:05Z","PageNum":1,"Articles":[{"CreatedByName":"Kobymaru","CreatedById":107372,"CreatedDateTime":"2017-03-31T18:37:05Z","Content":"\n\u003Cp\u003E\nHi! I am trying to calculate the velocity (with direction)\u00A0at a certain point later in the orbit.\n\u003C/p\u003E\n\u003Cp\u003E\nI am trying to read this with this with Orbit.getOrbitalVelocityAtUT()\u00A0 \u00A0 \u00A0 \u00A0 \u00A0 \u00A0\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003EVector3d orbitalVelocityAtImpact = vessel.orbit.getOrbitalVelocityAtUT(impactUT);\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nHowever, something very strange is occurring:\n\u003C/p\u003E\n\u003Cp\u003E\nI quickload a save, and proceed along the Orbit for a few in-game minutes. Then I reload the save from where I started. But the Orbital Velocity has changed direction! I presume it is still in the state \u003Cem\u003Ebefore\u00A0\u003C/em\u003Ethe quickload.\n\u003C/p\u003E\n\u003Cp\u003E\nHere are three values that I recorded right after quickloading:\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode\u0022\u003E\n\u002B\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0orbitalVelocityAtImpact\u00A0\u00A0 \u00A0\u0022[169.909714097467, 29.454900938199, 10.8833349871162]\u0022\u00A0\u00A0 \u00A0Vector3d\n\u002B\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0orbitalVelocityAtImpact\u00A0\u00A0 \u00A0\u0022[171.443843360678, 18.5448866639756, 10.8833496607608]\u0022\u00A0\u00A0 \u00A0Vector3d\n\u002B\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0orbitalVelocityAtImpact\u00A0\u00A0 \u00A0\u0022[172.27266602452, 7.68307916777123, 10.8833286528833]\u0022\u00A0\u00A0 \u00A0Vector3d\u003C/pre\u003E\n\u003Cp\u003E\nAs you can see, the velocity keeps rotating. This is with the argument of the function (the time) staying approximately the same. I am confused\u00A0\u003Cimg alt=\u0022:confused:\u0022 data-emoticon=\u0022\u0022 src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_huh.gif\u0022 title=\u0022:confused:\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan\u003E\u003Ca contenteditable=\u0022false\u0022 data-ipshover=\u0022\u0022 data-ipshover-target=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/104043-starstrider42/\u0026amp;do=hovercard\u0022 data-mentionid=\u0022104043\u0022 href=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/104043-starstrider42/\u0022 rel=\u0022\u0022\u003E@Starstrider42\u003C/a\u003E\u00A0was onto something here, and he mentioned something about Planetarium.Zup quaternions.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Ciframe data-embedcontent=\u0022\u0022 frameborder=\u00220\u0022 src=\u0022https://forum.kerbalspaceprogram.com/index.php?/topic/138529-orbit-state-vectors-not-reproducible/\u0026amp;do=embed\u0026amp;comment=2560126\u0026amp;embedComment=2560126\u0026amp;embedDo=findComment\u0022\u003E\u003C/iframe\u003E\n\u003Cp\u003E\nUnfortunately, I have no idea what Planetarium.Zup is, how it changes, how it relates to Orbit.getOrbitalVelocityAtUT(), and how to use it to fix my rotations.\n\u003C/p\u003E\n\u003Cp\u003E\nCan you guys help me out here?\n\u003C/p\u003E\n"},{"CreatedByName":"sarbian","CreatedById":57146,"CreatedDateTime":"2017-03-31T20:21:59Z","Content":"\n\u003Cp\u003E\nSorry for stating the obvious but orbit are not straight lines. The velocity will rotate\u00A0with time. You do not state the time difference between each samples.\n\u003C/p\u003E\n\u003Cp\u003E\nTry with\u00A0GetOrbitalStateVectorsAtUT\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"Kobymaru","CreatedById":107372,"CreatedDateTime":"2017-03-31T20:52:22Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00223004776\u0022 data-ipsquote-contentid=\u0022158484\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221490991719\u0022 data-ipsquote-userid=\u002257146\u0022 data-ipsquote-username=\u0022sarbian\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\n47 minutes ago, sarbian said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nSorry for stating the obvious but orbit are not straight lines. The velocity will rotate\u00A0with time. You do not state the time difference between each samples.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThe difference between the samples is zero.\n\u003C/p\u003E\n\u003Col\u003E\u003Cli\u003E\nQuicksave.\n\u003C/li\u003E\n\u003Cli\u003E\nObserve Value\n\u003C/li\u003E\n\u003Cli\u003E\nTimewarp 5 ingame minutes\n\u003C/li\u003E\n\u003Cli\u003E\nQuickload\n\u003C/li\u003E\n\u003Cli\u003E\nObserve Value\n\u003C/li\u003E\n\u003Cli\u003E\nTimewarp 5 ingame minutes\n\u003C/li\u003E\n\u003Cli\u003E\nQuickload\n\u003C/li\u003E\n\u003Cli\u003E\nObserve Value\n\u003C/li\u003E\n\u003C/ol\u003E\u003Cp\u003E\nIf I observe the value right after quickloading, it should be the same every single time, shouldn\u0027t it? Nothing inside the game universe changes.\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nQuote\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nTry with\u00A0GetOrbitalStateVectorsAtUT\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThanks, I will try that!\n\u003C/p\u003E\n\u003Cp\u003E\nBy the way, I actually just care about the surface-relative velocity at the UT, so if there\u0027s a shortcut for that that would also work.\n\u003C/p\u003E\n\u003Cp\u003E\nedit: Just tried\u00A0GetOrbitalStateVectorsAtUT(), returns a different value than getOrbitalVelocityAtUT() but\u00A0it also drifts across reloads.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222017-03-31T21:12:26Z\u0022 title=\u002203/31/2017 09:12  PM\u0022 data-short=\u00227 yr\u0022\u003EMarch 31, 2017\u003C/time\u003E by Kobymaru\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Kobymaru","CreatedById":107372,"CreatedDateTime":"2017-04-04T17:42:30Z","Content":"\n\u003Cp\u003E\nOk, update:\n\u003C/p\u003E\n\u003Cp\u003E\nI \u0022solved\u0022 my issue.\n\u003C/p\u003E\n\u003Cp\u003E\nTurns out that both \u00A0\u003Cspan style=\u0022color:#272a34;\u0022\u003EGetOrbitalStateVectorsAtUT and\u00A0getOrbitalVelocityAtUT return a value in some weird reference frame that rotates, but doesn\u0027t rotate back when quickloading.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nIn my application, I only needed the angle between the the up direction and the velocity at the time of impact. For this, I could simply take position and velocity vectors returned by\u00A0\u003Cspan style=\u0022color:#272a34;\u0022\u003EGetOrbitalStateVectorsAtUT, and calculate the angle between those, since the position vector was the local frame but rotated in the same way as the velocity vector.\u003C/span\u003E\n\u003C/p\u003E\n"},{"CreatedByName":"Jim DiGriz","CreatedById":92465,"CreatedDateTime":"2017-10-22T03:06:33Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00223009350\u0022 data-ipsquote-contentid=\u0022158484\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221491327750\u0022 data-ipsquote-userid=\u0022107372\u0022 data-ipsquote-username=\u0022Kobymaru\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nOn 4/4/2017 at 10:42 AM, Kobymaru said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nTurns out that both \u00A0\u003Cspan style=\u0022color:#272a34;\u0022\u003EGetOrbitalStateVectorsAtUT and\u00A0getOrbitalVelocityAtUT return a value in some weird reference frame...\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThat\u0027s the inverse rotation, when you\u0027re under the inverse rotation threshold.\n\u003C/p\u003E\n\u003Cp\u003E\nWorking code to update an orbit and then get the state vectors at some future time looks something like this:\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-c prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003E\n\u003C/span\u003E\u003Cspan class=\u0022kwd\u0022\u003Eprivate\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E \u003C/span\u003E\u003Cspan class=\u0022kwd\u0022\u003Evoid\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E CSEKSP\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E(\u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E r0\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E v0\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E \u003C/span\u003E\u003Cspan class=\u0022kwd\u0022\u003Edouble\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E t\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E out \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E rf\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E out \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E vf\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E)\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n            \u003C/span\u003E\u003Cspan\u003EVector3d\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E rot \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E=\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E orbit\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan\u003EGetRotFrameVelAtPos\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E(\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003EmainBody\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E r0\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Exzy\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E);\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n            \u003C/span\u003E\u003Cspan\u003ECSEorbit\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan\u003EUpdateFromStateVectors\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E(\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Er0\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Exzy\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E v0\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Exzy \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E\u002B\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E rot\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E mainBody\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E vesselState\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Etime\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E);\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n            \u003C/span\u003E\u003Cspan\u003ECSEorbit\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan\u003EGetOrbitalStateVectorsAtUT\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E(\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003EvesselState\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Etime \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E\u002B\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E t\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E out rf\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E out vf\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E);\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n            rot \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E=\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E orbit\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan\u003EGetRotFrameVelAtPos\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E(\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003EmainBody\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E,\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E rf\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E);\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n            rf \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E=\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E rf\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E.\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Exzy\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n            vf \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E=\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E(\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Evf \u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E-\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E rot\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E).\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003Exzy\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n\u003C/span\u003E\u003Cspan class=\u0022pun\u0022\u003E}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nOnly the velocity vector gets fixed like this, the position vectors don\u0027t need correcting.\u00A0 Above the inverse rotation threshold GRFVAP returns Vector3d.zero.\u00A0\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nSorry for the necro, but I wanted to update this thread with the information for search engines in case anyone else hits this.\n\u003C/p\u003E\n"}]}