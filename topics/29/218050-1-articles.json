{"TopicId":218050,"ForumId":29,"TopicTitle":"Need help with Vectrosity and VectorLine.","CreatedByName":"alexalex","CreatedById":224261,"CreatedDateTime":"2023-06-27T17:15:32Z","PageNum":1,"Articles":[{"CreatedByName":"alexalex","CreatedById":224261,"CreatedDateTime":"2023-06-27T17:15:32Z","Content":"\n\u003Cp\u003E\nI am trying to make the satellite and relay system operate a bit like how data connections work in real life so that experiments consume antenna bandwidth while antennas provide network capacity.\u00A0 So that each additional experiment that is being run would consume bandwidth and reduce the available capacity of the satellite relay network that it is on (I have this part mostly done).\n\u003C/p\u003E\n\u003Cp\u003E\nBut to make it work I need an easy to understand way to show the KSP player what is going on, and I\u0027m running into trouble with the graphical interface part.\u00A0 I can draw lines between the start and end points of a particular satellite relay network, but whenever I rotate the camera position the lines jitter and wobble about and I have no idea what\u0027s causing it.\u00A0 Vanilla KSP doesn\u0027t do this so it\u0027s definitely something to do with my code.\u00A0 Anyone know what\u0027s going on?\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\u003Cspan class=\u0022pln\u0022\u003Epublic class CommViewer : CommNetUI\n\t{\n\t\tpublic void Update()\n\t\t{\n\t\t\tif (line != null) VectorLine.Destroy(ref line);\n\n\t\t\tif (Monitor.commStatus != \u0022\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;b\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E \u0026lt;\u0026lt;  Available Bandwidth  \u0026gt;\u0026gt; \u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;/b\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\u0022) return;\n\n\t\t\tvar vesselList = new List\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vessel\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E();\n\t\t\tforeach (Vessel v in FlightGlobals.Vessels)\n\t\t\t{\n\t\t\t\tif (v.connection != null \u0026amp;\u0026amp; !v.connection.ControlPath.First.end.isHome)\n\t\t\t\t{\n\t\t\t\t\tVessel endVessel = CommHandlerCommNetBase.CommNodeToVessel(v.Connection.ControlPath.First.end);\n\t\t\t\t\tvesselList.Add(endVessel);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCommPath path = null;\n\t\t\tforeach (Vessel v in FlightGlobals.Vessels)\n\t\t\t{\n\t\t\t\tif (v.connection != null \u0026amp;\u0026amp; !vesselList.Contains(v))\n\t\t\t\t{\n\t\t\t\t\tpath = v.connection.ControlPath;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vector3\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E points = new List\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vector3\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E();\n\n\t\t\tpath.GetPoints(points, true);\n\n\t\t\tScaledSpace.LocalToScaledSpace(points);\n\n\t\t\tCreateLine(ref line, points);\n\n\t\t\tline.SetColor(Color.Lerp(new Color(0f, 1f, 1f), Color.clear, 0.3f));\n\n\t\t\tif (MapView.Draw3DLines)\n\t\t\t{\n\t\t\t\tline.SetWidth(lineWidth3D);\n\t\t\t\tline.Draw3D();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tline.SetWidth(lineWidth2D = 1f);\n\t\t\t\tline.Draw();\n\t\t\t}\n\t\t}\n\t}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222023-06-27T17:17:09Z\u0022 title=\u002206/27/2023 05:17  PM\u0022 data-short=\u00221 yr\u0022\u003EJune 27, 2023\u003C/time\u003E by alexalex\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"alexalex","CreatedById":224261,"CreatedDateTime":"2023-06-28T16:05:17Z","Content":"\n\u003Cp\u003E\nUpdate :\u00A0 Looking further at it appears that whenever the camera position moves the line lags behind where it should be, and the jitter is it jumping ahead and trying to catch up to where it should be, instead of it being fixed to the vessel coordinates and moving smoothly with them.\u00A0 Then when I stop moving the camera it catches up which is why there is no jitter then.\u00A0 But I still don\u0027t know what is causing it.\n\u003C/p\u003E\n"},{"CreatedByName":"alexalex","CreatedById":224261,"CreatedDateTime":"2023-07-09T21:23:11Z","Content":"\n\u003Cp\u003E\nUpdate : Nothing I tried was able to solve the issue directly since it just seems to be hard baked into the KSP code.\u00A0 The only way I found around it was to either override the UpdateDisplay() method of CommNetUI, or joyride on top of it at runtime which is what I ended up doing, since that allowed me to code out a mod conflict.\u00A0 On the plus side I think I\u0027m getting close to being able to release something.\u00A0 For posterity here is the code I ended up using.\u00A0 Now compare this to the *short* class I initially wrote above...\u003Cspan\u003E \u003C/span\u003E\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\u003Cspan class=\u0022pln\u0022\u003E[HarmonyPatch]\n\tpublic static class CommNetPatch\n\t{\n\t\tprivate static CommViewer commViewer;\n\n\t\t// prefix patch method\n\t\t[HarmonyPrefix]\n\t\tpublic static void PreFix()\n\t\t{\n\t\t\tif (commViewer == null)\n\t\t\t{\n\t\t\t\tcommViewer = new CommViewer();\n\t\t\t}\n\n\t\t\tcommViewer.LineDisplay();\n\t\t}\n\n\t\t// target method that determines which method to patch\n\t\t[HarmonyTargetMethod]\n\t\tpublic static MethodBase TargetingMethod()\n\t\t{\n\t\t\t// conditional that checks if the CommNetConstellation mod is present\n\t\t\tbool hasCNC = false;\n\n\t\t\tforeach (var a in AssemblyLoader.loadedAssemblies)\n\t\t\t{\n\t\t\t\tif (a.name == \u0022CommNetConstellation\u0022) // check for CNC\n\t\t\t\t{\n\t\t\t\t\thasCNC = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// returns the appropriate method to patch depending on if CommNetConstellation is present\n\t\t\tif (hasCNC)\n\t\t\t{\n\t\t\t\treturn AccessTools.Method(Type.GetType(\u0022CommNetConstellation.CommNetLayer.CNCCommNetUI, CommNetConstellation\u0022), \u0022UpdateDisplay\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn AccessTools.Method(typeof(CommNetUI), \u0022UpdateDisplay\u0022);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic class CommViewer : MonoBehaviour\n\t{\n\t\tpublic void LineDisplay()\n\t\t{\n\t\t\t// destroy the old gameobject to delete existing lines so their positions can be refreshed\n\t\t\tGameObject oldLineObject = GameObject.Find(\u0022CommViewerLine\u0022);\n\n\t\t\tif (oldLineObject != null)\n\t\t\t{\n\t\t\t\tDestroy(oldLineObject);\n\t\t\t}\n\n\t\t\tif (Monitor.commStatus != \u0022\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;b\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E \u0026lt;\u0026lt;  Available Bandwidth  \u0026gt;\u0026gt; \u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;/b\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\u0022)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// create a list of commlinks removing any duplicates\n\t\t\tHashSet\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;CommLink\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E uniqueLinks = new HashSet\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;CommLink\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E(new PrecisePositionComparer());\n\n\t\t\tforeach (Vessel v in FlightGlobals.Vessels)\n\t\t\t{\n\t\t\t\tif (v.connection != null)\n\t\t\t\t{\n\t\t\t\t\tforeach (CommLink link in v.connection.ControlPath)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!uniqueLinks.Contains(link))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuniqueLinks.Add(link);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// iterate over the commlink list and store the vessel coordinates as well as startVessel in a new list via a tuple\n\t\t\tList\u0026lt;Tuple\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVessel\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\u0026gt; linePositions = new List\u0026lt;Tuple\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVessel\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\u0026gt;();\n\n\t\t\tforeach (CommLink link in uniqueLinks)\n\t\t\t{\n\t\t\t\tVessel startVessel = CommHandlerCommNetBase.CommNodeToVessel(link.start);\n\t\t\t\tVector3d start = ScaledSpace.LocalToScaledSpace(startVessel.GetWorldPos3D());\n\n\t\t\t\tVessel endVessel = CommHandlerCommNetBase.CommNodeToVessel(link.end);\n\n\t\t\t\tVector3d end;\n\t\t\t\tif (!link.end.isHome)\n\t\t\t\t{\n\t\t\t\t\tend = ScaledSpace.LocalToScaledSpace(endVessel.GetWorldPos3D());\n\t\t\t\t}\n\t\t\t\telse end = ScaledSpace.LocalToScaledSpace(link.end.precisePosition); // this only updates once per second so where possible use GetWorldPos3D() instead\n\n\t\t\t\t// create a new tuple containing the start and end vector3 coordinates and startVessel\n\t\t\t\tTuple\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVessel\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E lineSegment = new Tuple\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVessel\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E(start, end, startVessel);\n\n\t\t\t\t// add the tuple to the list\n\t\t\t\tlinePositions.Add(lineSegment);\n\t\t\t}\n\n\t\t\t// create a parent GameObject for the lines\n\t\t\tGameObject lineObject = new GameObject(\u0022CommViewerLine\u0022);\n\t\t\tUnityEngine.LineRenderer line = lineObject.AddComponent\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;UnityEngine.LineRenderer\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E();\n\n\t\t\t// use a foreach loop to iterate over the list and create a child LineRenderer for each pair of coordinates\n\t\t\tforeach (Tuple\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;Vector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVector3\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E, \u003C/span\u003E\u003Cspan class=\u0022atn\u0022\u003EVessel\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E tuple in linePositions)\n\t\t\t{\n\t\t\t\tGameObject childLineObject = new GameObject(\u0022ChildLine\u0022);\n\t\t\t\tchildLineObject.transform.parent = lineObject.transform;\n\t\t\t\tUnityEngine.LineRenderer childLine = childLineObject.AddComponent\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;UnityEngine.LineRenderer\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E();\n\n\t\t\t\t// set the start and end positions of the line using tuple.Item1 and tuple.Item2\n\t\t\t\tchildLine.positionCount = 2;\n\t\t\t\tchildLine.SetPositions(new Vector3[] { tuple.Item1, tuple.Item2 });\n\n\t\t\t\tCamera cam = PlanetariumCamera.Camera;\n\t\t\t\tVector3d cam3d = cam.transform.position;\n\n\t\t\t\tfloat start = (float)Vector3d.Distance(cam3d, childLine.GetPosition(0));\n\t\t\t\tfloat end = (float)Vector3d.Distance(cam3d, childLine.GetPosition(1));\n\n\t\t\t\t// set the line width so it scales properly with zoom level\n\t\t\t\tchildLine.startWidth = start * 5 / 1000;\n\t\t\t\tchildLine.endWidth = end * 5 / 1000;\n\n\t\t\t\tchildLine.material = CommNetUI.TelemetryMaterial;\n\t\t\t\tchildLine.material.SetTexture(\u0022lineTex\u0022, CommNetUI.TelemetryTexture);\n\n\t\t\t\t// Use tuple.Item3 to access the startVessel so we can make the line color vary with signal strength\n\t\t\t\tVessel startVessel = tuple.Item3;\n\t\t\t\tfloat signalStrength = (float)startVessel.KerbalismData().Connection.strength;\n\n\t\t\t\t(Color startColor, Color endColor) = MixColors(signalStrength);\n\n\t\t\t\t// now make the line nice and pretty\n\t\t\t\tSetColorGradient(childLine, startColor, endColor);\n\n\t\t\t\tif (MapView.Draw3DLines)\n\t\t\t\t{\n\t\t\t\t\tchildLine.gameObject.layer = 31;\n\t\t\t\t\tchildLine.useWorldSpace = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchildLine.gameObject.layer = 10;\n\t\t\t\t\tchildLine.useWorldSpace = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic (Color, Color) MixColors(float percentage)\n\t\t{\n\t\t\t// define the two pairs of colors to mix\n\t\t\tColor color1a = Color.Lerp(new Color(0f, 1f, 0f, 1f), Color.clear, 0.3f);\n\t\t\tColor color1b = Color.Lerp(new Color(1f, 0f, 0f, 1f), Color.clear, 0.3f);\n\n\t\t\tColor color2a = Color.Lerp(new Color(0.004f, 0.196f, 0.125f), Color.clear, 0.3f);\n\t\t\tColor color2b = Color.Lerp(new Color(0.310f, 0f, 0f, 1f), Color.clear, 0.3f);\n\n\t\t\t// calculate the percentage for the other color\n\t\t\tfloat otherPercentage = 1f - percentage;\n\n\t\t\t// mix the first pair of colors using the percentage and its complement\n\t\t\tColor mixedColor1 = color1a * percentage \u002B color1b * otherPercentage;\n\n\t\t\t// mix the second pair of colors using the same percentage and its complement\n\t\t\tColor mixedColor2 = color2a * percentage \u002B color2b * otherPercentage;\n\n\t\t\t// return the two mixed colors\n\t\t\treturn (mixedColor1, mixedColor2);\n\t\t}\n\n\t\tpublic static void SetColorGradient(UnityEngine.LineRenderer childLine, Color startColor, Color endColor, float startAlpha = 1, float endAlpha = 1)\n\t\t{\n\t\t\tGradient gradient = new Gradient();\n\t\t\tgradient.SetKeys(\n\t\t\t\tnew GradientColorKey[] { new GradientColorKey(startColor, 0.0f), new GradientColorKey(endColor, 1.0f) },\n\t\t\t\tnew GradientAlphaKey[] { new GradientAlphaKey(startAlpha, 0.0f), new GradientAlphaKey(endAlpha, 1.0f) }\n\t\t\t);\n\t\t\tchildLine.colorGradient = gradient;\n\t\t}\n\t}\n\n\tclass PrecisePositionComparer : IEqualityComparer\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;CommLink\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E\n\t{\n\t\tpublic bool Equals(CommLink x, CommLink y)\n\t\t{\n\t\t\t// Check if x and y are null\n\t\t\tif (x == null \u0026amp;\u0026amp; y == null)\n\t\t\t\treturn true;\n\t\t\tif (x == null || y == null)\n\t\t\t\treturn false;\n\n\t\t\t// compare the start and end precise positions of x and y\n\t\t\treturn x.a.precisePosition == y.a.precisePosition \u0026amp;\u0026amp; x.b.precisePosition == y.b.precisePosition;\n\t\t}\n\n\t\tpublic int GetHashCode(CommLink obj)\n\t\t{\n\t\t\t// return a hash code based on the precise positions of obj\n\t\t\treturn obj.a.precisePosition.GetHashCode() ^ obj.b.precisePosition.GetHashCode();\n\t\t}\n\t}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"}]}