{"TopicId":170442,"ForumId":29,"TopicTitle":"Documentation for the KerbalFSM state machine (help needed)","CreatedByName":"linuxgurugamer","CreatedById":129964,"CreatedDateTime":"2018-02-03T14:46:46Z","PageNum":1,"Articles":[{"CreatedByName":"linuxgurugamer","CreatedById":129964,"CreatedDateTime":"2018-02-03T14:46:46Z","Content":"\n\u003Cp\u003E\nThe api available here:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Ca href=\u0022https://kerbalspaceprogram.com/api/class_kerbal_f_s_m.html\u0022 rel=\u0022\u0022\u003Ehttps://kerbalspaceprogram.com/api/class_kerbal_f_s_m.html\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nsimply documents the methods, but there is no real explanation for this.\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027ve searched the forums, but while it is referenced in many places, it is not explained.\u00A0 Apparently it was written back for 0.16 by \u003Ca contenteditable=\u0022false\u0022 data-ipshover=\u0022\u0022 data-ipshover-target=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/4-harvester/\u0026amp;do=hovercard\u0022 data-mentionid=\u00224\u0022 href=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/4-harvester/\u0022 rel=\u0022\u0022\u003E@HarvesteR\u003C/a\u003E, the earliest mention of this was found in a Devnote Tuesday back in 2014 here:\u00A0\u00A0\n\u003C/p\u003E\n\u003Ciframe allowfullscreen=\u0022\u0022 data-controller=\u0022core.front.core.autosizeiframe\u0022 data-embedcontent=\u0022\u0022 data-embedid=\u0022embed7334541768\u0022 scrolling=\u0022no\u0022 src=\u0022https://forum.kerbalspaceprogram.com/index.php?/topic/88161-devnote-tuesdays-the-kspumpkin-edition/\u0026amp;tab=comments\u0026amp;do=embed\u0026amp;comment=1480845\u0026amp;embedComment=1480845\u0026amp;embedDo=findComment#comment-1480845\u0022 style=\u0022height:315px;max-width:502px;\u0022\u003E\u003C/iframe\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nBesides the fact that I may be able to use this for new mods, I\u0027m now trying to understand how it works in a reverse-engineering way on a mod I\u0027m maintaining (NASA Countdown Clock).\n\u003C/p\u003E\n\u003Cp\u003E\nSo, I\u0027m going to attempt to write my own documentation here.\u00A0 I will incorporate any corrections or additions into the \u003Cabbr title=\u00221. Original Post(er). The first post in a thread, or the person who posted it. 2. Overpowered. A part or mechanic that upsets game balance by being too powerful.\u0022\u003EOP\u003C/abbr\u003E to try to keep a single point for reference.\u00A0 This will by necessity also include documentation on\u00A0\u00A0\u003Cstrong\u003EKFSMState\u00A0\u003C/strong\u003Eand\u00A0\u003Cstrong\u003EKFSMEvent.\u00A0 \u003C/strong\u003ESome will be redundant since I will be copying portions of the public API\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cstrong\u003E=================\u003C/strong\u003E\n\u003C/p\u003E\n\u003Cp\u003E\nThe state machine available for KSP is called \u003Ca href=\u0022https://kerbalspaceprogram.com/api/class_kerbal_f_s_m.html\u0022 rel=\u0022\u0022\u003EKerbalFSM\u003C/a\u003E.\u00A0 Two classes which it needs are \u003Ca href=\u0022https://kerbalspaceprogram.com/api/class_k_f_s_m_state.html\u0022 rel=\u0022\u0022\u003EKFSMState\u003C/a\u003E and \u003Ca href=\u0022https://kerbalspaceprogram.com/api/class_k_f_s_m_event.html\u0022 rel=\u0022\u0022\u003EKFSMEvent\u003C/a\u003E.\u00A0\n\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003E\n\u003Cstrong\u003EKerbalFSM \u003C/strong\u003Eis the main class for the state machine, essentially this is the controller\n\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EKFSMState \u003C/strong\u003Econtains information related to a specific state of the machine, such as what events will activate the state\n\u003C/li\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EKFSMEvent\u003C/strong\u003E contains information related to a specific event.\n\u003C/li\u003E\n\u003C/ul\u003E\u003Cp\u003E\nThe flow of events appears to be:\n\u003C/p\u003E\n\u003Col\u003E\u003Cli\u003E\nCreate state machine (KerbalFSM)\n\u003C/li\u003E\n\u003Cli\u003E\nCreate various states which will be added to the state machine\n\u003C/li\u003E\n\u003Cli\u003E\nFor each state, create events which are added to the state\n\u003C/li\u003E\n\u003Cli\u003E\nFinally, add the states to the state machine.\n\u003C/li\u003E\n\u003C/ol\u003E\u003Cp\u003E\nI\u0027ve included some code in the spoiler which summarize the above points:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\u003C/p\u003E\n\u003Cdiv\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\n\u003Cspan class=\u0022pln\u0022\u003E// Create the state machine\nprivate KerbalFsmEx _machine = new KerbalFsmEx();\n\n// Create States (the classes derive from KFSMState)\n\nInitialState initial = new InitialState(\u0022Init\u0022, _machine);\nSettingState settings = new SettingState(\u0022Settings\u0022, _machine);\nSequenceState sequence = new SequenceState(\u0022Sequence\u0022, _machine);\nKFSMState finish = new KFSMState(\u0022Finish\u0022);\n\n// Define some local events and add to the states \n\nvar go2Settings = new KFSMEvent(\u0022Settings\u0022) { GoToStateOnEvent = settings, updateMode = KFSMUpdateMode.MANUAL_TRIGGER };\ninitial.AddEvent(go2Settings);\n\nvar go2Init = new KFSMEvent(\u0022Init\u0022) { GoToStateOnEvent = initial, updateMode = KFSMUpdateMode.MANUAL_TRIGGER };\nsettings.AddEvent(go2Init);\nsequence.AddEvent(go2Init);\nfinish.AddEvent(go2Init);\n\n// Add states to the state machine\n\n_machine.AddState(initial);\n_machine.AddState(settings);\n_machine.AddState(sequence);\n_machine.AddState(launch);\n_machine.AddState(finish);\u003C/span\u003E\u003C/pre\u003E\n\u003Cspan style=\u0022background:rgba(220,220,220,.5) url(\u0026quot;//forum.kerbalspaceprogram.com/applications/core/interface/ckeditor/ckeditor/plugins/widget/images/handle.png\u0026quot;);\u0022\u003E\u003C/span\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u003C/p\u003E\n\u003Cbr\u003E\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nNow it gets a bit hazy...\n\u003C/p\u003E\n\u003Cp\u003E\nThe state machine needs to be started using the StartFSM method.\u00A0 There are two ways of calling:\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003Epublic void StartFSM(KFSMState initialState);\npublic void StartFSM(string initialStateName);\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nThe first starts the machine by passing in the method of the initial state.\n\u003C/p\u003E\n\u003Cp\u003E\nThe second starts the machine by passing in the name of the initial state.\n\u003C/p\u003E\n\u003Cp\u003E\nWhile the state machine defines methods for FixedUpdateFSM, LateUpdateFSM, and UpdateFSM, it doesn\u0027t call those itself, so you need to write the code for that, such as the following:\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\n\u003Cspan class=\u0022pln\u0022\u003Epublic void FixedUpdate()\n{\n\tif (_machine.Started)\n\t\t_machine.FixedUpdateFSM();\n}\n\npublic void Update()\n{\n\tif (_machine.Started)\n\t\t_machine.UpdateFSM();\n}\n\npublic void LateUpdate()\n{\n\tif (_machine.Started)\n\t\t_machine.LateUpdateFSM();\n}\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"Benjamin Kerman","CreatedById":172792,"CreatedDateTime":"2018-02-03T19:59:01Z","Content":"\n\u003Cp\u003E\nI checked the Community KSP API docs at\u00A0\u003Ca href=\u0022http://kspapi.forwoods.org/#/classes/KerbalFSM\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://kspapi.forwoods.org/#/classes/KerbalFSM\u003C/a\u003E, seems that there is a bit more of an explaination there.\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"DMagic","CreatedById":57416,"CreatedDateTime":"2018-02-03T22:27:48Z","Content":"\n\u003Cp\u003E\nA good example of how an FSM works in game is the docking ports. They set their behavior using a KerbalFSM and different KFSMStates and KFSMEvents, with each state identifiable by a string.\n\u003C/p\u003E\n\u003Cp\u003E\nI spent a long time digging into this while making my flexible docking ports mod, though it basically just works on top of the FSM:\u00A0\u003Ca href=\u0022https://github.com/DMagic1/KSP_Flexible_Docking/blob/master/Source/FlexoTube.cs#L304-L351\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://github.com/DMagic1/KSP_Flexible_Docking/blob/master/Source/FlexoTube.cs#L304-L351\u003C/a\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nEach state for the docking port would just define its behavior in the FixedUpdateFSM method. So when it\u0027s in the \u0022ready\u0022 state then it cycles through all of the docking ports in the scene checking if they are within distance, the right size, etc...\n\u003C/p\u003E\n\u003Cp\u003E\nThen when it finds a suitable matching port it changes (using a KFSMEvent, I assume) to the \u0022acquiring\u0022 state (the dominant port is chosen based on vessel mass; I\u0027m not sure how it chooses if they are the same mass), where it applies a force to bring the vessels together and makes another distance check (and other checks for rotation, alignment, etc...). Then it can switch to the \u0022docked\u0022 state.\n\u003C/p\u003E\n\u003Cp\u003E\nIt also uses the state to set the part\u0027s menu UI. Whenever it changes state it resets the part menu,\u00A0so that you get the different buttons like undock, or decouple (or whatever it says) when the port is in the \u0022PreAttached\u0022 state, when a port is connected to something in the editor.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nSo rather than having a horribly convoluted FixedUpdate method, the docking ports just set up the FSM when it starts. Then each behavior is its own contained component, which makes it easier to manage, and change or add new behaviors.\n\u003C/p\u003E\n"}]}