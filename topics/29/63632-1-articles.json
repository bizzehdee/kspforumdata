{"TopicId":63632,"ForumId":29,"TopicTitle":"Partless plugin with 3D mesh in map view","CreatedByName":"kubi","CreatedById":103032,"CreatedDateTime":"2014-02-18T22:43:55Z","PageNum":1,"Articles":[{"CreatedByName":"kubi","CreatedById":103032,"CreatedDateTime":"2014-02-18T22:43:55Z","Content":"\n\u003Cp\u003EHi,\u003C/p\u003E\u003Cp\u003EI\u0027m working on a simple plugin that should display a triangle at the selected celestial body in map (tracking station) view.\u003C/p\u003E\u003Cp\u003EI think I\u0027m OK with the Start(), Awake() and Update() callbacks, but the mesh is not displayed.\u003C/p\u003E\u003Cp\u003ECould anyone comment?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing System.Threading.Tasks;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003Enamespace KspCelestialOverlay\u003Cbr\u003E{\u003Cbr\u003E    [KSPAddon(KSPAddon.Startup.EveryScene, false)]\u003Cbr\u003E    internal class KspCelestialOverlay : MonoBehaviour\u003Cbr\u003E    {\u003Cbr\u003E        public const int GridLevel = 5;\u003Cbr\u003E\u003Cbr\u003E        public static KspCelestialOverlay Instance { get; private set; }\u003Cbr\u003E\u003Cbr\u003E        private CelestialBody body;\u003Cbr\u003E        private Mesh mesh;\u003Cbr\u003E        private static RenderingManager renderingManager;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        public void Awake()\u003Cbr\u003E        {\u003Cbr\u003E            var scene = HighLogic.LoadedScene;\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Awake scene=\u0022 \u002B scene.ToString() \u002B \u0022 \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E            // we do it in the trackstation only\u003Cbr\u003E            if (scene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Awake disabling\u0022);\u003Cbr\u003E                enabled = false;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // called only is enabled == true\u003Cbr\u003E        public void Start()\u003Cbr\u003E        {\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Start \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E\u003Cbr\u003E            if (Instance != null) Destroy(Instance.gameObject);\u003Cbr\u003E            Instance = this;\u003Cbr\u003E\u003Cbr\u003E            if (HighLogic.LoadedScene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Start not in trackstation wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            mesh = gameObject.AddComponent\u0026lt;MeshFilter\u0026gt;().mesh;\u003Cbr\u003E            var renderer = gameObject.AddComponent\u0026lt;MeshRenderer\u0026gt;();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Update()\u003Cbr\u003E        {\u003Cbr\u003E            if (HighLogic.LoadedScene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update not in trackstation wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E            if (!MapView.MapIsEnabled || MapView.MapCamera == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update mapviewproblem\u0022);\u003Cbr\u003E                gameObject.renderer.enabled = false;\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E            var target = MapView.MapCamera.target;\u003Cbr\u003E            var newBody = getTargetBody(target);\u003Cbr\u003E            if (newBody == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update newbody==null wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E            // do it once when a body is selected\u003Cbr\u003E            if (newBody != body)\u003Cbr\u003E            {\u003Cbr\u003E                body = newBody;\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update body.name \u0022 \u002B body.name \u002B \u0022 \u0022 \u002B body.Radius.ToString(\u00220.00\u0022));\u003Cbr\u003E\u003Cbr\u003E                Vector3[] vertices = {\u003Cbr\u003E                                     new Vector3(0,0,1),\u003Cbr\u003E                                     new Vector3(0,1,0),\u003Cbr\u003E                                     new Vector3(1,0,0)\u003Cbr\u003E                                 };\u003Cbr\u003E                int[] triangles = { 0, 1, 2 };\u003Cbr\u003E\u003Cbr\u003E                mesh.vertices = vertices;\u003Cbr\u003E                mesh.triangles = triangles;\u003Cbr\u003E                mesh.Optimize();\u003Cbr\u003E                gameObject.layer = 10;\u003Cbr\u003E                gameObject.transform.parent = body.GetTransform();\u003Cbr\u003E                gameObject.transform.localScale = Vector3.one * 2000000f;\u003Cbr\u003E                gameObject.transform.localPosition = Vector3.zero;\u003Cbr\u003E                gameObject.transform.localRotation = Quaternion.identity;\u003Cbr\u003E                gameObject.renderer.enabled = true;\u003Cbr\u003E\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void OnDestroy()\u003Cbr\u003E        {\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Ondestroy \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        private static CelestialBody getTargetBody(MapObject target)\u003Cbr\u003E        {\u003Cbr\u003E            if (target == null) return null;\u003Cbr\u003E            switch (target.type)\u003Cbr\u003E            {\u003Cbr\u003E                case MapObject.MapObjectType.CELESTIALBODY:\u003Cbr\u003E                    return target.celestialBody;\u003Cbr\u003E                case MapObject.MapObjectType.MANEUVERNODE:\u003Cbr\u003E                    return target.maneuverNode.patch.referenceBody;\u003Cbr\u003E                case MapObject.MapObjectType.VESSEL:\u003Cbr\u003E                    return target.vessel.mainBody;\u003Cbr\u003E                default:\u003Cbr\u003E                    return null;\u003Cbr\u003E            }\u003Cbr\u003E        }    \u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"kubi","CreatedById":103032,"CreatedDateTime":"2014-02-19T01:37:59Z","Content":"\n\u003Cp\u003EInstead of \u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EgameObject.transform.parent = body.GetTransform();\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EgameObject.transform.parent = ScaledSpace.Instance.scaledSpaceTransforms.Single(t =\u0026gt; t.name == body.name);\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Esolved the issue.\u003C/p\u003E\n"},{"CreatedByName":"kubi","CreatedById":103032,"CreatedDateTime":"2014-02-19T18:30:46Z","Content":"\n\u003Cp\u003EThe saga continues. Now with a sphere...\u003C/p\u003E\u003Cp\u003EWhy doesn\u0027t it appear?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003Enamespace KspCelestialOverlay\u003Cbr\u003E{\u003Cbr\u003E    [KSPAddon(KSPAddon.Startup.EveryScene, false)]\u003Cbr\u003E    internal class KspCelestialOverlay : MonoBehaviour\u003Cbr\u003E    {\u003Cbr\u003E        public const int GridLevel = 5;\u003Cbr\u003E\u003Cbr\u003E        public static KspCelestialOverlay Instance { get; private set; }\u003Cbr\u003E\u003Cbr\u003E        private CelestialBody body;\u003Cbr\u003E        private Mesh mesh;\u003Cbr\u003E\u003Cbr\u003E        static GameObject sphere = null;\u003Cbr\u003E\u003Cbr\u003E        public void Awake()\u003Cbr\u003E        {\u003Cbr\u003E            var scene = HighLogic.LoadedScene;\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Awake scene=\u0022 \u002B scene.ToString() \u002B \u0022 \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E            // we do it in the trackstation only\u003Cbr\u003E            if (scene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Awake disabling\u0022);\u003Cbr\u003E                enabled = false;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // called only is enabled == true\u003Cbr\u003E        public void Start()\u003Cbr\u003E        {\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Start \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E\u003Cbr\u003E            if (Instance != null) Destroy(Instance.gameObject);\u003Cbr\u003E            Instance = this;\u003Cbr\u003E\u003Cbr\u003E            if (HighLogic.LoadedScene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Start not in trackstation wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E/*\u003Cbr\u003E            mesh = gameObject.AddComponent\u0026lt;MeshFilter\u0026gt;().mesh;\u003Cbr\u003E            var renderer = gameObject.AddComponent\u0026lt;MeshRenderer\u0026gt;();\u003Cbr\u003E */ \u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Start2 \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E\u003Cbr\u003E            if (sphere == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay createsphere \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E                sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);\u003Cbr\u003E                sphere.collider.enabled = false;\u003Cbr\u003E                Destroy(sphere.collider);\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Update()\u003Cbr\u003E        {\u003Cbr\u003E\u003Cbr\u003E            if (HighLogic.LoadedScene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update not in trackstation wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E            if (!MapView.MapIsEnabled || MapView.MapCamera == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update mapviewproblem\u0022);\u003Cbr\u003E                gameObject.renderer.enabled = false;\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            var target = MapView.MapCamera.target;\u003Cbr\u003E            var newBody = getTargetBody(target);\u003Cbr\u003E            if (newBody == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update newbody==null wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            // do it once when a body is selected\u003Cbr\u003E            if (newBody != body)\u003Cbr\u003E            {\u003Cbr\u003E                body = newBody;\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update body.name \u0022 \u002B body.name \u002B \u0022 \u0022 \u002B body.Radius.ToString(\u00220.00\u0022));\u003Cbr\u003E/*\u003Cbr\u003E                Vector3[] vertices = {\u003Cbr\u003E                                     new Vector3(0,0,0),\u003Cbr\u003E                                     new Vector3(0,0,1),\u003Cbr\u003E                                     new Vector3(0,1,0),\u003Cbr\u003E                                     new Vector3(1,0,0)\u003Cbr\u003E                                 };\u003Cbr\u003E                int[] triangles = { 1,3,2, 0,1,2, 0,1,3, 0,2,3 };\u003Cbr\u003E\u003Cbr\u003E                mesh.vertices = vertices;\u003Cbr\u003E                mesh.triangles = triangles;\u003Cbr\u003E                mesh.Optimize();\u003Cbr\u003E\u003Cbr\u003E                gameObject.layer = 10;\u003Cbr\u003E                gameObject.transform.parent = ScaledSpace.Instance.scaledSpaceTransforms.Single(t =\u0026gt; t.name == body.name);\u003Cbr\u003E                gameObject.transform.localScale = Vector3.one * 2025f;\u003Cbr\u003E                gameObject.transform.localPosition = Vector3.zero;\u003Cbr\u003E                gameObject.transform.localRotation = Quaternion.identity;\u003Cbr\u003E                gameObject.renderer.enabled = true;\u003Cbr\u003E                gameObject.renderer.castShadows = false;\u003Cbr\u003E                gameObject.renderer.receiveShadows = false;\u003Cbr\u003E                gameObject.renderer.material.color = Color.green;\u003Cbr\u003E*/\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                sphere.layer = 10;\u003Cbr\u003E                sphere.transform.parent = ScaledSpace.Instance.scaledSpaceTransforms.Single(t =\u0026gt; t.name == body.name);\u003Cbr\u003E                sphere.transform.localScale = Vector3.one * 1500f;\u003Cbr\u003E                sphere.transform.localPosition = Vector3.zero;\u003Cbr\u003E                sphere.transform.localRotation = Quaternion.identity;\u003Cbr\u003E                sphere.renderer.enabled = true;\u003Cbr\u003E                sphere.renderer.castShadows = false;\u003Cbr\u003E                sphere.renderer.receiveShadows = false;\u003Cbr\u003E                sphere.renderer.material.color = Color.red;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void OnDestroy()\u003Cbr\u003E        {\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Ondestroy \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        private static CelestialBody getTargetBody(MapObject target)\u003Cbr\u003E        {\u003Cbr\u003E            if (target == null) return null;\u003Cbr\u003E            switch (target.type)\u003Cbr\u003E            {\u003Cbr\u003E                case MapObject.MapObjectType.CELESTIALBODY:\u003Cbr\u003E                    return target.celestialBody;\u003Cbr\u003E                case MapObject.MapObjectType.MANEUVERNODE:\u003Cbr\u003E                    return target.maneuverNode.patch.referenceBody;\u003Cbr\u003E                case MapObject.MapObjectType.VESSEL:\u003Cbr\u003E                    return target.vessel.mainBody;\u003Cbr\u003E                default:\u003Cbr\u003E                    return null;\u003Cbr\u003E            }\u003Cbr\u003E        }    \u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-02-19T18:40:04Z\u0022 title=\u002202/19/2014 06:40  PM\u0022 data-short=\u002210 yr\u0022\u003EFebruary 19, 2014\u003C/time\u003E by kubi\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2014-02-20T18:15:39Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022kubi\u0022 data-cite=\u0022kubi\u0022\u003E\u003Cdiv\u003EThe saga continues. Now with a sphere...\u003Cp\u003EWhy doesn\u0027t it appear?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003Enamespace KspCelestialOverlay\u003Cbr\u003E{\u003Cbr\u003E    [KSPAddon(KSPAddon.Startup.EveryScene, false)]\u003Cbr\u003E    internal class KspCelestialOverlay : MonoBehaviour\u003Cbr\u003E    {\u003Cbr\u003E        public const int GridLevel = 5;\u003Cbr\u003E\u003Cbr\u003E        public static KspCelestialOverlay Instance { get; private set; }\u003Cbr\u003E\u003Cbr\u003E        private CelestialBody body;\u003Cbr\u003E        private Mesh mesh;\u003Cbr\u003E\u003Cbr\u003E        static GameObject sphere = null;\u003Cbr\u003E\u003Cbr\u003E        public void Awake()\u003Cbr\u003E        {\u003Cbr\u003E            var scene = HighLogic.LoadedScene;\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Awake scene=\u0022 \u002B scene.ToString() \u002B \u0022 \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E            // we do it in the trackstation only\u003Cbr\u003E            if (scene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Awake disabling\u0022);\u003Cbr\u003E                enabled = false;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // called only is enabled == true\u003Cbr\u003E        public void Start()\u003Cbr\u003E        {\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Start \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E\u003Cbr\u003E            if (Instance != null) Destroy(Instance.gameObject);\u003Cbr\u003E            Instance = this;\u003Cbr\u003E\u003Cbr\u003E            if (HighLogic.LoadedScene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Start not in trackstation wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E/*\u003Cbr\u003E            mesh = gameObject.AddComponent\u0026lt;MeshFilter\u0026gt;().mesh;\u003Cbr\u003E            var renderer = gameObject.AddComponent\u0026lt;MeshRenderer\u0026gt;();\u003Cbr\u003E */ \u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Start2 \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E\u003Cbr\u003E            if (sphere == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay createsphere \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E                sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);\u003Cbr\u003E                sphere.collider.enabled = false;\u003Cbr\u003E                Destroy(sphere.collider);\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Update()\u003Cbr\u003E        {\u003Cbr\u003E\u003Cbr\u003E            if (HighLogic.LoadedScene != GameScenes.TRACKSTATION)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update not in trackstation wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E            if (!MapView.MapIsEnabled || MapView.MapCamera == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update mapviewproblem\u0022);\u003Cbr\u003E                gameObject.renderer.enabled = false;\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            var target = MapView.MapCamera.target;\u003Cbr\u003E            var newBody = getTargetBody(target);\u003Cbr\u003E            if (newBody == null)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update newbody==null wtf?!\u0022);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            // do it once when a body is selected\u003Cbr\u003E            if (newBody != body)\u003Cbr\u003E            {\u003Cbr\u003E                body = newBody;\u003Cbr\u003E                Debug.LogError(\u0022KspCelestialOverlay Update body.name \u0022 \u002B body.name \u002B \u0022 \u0022 \u002B body.Radius.ToString(\u00220.00\u0022));\u003Cbr\u003E/*\u003Cbr\u003E                Vector3[] vertices = {\u003Cbr\u003E                                     new Vector3(0,0,0),\u003Cbr\u003E                                     new Vector3(0,0,1),\u003Cbr\u003E                                     new Vector3(0,1,0),\u003Cbr\u003E                                     new Vector3(1,0,0)\u003Cbr\u003E                                 };\u003Cbr\u003E                int[] triangles = { 1,3,2, 0,1,2, 0,1,3, 0,2,3 };\u003Cbr\u003E\u003Cbr\u003E                mesh.vertices = vertices;\u003Cbr\u003E                mesh.triangles = triangles;\u003Cbr\u003E                mesh.Optimize();\u003Cbr\u003E\u003Cbr\u003E                gameObject.layer = 10;\u003Cbr\u003E                gameObject.transform.parent = ScaledSpace.Instance.scaledSpaceTransforms.Single(t =\u0026gt; t.name == body.name);\u003Cbr\u003E                gameObject.transform.localScale = Vector3.one * 2025f;\u003Cbr\u003E                gameObject.transform.localPosition = Vector3.zero;\u003Cbr\u003E                gameObject.transform.localRotation = Quaternion.identity;\u003Cbr\u003E                gameObject.renderer.enabled = true;\u003Cbr\u003E                gameObject.renderer.castShadows = false;\u003Cbr\u003E                gameObject.renderer.receiveShadows = false;\u003Cbr\u003E                gameObject.renderer.material.color = Color.green;\u003Cbr\u003E*/\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                sphere.layer = 10;\u003Cbr\u003E                sphere.transform.parent = ScaledSpace.Instance.scaledSpaceTransforms.Single(t =\u0026gt; t.name == body.name);\u003Cbr\u003E                sphere.transform.localScale = Vector3.one * 1500f;\u003Cbr\u003E                sphere.transform.localPosition = Vector3.zero;\u003Cbr\u003E                sphere.transform.localRotation = Quaternion.identity;\u003Cbr\u003E                sphere.renderer.enabled = true;\u003Cbr\u003E                sphere.renderer.castShadows = false;\u003Cbr\u003E                sphere.renderer.receiveShadows = false;\u003Cbr\u003E                sphere.renderer.material.color = Color.red;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void OnDestroy()\u003Cbr\u003E        {\u003Cbr\u003E            Debug.LogError(\u0022KspCelestialOverlay Ondestroy \u0022 \u002B Time.time.ToString(\u00220.0000\u0022));\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        private static CelestialBody getTargetBody(MapObject target)\u003Cbr\u003E        {\u003Cbr\u003E            if (target == null) return null;\u003Cbr\u003E            switch (target.type)\u003Cbr\u003E            {\u003Cbr\u003E                case MapObject.MapObjectType.CELESTIALBODY:\u003Cbr\u003E                    return target.celestialBody;\u003Cbr\u003E                case MapObject.MapObjectType.MANEUVERNODE:\u003Cbr\u003E                    return target.maneuverNode.patch.referenceBody;\u003Cbr\u003E                case MapObject.MapObjectType.VESSEL:\u003Cbr\u003E                    return target.vessel.mainBody;\u003Cbr\u003E                default:\u003Cbr\u003E                    return null;\u003Cbr\u003E            }\u003Cbr\u003E        }    \u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EHmmmm... You sure 1500 is big enough to cover the body (it should, but you can\u0027t be too careful)? You haven\u0027t assigned a material or renderer either. Check your logs. You probably have a few null-reference exceptions from those.\u003C/p\u003E\n"},{"CreatedByName":"kubi","CreatedById":103032,"CreatedDateTime":"2014-02-23T09:25:56Z","Content":"\n\u003Cp\u003EYou are right. 1500 was too small. For the sphere r=0.5, not r=1...\u003C/p\u003E\n"}]}