{"TopicId":72060,"ForumId":29,"TopicTitle":"Scary Reflection stuff when wrapping an implicit operator.","CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-11T13:04:16Z","PageNum":1,"Articles":[{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-11T13:04:16Z","Content":"\n\u003Cp\u003EI am pulling together a relfection wrapper for the CLS mod so that other mods can use it without having a hard dependency on it. I am \u0022been inspired\u0022 by the work blitzy did for wrapping the toolbar mod, but have come upon a problem... (note that I have not executed any of this code yet, so it might all be borked!)\u003C/p\u003E\u003Cp\u003EThe CLS mod defines two implicit operators on the CLSPart class. The idea is that this allows you to cast a CLSPart into a part to get the Part object in question, or cast it to a ModuleConnectedLivingSpace to access the appropriate model. This all works nicely, and PapaJoe has told me that it makes his code nice, which is great.\u003C/p\u003E\u003Cp\u003EAnyhow, I now need to wrap these operators using reflection. So following the toolbar example, I am proving a file of code that defines all the public classes in CLS, and for each of the public methods / properties providing some code that uses reflection to invoke the actual method or property. However I am struggling for the syntax to use for the implicit operator. Here is what I have got so far:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        // Allow a CLSPart to be cast into a Part\u003Cbr\u003E        public static implicit operator Part(CLSPart _p)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSPartType = AssemblyLoader.loadedAssemblies.SelectMany(a =\u0026gt; a.assembly.GetExportedTypes()).SingleOrDefault(t =\u0026gt; t.FullName == \u0022ConnectedLivingSpace.CLSPart\u0022);\u003Cbr\u003E            MethodInfo method = CLSPartType.GetMethod(\u0022op_Implicit\u0022, BindingFlags.Public | BindingFlags.Static);\u003Cbr\u003E            Part retVal = (Part)method.Invoke(null,new object[] { _p });\u003Cbr\u003E            return (retVal);\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis all seems good. However, if I write the same code for the implicit operator that will cast into a ModuleConnectedLivingSpace I get:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E       // Allow a CLSPart to be cast into a ModuleConnectedLivingSpace. \u003Cbr\u003E        public static implicit operator ModuleConnectedLivingSpace(CLSPart _p)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSPartType = AssemblyLoader.loadedAssemblies.SelectMany(a =\u0026gt; a.assembly.GetExportedTypes()).SingleOrDefault(t =\u0026gt; t.FullName == \u0022ConnectedLivingSpace.CLSPart\u0022);\u003Cbr\u003E            MethodInfo method = CLSPartType.GetMethod(\u0022op_Implicit\u0022, BindingFlags.Public | BindingFlags.Static);\u003Cbr\u003E            ModuleConnectedLivingSpace retVal = (ModuleConnectedLivingSpace)method.Invoke(null, new object[] { _p });\u003Cbr\u003E            return (retVal);\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe problem is that this is the identical bit of code apart from the cast in the last line. It seems to me that this can not be correct. How does the code know to invoke the \u0022implicit operator Part\u0022 rather than the \u0022implicit operator ModuleConnectedLivingSpace\u0022? it seems to me that calling GetMethod.(\u0022op_Implicit\u0022, ... ) is not going to specify which of these two casts I am interested in, so there must be a way of distinguishing between then. Does anyone know what it is?\u003C/p\u003E\n"},{"CreatedByName":"blizzy78","CreatedById":68543,"CreatedDateTime":"2014-05-11T13:18:11Z","Content":"\n\u003Cp\u003EPerhaps also try \u0022op_Explicit\u0022? \u003Ca href=\u0022http://bytes.com/topic/c-sharp/answers/903775-getting-operators-using-reflection\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://bytes.com/topic/c-sharp/answers/903775-getting-operators-using-reflection\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EOther than that, I\u0027d try checking the return type of the method, and also if there are multiple methods with the same name.\u003C/p\u003E\u003Cp\u003EThat\u0027s just quick off the top of my head.\u003C/p\u003E\u003Cp\u003EEdit: Also, are you sure this will work at all? You cannot cast into a type that is not known to the assembly where the source object is coming from. Conversely, you can also not cast into a type that is not known to the receiving assembly.\u003C/p\u003E\n"},{"CreatedByName":"Faark","CreatedById":69775,"CreatedDateTime":"2014-05-11T14:16:01Z","Content":"\n\u003Cp\u003EDon\u0027t! I think you are probably choosing a great tool for the wrong task. Reflection-Wrappers are great, if someone using your mod have a soft dependency on your mod. Usually, the main task of such a wrapper is to provide a. version compatible and b. provide a default implementation in case your api isn\u0027t present on that installation. You code above does none of it. It also would horrible in terms of performance if used somewhat more frequently, and implicit operators trend to be used quite often.\u003C/p\u003E\u003Cp\u003EWhat is your primary intention of providing a reflection wrapper?\u003C/p\u003E\u003Cp\u003EBlizzy is right, you would have to provide wrappers for all classes of your assembly. Also only use reflection at initialization, not at call time (for perf). As already mentioned it would make sense to make your methods \u0022transparent\u0022 in case your mod isn\u0027t present, so other mods don\u0027t frequently have to check whether YourWrapper.IsPresent. Thus a default implementations for GetConnectedLivingSpaces(part) might return an empty enumerator...\u003C/p\u003E\u003Cp\u003EFor larger mods it might makes sense to have an \u0022exports.cs\u0022 file, that contains all static methods you use on reflection. This way you won\u0027t accidentally break reflection without getting a compiler warning. And so on... but again first make sure such a wrapper actually gives you a real benefit.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-11T15:17:41Z","Content":"\n\u003Cp\u003EThanks for your reply. Let me take a step back and explain where I have got to, and then perhaps you can suggest a better approach.\u003C/p\u003E\u003Cp\u003ESo I have written a mod called Connected Living Space (CLS) that takes a look at your craft and some config related to the parts and figures out where a kerbals can move internally within the craft. It then generates a set of data that describes this with a view to other mods using it to do whatever they are looking to do. The idea is that there becomes one place to set config describing how kerbals can move within the parts of your new funky part pack, and there is one place you can go to to figure out the answer to questions such as \u0022can a kerbal move from part a to part b without going EVA?\u0022 or \u0022does Bill a have to share a living space with Jeb, and is it slowly driving him insane?\u0022 So far it is starting to work nicely, with players producing config for some of the major part packs and one particular mod (ShipManifest) using it to enhance its crew transfer feature, and interest from other modders as well for using it with their projects.\u003C/p\u003E\u003Cp\u003EHowever the author of Ship Manifest has received lots of hastle from players who are not into CLS saying \u0022why have you broken SM\u0022 and \u0022I do not want to use CLS\u0022 etc etc. At the moment CLS is a hard dependency for Ship Manifest, and whenever I make a new release of CLS and bump up the version number, SM needs to be rebuilt, which leads to more hassle, and incompatibilities etc. The author of Ship Manifest has been amazing patient and helpful, and has been very supportive of CLS, however it seems life would be easier if it was possible to Ship Mnaifest to work one way is CLS is not installed, and use CLS features if it is, without having to explain what CLS is and where the config options are to turn it off to players that simply do not care.\u003C/p\u003E\u003Cp\u003EI thought that the best approach to this problem was to use reflection to write a wrapper around CLS. That way Ship manifest will still work if CLS is not installed. It would also encourage other modders to provide support for CLS if a toolbox style wrapper was available.\u003C/p\u003E\u003Cp\u003EThe issue with implicit operator casts is a consequence of writing a wrapper for all the publicly exposed CLS functionality. It is almost complete and it is just these implicit operator methods left to sort out. I might have written CLS not to provide such implicit type conversions, but it seemed like a nice way of doing things at the time.\u003C/p\u003E\u003Cp\u003ESo what do you think my best way forward is? I feel guilty every time I make a release and PapaJoe catches a load of stick from his user-base over all the dependency issues.\u003C/p\u003E\n"},{"CreatedByName":"Papa_Joe","CreatedById":10788,"CreatedDateTime":"2014-05-11T15:53:27Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022codepoet\u0022 data-cite=\u0022codepoet\u0022\u003E\u003Cdiv\u003EThanks for your reply. Let me take a step back and explain where I have got to, and then perhaps you can suggest a better approach.\u003Cp\u003ESo I have written a mod called Connected Living Space (CLS) that takes a look at your craft and some config related to the parts and figures out where a kerbals can move internally within the craft. It then generates a set of data that describes this with a view to other mods using it to do whatever they are looking to do. The idea is that there becomes one place to set config describing how kerbals can move within the parts of your new funky part pack, and there is one place you can go to to figure out the answer to questions such as \u0022can a kerbal move from part a to part b without going EVA?\u0022 or \u0022does Bill a have to share a living space with Jeb, and is it slowly driving him insane?\u0022 So far it is starting to work nicely, with players producing config for some of the major part packs and one particular mod (ShipManifest) using it to enhance its crew transfer feature, and interest from other modders as well for using it with their projects.\u003C/p\u003E\u003Cp\u003EHowever the author of Ship Manifest has received lots of hastle from players who are not into CLS saying \u0022why have you broken SM\u0022 and \u0022I do not want to use CLS\u0022 etc etc. At the moment CLS is a hard dependency for Ship Manifest, and whenever I make a new release of CLS and bump up the version number, SM needs to be rebuilt, which leads to more hassle, and incompatibilities etc. The author of Ship Manifest has been amazing patient and helpful, and has been very supportive of CLS, however it seems life would be easier if it was possible to Ship Mnaifest to work one way is CLS is not installed, and use CLS features if it is, without having to explain what CLS is and where the config options are to turn it off to players that simply do not care.\u003C/p\u003E\u003Cp\u003EI thought that the best approach to this problem was to use reflection to write a wrapper around CLS. That way Ship manifest will still work if CLS is not installed. It would also encourage other modders to provide support for CLS if a toolbox style wrapper was available.\u003C/p\u003E\u003Cp\u003EThe issue with implicit operator casts is a consequence of writing a wrapper for all the publicly exposed CLS functionality. It is almost complete and it is just these implicit operator methods left to sort out. I might have written CLS not to provide such implicit type conversions, but it seemed like a nice way of doing things at the time.\u003C/p\u003E\u003Cp\u003ESo what do you think my best way forward is? I feel guilty every time I make a release and PapaJoe catches a load of stick from his user-base over all the dependency issues.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E@codepoet,\u003C/p\u003E\u003Cp\u003EFirst, it was my decision to incorporate CLS, so the burden is mine not yours. As with all \u0022new\u0022 things, there will be \u0022resistance\u0022. I can live with that, and since the plugin does allow players to \u0022turn it off\u0022, they can get the experience they want, even if it means adding another plugin. So please don\u0027t feel guilty. We are in this together, and the end results will justify the \u0022initial pain\u0022 on introducing something new. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003ENow, I must admit, I\u0027ve not done much with reflection, so I\u0027m in unfamiliar territory. I\u0027m going to do some research and see what I come up with.\u003C/p\u003E\n"},{"CreatedByName":"acc","CreatedById":80018,"CreatedDateTime":"2014-05-11T16:09:01Z","Content":"\n\u003Cp\u003EI just want to say I like the concept of CLS. The reason why I don\u0027t want to use them is simple: I don\u0027t need it, because my own game rule is to not to transfer resources or crew, if there is no \u0022imagine\u0022 connection. It\u0027s not because I don\u0027t like the idea. The idea is great, but I need not a script what I have already working in my brain. I have a lot of mods and plugins installed and really need to keep all resources for performance I can \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-05-11T16:11:06Z\u0022 title=\u002205/11/2014 04:11  PM\u0022 data-short=\u002210 yr\u0022\u003EMay 11, 2014\u003C/time\u003E by acc\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Papa_Joe","CreatedById":10788,"CreatedDateTime":"2014-05-11T17:02:32Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Faark\u0022 data-cite=\u0022Faark\u0022\u003E\u003Cdiv\u003EDon\u0027t! I think you are probably choosing a great tool for the wrong task. Reflection-Wrappers are great, if someone using your mod have a soft dependency on your mod. Usually, the main task of such a wrapper is to provide a. version compatible and b. provide a default implementation in case your api isn\u0027t present on that installation. You code above does none of it. It also would horrible in terms of performance if used somewhat more frequently, and implicit operators trend to be used quite often.\u003Cp\u003EWhat is your primary intention of providing a reflection wrapper?\u003C/p\u003E\u003Cp\u003EBlizzy is right, you would have to provide wrappers for all classes of your assembly. Also only use reflection at initialization, not at call time (for perf). As already mentioned it would make sense to make your methods \u0022transparent\u0022 in case your mod isn\u0027t present, so other mods don\u0027t frequently have to check whether YourWrapper.IsPresent. Thus a default implementations for GetConnectedLivingSpaces(part) might return an empty enumerator...\u003C/p\u003E\u003Cp\u003EFor larger mods it might makes sense to have an \u0022exports.cs\u0022 file, that contains all static methods you use on reflection. This way you won\u0027t accidentally break reflection without getting a compiler warning. And so on... but again first make sure such a wrapper actually gives you a real benefit.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThe concept of checking only at initialization would work for me, as I would check for the existence of the dll, and flip a switch to bypass any CLS calls. I theory that would work, as I would make no calls except for the first to initialize my environment.\u003C/p\u003E\n"},{"CreatedByName":"Papa_Joe","CreatedById":10788,"CreatedDateTime":"2014-05-11T17:24:37Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022codepoet\u0022 data-cite=\u0022codepoet\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EThe problem is that this is the identical bit of code apart from the cast in the last line. It seems to me that this can not be correct. How does the code know to invoke the \u0022implicit operator Part\u0022 rather than the \u0022implicit operator ModuleConnectedLivingSpace\u0022? it seems to me that calling GetMethod.(\u0022op_Implicit\u0022, ... ) is not going to specify which of these two casts I am interested in, so there must be a way of distinguishing between then. Does anyone know what it is?\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI found this on the web. not sure if it is helpful or not (you may be well past this), but you can decide.\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://chrisxwallis.wordpress.com/2010/10/01/late-binding-to-a-class-librarydll-in-c/\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://chrisxwallis.wordpress.com/2010/10/01/late-binding-to-a-class-librarydll-in-c/\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EUpon consideration, I got to thinking.\u003C/p\u003E\u003Cp\u003EIf the interface is instantiated at run time, and we do the dll existence check there, If the dll is not htere I simpley end up with a null for the object. If there, and an object is in existence, I would think that the need for the function level reflection becomes moot.. Do I understand correctly? At that point I can make the calls to the functions via the Instantiated dll object\u0027s interface methods...\u003C/p\u003E\u003Cp\u003EToo simple? am I missing something? both objects are .NET, so the need for native binding does not exist....\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-05-11T17:46:16Z\u0022 title=\u002205/11/2014 05:46  PM\u0022 data-short=\u002210 yr\u0022\u003EMay 11, 2014\u003C/time\u003E by Papa_Joe\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-11T18:13:31Z","Content":"\n\u003Cp\u003EYes, too simple I am afraid. The problem is that if you code makes calls to the CLS assembly then the assembly loader will want it to be present, and barf if it is not. The theory behind the reflection wrapper is that the wrapper (a file full of code that you include in your project) provides implementations of all the classes etc that you are expecting to use, but in your namespace, rather than CLS\u0027s. Instead of referencing the CLS assembly, you build against that file, which will compile as the wrapper file is providing all the stuff that the CLS assembly would have. The wrapper then uses reflection to load the CLS assembly (if possible) and if it is there, use reflection to call its methods etc. If we did not use reflection to do this a dependency to CLS assembly would be created.\u003C/p\u003E\u003Cp\u003EI do not think that there is a problem with the principle (obviosuly I have a few technical things to shake out) but I am alarmed to read Faark saying \u0022don\u0027t bother\u0022 as I understood that this is a good example of when a reflection wrapper is the tool for the job. If it is not the best tool for the job, then what is, because simply creating a dependency can cause users frustration, and that is then a barrier to other modders using CLS, which I do not want.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-11T18:22:50Z","Content":"\n\u003Cp\u003EFor clarity in the discussion, here is the wrapper file I have been writing. None of this code has been run yet, but it is \u0022code complete\u0022, however I am pretty un hopeful that the operator implicits will work.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E\u00C3\u00AF\u00C2\u00BB\u00C2\u00BFusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Reflection;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Enamespace KerbalHotSeat\u003Cbr\u003E{\u003Cbr\u003E    public class CLSAddon \u003Cbr\u003E    {\u003Cbr\u003E        private static bool? _CLSAvailable = null;\u003Cbr\u003E        private static CLSAddon _instance;\u003Cbr\u003E        private CLSTypes types = new CLSTypes();\u003Cbr\u003E        private PropertyInfo vesselProperty;\u003Cbr\u003E        private MethodInfo vesselPropertyGet;\u003Cbr\u003E        private object realCLSAddon;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        /// \u0026lt;summary\u0026gt;\u003Cbr\u003E        /// Whether the Toolbar Plugin is available.\u003Cbr\u003E        /// \u0026lt;/summary\u0026gt;\u003Cbr\u003E        public static bool CLSAvailable \u003Cbr\u003E        {\u003Cbr\u003E            get \u003Cbr\u003E            {\u003Cbr\u003E                if (_CLSAvailable == null) \u003Cbr\u003E                {\u003Cbr\u003E                    _CLSAvailable = Instance != null;\u003Cbr\u003E                }\u003Cbr\u003E                return (bool)_CLSAvailable;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        /// \u0026lt;summary\u0026gt;\u003Cbr\u003E        /// The global tool bar manager instance.\u003Cbr\u003E        /// \u0026lt;/summary\u0026gt;\t\t\u003Cbr\u003E        public static CLSAddon Instance \u003Cbr\u003E        {\t\t\t\u003Cbr\u003E            get \u003Cbr\u003E            {\u003Cbr\u003E                if ((CLSAvailable != false) \u0026amp;\u0026amp; (_instance == null)) \u003Cbr\u003E                {\u003Cbr\u003E                    Type type = CLSTypes.getType(\u0022ConnectedLivingSpace.CLSAddon\u0022);\u003Cbr\u003E                    if (type != null)\u003Cbr\u003E                    {\u003Cbr\u003E                        object realCLSAddon = CLSTypes.getStaticProperty(type, \u0022Instance\u0022).GetValue(null, null);\u003Cbr\u003E                        _instance = new CLSAddon(realCLSAddon);\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E                return _instance;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public CLSVessel Vessel\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                CLSVessel returnVal = (CLSVessel)vesselPropertyGet.Invoke(realCLSAddon, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Constructor - the wrapper gets a refference to the real object passed in, stores it and can use it for future calls.\u003Cbr\u003E        private CLSAddon(object realCLSAddon) \u003Cbr\u003E        {\u003Cbr\u003E            this.realCLSAddon = realCLSAddon;\u003Cbr\u003E            this.vesselProperty = CLSTypes.getProperty(types.CLSVesselType, \u0022Vessel\u0022);\u003Cbr\u003E            this.vesselPropertyGet = vesselProperty.GetGetMethod();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    public class CLSVessel\u003Cbr\u003E    {\u003Cbr\u003E        private object realCLSVessel;\u003Cbr\u003E        private PropertyInfo SpacesProperty;\u003Cbr\u003E        private PropertyInfo PartsProperty;\u003Cbr\u003E        private MethodInfo ClearMethod;\u003Cbr\u003E        private MethodInfo HighlightMethod;\u003Cbr\u003E        private MethodInfo SpacesPropertyGet;\u003Cbr\u003E        private MethodInfo PartsPropertyGet;\u003Cbr\u003E\u003Cbr\u003E        public CLSVessel()\u003Cbr\u003E        {\u003Cbr\u003E   \t\t\tType CLSVesselType = CLSTypes.getType(\u0022ConnectedLivingSpace.CLSVessel\u0022);\u003Cbr\u003E\t\t\trealCLSVessel = Activator.CreateInstance(CLSVesselType, null);\u003Cbr\u003E\t\t\tClearMethod = CLSTypes.getMethod(CLSVesselType, \u0022Clear\u0022);\u003Cbr\u003E\t\t\tHighlightMethod = CLSTypes.getMethod(CLSVesselType, \u0022Highlight\u0022);\u003Cbr\u003E            SpacesProperty = CLSTypes.getProperty(CLSVesselType,\u0022Spaces\u0022);\u003Cbr\u003E            SpacesPropertyGet = SpacesProperty.GetGetMethod();\u003Cbr\u003E            PartsProperty = CLSTypes.getProperty(CLSVesselType, \u0022Parts\u0022);\u003Cbr\u003E            PartsPropertyGet = PartsProperty.GetGetMethod();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public List\u0026lt;CLSSpace\u0026gt; Spaces\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                List\u0026lt;CLSSpace\u0026gt; returnVal = (List\u0026lt;CLSSpace\u0026gt;)SpacesPropertyGet.Invoke(realCLSVessel,null);\u003Cbr\u003E                return returnVal ;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public List\u0026lt;CLSPart\u0026gt; Parts\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                List\u0026lt;CLSPart\u0026gt; returnVal = (List\u0026lt;CLSPart\u0026gt;)PartsPropertyGet.Invoke(realCLSVessel, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Clear()\u003Cbr\u003E        {\u003Cbr\u003E\t\t\tClearMethod.Invoke(realCLSVessel, null);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Highlight(bool arg)\u003Cbr\u003E        {\u003Cbr\u003E            HighlightMethod.Invoke(realCLSVessel, new object[] {arg});\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    // Warpper class for the CLSSpace object\u003Cbr\u003E    public class CLSSpace\u003Cbr\u003E    {\u003Cbr\u003E        private object realCLSSpace;\u003Cbr\u003E        private PropertyInfo CrewProperty;\u003Cbr\u003E        private PropertyInfo MaxCrewProperty;\u003Cbr\u003E        private PropertyInfo PartsProperty;\u003Cbr\u003E        private PropertyInfo NameProperty;\u003Cbr\u003E        private PropertyInfo VesselProperty;\u003Cbr\u003E        private MethodInfo HighlightMethod;\u003Cbr\u003E        private MethodInfo CrewPropertyGet;\u003Cbr\u003E        private MethodInfo MaxCrewPropertyGet;\u003Cbr\u003E        private MethodInfo PartsPropertyGet;\u003Cbr\u003E        private MethodInfo NamePropertyGet;\u003Cbr\u003E        private MethodInfo NamePropertySet;\u003Cbr\u003E        private MethodInfo VesselPropertyGet;\u003Cbr\u003E\u003Cbr\u003E        public List\u0026lt;CLSPart\u0026gt; Parts\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                List\u0026lt;CLSPart\u0026gt; returnVal = (List\u0026lt;CLSPart\u0026gt;)PartsPropertyGet.Invoke(realCLSSpace, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public int MaxCrew\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                int returnVal = (int)MaxCrewPropertyGet.Invoke(realCLSSpace, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public String Name\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                String returnVal = (String)NamePropertyGet.Invoke(realCLSSpace, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E            set\u003Cbr\u003E            {\u003Cbr\u003E                NamePropertySet.Invoke(realCLSSpace, new object[] { value });\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public CLSVessel Vessel\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                CLSVessel returnVal = (CLSVessel)VesselPropertyGet.Invoke(realCLSSpace, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public List\u0026lt;CLSKerbal\u0026gt; Crew\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                List\u0026lt;CLSKerbal\u0026gt; returnVal = (List\u0026lt;CLSKerbal\u0026gt;)CrewPropertyGet.Invoke(realCLSSpace, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public CLSSpace(CLSVessel v)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSSpaceType = CLSTypes.getType(\u0022ConnectedLivingSpace.CLSSpace\u0022);\u003Cbr\u003E            realCLSSpace = Activator.CreateInstance(CLSSpaceType, new object[] { v });\u003Cbr\u003E\u003Cbr\u003E            HighlightMethod = CLSTypes.getMethod(CLSSpaceType, \u0022Highlight\u0022);\u003Cbr\u003E            CrewProperty = CLSTypes.getProperty(CLSSpaceType, \u0022Crew\u0022);\u003Cbr\u003E            MaxCrewProperty = CLSTypes.getProperty(CLSSpaceType, \u0022MaxCrew\u0022);\u003Cbr\u003E            PartsProperty = CLSTypes.getProperty(CLSSpaceType, \u0022Parts\u0022);\u003Cbr\u003E            NameProperty = CLSTypes.getProperty(CLSSpaceType, \u0022Name\u0022);\u003Cbr\u003E            VesselProperty = CLSTypes.getProperty(CLSSpaceType, \u0022Vessel\u0022);\u003Cbr\u003E            CrewPropertyGet = CrewProperty.GetGetMethod();\u003Cbr\u003E            MaxCrewPropertyGet = MaxCrewProperty.GetGetMethod();\u003Cbr\u003E            PartsPropertyGet = PartsProperty.GetGetMethod();\u003Cbr\u003E            NamePropertyGet = NameProperty.GetGetMethod();\u003Cbr\u003E            NamePropertySet = NameProperty.GetSetMethod();\u003Cbr\u003E            VesselPropertyGet = VesselProperty.GetGetMethod();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Highlight(bool val)\u003Cbr\u003E        {\u003Cbr\u003E            HighlightMethod.Invoke(realCLSSpace, new object[] { val });\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    public class CLSPart\u003Cbr\u003E    {\u003Cbr\u003E        private object realCLSPart;\u003Cbr\u003E        private PropertyInfo SpaceProperty;\u003Cbr\u003E        private PropertyInfo HatchStatusProperty;\u003Cbr\u003E        private PropertyInfo DockedProperty;\u003Cbr\u003E        private PropertyInfo CrewProperty;\u003Cbr\u003E        private PropertyInfo HabitableProperty;\u003Cbr\u003E        private PropertyInfo NavigableProperty;        \u003Cbr\u003E\u003Cbr\u003E        private MethodInfo HighlightMethod;\u003Cbr\u003E\u003Cbr\u003E        private MethodInfo ImplicitPartCastMethod;\u003Cbr\u003E\u003Cbr\u003E        private MethodInfo CrewPropertyGet;\u003Cbr\u003E        private MethodInfo SpacePropertyGet;\u003Cbr\u003E        private MethodInfo DockedPropertyGet;\u003Cbr\u003E        private MethodInfo HabitablePropertyGet;\u003Cbr\u003E        private MethodInfo NavigablePropertyGet;\u003Cbr\u003E\u003Cbr\u003E        public CLSPart(Part p)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSPartType = CLSTypes.getType(\u0022ConnectedLivingSpace.CLSPart\u0022);\u003Cbr\u003E            realCLSPart = Activator.CreateInstance(CLSPartType, new object[] { p });\u003Cbr\u003E\u003Cbr\u003E            HighlightMethod = CLSTypes.getMethod(CLSPartType, \u0022Highlight\u0022);\u003Cbr\u003E            ImplicitPartCastMethod = CLSTypes.getMethod(CLSPartType, \u0022op_Implicit\u0022);\u003Cbr\u003E            CrewProperty = CLSTypes.getProperty(CLSPartType, \u0022Crew\u0022);\u003Cbr\u003E            CrewPropertyGet = CrewProperty.GetGetMethod();\u003Cbr\u003E            DockedProperty = CLSTypes.getProperty(CLSPartType, \u0022Docked\u0022);\u003Cbr\u003E            DockedPropertyGet = DockedProperty.GetGetMethod();\u003Cbr\u003E            HabitableProperty = CLSTypes.getProperty(CLSPartType, \u0022Habitable\u0022);\u003Cbr\u003E            HabitablePropertyGet = HabitableProperty.GetGetMethod();\u003Cbr\u003E            NavigableProperty = CLSTypes.getProperty(CLSPartType, \u0022Navigable\u0022);\u003Cbr\u003E            NavigablePropertyGet = NavigableProperty.GetGetMethod();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public CLSSpace Space\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                CLSSpace returnVal = (CLSSpace)SpacePropertyGet.Invoke(realCLSPart, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public bool Docked\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                bool returnVal = (bool)DockedPropertyGet.Invoke(realCLSPart,null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public List\u0026lt;CLSKerbal\u0026gt; Crew\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                List\u0026lt;CLSKerbal\u0026gt; returnVal = (List\u0026lt;CLSKerbal\u0026gt;)CrewPropertyGet.Invoke(realCLSPart, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Allow a CLSPart to be cast into a Part\u003Cbr\u003E        public static implicit operator Part(CLSPart _p)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSPartType = AssemblyLoader.loadedAssemblies.SelectMany(a =\u0026gt; a.assembly.GetExportedTypes()).SingleOrDefault(t =\u0026gt; t.FullName == \u0022ConnectedLivingSpace.CLSPart\u0022);\u003Cbr\u003E            MethodInfo method = CLSPartType.GetMethod(\u0022op_Implicit\u0022, BindingFlags.Public | BindingFlags.Static);\u003Cbr\u003E            Part retVal = (Part)method.Invoke(null,new object[] { _p });\u003Cbr\u003E            return (retVal);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Allow a CLSPart to be cast into a ModuleConnectedLivingSpace. Note that this might fail, if the part in question does not have the CLS module configured.\u003Cbr\u003E        public static implicit operator ModuleConnectedLivingSpace(CLSPart _p)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSPartType = AssemblyLoader.loadedAssemblies.SelectMany(a =\u0026gt; a.assembly.GetExportedTypes()).SingleOrDefault(t =\u0026gt; t.FullName == \u0022ConnectedLivingSpace.CLSPart\u0022);\u003Cbr\u003E            MethodInfo method = CLSPartType.GetMethod(\u0022op_Implicit\u0022, BindingFlags.Public | BindingFlags.Static);\u003Cbr\u003E\u003Cbr\u003E            object realModCLS = method.Invoke(null, new object[] { _p });\u003Cbr\u003E\u003Cbr\u003E            ModuleConnectedLivingSpace retVal = new ModuleConnectedLivingSpace(realModCLS);\u003Cbr\u003E\u003Cbr\u003E            return (retVal);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Highlight(bool val)\u003Cbr\u003E        {\u003Cbr\u003E            HighlightMethod.Invoke(realCLSPart, new object[] { val });\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public bool Habitable\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                bool returnVal = (bool)HabitablePropertyGet.Invoke(realCLSPart, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public bool Navigable\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                bool returnVal = (bool)NavigablePropertyGet.Invoke(realCLSPart, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    public class CLSKerbal\u003Cbr\u003E    {\u003Cbr\u003E        private object realCLSKerbal;\u003Cbr\u003E        private PropertyInfo PartProperty;\u003Cbr\u003E        private MethodInfo PartPropertyGet;\u003Cbr\u003E\u003Cbr\u003E        public CLSKerbal(ProtoCrewMember k, CLSPart p)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSKerbalType = CLSTypes.getType(\u0022ConnectedLivingSpace.CLSKerbal\u0022);\u003Cbr\u003E            realCLSKerbal = Activator.CreateInstance(CLSKerbalType, new object[] { k,p });\u003Cbr\u003E\u003Cbr\u003E            PartProperty = CLSTypes.getProperty(CLSKerbalType, \u0022Part\u0022);\u003Cbr\u003E            PartPropertyGet = PartProperty.GetGetMethod();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public static implicit operator ProtoCrewMember(CLSKerbal _k)\u003Cbr\u003E        {\u003Cbr\u003E            ProtoCrewMember retVal = (ProtoCrewMember)_k.realCLSKerbal;\u003Cbr\u003E            return retVal;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public CLSPart Part\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                CLSPart returnVal = (CLSPart)PartPropertyGet.Invoke(realCLSKerbal, null);\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    public class ModuleConnectedLivingSpace : PartModule\u003Cbr\u003E    {\u003Cbr\u003E        private object realModCLS; // TODO how does this get set?\u003Cbr\u003E\u003Cbr\u003E        // Constructor for the wrapper class. The actual class does not have a constructor\u003Cbr\u003E        public ModuleConnectedLivingSpace(object real)\u003Cbr\u003E        {\u003Cbr\u003E            this.realModCLS = real;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Allow a Part to be cast into a ModuleConnectedLivingSpace. \u003Cbr\u003E        public static implicit operator ModuleConnectedLivingSpace(Part _p)\u003Cbr\u003E        {\u003Cbr\u003E            Type CLSPartType = AssemblyLoader.loadedAssemblies.SelectMany(a =\u0026gt; a.assembly.GetExportedTypes()).SingleOrDefault(t =\u0026gt; t.FullName == \u0022ConnectedLivingSpace.CLSPart\u0022);\u003Cbr\u003E            MethodInfo method = CLSPartType.GetMethod(\u0022op_Implicit\u0022, BindingFlags.Public | BindingFlags.Static);\u003Cbr\u003E\u003Cbr\u003E            object realModCLS = method.Invoke(null, new object[] { _p });\u003Cbr\u003E\u003Cbr\u003E            ModuleConnectedLivingSpace retVal = new ModuleConnectedLivingSpace(realModCLS);\u003Cbr\u003E\u003Cbr\u003E            return (retVal);\u003Cbr\u003E\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public override string GetInfo()\u003Cbr\u003E        {\u003Cbr\u003E            Type ModuleConnectedLivingSpaceType = CLSTypes.getType(\u0022ConnectedLivingSpace.ModuleConnectedLivingSpace\u0022);\u003Cbr\u003E\u003Cbr\u003E            MethodInfo methodInfo = CLSTypes.getMethod(ModuleConnectedLivingSpaceType,\u0022GetInfo\u0022);\u003Cbr\u003E\u003Cbr\u003E            string retVal = (string)methodInfo.Invoke(this.realModCLS, null);\u003Cbr\u003E\u003Cbr\u003E            return retVal;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E    // Class to help with some of the reflection stuff.\u003Cbr\u003E    internal class CLSTypes\u003Cbr\u003E    {\u003Cbr\u003E        internal readonly  Type CLSAddonType;\u003Cbr\u003E        internal readonly  Type CLSVesselType;\u003Cbr\u003E        internal readonly Type CLSSpaceType;\u003Cbr\u003E        internal readonly Type CLSPartType;\u003Cbr\u003E        internal readonly Type CLSKerbalType;\u003Cbr\u003E\u003Cbr\u003E        internal CLSTypes()\u003Cbr\u003E        {\u003Cbr\u003E            CLSAddonType = getType(\u0022ConnectedLivingSpace.CLSAddon\u0022);\u003Cbr\u003E            CLSVesselType = getType(\u0022ConnectedLivingSpace.CLSVessel\u0022);\u003Cbr\u003E            CLSSpaceType = getType(\u0022ConnectedLivingSpace.CLSSpace\u0022);\u003Cbr\u003E            CLSPartType = getType(\u0022ConnectedLivingSpace.CLSPart\u0022);\u003Cbr\u003E            CLSKerbalType = getType(\u0022ConnectedLivingSpace.CLSKerbal\u0022);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        internal static Type getType(string name)\u003Cbr\u003E        {\u003Cbr\u003E            return AssemblyLoader.loadedAssemblies.\u003Cbr\u003E                SelectMany(a =\u0026gt; a.assembly.GetExportedTypes()).\u003Cbr\u003E                SingleOrDefault(t =\u0026gt; t.FullName == name); \u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        internal static PropertyInfo getProperty(Type type, string name)\u003Cbr\u003E        {\u003Cbr\u003E            return type.GetProperty(name, BindingFlags.Public | BindingFlags.Instance);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        internal static PropertyInfo getStaticProperty(Type type, string name)\u003Cbr\u003E        {\u003Cbr\u003E            return type.GetProperty(name, BindingFlags.Public | BindingFlags.Static);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        internal static EventInfo getEvent(Type type, string name)\u003Cbr\u003E        {\u003Cbr\u003E            return type.GetEvent(name, BindingFlags.Public | BindingFlags.Instance);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        internal static MethodInfo getMethod(Type type, string name)\u003Cbr\u003E        {\u003Cbr\u003E            return type.GetMethod(name, BindingFlags.Public | BindingFlags.Instance);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        internal static FieldInfo getField(Type type, string name)\u003Cbr\u003E        {\u003Cbr\u003E            return type.GetField(name);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"Faark","CreatedById":69775,"CreatedDateTime":"2014-05-11T19:43:52Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Papa_Joe\u0022 data-cite=\u0022Papa_Joe\u0022\u003E\u003Cdiv\u003E\u003Ca href=\u0022http://chrisxwallis.wordpress.com/2010/10/01/late-binding-to-a-class-librarydll-in-c/\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://chrisxwallis.wordpress.com/2010/10/01/late-binding-to-a-class-librarydll-in-c/\u003C/a\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThats actually an interesting concept. You would end up with a bunch of duplicate interface files, since they cannot be changed once released anymore. Also our APIs would have to implement a lot of them. Not very practical and i don\u0027t really think it will be adopted for KSP, but it should work.\u003C/p\u003E\u003Cp\u003EI\u0027m currently creating such a wrapper for LoD as well. Not yet done, but that is what i have so far: \u003Ca href=\u0022https://github.com/Faark/KspLoadOnDemand/blob/master/LoadOnDemand/External.cs\u0022 rel=\u0022external nofollow\u0022\u003EAPI side\u003C/a\u003E, \u003Ca href=\u0022https://github.com/Faark/KspLoadOnDemand/blob/master/LoadOnDemand/Foreign/LoadOnDemandWrapper.cs\u0022 rel=\u0022external nofollow\u0022\u003EExternal wrapper\u003C/a\u003E.\u003C/p\u003E\u003Cp\u003EIt certainly isn\u0027t perfect, but there are a bunch of design decisions you might want to adopt or consider.\u003C/p\u003E\u003Cp\u003E- Do not use Reflection when executing your API methods. Do that when you initialize your wrapper. The code shown initially loops though all assemblies and all types on every single implicit cast (what should be an ultra lightweight call), what ofc doesn\u0027t make much sense. Toolbar and your remaining code at least stores MethodInfo\u0027s. Thats kinda better, but still has to do a bunch of type checking at execution. Delegates are probably the best way to go, see methodInfo.CreateDelegate.\u003C/p\u003E\u003Cp\u003E- You will change your code. Because of that i prefer to not let the wrapper \u0022search\u0022 for methods by name, argument list, type or visibility. I have sth like \u0022Delegate[] GiveMeFunctionsForWrapperVersion(int version)\u0022. In future version i could change my API however i want but the old wrapper might still function, as long as i still provide those single method and it still returns compatible delegates. It also allows me to not use any reflection except for this initial call.\u003C/p\u003E\u003Cp\u003E- Type safety. Another reason to use delegates. I am forwarding a list of delegates, so i kinda break type safety for a seconds. But it would crash on initialization and more importantly i will get compiler errors whenever i change sth unintentionally. Except ofc its a change in GiveMeFunctionsForWrapperVersion(..), but thats a much simpler rule to follow (don\u0027t change it unless you change and consider wrappers as well).\u003C/p\u003E\u003Cp\u003E- What I\u0027m not very good in yet is making this wrapper in a way that the user don\u0027t has to bother whether LOD is available. I intend that all Wrapper calls are at least either ignored or return default values that you can use as \u0022usual\u0022. In your case it seems (after a very brief look) like SM only uses Vessel.GetSpaces and sth like CanTransfer(fromPart, toPart). So you could provide a simple default implementation for both of it and save whoever uses your API some work. But yes, in that case SM seems to not need this anymore and thus it isn\u0027t really necessary. Maybe some day some other developer tries to find what parts kerbals can live in instead of figuring it out by himself he can just use your API and thus also profit in case your mod is installed.\u003C/p\u003E\u003Cp\u003ERegarding your code in particular:\u003C/p\u003E\u003Cp\u003E- ModuleConnectedLivingSpace is wrong. It must not derive from PartModule, since that would mean you have 2 of them instantiated (one in your DLL, one in the DLL that included your wrapper)\u003C/p\u003E\u003Cp\u003E- Just because i\u0027m curious: Why did you choose implicit conversion over a readonly property? \u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Epublic Part Part { get; private set; }\u003C/pre\u003E\u003Cp\u003E \u003C/p\u003E\u003Cp\u003E- Any of your constructors seem to create an instance in your mod.dll. Doesn\u0027t those already exist? If they never do, why can\u0027t someone just include this particular code/class into its own dll?\u003C/p\u003E\n"},{"CreatedByName":"Papa_Joe","CreatedById":10788,"CreatedDateTime":"2014-05-11T20:39:40Z","Content":"\n\u003Cp\u003EThanks, the code helps me a lot with understanding the problem. \u003C/p\u003E\u003Cp\u003E@Faark, Your approach is similar to what I was thinking (tho my thinking was very rudimentary). Do the lifting in one place, and simply ignore the object if not properly instantiated.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-11T20:43:28Z","Content":"\n\u003Cp\u003EFaark, thanks for that - there is a lot to think about in there. As I have not done this stuff before it is all learning for me. I am now starting to wonder is implicit casts are a good idea. Life would be simpler without them. I am also wondering if it would be good to do a wrapper that has everything SM needs, and the add the rest later.\u003C/p\u003E\n"},{"CreatedByName":"Papa_Joe","CreatedById":10788,"CreatedDateTime":"2014-05-11T22:21:09Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022codepoet\u0022 data-cite=\u0022codepoet\u0022\u003E\u003Cdiv\u003EFaark, thanks for that - there is a lot to think about in there. As I have not done this stuff before it is all learning for me. I am now starting to wonder is implicit casts are a good idea. Life would be simpler without them. I am also wondering if it would be good to do a wrapper that has everything SM needs, and the add the rest later.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EPersonally, I think that what is good for the community comes first. I can rework what I need to for the good of the group. The way I see it, if we have a chance to \u0022do it right\u0022, let\u0027s take it.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-12T15:13:01Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Papa_Joe\u0022 data-cite=\u0022Papa_Joe\u0022\u003E\u003Cdiv\u003EPersonally, I think that what is good for the community comes first. I can rework what I need to for the good of the group. The way I see it, if we have a chance to \u0022do it right\u0022, let\u0027s take it.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI agree with you on doing it right - one reason I swapped religion as a job and software as a hobby from the other way round is I hated not having the commercial space to get the software right.\u003C/p\u003E\u003Cp\u003EAnyhow, think I will:\u003C/p\u003E\u003Cp\u003E1) add a none opimplicit way of doing the things that those type conversions do.\u003C/p\u003E\u003Cp\u003E2) provide a reflection wrapper for those read only properties but not the opimplicit ones.\u003C/p\u003E\u003Cp\u003E3) acknowledge that the mod using CLS is at liberty to make a better reflection wrapper if they are concerned about performance.\u003C/p\u003E\u003Cp\u003E4) synchronise a release with PapaJoe so CLS and SM that is does not have a hard dependency are released at the same time.\u003C/p\u003E\u003Cp\u003EI hope that provides a way forwards that does not cut off the optiond for improvements in the future, but also gets us to the place we are heading towards.\u003C/p\u003E\n"},{"CreatedByName":"Papa_Joe","CreatedById":10788,"CreatedDateTime":"2014-05-12T15:17:43Z","Content":"\n\u003Cp\u003ESounds like plan. Let me know what I can do to assist.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-12T15:23:11Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Papa_Joe\u0022 data-cite=\u0022Papa_Joe\u0022\u003E\u003Cdiv\u003EPersonally, I think that what is good for the community comes first. I can rework what I need to for the good of the group. The way I see it, if we have a chance to \u0022do it right\u0022, let\u0027s take it.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI agree with you on doing it right - one reason I swapped religion as a job and software as a hobby from the other way round is I hated not having the commercial space to get the software right.\u003C/p\u003E\u003Cp\u003EAnyhow, think I will:\u003C/p\u003E\u003Cp\u003E1) add a none opimplicit way of doing the things that those type conversions do.\u003C/p\u003E\u003Cp\u003E2) provide a reflection wrapper for those read only properties but not the opimplicit ones.\u003C/p\u003E\u003Cp\u003E3) acknowledge that the mod using CLS is at liberty to make a better reflection wrapper if they are concerned about performance.\u003C/p\u003E\u003Cp\u003E4) synchronise a release with PapaJoe so CLS and SM that is does not have a hard dependency are released at the same time.\u003C/p\u003E\u003Cp\u003EI hope that provides a way forwards that does not cut off the optiond for improvements in the future, but also gets us to the place we are heading towards.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-13T06:58:26Z","Content":"\n\u003Cp\u003EOK, I am stuck again \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_sad.gif\u0022 alt=\u0022:(\u0022\u003E\u003C/p\u003E\u003Cp\u003EI have been getting my wrapper up together - I am sure there are things about it that could be better, but I just want to achieve functional to start with. However I have got stuck on my methods that return a List of objects as a return value.\u003C/p\u003E\u003Cp\u003EIn general whenever I need to return an object of a type that is being wrapped, I create a wrapper version of it and hide the reference inside. It looks like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        public CLSSpace Space\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                CLSSpace returnVal = new CLSSpace(SpacePropertyGet.Invoke(realCLSPart, null));\u003Cbr\u003E                return returnVal;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eas the wrapper class has a constuctor that takes the object returned by the Invoke call.\u003C/p\u003E\u003Cp\u003EAll good, that works. However if the wrapped call returns a List\u0026lt;CLSPart\u0026gt; for example, I need to create a List of wrapped CLSPart objects. That means I need to take the object that comes back from the call to Invoke and iterate through it. However this does not seem to be possible without being able to deal with the wrapper CLSPart type. Here is some code to illustrate the problem:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        public List\u0026lt;CLSSpace\u0026gt; Spaces\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                List\u0026lt;CLSSpace\u0026gt; returnValue = new List\u0026lt;CLSSpace\u0026gt;();\u003Cbr\u003E\u003Cbr\u003E                object list = SpacesPropertyGet.Invoke(realCLSVessel, null);\u003Cbr\u003E\u003Cbr\u003E                Debug.Log(list.ToString());\u003Cbr\u003E\u003Cbr\u003E                IEnumerable\u0026lt;object\u0026gt; listEnum = (IEnumerable\u0026lt;object\u0026gt;)list; //  This call fails with a cast exception\u003Cbr\u003E\u003Cbr\u003E                if(null != list)\u003Cbr\u003E                {\u003Cbr\u003E                    foreach (object o in listEnum)\u003Cbr\u003E                    {\u003Cbr\u003E                        returnValue.Add(new CLSSpace(o));\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E\u003Cbr\u003E                return returnValue;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI want to iterate through the list variable, but I can\u0027t without being able to handle the unwrapped CLSSpace type. Can anyone suggest a solution?\u003C/p\u003E\n"},{"CreatedByName":"blizzy78","CreatedById":68543,"CreatedDateTime":"2014-05-13T08:18:21Z","Content":"\n\u003Cp\u003EFirst of all, I\u0027d like to mention that I think you\u0027re on the right track, what with all the wrapping and such.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022codepoet\u0022 data-cite=\u0022codepoet\u0022\u003E\u003Cdiv\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E                IEnumerable\u0026lt;object\u0026gt; listEnum = (IEnumerable\u0026lt;object\u0026gt;)list; //  This call fails with a cast exception\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIs that even possible in C#? It is possible in Java because of erasure, which means that at runtime, a List\u0026lt;String\u0026gt; is the same as List\u0026lt;Integer\u0026gt; or even List (not at compile-time.) If it\u0027s not possible in C#, you could try casting to just IEnumerable. If that also fails, I only see getting the elements via reflection instead of regular means.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-13T09:31:56Z","Content":"\n\u003Cp\u003EI do all my best thinking in the bath - here is what happened this morning...\u003C/p\u003E\u003Cp\u003EI am thinking \u0022why is this so hard - it was never like this back in the COM days - we had IDispatch and everything - it was no problem.\u0022\u003C/p\u003E\u003Cp\u003EThe i realised that of course the thing that makes it easy with COM to do what I am seeking to do (i.e loose binding) is the ability to publish your interface separately from your implementation. That is what I am missing - defining interfaces!\u003C/p\u003E\u003Cp\u003ESo here is the plan:\u003C/p\u003E\u003Cp\u003E1) I define a whole load of ICLSPart, ICLSSpace etc interfaces in a single CLSInterfaces.cs file\u003C/p\u003E\u003Cp\u003E2) I get my various objects to implement those interfaces and ship that as an assembly\u003C/p\u003E\u003Cp\u003E3) I provide a CLSWrapper.cs that also implements those interfaces, but under the covers does all the reflection stuff required. However the good news is that I no longer need to worry about the reflection code not knowing about my types, because it does not need to know about my types - it just needs to know about my interfaces, which it already does.\u003C/p\u003E\u003Cp\u003Eany problems?\u003C/p\u003E\n"},{"CreatedByName":"blizzy78","CreatedById":68543,"CreatedDateTime":"2014-05-13T09:34:08Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022codepoet\u0022 data-cite=\u0022codepoet\u0022\u003E\u003Cdiv\u003E3) I provide a CLSWrapper.cs that also implements those interfaces\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENot possible. You cannot use any type (interface or not) without creating a hard dependency.\u003C/p\u003E\u003Cp\u003EThis is why I ended up adding \u003Cstrong\u003Eall\u003C/strong\u003E public types in the Toolbar Plugin API to the wrapper as well, to make it absolutely transparent to the user of the wrapper whether they\u0027re using the wrapper or the real thing.\u003C/p\u003E\n"},{"CreatedByName":"Faark","CreatedById":69775,"CreatedDateTime":"2014-05-13T10:02:03Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022blizzy78\u0022 data-cite=\u0022blizzy78\u0022\u003E\u003Cdiv\u003EIs that even possible in C#? It is possible in Java because of erasure, which means that at runtime, a List\u0026lt;String\u0026gt; is the same as List\u0026lt;Integer\u0026gt; or even List (not at compile-time.)\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThey introduced co \u0026amp; contra variance in some later version of .NET, what should make it possible. At least in the same assembly and at compile time. Ofc not in KSP/Unity, anyway.\u003C/p\u003E\u003Cp\u003EYes, a non-generic enumerable as suggested by blizzy should work. If you are fine with enumerables it could look like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EIEnumerable\u0026lt;CLSSpace\u0026gt; Spaces\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                var list = (System.Collections.IEnumerable)SpacesPropertyGet.Invoke(realCLSVessel, null)\u003Cbr\u003E                foreach (var obj in list)\u003Cbr\u003E                {\u003Cbr\u003E                    yield return new CLSSpace(obj);\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E        }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EOfc you could always a simple method in your API assembly that you use just for reflection and has simple objects that use only types from .net, unity and KSP instead of your own. No one is forcing you to use exactly the same \u0022kind\u0022 of method in both assemblies. If you want to have implicit cast operators, the wrapper\u0027s operator could invoke some static method in the API that does the conversion (and maybe uses its \u0022local\u0022 implicit cast operator, but you wrapper doesn\u0027t have to care how its done).\u003C/p\u003E\u003Cp\u003E@Interfaces:\u003C/p\u003E\u003Cp\u003EYou have to creates the interfaces in a different project to make it work. Those your_interfaces.dll have to be referenced by both dlls (your API and the one using your stuff) and both of them would have to ship with this interfaces.dll next to their dll that implements them. You still need some reflection to get some objects with interfaces to the dll using your API in the first place (likely your casting or some kind of \u0022manager\u0022). You can never again change your interfaces.dll without breaking compatibility. If you want to add a feature, create a new interfacesV2.dll and make your types in the api implement both versions.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-05-13T10:10:37Z\u0022 title=\u002205/13/2014 10:10  AM\u0022 data-short=\u002210 yr\u0022\u003EMay 13, 2014\u003C/time\u003E by Faark\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-13T10:53:52Z","Content":"\n\u003Cp\u003EThe caveats you have pointed out with the interfaces route is what I would have expected - the interfaces.dll assembly plays the role of the typelibrary in the COM world, and allows clients to know what they have got to build against before they ever see the implementation. From where I am coming from interfaces are supposed to be well defined and unchanging, so I am cool with that - like you say it is always possible to add a new interface.\u003C/p\u003E\u003Cp\u003ESo would it be such a bad thing if we ended up with:\u003C/p\u003E\u003Cp\u003ECLS.dll which provides the CLS implementation \u003C/p\u003E\u003Cp\u003ECLSInterfaces.dll that defines the interfaces\u003C/p\u003E\u003Cp\u003ESM.dll which has a reference to CLSInterfaces.dll that is shipped alongside SM.dll\u003C/p\u003E\u003Cp\u003EWould it matter that there are two CLSInterface.dll files hanging around? Would they both get loaded, or would there be separate dependency paths?\u003C/p\u003E\n"},{"CreatedByName":"Faark","CreatedById":69775,"CreatedDateTime":"2014-05-13T12:17:14Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022codepoet\u0022 data-cite=\u0022codepoet\u0022\u003E\u003Cdiv\u003EWould it matter that there are two CLSInterface.dll files hanging around? Would they both get loaded, or would there be separate dependency paths?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThere better be 2 CLSInterface.dll\u0027s, to make sure KSP can load them properly. Yes, KSP should only load the first one it finds and reuse that, as long as they have the same assembly name, version, etc. Otherwise it would be two different types internally and thus wouldn\u0027t work.\u003C/p\u003E\u003Cp\u003EBtw, with interfaces you definitively can\u0027t use operators \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_tongue.gif\u0022 alt=\u0022:P\u0022\u003E\u003C/p\u003E\u003Cp\u003EInstead you will have a single [singelton?] class / .cs file SM has to include that takes care of stuff like that and \u0022first contact\u0022 in general (e.g. getting a reference to some singelton object that implements a general \u0022manager\u0022 interface).\u003C/p\u003E\n"},{"CreatedByName":"blizzy78","CreatedById":68543,"CreatedDateTime":"2014-05-13T12:20:16Z","Content":"\n\u003Cp\u003EI somehow feel that you are overcomplicating things with all those interfaces...\u003C/p\u003E\n"}]}