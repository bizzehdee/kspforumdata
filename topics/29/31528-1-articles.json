{"TopicId":31528,"ForumId":29,"TopicTitle":"Part Metadata \u002B Drawing Part Icons","CreatedByName":"BlackNecro","CreatedById":7728,"CreatedDateTime":"2013-06-05T19:12:01Z","PageNum":1,"Articles":[{"CreatedByName":"BlackNecro","CreatedById":7728,"CreatedDateTime":"2013-06-05T19:12:01Z","Content":"\n\u003Cp\u003EHello there,\u003C/p\u003E\u003Cp\u003EAfter some fiddling around with the AvailablePart, PartLoader and EditorPartList classes I\u0027ve come to no real conclusion on this one. \u003C/p\u003E\u003Cp\u003EI already had this in the help a dev thread but as it\u0027s a bit scattered apart and a few new things popped up, so I thought to maybe give it it\u0027s own thread.\u003C/p\u003E\u003Cp\u003EI\u0027m currently working on a plugin that allows you to dynamically tag parts in the editor in order to put them in custom categories and filter them based on these tags. This already works pretty well so far, the basic framework and featureset is worked out but in order to get this to the volume I want it to provide I still have to iron out a few things.\u003C/p\u003E\u003Cp\u003EThere are two big ones which I\u0027d like to address first as well as a smaller one which could work around even it doesn\u0027t work out really.\u003C/p\u003E\u003Cp\u003E1) Part Paths\u003C/p\u003E\u003Cp\u003EI\u0027m trying to find the actual URL / path of all available parts. This would be needed in order to get the mod folder in GameData the part cfg resides in in order to allow for automatic mod tagging (You add a new mod and are able to generate a preset category instead of having to haul all new parts into a group manually).\u003C/p\u003E\u003Cp\u003ESadly the API is very obscure on this point.\u003C/p\u003E\u003Cp\u003EI first tried to use the PartLoader.LoadedPartList which provides a list of AvailableParts. Sadly for these no fields apart from the actual AvailablePart.name are set so I tried using the PartLoader.getPartInfoByName method as I thought those additional fields might be filled only when explicitly asked for some reason, didn\u0027t work out aswell. I should add the ConfigNodes on those were empty aswell.\u003C/p\u003E\u003Cp\u003EI then tried to get some properly filled AvailableParts via the EditorPartList.Instance.limitedParts but that List wasn\u0027t filled in any occasion at all even when all parts where displayed or filtered out.\u003C/p\u003E\u003Cp\u003E2) Part Icons \u003C/p\u003E\u003Cp\u003EFor the actual Tag management I\u0027m using a simple list of part names at the moment. For the finished version I\u0027d prefer to the 3D model of the part just like the editor does. I found no obvious way to do that looking through the class definitions. Incase this doesn\u0027t work out this one is still somewhat dependant on 1) as I\u0027d need proper part titles for the list as the part names are pretty hideous looking on their own.\u003C/p\u003E\u003Cp\u003E3) Button Icons\u003C/p\u003E\u003Cp\u003EThe categories / Tags are displayed along the top of your screen as a continuation of the default categories button list, each tag can be given a custom icon but I\u0027m currently looking into a way to draw the default part icon for staging on a button (just to provide some default icons for custom tag groups without properly set up icons). So is there some way to get the actual Texture2D for the default buttons instead of just that DefaultIcons enumeration? This is a minor one as it could just be worked out with some assets for some default button textures.\u003C/p\u003E\u003Cp\u003EIf someone got an idea, a solution for those problems or even a mod that does something similiar to said problems to have a look at, I\u0027d be very grateful if you\u0027d throw me a bone.\u003C/p\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2013-06-07T03:04:12Z","Content":"\n\u003Cp\u003EI\u0027ve determined that only partURL and typeDescription are null in the PartLoader.LoadedPartList instance. All the other fields are there (though the filePath property also returns null.) Trying to figure out how to get the url or path; it should be possible because how does the engine instance a Part from the AvailableParts list?\u003C/p\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2013-06-07T05:01:44Z","Content":"\n\u003Cp\u003EYou can grab the Part from an AvailablePart using the partPrefab field e.g. PartLoader.LoadedPartList[3].partPrefab. From there you can use the Modules property of Part to get a list of PartModules attached to the part. The problem with trying to sort by mod is that some mods simply attach PartModules to existing stock parts, so there\u0027s no way necessarily to distinguish between stock and mod parts. You could construct a file system graph (make sure you use System.IO without a using directive -- it messes with Unity functions; you\u0027ll have to fully qualify the System.IO methods) then compare the PartModule.moduleName to the names of each of the folders to determine which parts sit in the Squad folder and which don\u0027t. (You can use KSPUtil.ApplicationRootPath to get the root directory.)\u003C/p\u003E\n"},{"CreatedByName":"BlackNecro","CreatedById":7728,"CreatedDateTime":"2013-06-07T09:19:48Z","Content":"\n\u003Cp\u003EAh nice the PartModules one is an interesting option for further sorting parts. \u003C/p\u003E\u003Cp\u003EAll assemblies referencing System.IO won\u0027t be loaded by KSP as disk access is sandboxed via KSP.IO. If that would work I\u0027d just parse the part.cfgs for names myself but like this - no luck.\u003C/p\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2013-06-07T13:15:17Z","Content":"\n\u003Cp\u003EYour project sounds like a superset of what I\u0027m working on: a simple sort and filter mechanism for the part list. I got the sort working and just have GUI coding for the filter capability, but I think I\u0027ll abandon the project to wait for your more polished-sounding offering. I was just using the idea as a way to get my feet wet in the plug-in world anyway.\u003C/p\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2013-06-07T15:32:10Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022BlackNecro\u0022 data-cite=\u0022BlackNecro\u0022\u003E\u003Cdiv\u003EI\u0027d need proper part titles for the list as the part names are pretty hideous looking on their own.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou can use AvailablePart.title, which is the part name as displayed at the top of the tooltip popup.\u003C/p\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2013-06-07T15:38:36Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022BlackNecro\u0022 data-cite=\u0022BlackNecro\u0022\u003E\u003Cdiv\u003EAll assemblies referencing System.IO won\u0027t be loaded by KSP as disk access is sandboxed via KSP.IO. If that would work I\u0027d just parse the part.cfgs for names myself but like this - no luck.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EAh. I wondered about that. You could (yes it\u0027s ugly) pre-generate a file graph in the ConfigNode xml format, then serialize from it using the ConfigNode interface.\n\u003C/p\u003E\u003Cdiv class=\u0022ipsEmbeddedVideo\u0022 contenteditable=\u0022false\u0022\u003E\u003Cdiv\u003E\u003Ciframe width=\u0022480\u0022 height=\u0022270\u0022 src=\u0022https://www.youtube.com/embed/videoseries?list=PLBCtPCe8pDWvI425f_YYOsYVKmUsjT6zh\u0022 frameborder=\u00220\u0022 allowfullscreen=\u0022true\u0022\u003E\u003C/iframe\u003E\u003C/div\u003E\u003C/div\u003E has the outlines of how it might be possible to do this.\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2013-06-08T00:44:53Z","Content":"\n\u003Cp\u003EHere\u0027s the code you\u0027re looking for:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Estring findPartMod(AvailablePart part)\u003Cbr\u003E        {\u003Cbr\u003E            string mod = \u0022\u0022;\u003Cbr\u003E            UrlDir.UrlConfig[] configs = GameDatabase.Instance.GetConfigs(\u0022PART\u0022);\u003Cbr\u003E            UrlDir.UrlConfig config = Array.Find\u0026lt;UrlDir.UrlConfig\u0026gt;(configs, (c =\u0026gt; part.name == c.name));\u003Cbr\u003E            if (config != null)\u003Cbr\u003E            {\u003Cbr\u003E                var id = new UrlDir.UrlIdentifier(config.url);\u003Cbr\u003E                mod = id[0];\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            return mod;\u003Cbr\u003E        }\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EIt grabs the list of PART type configs from GameDatabase, then searches for a name match, then parses the url for the root namespace. I\u0027m not sure if this is the best or most efficient way to do this (suggestions welcome) but it works. This should work for all mods, except that some of them have a manufacturer ID in the root namespace instead of the mod name. There\u0027s no standard way to traverse the url for mod name except to grab the root though. If you want to filter stock only, just compare the return value of this method to \u0022Squad\u0022 like so:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EEditorPartListFilter filter = new EditorPartListFilter(\u0022Stock Only\u0022,\u003Cbr\u003E    (part =\u0026gt; findPartMod(part) == \u0022Squad\u0022));\u003Cbr\u003EEditorPartList.Instance.ExcludeFilters.AddFilter(filter);\u003Cbr\u003EEditorPartList.Instance.Refresh();\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222013-06-08T00:49:34Z\u0022 title=\u002206/08/2013 12:49  AM\u0022 data-short=\u002211 yr\u0022\u003EJune 8, 2013\u003C/time\u003E by Mr Shifty\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"BlackNecro","CreatedById":7728,"CreatedDateTime":"2013-06-08T01:36:02Z","Content":"\n\u003Cp\u003EThank you very much for that URLConfig one - now that works most of the times, should be enough for some rough presorting of of parts.\u003C/p\u003E\n"},{"CreatedByName":"Mr Shifty","CreatedById":68146,"CreatedDateTime":"2013-06-08T05:26:53Z","Content":"\n\u003Cp\u003EFYI, part names in urls have \u0027_\u0027 instead of \u0027.\u0027 in the name. Here\u0027s an improved version of findPartMod:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Estring findPartMod(AvailablePart part)\u003Cbr\u003E{\u003Cbr\u003E    string mod = \u0022\u0022;\u003Cbr\u003E    UrlDir.UrlConfig config = Array.Find\u0026lt;UrlDir.UrlConfig\u0026gt;(configs, (c =\u0026gt; part.name == c.name.Replace(\u0027_\u0027, \u0027.\u0027)));\u003Cbr\u003E    if (config != null)\u003Cbr\u003E    {\u003Cbr\u003E        var id = new UrlDir.UrlIdentifier(config.url);\u003Cbr\u003E        mod = id[0];\u003Cbr\u003E    }\u003Cbr\u003E\u003Cbr\u003E    return mod;\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"}]}