{"TopicId":71208,"ForumId":29,"TopicTitle":"When the part config and the save file are different","CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-02T09:40:57Z","PageNum":1,"Articles":[{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-02T09:40:57Z","Content":"\n\u003Cp\u003EI am experiencing some strange problems when I chnage my configurations around. In particular if I remove a MODULE from a PART in its config and add a different one, then things go a bit strange if I load a save file containing a vessel with the PART with the original MODULE. I am not sure what is going on here. I thought that the game would just create the part and at the modules as described in the save file. How can changing the .cfg file for the part influence the part in the save.\u003C/p\u003E\u003Cp\u003EAnyone cleverer that me know the answer to this one?\u003C/p\u003E\n"},{"CreatedByName":"UbioZur","CreatedById":72946,"CreatedDateTime":"2014-05-02T14:37:10Z","Content":"\n\u003Cp\u003EI guess since some modules variable are saved in the persistent file (look at the field). this would be why, it may try to load those data to a non existing variable for the part.\u003C/p\u003E\n"},{"CreatedByName":"NathanKell","CreatedById":75006,"CreatedDateTime":"2014-05-02T17:36:47Z","Content":"\n\u003Cp\u003EKSP has a part-loading issue: if the order of modules in the prefab differs from the order of confignodes for modules in the .craft or .sfs file\u0027s entry for that part, the [persistent] data in them won\u0027t be loaded into the prefab when it\u0027s instanced for use.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-02T19:32:14Z","Content":"\n\u003Cp\u003EI have to confess that I d not fully understand how the code works in relation to prefabs. I kind of get it, but it do not understand when the prefab gets created and how it is used to create the actual part.\u003C/p\u003E\n"},{"CreatedByName":"NathanKell","CreatedById":75006,"CreatedDateTime":"2014-05-02T21:49:16Z","Content":"\n\u003Cp\u003EWell, I don\u0027t claim to have this down 100%, but here\u0027s my understanding:\u003C/p\u003E\u003Cp\u003EOn game load, the game goes through all PART{} confignodes creating Part objects (and running OnLoad for them and their modules based off the part.cfg). These are the prefabs. Then, when you place a part (in the VAB), or you load a craft file in the VAB (with its parts) or the game loads an sfs file (with vessels with parts), the game instantiates (clones) each part off the prefab, updating it via calling OnLoad fed by the peristent confignode (in .craft or .sfs) which contains all the updated persistent fields. So the prefab is cloned into a new object, and its fields (and its modules\u0027 fields) are updated to their \u0022customized\u0022 values, to create that actual as-saved part.\u003C/p\u003E\u003Cp\u003EThen, when the .craft is saved, or the vessel goes on rails (and eventually is saved to sfs), everything has OnSave called, which builds the persistent confignodes.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-03T21:29:27Z","Content":"\n\u003Cp\u003EHmmm. OK I think I am slowly expanding my understanding on this, but there are still thinks that are not clear. My particular problem now is this:\u003C/p\u003E\u003Cp\u003EI have a KSPAddon that in its Start method added a Module to some of the part prefabs and sets the value of persistable fields within that module. This all seems for work well. However when the prefab is cloned to create an actual Part the cloned part does have my new Module attached, but the values of the persistable fields have not been copied across to the actual part.\u003C/p\u003E\u003Cp\u003EAny ideas on what is going on here?\u003C/p\u003E\n"},{"CreatedByName":"NathanKell","CreatedById":75006,"CreatedDateTime":"2014-05-04T01:13:01Z","Content":"\n\u003Cp\u003EOther than the fact that serialization is screwed up *so* badly (see how much breaks when you clone a part in the VAB or do symmetry...), not offhand.\u003C/p\u003E\u003Cp\u003EWait, *what* fields are marked persistent? Can you paste the code block that defines them? Might help some.\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-04T06:16:07Z","Content":"\n\u003Cp\u003EHere is some code.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003Eusing System.Reflection;\u003Cbr\u003E\u003Cbr\u003Enamespace ConnectedLivingSpace\u003Cbr\u003E{\u003Cbr\u003E    // This module will be added at runtime to any part that also has a ModuleDockingNode. There will be a one to one relationship between ModuleDockingHatch and ModuleDockingNode\u003Cbr\u003E    public class ModuleDockingHatch : PartModule\u003Cbr\u003E    {\u003Cbr\u003E        [KSPField(isPersistant = true)]\u003Cbr\u003E        private bool hatchOpen;\u003Cbr\u003E\u003Cbr\u003E        [KSPField(isPersistant = true)]\u003Cbr\u003E        private string docNodeAttachmentNodeName;\u003Cbr\u003E        [KSPField(isPersistant = true)]\u003Cbr\u003E        private string docNodeTransformName;\u003Cbr\u003E        internal  ModuleDockingNode modDockNode;\u003Cbr\u003E\u003Cbr\u003E        public bool HatchOpen\u003Cbr\u003E        {\u003Cbr\u003E            get\u003Cbr\u003E            {\u003Cbr\u003E                return this.hatchOpen;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            set\u003Cbr\u003E            {\u003Cbr\u003E                this.hatchOpen = value;\u003Cbr\u003E\u003Cbr\u003E                if (value)\u003Cbr\u003E                {\u003Cbr\u003E                    this.hatchStatus = \u0022Open\u0022;\u003Cbr\u003E                }\u003Cbr\u003E                else\u003Cbr\u003E                {\u003Cbr\u003E                    this.hatchStatus = \u0022Closed\u0022;\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        [KSPField(isPersistant = false, guiActive = true, guiName = \u0022Hatch status\u0022)]\u003Cbr\u003E        private string hatchStatus = \u0022\u0022;\u003Cbr\u003E\u003Cbr\u003E        [KSPEvent(active = true, guiActive = true, guiName = \u0022Open Hatch\u0022)]\u003Cbr\u003E        private void OpenHatch()\u003Cbr\u003E        {\u003Cbr\u003E            bool docked = isInDockedState();\u003Cbr\u003E\u003Cbr\u003E            if (docked)\u003Cbr\u003E            {\u003Cbr\u003E                this.HatchOpen = true;\u003Cbr\u003E                this.Events[\u0022CloseHatch\u0022].active = true;\u003Cbr\u003E                this.Events[\u0022OpenHatch\u0022].active = false;\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                this.HatchOpen = false;\u003Cbr\u003E                this.Events[\u0022CloseHatch\u0022].active = false;\u003Cbr\u003E                this.Events[\u0022OpenHatch\u0022].active = false;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            // Finally fire the VesselChange event to cause the CLSAddon to re-evaluate everything. ActiveVEssel is only available in flight, but then it should only be possible to open and close hatches in flight so we should be OK.\u003Cbr\u003E            GameEvents.onVesselChange.Fire(FlightGlobals.ActiveVessel);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        [KSPEvent(active = true, guiActive = true, guiName = \u0022Close Hatch\u0022)]\u003Cbr\u003E        private void CloseHatch()\u003Cbr\u003E        {\u003Cbr\u003E            bool docked = isInDockedState();\u003Cbr\u003E\u003Cbr\u003E            this.HatchOpen = false;\u003Cbr\u003E\u003Cbr\u003E            this.Events[\u0022CloseHatch\u0022].active = false;\u003Cbr\u003E            if (isInDockedState())\u003Cbr\u003E            {\u003Cbr\u003E                this.Events[\u0022OpenHatch\u0022].active = true;\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                this.Events[\u0022OpenHatch\u0022].active = false;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            // Finally fire the VesselChange event to cause the CLSAddon to re-evaluate everything. ActiveVEssel is only available in flight, but then it should only be possible to open and close hatches in flight so we should be OK.\u003Cbr\u003E            GameEvents.onVesselChange.Fire(FlightGlobals.ActiveVessel);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public override void OnLoad(ConfigNode node)\u003Cbr\u003E        {\u003Cbr\u003E            Debug.Log(\u0022OnLoad\u0022);\u003Cbr\u003E            Debug.Log(\u0022this.docNodeAttachmentNodeName: \u0022 \u002B this.docNodeAttachmentNodeName);\u003Cbr\u003E            Debug.Log(\u0022this.docNodeTransformName: \u0022 \u002B this.docNodeTransformName);\u003Cbr\u003E            Debug.Log(\u0022node.GetValue(docNodeTransformName): \u0022 \u002B node.GetValue(\u0022docNodeTransformName\u0022));\u003Cbr\u003E            Debug.Log(\u0022node.GetValue(docNodeAttachmentNodeName): \u0022 \u002B node.GetValue(\u0022docNodeAttachmentNodeName\u0022));\u003Cbr\u003E\u003Cbr\u003E            // The Loader with have set hatchOpen, but not via the Property HatchOpen, so we need to re-do it to ensure that hatchStatus gets properly set.\u003Cbr\u003E            this.HatchOpen = this.hatchOpen;\u003Cbr\u003E\u003Cbr\u003E            // Set the GUI state of the open/close hatch events as appropriate\u003Cbr\u003E            if (isInDockedState())\u003Cbr\u003E            {\u003Cbr\u003E                if (this.HatchOpen)\u003Cbr\u003E                {\u003Cbr\u003E                    this.Events[\u0022CloseHatch\u0022].active = true;\u003Cbr\u003E                    this.Events[\u0022OpenHatch\u0022].active = false;\u003Cbr\u003E                }\u003Cbr\u003E                else\u003Cbr\u003E                {\u003Cbr\u003E                    this.Events[\u0022CloseHatch\u0022].active = false;\u003Cbr\u003E                    this.Events[\u0022OpenHatch\u0022].active = true;\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                this.Events[\u0022CloseHatch\u0022].active = false;\u003Cbr\u003E                this.Events[\u0022OpenHatch\u0022].active = false; \u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Called every physics frame. Make sure that the menu options are valid for the state that we are in. \u003Cbr\u003E        private void FixedUpdate()\u003Cbr\u003E        {\u003Cbr\u003E            if (isInDockedState())\u003Cbr\u003E            {\u003Cbr\u003E                if (!this.HatchOpen)\u003Cbr\u003E                {\u003Cbr\u003E                    // We are docked, but the hatch is closed. Make sure that it is possible to open the hatch\u003Cbr\u003E                    this.Events[\u0022CloseHatch\u0022].active = false;\u003Cbr\u003E                    this.Events[\u0022OpenHatch\u0022].active = true; \u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                // We are not docked - close up the hatch if it is open!\u003Cbr\u003E                if (this.HatchOpen)\u003Cbr\u003E                {\u003Cbr\u003E                    this.HatchOpen = false;\u003Cbr\u003E                    this.Events[\u0022CloseHatch\u0022].active = false;\u003Cbr\u003E                    this.Events[\u0022OpenHatch\u0022].active = false; \u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // TODO is this necassery now that we ar eusing FixedUpdate and no OnFixedUpdate?\u003Cbr\u003E        public override void OnStart(PartModule.StartState st)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022ModuleDockingNodeHatch::OnStart\u0022);\u003Cbr\u003E\u003Cbr\u003E            // As long as we have not started in the editor, ensure the module is active / enabled.\u003Cbr\u003E            if (st != StartState.Editor)\u003Cbr\u003E            {\u003Cbr\u003E                //Debug.Log(\u0022ModuleDockingNodeHatch::OnStart setting enabled = true\u0022);\u003Cbr\u003E                this.enabled = true;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private bool CheckModuleDockingNode()\u003Cbr\u003E        {\u003Cbr\u003E            if (null == this.modDockNode)\u003Cbr\u003E            {\u003Cbr\u003E                // We do not know which ModuleDockingNode we are attached to yet. Try to find one.\u003Cbr\u003E                foreach (ModuleDockingNode dockNode in this.part.Modules.OfType\u0026lt;ModuleDockingNode\u0026gt;())\u003Cbr\u003E                {\u003Cbr\u003E                    if (IsRelatedDockingNode(dockNode))\u003Cbr\u003E                    {\u003Cbr\u003E                        this.modDockNode = dockNode;\u003Cbr\u003E                        return true;\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                return true;\u003Cbr\u003E            }\u003Cbr\u003E            return false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // This method allows us to check if a specified ModuleDockingNode is one that this hatch is attached to\u003Cbr\u003E        internal bool IsRelatedDockingNode(ModuleDockingNode dockNode)\u003Cbr\u003E        {\u003Cbr\u003E            if (dockNode.nodeTransformName == this.docNodeTransformName)\u003Cbr\u003E            {\u003Cbr\u003E                this.modDockNode = dockNode;\u003Cbr\u003E                return true;\u003Cbr\u003E            }\u003Cbr\u003E            if (dockNode.referenceAttachNode == this.docNodeAttachmentNodeName)\u003Cbr\u003E            {\u003Cbr\u003E                this.modDockNode = dockNode;\u003Cbr\u003E                return true;\u003Cbr\u003E            }\u003Cbr\u003E            return false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // tries to work out if the docking port is docked based on the state\u003Cbr\u003E        private bool isInDockedState()\u003Cbr\u003E        {\u003Cbr\u003E            // First ensure that we know which ModuleDockingNode we are reffering to.\u003Cbr\u003E            if (CheckModuleDockingNode())\u003Cbr\u003E            {\u003Cbr\u003E                if (this.modDockNode.state == \u0022Docked (dockee)\u0022 || this.modDockNode.state == \u0022Docked (docker)\u0022)\u003Cbr\u003E                {\u003Cbr\u003E                    return true;\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                // This is bad - it means there is a hatch that we can not match to a docking node. This should not happen. We will log an error but it will likely spam the log.\u003Cbr\u003E                Debug.LogError(\u0022 Error - Docking port hatch can not find its ModuleDockingNode docNodeTransformName:\u0022 \u002B this.docNodeTransformName \u002B \u0022 docNodeAttachmentNodeName \u0022 \u002B this.docNodeAttachmentNodeName);\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            return false;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Method that cna be used to set up the ModuleDockingNode that this ModuleDockingHatch reffers to.\u003Cbr\u003E        public void AttachModuleDockingNode(ModuleDockingNode _modDocNode)\u003Cbr\u003E        {\u003Cbr\u003E            this.modDockNode = _modDocNode;\u003Cbr\u003E\u003Cbr\u003E            this.docNodeTransformName = _modDocNode.nodeTransformName;\u003Cbr\u003E            this.docNodeAttachmentNodeName = _modDocNode.referenceAttachNode;\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E...and here is some more for the Addon that adds a ModuleDockingHatch for each ModuleDockingNode in the part.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Eusing System;\u003Cbr\u003Eusing System.Collections.Generic;\u003Cbr\u003Eusing System.Linq;\u003Cbr\u003Eusing System.Text;\u003Cbr\u003Eusing System.Reflection;\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003Eusing Toolbar;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Enamespace ConnectedLivingSpace\u003Cbr\u003E{\u003Cbr\u003E    [KSPAddonFixedCLS(KSPAddon.Startup.EveryScene, false, typeof(CLSAddon))]\u003Cbr\u003E    public class CLSAddon : MonoBehaviour\u003Cbr\u003E    {\u003Cbr\u003E        private static Rect windowPosition = new Rect(0,0,320,360);\u003Cbr\u003E        private static GUIStyle windowStyle = null;\u003Cbr\u003E\u003Cbr\u003E        private Vector2 scrollViewer = Vector2.zero;\u003Cbr\u003E\u003Cbr\u003E        private CLSVessel vessel = null;\u003Cbr\u003E        private int selectedSpace = -1;\u003Cbr\u003E\u003Cbr\u003E        private IButton toolbarButton = null; // Toolbar button\u003Cbr\u003E        private bool visable = false;\u003Cbr\u003E\u003Cbr\u003E        private int editorPartCount = 0; // This is horrible. Because there does not seem to be an obvious callback to sink when parts are added and removed in the editor, on each fixed update we will could the parts and if it has changed then rebuild the CLSVessel. Yuk!\u003Cbr\u003E\u003Cbr\u003E        private int sanityCheckCounter = 0;\u003Cbr\u003E        private int sanityCheckFrequency = 100; // Change this to make the sanity checks more or less frequent.\u003Cbr\u003E\u003Cbr\u003E        private string spaceNameEditField;\u003Cbr\u003E\u003Cbr\u003E        public CLSVessel Vessel\u003Cbr\u003E        {\u003Cbr\u003E            get \u003Cbr\u003E            {\u003Cbr\u003E                return this.vessel;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public static CLSAddon Instance\u003Cbr\u003E        {\u003Cbr\u003E            get;\u003Cbr\u003E            private set;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public CLSAddon()\u003Cbr\u003E        {\u003Cbr\u003E            if (Instance == null)\u003Cbr\u003E            {\u003Cbr\u003E                Instance = this;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Awake() \u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon:Awake\u0022);\u003Cbr\u003E\u003Cbr\u003E            this.toolbarButton = ToolbarManager.Instance.add(\u0022ConnectedLivingSpace\u0022, \u0022buttonCLS\u0022);\u003Cbr\u003E\t\t\tthis.toolbarButton.TexturePath = \u0022ConnectedLivingSpace/assets/cls_icon_off\u0022;\u003Cbr\u003E            this.toolbarButton.ToolTip = \u0022Connected Living Space\u0022;\u003Cbr\u003E            this.toolbarButton.OnClick \u002B= (e) =\u0026gt; { OnToolbarButton_Click(); };\u003Cbr\u003E            this.toolbarButton.Visibility = new GameScenesVisibility(GameScenes.EDITOR, GameScenes.SPH, GameScenes.FLIGHT);\u003Cbr\u003E\u003Cbr\u003E            this.selectedSpace = -1;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Start() \u003Cbr\u003E        {\u003Cbr\u003E            // Debug.Log(\u0022CLSAddon:Start\u0022);\u003Cbr\u003E\u003Cbr\u003E            windowStyle = new GUIStyle(HighLogic.Skin.window);\u003Cbr\u003E\u003Cbr\u003E            try\u003Cbr\u003E            {\u003Cbr\u003E                RenderingManager.RemoveFromPostDrawQueue(0, OnDraw);\u003Cbr\u003E            }\u003Cbr\u003E            catch (Exception ex)\u003Cbr\u003E            {\u003Cbr\u003E\t\t\t\tDebug.LogException(ex);\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            if (HighLogic.LoadedSceneIsEditor || HighLogic.LoadedSceneIsFlight)\u003Cbr\u003E            {\u003Cbr\u003E                RenderingManager.AddToPostDrawQueue(0, OnDraw);\u003Cbr\u003E                GameEvents.onJointBreak.Add(OnJointBreak);\u003Cbr\u003E                GameEvents.onPartAttach.Add(OnPartAttach);\u003Cbr\u003E                GameEvents.onPartCouple.Add(OnPartCouple);\u003Cbr\u003E                GameEvents.onPartDie.Add(OnPartDie);\u003Cbr\u003E                GameEvents.onPartExplode.Add(OnPartExplode);\u003Cbr\u003E                GameEvents.onPartRemove.Add(OnPartRemove);\u003Cbr\u003E                GameEvents.onPartUndock.Add(OnPartUndock);\u003Cbr\u003E                GameEvents.onStageSeparation.Add(OnStageSeparation);\u003Cbr\u003E                GameEvents.onUndock.Add(OnUndock);\u003Cbr\u003E                GameEvents.onVesselCreate.Add(OnVesselCreate);\u003Cbr\u003E                GameEvents.onVesselDestroy.Add(OnVesselDestroy);\u003Cbr\u003E                GameEvents.onVesselWasModified.Add(OnVesselWasModified);\u003Cbr\u003E                GameEvents.onVesselChange.Add(OnVesselChange);\u003Cbr\u003E                GameEvents.onVesselLoaded.Add(OnVesselLoaded);\u003Cbr\u003E                GameEvents.onVesselTerminated.Add(OnVesselTerminated);\u003Cbr\u003E                GameEvents.onFlightReady.Add(OnFlightReady);\u003Cbr\u003E\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            // Add the CLSModule to all parts that can house crew (and do not already have it).\u003Cbr\u003E            AddModuleToParts();\u003Cbr\u003E\u003Cbr\u003E            // Add the ModuleDockingNodeHatch to all the Docking Nodes\u003Cbr\u003E            AddHatchModuleToParts();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private void OnToolbarButton_Click()\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022OnToolbarButton_Click\u0022);\u003Cbr\u003E\u003Cbr\u003E            // If the window is currently visible, set the selected space back to -1 so the highlighting is cleared.\u003Cbr\u003E            if (this.visable) \u003Cbr\u003E            {\u003Cbr\u003E\t\t\t\tif (null != this.vessel) \u003Cbr\u003E                {\u003Cbr\u003E\t\t\t\t\tvessel.Highlight (false);\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t\tthis.selectedSpace = -1;\u003Cbr\u003E\t\t\t\tthis.toolbarButton.TexturePath = \u0022ConnectedLivingSpace/assets/cls_icon_off\u0022;\u003Cbr\u003E\t\t\t} \u003Cbr\u003E            else \u003Cbr\u003E            {\u003Cbr\u003E                this.toolbarButton.TexturePath = \u0022ConnectedLivingSpace/assets/cls_icon_on\u0022;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E            this.visable = !this.visable;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private void OnFlightReady()\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnFlightReady\u0022);          \u003Cbr\u003E\u003Cbr\u003E            // Now scan the vessel\u003Cbr\u003E            //Debug.Log(\u0022Calling RebuildCLSVessel from onFlightReady\u0022);\u003Cbr\u003E            this.RebuildCLSVessel();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private void OnVesselLoaded(Vessel data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnVesselLoaded\u0022);\u003Cbr\u003E\u003Cbr\u003E            //Debug.Log(\u0022Calling RebuildCLSVessel from OnVesselLoaded\u0022);\u003Cbr\u003E            RebuildCLSVessel(data);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnVesselTerminated(ProtoVessel data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnVesselTerminated\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnJointBreak(EventReport eventReport)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnJointBreak\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnPartAttach(GameEvents.HostTargetAction\u0026lt;Part, Part\u0026gt; data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnPartAttach\u0022); \u003Cbr\u003E        }\u003Cbr\u003E        private void OnPartCouple(GameEvents.FromToAction \u0026lt;Part, Part\u0026gt; data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnPartCouple\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnPartDie(Part data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnPartDie\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnPartExplode(GameEvents.ExplosionReaction data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnPartExplode\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnPartRemove(GameEvents.HostTargetAction\u0026lt;Part, Part\u0026gt; data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnPartRemove\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnPartUndock(Part data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnPartUndock\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnStageSeparation(EventReport eventReport)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnStageSeparation\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnUndock(EventReport eventReport)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnUndock\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnVesselDestroy(Vessel data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnVesselDestroy\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnVesselCreate(Vessel data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnVesselCreate\u0022);\u003Cbr\u003E        }\u003Cbr\u003E        private void OnVesselWasModified(Vessel data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnVesselWasModified\u0022);\u003Cbr\u003E\u003Cbr\u003E            //Debug.Log(\u0022Calling RebuildCLSVessel from OnVesselWasModified\u0022);\u003Cbr\u003E\u003Cbr\u003E            RebuildCLSVessel(data);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // This event is fired when the vessel is changed. If this happens we need to throw away all of our thoiughts about the previous vessel, and analyse the new one.\u003Cbr\u003E        private void OnVesselChange(Vessel data)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnVesselChange\u0022);\u003Cbr\u003E\u003Cbr\u003E            //Debug.Log(\u0022Calling RebuildCLSVessel from OnVesselChange\u0022);\u003Cbr\u003E            RebuildCLSVessel(data);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private void OnDraw()\u003Cbr\u003E        {\u003Cbr\u003E            if (this.visable)\u003Cbr\u003E            {\u003Cbr\u003E                windowPosition = GUILayout.Window(947695, windowPosition, OnWindow, \u0022Connected Living Space\u0022, windowStyle,GUILayout.MinHeight(20));\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        private void RebuildCLSVessel()\u003Cbr\u003E        {\u003Cbr\u003E            if (HighLogic.LoadedSceneIsFlight)\u003Cbr\u003E            {\u003Cbr\u003E                RebuildCLSVessel(FlightGlobals.ActiveVessel);\u003Cbr\u003E            }\u003Cbr\u003E            else if (HighLogic.LoadedSceneIsEditor)\u003Cbr\u003E            {\u003Cbr\u003E                RebuildCLSVessel(EditorLogic.startPod);\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private void RebuildCLSVessel(Vessel newVessel)\u003Cbr\u003E        {\u003Cbr\u003E            RebuildCLSVessel(newVessel.rootPart);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private void RebuildCLSVessel(Part newRootPart)\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022RebuildCLSVessel\u0022);\u003Cbr\u003E            // Before we rebuild the vessel, we need to take some steps to tidy up the highlighting and our idea of which space is the selected space. We will make a list of all the parts that are currently in the selected space. We will also unhighlight parts that are highlighted. Once the rebuild is complete we will work out which space will be the selected space based on the first part in our list that we find in oneof the new spaces. We can then highlight that new space.\u003Cbr\u003E\u003Cbr\u003E            List\u0026lt;uint\u0026gt; listSelectedParts = new List\u0026lt;uint\u0026gt;();\u003Cbr\u003E\u003Cbr\u003E            if (-1 != selectedSpace)\u003Cbr\u003E            {\u003Cbr\u003E                foreach (CLSPart p in vessel.Spaces[selectedSpace].Parts)\u003Cbr\u003E                {\u003Cbr\u003E                    Part part = (Part)p;\u003Cbr\u003E                    listSelectedParts.Add(part.flightID);\u003Cbr\u003E                    //Debug.Log(\u0022Part : \u0022\u002B part.flightID \u002B \u0022 currently in use.\u0022 ) ;\u003Cbr\u003E                }\u003Cbr\u003E\u003Cbr\u003E                vessel.Spaces[selectedSpace].Highlight(false);\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            //Debug.Log(\u0022Old selected space had \u0022\u002BlistSelectedParts.Count \u002B \u0022 parts in it.\u0022);\u003Cbr\u003E\u003Cbr\u003E            // Tidy up the old vessel information\u003Cbr\u003E            if (null != this.vessel)\u003Cbr\u003E            {\u003Cbr\u003E                vessel.Clear();\u003Cbr\u003E            }\u003Cbr\u003E            this.vessel = null;\u003Cbr\u003E\u003Cbr\u003E            // Build new vessel information\u003Cbr\u003E            this.vessel = new CLSVessel();\u003Cbr\u003E            this.vessel.Populate(newRootPart);\u003Cbr\u003E\u003Cbr\u003E            // Now work out which space should be highlighted.\u003Cbr\u003E            this.selectedSpace = -1;\u003Cbr\u003E            foreach (CLSPart clsPart in this.vessel.Parts)\u003Cbr\u003E            {\u003Cbr\u003E                Part p = clsPart;\u003Cbr\u003E\u003Cbr\u003E                //Debug.Log(\u0022New vessel contains part : \u0022 \u002B p.flightID);\u003Cbr\u003E\u003Cbr\u003E                if (listSelectedParts.Contains(p.flightID))\u003Cbr\u003E                {\u003Cbr\u003E                    //Debug.Log(\u0022Part \u0022 \u002B p.partInfo.title \u002B \u0022 was in the old selected space and is in the CLSVessel\u0022);\u003Cbr\u003E                    if (clsPart.Space != null)\u003Cbr\u003E                    {\u003Cbr\u003E                        // We have found the new space for a part that was in the old selected space.\u003Cbr\u003E                        this.selectedSpace = this.vessel.Spaces.IndexOf(clsPart.Space);\u003Cbr\u003E                        //Debug.Log(\u0022... it is also part of a space. We will use that space to be our new selected space. index:\u0022 \u002B this.selectedSpace);\u003Cbr\u003E                        break;\u003Cbr\u003E                    }\u003Cbr\u003E                    else\u003Cbr\u003E                    {\u003Cbr\u003E                        //Debug.Log(\u0022it is no longer part of a space :(\u0022);\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            if (this.selectedSpace != -1)\u003Cbr\u003E            {\u003Cbr\u003E                this.vessel.Spaces[this.selectedSpace].Highlight(true);\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E            {\u003Cbr\u003E                //Debug.Log(\u0022No space is selected after the rebuild.\u0022);\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            // Sanity check the selected space. If the CLSvessel has been rebuilt and there are no Spaces, or it references an out of range space then set it to -1\u003Cbr\u003E\u003Cbr\u003E            if (vessel.Spaces.Count == 0 || vessel.Spaces.Count \u0026lt;= this.selectedSpace)\u003Cbr\u003E            {\u003Cbr\u003E                this.selectedSpace = -1;\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        private void OnWindow(int windowID)\u003Cbr\u003E        {\u003Cbr\u003E            try\u003Cbr\u003E            {\u003Cbr\u003E                // Build a string descibing the contents of each of the spaces.\u003Cbr\u003E                if (null != this.vessel)\u003Cbr\u003E                {\u003Cbr\u003E                    GUILayout.BeginVertical();\u003Cbr\u003E\u003Cbr\u003E                    String[] spaceNames = new String[vessel.Spaces.Count];\u003Cbr\u003E                    int counter = 0;\u003Cbr\u003E                    int newSelectedSpace = -1;\u003Cbr\u003E\u003Cbr\u003E                    String partsList = \u0022\u0022;\u003Cbr\u003E                    foreach (CLSSpace space in vessel.Spaces)\u003Cbr\u003E                    {\u003Cbr\u003E                        if (space.Name == \u0022\u0022)\u003Cbr\u003E                        {\u003Cbr\u003E                            spaceNames[counter] = \u0022Living Space \u0022 \u002B (counter \u002B 1).ToString();\u003Cbr\u003E                        }\u003Cbr\u003E                        else\u003Cbr\u003E                        {\u003Cbr\u003E                            spaceNames[counter] = space.Name;\u003Cbr\u003E                        }\u003Cbr\u003E                        counter\u002B\u002B;\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    if (vessel.Spaces.Count \u0026gt; 0)\u003Cbr\u003E                    {\u003Cbr\u003E                        newSelectedSpace = GUILayout.SelectionGrid(this.selectedSpace, spaceNames, counter);\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    // If one of the spaces has been selected then display a list of parts that make it up and sort out the highlighting\u003Cbr\u003E                    if (-1 != newSelectedSpace)\u003Cbr\u003E                    {\u003Cbr\u003E                        // Only fiddle witht he highlighting is the selected space has actually changed\u003Cbr\u003E                        if (newSelectedSpace != this.selectedSpace)\u003Cbr\u003E                        {\u003Cbr\u003E                            // First unhighlight the space that was selected.\u003Cbr\u003E                            if (-1 != this.selectedSpace \u0026amp;\u0026amp; this.selectedSpace \u0026lt; this.vessel.Spaces.Count)\u003Cbr\u003E                            {\u003Cbr\u003E                                vessel.Spaces[this.selectedSpace].Highlight(false);\u003Cbr\u003E                            }\u003Cbr\u003E\u003Cbr\u003E                            // Update the space that has been selected.\u003Cbr\u003E                            this.selectedSpace = newSelectedSpace;\u003Cbr\u003E\u003Cbr\u003E                            // Update the text in the Space edit box\u003Cbr\u003E                            this.spaceNameEditField = vessel.Spaces[this.selectedSpace].Name;\u003Cbr\u003E\u003Cbr\u003E                            // Highlight the new space\u003Cbr\u003E                            vessel.Spaces[this.selectedSpace].Highlight(true);\u003Cbr\u003E                        }\u003Cbr\u003E\u003Cbr\u003E                        // Loop through all the parts in the newly selected space and create a list of all the spaces in it.\u003Cbr\u003E                        foreach (CLSPart p in vessel.Spaces[this.selectedSpace].Parts)\u003Cbr\u003E                        {\u003Cbr\u003E                            Part part = (Part)p;\u003Cbr\u003E                            partsList \u002B= part.partInfo.title \u002B \u0022\\n\u0022;\u003Cbr\u003E                        }\u003Cbr\u003E\u003Cbr\u003E                        // Display the text box that allows the space name to be changed\u003Cbr\u003E                        GUILayout.BeginHorizontal();\u003Cbr\u003E                        GUILayout.Label(\u0022Space Name:\u0022);\u003Cbr\u003E                        this.spaceNameEditField = GUILayout.TextField(this.spaceNameEditField);\u003Cbr\u003E                        if (GUILayout.Button(\u0022Update\u0022))\u003Cbr\u003E                        {\u003Cbr\u003E                            vessel.Spaces[this.selectedSpace].Name = this.spaceNameEditField;\u003Cbr\u003E                        }\u003Cbr\u003E                        GUILayout.EndHorizontal();\u003Cbr\u003E\u003Cbr\u003E                        this.scrollViewer = GUILayout.BeginScrollView(this.scrollViewer,GUILayout.ExpandHeight(true),GUILayout.ExpandWidth(true));\u003Cbr\u003E                        GUILayout.BeginVertical();\u003Cbr\u003E\u003Cbr\u003E                        // Display the crew capacity of the space.\u003Cbr\u003E                        GUILayout.Label(\u0022Crew Capacity: \u0022 \u002B vessel.Spaces[this.selectedSpace].MaxCrew);\u003Cbr\u003E\u003Cbr\u003E                        // And list the crew names\u003Cbr\u003E                        String crewList = \u0022Crew Info:\\n\u0022;\u003Cbr\u003E\u003Cbr\u003E                        foreach(CLSKerbal crewMember in vessel.Spaces[this.selectedSpace].Crew)\u003Cbr\u003E                        {\u003Cbr\u003E                            crewList \u002B= ((ProtoCrewMember)crewMember).name \u002B\u0022\\n\u0022;\u003Cbr\u003E                        }\u003Cbr\u003E                        GUILayout.Label(crewList);\u003Cbr\u003E\u003Cbr\u003E                        // Display the list of component parts.\u003Cbr\u003E                        GUILayout.Label(partsList);\u003Cbr\u003E\u003Cbr\u003E                        GUILayout.EndVertical();\u003Cbr\u003E                        GUILayout.EndScrollView();\u003Cbr\u003E\u003Cbr\u003E                    }\u003Cbr\u003E                    GUILayout.EndVertical();\u003Cbr\u003E                }\u003Cbr\u003E                else\u003Cbr\u003E                {\u003Cbr\u003E                    Debug.LogError(\u0022this.vessel was null\u0022);\u003Cbr\u003E                }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                GUI.DragWindow();\u003Cbr\u003E            }\u003Cbr\u003E            catch (Exception ex)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogException(ex);\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void Update()\u003Cbr\u003E        {\u003Cbr\u003E            // Debug.Log(\u0022CLSAddon:Update\u0022);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void FixedUpdate()\u003Cbr\u003E        {\u003Cbr\u003E            try\u003Cbr\u003E            {\u003Cbr\u003E                // Debug.Log(\u0022CLSAddon:FixedUpdate\u0022);\u003Cbr\u003E\u003Cbr\u003E                // If we are in the editor, and there is a ship in the editor, then compare the number of parts to last time we did this. If it has changed then rebuild the CLSVessel\u003Cbr\u003E                if (HighLogic.LoadedSceneIsEditor)\u003Cbr\u003E                {\u003Cbr\u003E                    int currentPartCount = 0;\u003Cbr\u003E                    if (null == EditorLogic.startPod)\u003Cbr\u003E                    {\u003Cbr\u003E                        currentPartCount = 0; // I know that this is already 0, but just to make the point - if there is no startPod in the editor, then there are no parts in the vessel.\u003Cbr\u003E                    }\u003Cbr\u003E                    else\u003Cbr\u003E                    {\u003Cbr\u003E                        currentPartCount = EditorLogic.SortedShipList.Count;\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    if (currentPartCount != this.editorPartCount)\u003Cbr\u003E                    {\u003Cbr\u003E                        Debug.Log(\u0022Calling RebuildCLSVessel as the part count has changed in the editor\u0022);\u003Cbr\u003E\u003Cbr\u003E                        this.RebuildCLSVessel();\u003Cbr\u003E                        this.editorPartCount = currentPartCount;\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E                else if (HighLogic.LoadedSceneIsFlight)\u003Cbr\u003E                {\u003Cbr\u003E                    // In flight, run the sanity checker.\u003Cbr\u003E                    if (FlightGlobals.ready)\u003Cbr\u003E                    {\u003Cbr\u003E                        // Do not run the sanity checker if the CLSVessel (and hence all the CLS parts) has not yet been constructed.\u003Cbr\u003E                        if (null != this.vessel)\u003Cbr\u003E                        {\u003Cbr\u003E                            // Only run the sanity check every now and again!\u003Cbr\u003E                            this.sanityCheckCounter\u002B\u002B;\u003Cbr\u003E                            this.sanityCheckCounter = this.sanityCheckCounter % this.sanityCheckFrequency;\u003Cbr\u003E\u003Cbr\u003E                            // Debug.Log(\u0022sanityCheckCounter: \u0022 \u002B sanityCheckCounter);\u003Cbr\u003E\u003Cbr\u003E                            if (1 == this.sanityCheckCounter) // but running the checker when the counter is one, we know that we can force the check on the next physics frame by setting it to 0.\u003Cbr\u003E                            {\u003Cbr\u003E                                this.SanityCheck();\u003Cbr\u003E                            }\u003Cbr\u003E                        }\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            catch (Exception ex)\u003Cbr\u003E            {\u003Cbr\u003E                Debug.LogException(ex);\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        public void OnDestroy()\u003Cbr\u003E        {\u003Cbr\u003E            //Debug.Log(\u0022CLSAddon::OnDestroy\u0022);\u003Cbr\u003E            GameEvents.onVesselWasModified.Remove(OnVesselWasModified);\u003Cbr\u003E            GameEvents.onVesselChange.Remove(OnVesselChange);\u003Cbr\u003E            GameEvents.onJointBreak.Remove(OnJointBreak);\u003Cbr\u003E            GameEvents.onPartAttach.Remove(OnPartAttach);\u003Cbr\u003E            GameEvents.onPartCouple.Remove(OnPartCouple);\u003Cbr\u003E            GameEvents.onPartDie.Remove(OnPartDie);\u003Cbr\u003E            GameEvents.onPartExplode.Remove(OnPartExplode);\u003Cbr\u003E            GameEvents.onPartRemove.Remove(OnPartRemove);\u003Cbr\u003E            GameEvents.onPartUndock.Remove(OnPartUndock);\u003Cbr\u003E            GameEvents.onStageSeparation.Remove(OnStageSeparation);\u003Cbr\u003E            GameEvents.onUndock.Remove(OnUndock);\u003Cbr\u003E            GameEvents.onVesselCreate.Remove(OnVesselCreate);\u003Cbr\u003E            GameEvents.onVesselDestroy.Remove(OnVesselDestroy);\u003Cbr\u003E            GameEvents.onVesselWasModified.Remove(OnVesselWasModified);\u003Cbr\u003E            GameEvents.onVesselChange.Remove(OnVesselChange);\u003Cbr\u003E            GameEvents.onVesselTerminated.Remove(OnVesselTerminated);\u003Cbr\u003E            GameEvents.onVesselLoaded.Remove(OnVesselLoaded);\u003Cbr\u003E            GameEvents.onFlightReady.Remove(OnFlightReady);\u003Cbr\u003E\u003Cbr\u003E            // Remove the toolbar button\u003Cbr\u003E\u003Cbr\u003E            this.toolbarButton.Destroy();\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Method to ensure that all parts which have a crewcapacity \u0026gt;0 have a CLSModule attached to it.\u003Cbr\u003E        private void AddModuleToParts()\u003Cbr\u003E        {\u003Cbr\u003E            IEnumerable\u0026lt;AvailablePart\u0026gt; parts = PartLoader.LoadedPartsList.Where(p =\u0026gt; p.partPrefab != null \u0026amp;\u0026amp; p.partPrefab.CrewCapacity \u0026gt; 0);\u003Cbr\u003E            foreach (AvailablePart part in parts) \u003Cbr\u003E            {\u003Cbr\u003E                try\u003Cbr\u003E                {\u003Cbr\u003E                    if (part.name.Equals(\u0022kerbalEVA\u0022))\u003Cbr\u003E                    {\u003Cbr\u003E                        // Debug.Log(\u0022No CLS required for KerbalEVA!\u0022);\u003Cbr\u003E                    }\u003Cbr\u003E                    else\u003Cbr\u003E                    {\u003Cbr\u003E                        Part prefabPart = part.partPrefab;\u003Cbr\u003E\u003Cbr\u003E                        //Debug.Log(\u0022Adding ConnectedLivingSpace Support to \u0022 \u002B part.name \u002B \u0022/\u0022 \u002B prefabPart.partInfo.title);\u003Cbr\u003E\u003Cbr\u003E                        if (!prefabPart.Modules.Contains(\u0022ModuleConnectedLivingSpace\u0022))\u003Cbr\u003E                        {\u003Cbr\u003E                            //Debug.Log(\u0022The ModuleConnectedLivingSpace is missing!\u0022);\u003Cbr\u003E\u003Cbr\u003E                            ConfigNode node = new ConfigNode(\u0022MODULE\u0022);\u003Cbr\u003E                            node.AddValue(\u0022name\u0022, \u0022ModuleConnectedLivingSpace\u0022);\u003Cbr\u003E                            {\u003Cbr\u003E                                // This block is required as calling AddModule and passing in the node throws an exception if Awake has not been called. The method Awaken uses reflection to call then private method Awake. See http://forum.kerbalspaceprogram.com/threads/27851 for more information.\u003Cbr\u003E                                PartModule pm = prefabPart.AddModule(\u0022ModuleConnectedLivingSpace\u0022);\u003Cbr\u003E                                if (Awaken(pm))\u003Cbr\u003E                                {\u003Cbr\u003E                                    pm.Load(node);\u003Cbr\u003E                                }\u003Cbr\u003E                            }\u003Cbr\u003E                        }\u003Cbr\u003E                        else\u003Cbr\u003E                        {\u003Cbr\u003E                            // Debug.Log(\u0022The ModuleConnectedLivingSpace is already there.\u0022);\u003Cbr\u003E                        }\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E                catch (Exception ex)\u003Cbr\u003E                {\u003Cbr\u003E                    Debug.LogException(ex);\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Method to add Docking Hatches to all pars that have Dockong Nodes\u003Cbr\u003E        private void AddHatchModuleToParts()\u003Cbr\u003E        {\u003Cbr\u003E            IEnumerable\u0026lt;AvailablePart\u0026gt; parts = PartLoader.LoadedPartsList.Where(p =\u0026gt; p.partPrefab != null);\u003Cbr\u003E            foreach (AvailablePart part in parts)\u003Cbr\u003E            {\u003Cbr\u003E                try\u003Cbr\u003E                {\u003Cbr\u003E                    Part prefabPart = part.partPrefab;\u003Cbr\u003E\u003Cbr\u003E                    // If the prefab part does not have any modules set up then move to the next part\u003Cbr\u003E                    if (null == prefabPart.Modules)\u003Cbr\u003E                    {\u003Cbr\u003E                        continue;\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    List\u0026lt;ModuleDockingNode\u0026gt; listDockNodes = new List\u0026lt;ModuleDockingNode\u0026gt;();\u003Cbr\u003E                    List\u0026lt;ModuleDockingHatch\u0026gt; listDockHatches = new List\u0026lt;ModuleDockingHatch\u0026gt;();\u003Cbr\u003E\u003Cbr\u003E                    // Build a temporary list of docking node to consider. This is necassery can we can not add hatch modules to the modules list while we are enumerating the very same list!\u003Cbr\u003E                    foreach (ModuleDockingNode dockNode in prefabPart.Modules.OfType\u0026lt;ModuleDockingNode\u0026gt;())\u003Cbr\u003E                    {\u003Cbr\u003E                        listDockNodes.Add(dockNode);\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    foreach (ModuleDockingHatch dockHatch in prefabPart.Modules.OfType\u0026lt;ModuleDockingHatch\u0026gt;())\u003Cbr\u003E                    {\u003Cbr\u003E                        listDockHatches.Add(dockHatch);\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    foreach (ModuleDockingNode dockNode in listDockNodes)\u003Cbr\u003E                    {\u003Cbr\u003E                        // Does this docking node have a corresponding hatch?\u003Cbr\u003E                        ModuleDockingHatch hatch = null;\u003Cbr\u003E                        foreach (ModuleDockingHatch h in listDockHatches)\u003Cbr\u003E                        {\u003Cbr\u003E                            if (h.IsRelatedDockingNode(dockNode))\u003Cbr\u003E                            {\u003Cbr\u003E                                hatch = h;\u003Cbr\u003E                                break;\u003Cbr\u003E                            }\u003Cbr\u003E                        }\u003Cbr\u003E\u003Cbr\u003E                        if (null == hatch)\u003Cbr\u003E                        {\u003Cbr\u003E                            // There is no corresponding hatch - add one.\u003Cbr\u003E                            ConfigNode node = new ConfigNode(\u0022MODULE\u0022);\u003Cbr\u003E                            node.AddValue(\u0022name\u0022, \u0022ModuleDockingHatch\u0022);\u003Cbr\u003E\u003Cbr\u003E                            if (dockNode.referenceAttachNode != string.Empty)\u003Cbr\u003E                            {\u003Cbr\u003E                                Debug.Log(\u0022Adding ModuleDockingHatch to part \u0022 \u002B prefabPart.partInfo.title \u002B \u0022 and the docking node that uses attachNode \u0022 \u002B dockNode.referenceAttachNode);\u003Cbr\u003E                                node.AddValue(\u0022docNodeAttachmentNodeName\u0022, dockNode.referenceAttachNode);\u003Cbr\u003E                            }\u003Cbr\u003E                            else\u003Cbr\u003E                            {\u003Cbr\u003E                                if (dockNode.nodeTransformName != string.Empty)\u003Cbr\u003E                                {\u003Cbr\u003E                                    Debug.Log(\u0022Adding ModuleDockingHatch to part \u0022 \u002B prefabPart.partInfo.title \u002B \u0022 and the docking node that uses transform \u0022 \u002B dockNode.nodeTransformName);\u003Cbr\u003E                                    node.AddValue(\u0022docNodeTransformName\u0022, dockNode.nodeTransformName);\u003Cbr\u003E                                }\u003Cbr\u003E                            }\u003Cbr\u003E\u003Cbr\u003E                            {\u003Cbr\u003E                                // This block is required as calling AddModule and passing in the node throws an exception if Awake has not been called. The method Awaken uses reflection to call then private method Awake. See http://forum.kerbalspaceprogram.com/threads/27851 for more information.\u003Cbr\u003E                                PartModule pm = prefabPart.AddModule(\u0022ModuleDockingHatch\u0022);\u003Cbr\u003E                                if (Awaken(pm))\u003Cbr\u003E                                {\u003Cbr\u003E                                    Debug.Log(\u0022Loading the ModuleDockingHatch config\u0022);\u003Cbr\u003E                                    pm.Load(node);\u003Cbr\u003E                                }\u003Cbr\u003E                                else\u003Cbr\u003E                                {\u003Cbr\u003E                                    Debug.Log(\u0022Failed to call Awaken so the config has not been loaded.\u0022);\u003Cbr\u003E                                }\u003Cbr\u003E                            }\u003Cbr\u003E                        }\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E                catch (Exception ex)\u003Cbr\u003E                {\u003Cbr\u003E                    Debug.LogException(ex);\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        //This method uses reflection to call the Awake private method in PartModule. It turns out that Part.AddModule fails if Awake has not been called (which sometimes it has not). See http://forum.kerbalspaceprogram.com/threads/27851 for more info on this.\u003Cbr\u003E        public static bool Awaken(PartModule module)\u003Cbr\u003E        {\u003Cbr\u003E            // thanks to Mu and Kine for help with this bit of Dark Magic. \u003Cbr\u003E            // KINEMORTOBESTMORTOLOLOLOL\u003Cbr\u003E            if (module == null)\u003Cbr\u003E                return false;\u003Cbr\u003E            object[] paramList = new object[] { };\u003Cbr\u003E            MethodInfo awakeMethod = typeof(PartModule).GetMethod(\u0022Awake\u0022, BindingFlags.Instance | BindingFlags.NonPublic);\u003Cbr\u003E\u003Cbr\u003E            if (awakeMethod == null)\u003Cbr\u003E                return false;\u003Cbr\u003E\u003Cbr\u003E            awakeMethod.Invoke(module, paramList);\u003Cbr\u003E            return true;\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E        // Utility method that is run every now an again and just checks that everything is in sync and makes sense. The actualt funtionailty in a method on the module class.\u003Cbr\u003E        private void SanityCheck()\u003Cbr\u003E        {\u003Cbr\u003E            foreach(Part p in FlightGlobals.ActiveVessel.Parts)\u003Cbr\u003E            {\u003Cbr\u003E                foreach (ModuleConnectedLivingSpace clsmod in p.Modules.OfType\u0026lt;ModuleConnectedLivingSpace\u0026gt;())\u003Cbr\u003E                {\u003Cbr\u003E                    //clsmod.SanityCheck();\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E    }\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"NathanKell","CreatedById":75006,"CreatedDateTime":"2014-05-04T18:54:16Z","Content":"\n\u003Cp\u003ENot immediately seeing anything. Lemme ponder it some. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_sad.gif\u0022 alt=\u0022:(\u0022\u003E\u003C/p\u003E\u003Cp\u003EAlso, you might consider hopping on #kspmodders and asking around; maybe someone else has an idea?\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-04T19:27:39Z","Content":"\n\u003Cp\u003EHmmm, I have never really used IRC, and last time I tried I could not get it to work, but perhaps I will give it a go.\u003C/p\u003E\u003Cp\u003EI think I have concluded that my premise is just wrong. Setting values in the module of a prefab will simply not work. While the prefab gets cloned when a part is created, its modules will not get any special creation - just the constructor, and a call to OnInitialize (which would not help me).\u003C/p\u003E\u003Cp\u003EI think I need to use FixedUpdate to somehow check for any parts with ModuleDockingNodes that do not have a corresponding ModuleDockingHatch. The challenge is to do this without trashing the processor \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_sad.gif\u0022 alt=\u0022:(\u0022\u003E ......\u003C/p\u003E\u003Cp\u003E(Thanks for taking the time to look at my code BTW - it is never pleasant having to wade through other people\u0027s stuff)\u003C/p\u003E\n"},{"CreatedByName":"codepoet","CreatedById":73449,"CreatedDateTime":"2014-05-04T21:44:58Z","Content":"\n\u003Cp\u003ENailed it (I think)\u003C/p\u003E\n"},{"CreatedByName":"NathanKell","CreatedById":75006,"CreatedDateTime":"2014-05-04T22:59:30Z","Content":"\n\u003Cp\u003EGreat!\u003C/p\u003E\u003Cp\u003EYour other option: add a check in OnStart to pull data from the prefab. This is what MFS/RF and ModuleRCSFX do, to get around stuff not being serialized correctly.\u003C/p\u003E\n"}]}