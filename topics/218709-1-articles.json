{"TopicId":218709,"ForumId":55,"TopicTitle":"[nerds only] if I was in charge of the KSP physics engine","CreatedByName":"jeancallisti","CreatedById":94406,"CreatedDateTime":"2023-07-31T21:51:36Z","PageNum":1,"Articles":[{"CreatedByName":"jeancallisti","CreatedById":94406,"CreatedDateTime":"2023-07-31T21:51:36Z","Content":"\n\u003Cdiv dir=\u0022ltr\u0022\u003E\n\u003Cp\u003E\nI am in no way saying that this is the only way to make a better KSP or an actual KSP 2; this is just what *I* would do if I had the time, budget and expertise.\u003Cbr\u003E\n\u003Cbr\u003E\nPlease take in consideration that I know how to program professionally; this is not coming out of nowhere. Finally, this is a technical post, this is not at all about the game mechanics. It will be nerdy and boring.\u003Cbr\u003E\n\u003Cbr\u003E\nIMPORTANT: the model below would not leave enough computing power for a \u0022pretty\u0022 game. All the power goes to computing physics. The game would look ugly.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n1) I would not start with implementing space, \u00A0instead I would start with TIME.\u003Cbr\u003E\n\u003Cbr\u003E\nI would implement the ability to have more than one timeline, and branching between those timelines. Or at least, I would lay clear concepts to divide that paradigm into smaller problems. Think \u0022git\u0022 but applied to a KSP game: just like git has branches, commits, merge, rebase, squash, etc... Here we would have timelines, snapshots, etc.\n\u003C/p\u003E\n\u003Cp\u003E\nEach parallel timeline would be a succession of \u0022snapshots\u0022 of the player\u0027s universe.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nYou think it\u0027s weird and impossible? Well, this exists more or less already in KSP 1 as part of the so-called \u0022multiplayer\u0022 plugin. Vanilla KSP lets you fast forward time, but on top of it the plugin lets you do more: you can create alternate timelines and it lets you \u0022resync\u0022 them. Implicitly, it means a primitive form of \u0022rewind\u0022 by reverting to snapshots.\u003Cbr\u003E\n\u003Cbr\u003E\n2) I would think about how to SAVE those snapshots\u003Cbr\u003E\n\u003Cbr\u003E\nThose timelines are a succession of snapshots.\u003Cbr\u003E\n\u003Cbr\u003E\nUnfortunately, the player spends most of their time playing \u0022real time\u0022 in KSP. It would be too resource-intensive to save the entire flow of events.\u003Cbr\u003E\n\u003Cbr\u003E\nThe only way is a) to restrict the moments in time when the engine can take a snapshot, and b) to make it possible to reconstruct/interpolate what comes after until the next snapshot.\u003Cbr\u003E\n\u003Cbr\u003E\nIt\u0027s a matter of making decisions (i.e. RULES), and sticking to it.\u003Cbr\u003E\n\u003Cbr\u003E\nConsider KSP 1: it already forbids you from saving when you accelerate, or are in the atmosphere, etc. (I can\u0027t remember exactly if those restrictions have been worked around, but my point is that there are rules). It means that the INITIAL CONDITIONS after a savinga snapshot are UNAMBIGUOUS; with a bit of effort, the engine could more it less reconstruct what happens to a craft until the next snapshot\n\u003C/p\u003E\n\u003Cp\u003E\nTo give you an idea (among many real-life examples), you can imagine how a video codec works: it can compute the next few seconds of video by using (a) an initial state (a full screen image) and (b) a little bit of computation/incremental data (the minimum amount of changes between each video frame)\u003Cbr\u003E\n\u003Cbr\u003E\nI did not detail here the tricks I would use to work around complicated situations, such as a craft under acceleration, or a craft entering/exciting a sphere of influence, etc. That will come after .\u003Cbr\u003E\n\u003Cbr\u003E\n3) I would start with applying this discretization of time to CELESTIAL BODIES\u003Cbr\u003E\n\u003Cbr\u003E\nit would be absolutely crucial to be able to find the position of every celestial body relatively quickly, as far in the future as we want.\u003Cbr\u003E\n\u003Cbr\u003E\nIf you ask an astronomy geek, they will tell you that it\u0027s impossible, because computations on multiple bodies creates a chaotic system (in the physics sense), i.e. incredibly heavy (nearly impossible) calculations\u003Cbr\u003E\n\u003Cbr\u003E\nBut again, for a videogame it\u0027s a matter of setting rules, to simplify and calculate only what\u0027s needed (while swiping the difficult bits under the rug). Illusion!\u003Cbr\u003E\n\u003Cbr\u003E\nIn the case of orbits I would stick to simple systems: a) the sun is central and immutable, b) the planets don\u0027t interact with one another, c) satellites don\u0027t interact with one another.\n\u003C/p\u003E\n\u003Cp\u003E\nIf you need a two-bodies system (i.e. Neptune so heavy that it deviates the sun) then hard-code it.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nThe position of each satellite is an offset to add to the position of its parent body. No complicated conics, maybe a simplification relying on segments of hyperboles or a handful of carefully chosen B\u00E9zier curves.\u003Cbr\u003E\n\u003Cbr\u003E\nBut remember that the whole engine is snapshots-oriented. You can\u0027t save every point (in time and space) of every orbit of orbits. Therefore, even the \u0022simplified\u0022 orbits would eventually be broken down to a set of points with a LINEAR resolution between each point. between point A and point B, we decide that the celestial body travels at constant speed, in a straight line. We can smooth out the change in speed between each point (again: linearly).\u003Cbr\u003E\n\u003Cbr\u003E\nHere I don\u0027t explain how to save the points\u0027 positions with enough precision; I will explain further.\u003Cbr\u003E\n\u003Cbr\u003E\nSide note 1: A good idea would be to snapshot the positions of the Lagrange points, additionally to the positions of the celestial bodies.\u003Cbr\u003E\n\u003Cbr\u003E\nSide note 2: there\u0027s still the case of random asteroids, like in KSP 1. I would make them pop in and out of existence randomly, but following a system of seeds (i.e. you can predict where and when it appears). then the engine can compute the asteroid\u0027s position based on that initial position and speed, but only IF it needs to, i.e. IF the player decides to interact with it.\u003Cbr\u003E\n\u003Cbr\u003E\n4) Discretization of space\u003Cbr\u003E\n\u003Cbr\u003E\nLike the original Dev of KSP wrote in an old blog post, one of the challenges of such a game is that the engine needs to manage a 3D space at a scale a of a few centimetres (does your kerbal\u0027s foot touch the ladder?) all the way up to astronomical distances.\u003Cbr\u003E\n\u003Cbr\u003E\nThis is resolved (on paper and in some way in KSP 1) by managing space at TWO different scales: the \u0022SMALL-ISH\u0022 scale, i.e. everything that\u0027s close enough to the craft to be managed natively by the physics engine with sufficient precision. And the \u0022LARGE\u0022 scale, which is more or less doubling or quadrupling the precision of floating point numbers by adding an extra 32, 64, etc. bits. Possibly in a separate variable that rarely changes.\u003Cbr\u003E\n\u003Cbr\u003E\nIn other words, the 3D space is a kind of VOXEL. The \u0022secondary\u0022 number where you store the \u0022large\u0022 position of a craft is the equivalent of the CHUNKS in Minecraft, and rarely changes.\u003Cbr\u003E\n\u003Cbr\u003E\nBut I would push the concept further, by developing a kind of space discretization more suitable for orbital mechanics.\u003Cbr\u003E\n\u003Cbr\u003E\nLet\u0027s call it SPHERICAL VOXEL. For as long as a craft is within a sphere of influence, you could define its location above the surface by using its latitude chunk and longitude chunk. And then of course within each chunk, use a regular floating point position. The interesting part would be the altitude: you could define vertical chunks that are NOT divided linearly, but instead exponentially, to reflect the rapid decrease of gravity as you go up.\u003Cbr\u003E\n\u003Cbr\u003E\nHowever, still following our concern for snapshots and requirement for minimal storage needs, the gravity change would be resolved linearly within each vertical chunk (with a linear smoothing as we transition from one chunk to the next)\u003Cbr\u003E\n\u003Cbr\u003E\nGoing back to discretization of space: when the craft is NOT within a sphere of influence, we save its position in a regular cubic voxel, with its initial position, direction and speed at the edge of the voxel, and since we know what forces are applied to it (both because of our simplistic model for celestial bodies positions and because we have strict rules for snapshots) we can calculate its position as simply as possible at any point in time until the next snapshot.\u003Cbr\u003E\n\u003Cbr\u003E\nIt\u0027s trivial to determine when an object leaves the cubical voxel to enter the spherical voxel, as it\u0027s directly related to its distance to the celestial body.\u003Cbr\u003E\n\u003Cbr\u003E\n5) collisions\u003Cbr\u003E\n\u003Cbr\u003E\nThe double voxel system described previously (both the cubical voxel and the spherical voxel) lets us determine quickly when two objects are far enough apart from one another to NEVER collide. That is, when they are in two different chunks.\u003Cbr\u003E\n\u003Cbr\u003E\nAny object going at extreme speeds might require extra care (the problem arises when it\u0027s going so fast that it skips several chunks between each game tick) but that\u0027s still resolved reasonably easily by following standard algorithms -- similar to netcode algorithms (simulating continuous movements from discrete data, like when counterstrike\u0027s net code determines if a projectile hit you). As a fallback you can decide that if a craft goes that fast then it should disintegrate! Or that you \u0022lost connection\u0022 to it. Or create an entirely new model for crafts going at extreme speeds.\u003Cbr\u003E\n\u003Cbr\u003E\nAnyways, once you\u0027ve asserted that a craft can only go from one chunk to its neighbour chunk then you can compute what craft might collide with what other object within one chunk, both in time and space. Once again we rely on our extensive use of linear resolution of trajectories (or, at worst, polynomial) to cast \u0022rays\u0022 (in the 3D graphics sense) and determine if the relatively tiny objects that are crafts (in the immensity of space) do collide within the large chunk. Let the physics engine do the rest, as the crafts are in fact rigid bodies.\u003Cbr\u003E\n\u003Cbr\u003E\n6) rigid bodies\u003Cbr\u003E\n\u003Cbr\u003E\nThis paragraph is secondary to the whole system, but here\u0027s an idea: each craft part (tank, engine, antenna...) should in fact be designed from the beginning as a set of attachment points and struts/metal beams. Not literal struts or literal metal beams, of course (we don\u0027t need to see what\u0027s inside the craft\u0027s part!). But the physics engine should be fed the rough structure of the part, to know where it should bend and where it should break.\n\u003C/p\u003E\n\u003Cp\u003E\nFor example, a tank should not secretly be just two attachment points connected by one single vertice (with a pretty cylinder mesh slapped onto it as a skin). Instead it should be a handful of vertices arranged in cylinder shape, representing its inner metal beams. The physics engine would work with those so-called beams and calculate the constraints on them, like in the video game Polybridge. Pretty standard stuff.\u003Cbr\u003E\n\u003Cbr\u003E\nKSP 1 already did an embryo of that when it introduced actual struts as well as autostrut. But while that \u0022physical mesh\u0022 should remain hidden to the player during a flight, its existence should be made explicit (for example, through a new overlay in the \u003Cabbr title=\u0022Vehicle Assembly Building\u0022\u003E\u003Cabbr title=\u0022Vehicle Assembly Building\u0022\u003EVAB\u003C/abbr\u003E)\u003C/abbr\u003E. The actual mesh of the part (the one visible to the player) would only be cosmetic. That mesh could even distort, following the \u0022physical\u0022 mesh\u0027s distortions, by using a simple displacement shader. Only if the physical mesh gets \u0022too distorted\u0022 then the part gets ripped off the rest of the craft, or explodes.\u003Cbr\u003E\n\u003Cbr\u003E\nThe rigid body that is the part doesn\u0027t need to have MANY physical points (that would require too much GPU). In fact, it needs very few points, the same way a collision is very often just a cube. Just enough to make it interesting. This way ships could break in other places than just the attachment points between parts. And they could bend in unpredictable ways.\u003Cbr\u003E\n\u003Cbr\u003E\nno, I\u0027m not advocating for KSP2\u0027s floppy rockets. Quite the opposite.\u003Cbr\u003E\n\u003Cbr\u003E\n7) weather\u003Cbr\u003E\n\u003Cbr\u003E\nuse the standard way of generating weather and volumetric clouds in a game (seed-based pseudo-random noise) and keep it as deterministic as possible to shoehorn it into the snapshots and voxel systems. To put it shortly: 3D Perlin noise creates shapes in small cubes, that you can interpolate linearly. Just like our voxel. They fit together.\u003Cbr\u003E\n\u003Cbr\u003E\n8) aerodynamics\u003Cbr\u003E\n\u003Cbr\u003E\nThe \u0022Ferram aerospace\u0022 plugin lays the path for proper aerodynamics. It uses voxel, but it has nothing to do with our voxel system.\u003Cbr\u003E\n\u003Cbr\u003E\nThe main goal would not be to have \u0022accurate\u0022 aerodynamics (that comes as a bonus) but instead to pre-bake as much aerodynamics-related data, in order to alleviate the GPU \u0027s work as much as possible when resolving/predicting the trajectory of a craft. In other words: from the pre-baked model, try to extract some discrete aerodynamics behaviours (craft angled 0\u00B0, craft angled 10\u00B0, etc.) and make heavy use of those simplifications while maintaining a reasonable level of detail in the flight behaviour.\u003Cbr\u003E\n\u003Cbr\u003E\n10) resync\u0027ing of timelines\u003Cbr\u003E\n\u003Cbr\u003E\nI\u0027ve come full circle from time to \u0022orbit-scale\u0022 space to \u0022craft-scale\u0022 space.\u003Cbr\u003E\n\u003Cbr\u003E\nIt is now obvious that some aspects of the game can be resolved on-demand by the engine (snapshot, rewind, fast-forward, etc.), such as the position of celestial bodies and the position of crafts that are in orbit, while some aspects are still out of reach (such as the position of a craft submitted to aerodynamic forces).\u003Cbr\u003E\n\u003Cbr\u003E\nThe time has come to explain how I would resolve that.\u003Cbr\u003E\n\u003Cbr\u003E\nImagine you\u0027re flying a craft in the atmosphere and it separates into two crafts, each with a guidance system.\u003Cbr\u003E\n1. Both crafts\u0027 flights still need to be managed by the game engine. None of them becomes a falling brick. The engine needs to be robust enough to handle as many crafts as are present in the current voxel chunk, even if it means a drop in frame rate (no skipping allowed for the physics engine!!!)\u003Cbr\u003E\n2. When one of the crafts gets \u0022far enough\u0022 from the craft currently being flown, the engine applies a simplified flight trajectory to it just to show it on screen, but that trajectory means nothing. The engine marks that \u0022fake flight\u0022 as \u0022unresolved\u0022.\n\u003C/p\u003E\n\u003Cp\u003E\nThe player can no longer switch to it.\n\u003C/p\u003E\n\u003Cp\u003E\n3. In order to \u0022resolve\u0022 what became of that craft, the player needs to (a) finish flying the current craft until it becomes possible to create a new snapshot of this timeline, then (b) tell the game that he/she now wants to \u0022resolve\u0022 the flight of that other craft. Then (c) the game obeys by reverting to the snapshot taken when that craft went too far from the original craft, and (d) lets you fly it until it becomes possible to create a new snapshot for that craft.\n\u003C/p\u003E\n\u003Cp\u003E\nThose two crafts now have different timelines, and both are resolved as far as the player flew those crafts.\u003Cbr\u003E\n\u003Cbr\u003E\nBut what if the player flies the second craft close enough to the first craft again?\u003Cbr\u003E\n\u003Cbr\u003E\nThat\u0027s the interesting part. The two timelines become reunited temporarily. If the crafts don\u0027t collide then the timelines separate again, possibly without changing the snapshot created previously (i.e., created AFTER flying the first craft to completion). But if the crafts collide, then the two timelines get reunited permanently (and any subsequent snapshots they might have had get deleted). After the collision, if they get separated again, then Both crafts\u0027 flights need to be resolved again, separately, just like before.\u003Cbr\u003E\n\u003Cbr\u003E\nPlease note that an \u0022unresolved\u0022 flight can remain unresolved indefinitely. The incentive for the player to resolve a flight is that if they don\u0027t, then the craft never lands or never crashes, and the player can never recover the parts.\u003Cbr\u003E\n\u003Cbr\u003E\nunresolved flights could be displayed in the tracking station,\u00A0 just like any other craft.\u003Cbr\u003E\n\u003Cbr\u003E\n11) resync\u0027ing of timelines in the distant future\u003Cbr\u003E\n\u003Cbr\u003E\nEverything I\u0027m about to describe was already a paradigm in the multiplayer plugin of KSP 1, and we know from Dev interviews that the KSP 2 team had similar ideas as what I\u0027m about to present.\n\u003C/p\u003E\n\u003Cp\u003E\nImagine this scenario:\u003Cbr\u003E\n1. you take 10 days to fly a craft to, let\u0027s say, the Mun, and you lend it there. That craft is named \u0022MISSION A\u0022.\u003Cbr\u003E\n2. The game engine can assert that could repeat that flight as many times as you want, given the same resources and the same time to travel. Therefore, if the player requests it, the game can create a \u0022commercial route\u0022. It can even assume that the same amount of fuel that was left in your craft when you landed will be present on any subsequent \u0022automated\u0022 craft landing on the moon. It does not need to simulate each and every craft .\u003Cbr\u003E\nThat\u0027s the trivial part.\u003Cbr\u003E\nnow for the fun part:\u003Cbr\u003E\n3. Imagine you revert to the timeline snapshot just before MISSION A departed. Now you decide to launch a new MISSION B.\u003Cbr\u003E\n4. that second fight takes only 4 days to fly to Mun, because this time you flew better. It lands in the exact same spot where MISSION A will land 6 days from now.\u003Cbr\u003E\n5. We can let the player play with MISSION B as long as he/she wants. If that craft leaves the surface in less than 6 days, then nothing special happens. BUT.... Here comes the catch! If MISSION B stays 6 days then we know that it occupies the same surface chunk as MISSION A. the two timelines need to be resolved! The player is notified of it and needs to keep playing one of those crafts for as long as they\u0027re within potential collision distance, otherwise the flight is marked as \u0022unresolved\u0022 as we explained before.\u003Cbr\u003E\n\u003Cbr\u003E\n12) actual cooperative or competitive multiplayer?\u003Cbr\u003E\n\u003Cbr\u003E\nBy the way, this mechanics allows for real multiplayer in KSP. However, not real time.\u003Cbr\u003E\nIt would be fun to imagine game modes where there\u0027s a game master who can decide who can rewind time, and how far back. Or each player can rewind time only a limited amount of times. Etc.\u003Cbr\u003E\n\u003Cbr\u003E\n13) landmarks\u003Cbr\u003E\n\u003Cbr\u003E\n[A somewhat dumb and out-of-place] addition to this long post.]\u003Cbr\u003E\n\u003Cbr\u003E\nI find it strange that KSP 2\u0027s engine was not immediately able to handle the \u003Cabbr title=\u0022Kerbal Space Center\u0022\u003E\u003Cabbr title=\u0022Kerbal Space Center\u0022\u003EKSC\u003C/abbr\u003E\u003C/abbr\u003E properly (from a rendering perspective).\u003Cbr\u003E\nEach large landmark at the surface of a planet (whether be building, arch, cave, solar flare, etc ) should be modelled at several levels of detail. Low-poly version for everyone as soon as you get away from it! The collisions work with the low poly version at high speed/large distance, or with the full details at short range/low speed.\n\u003C/p\u003E\n\u003Cdiv style=\u0022clear:both;\u0022\u003E\n\u00A0\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cdiv style=\u0022clear:both;\u0022\u003E\n\u00A0\n\u003C/div\u003E\n\u003Cdiv dir=\u0022ltr\u0022\u003E\n\u00A0\n\u003C/div\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222023-08-01T07:49:37Z\u0022 title=\u002208/01/2023 07:49  AM\u0022 data-short=\u0022Aug 1\u0022\u003EAugust 1, 2023\u003C/time\u003E by jeancallisti\u003C/strong\u003E\n\u003Cbr\u003Ebetter title\n\u003C/span\u003E\n"},{"CreatedByName":"Gargamel","CreatedById":64714,"CreatedDateTime":"2023-08-01T16:07:26Z","Content":"\n\u003Cp\u003E\nMoved to ksp1 suggestions. \u00A0 Or is this about KSP2? \u00A0 \u00A0I can\u2019t tell, it jumps back and forth.\u00A0\u003Cbr\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n"},{"CreatedByName":"jeancallisti","CreatedById":94406,"CreatedDateTime":"2023-08-01T20:27:32Z","Content":"\n\u003Cp\u003E\nAccording to the forums\u0027 descriptions, I don\u0027t think you should have moved it. It\u0027s about neither directly KSP 1 nor directly KSP 2.\n\u003C/p\u003E\n\u003Cp\u003E\nIt\u0027s more about a fantasy KSP clone. What \u003Cem\u003Ecould\u003C/em\u003E have been done of the KSP1 code base when the development of KSP 2 started.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222023-08-01T20:32:54Z\u0022 title=\u002208/01/2023 08:32  PM\u0022 data-short=\u0022Aug 1\u0022\u003EAugust 1, 2023\u003C/time\u003E by jeancallisti\u003C/strong\u003E\n\u003C/span\u003E\n"}]}