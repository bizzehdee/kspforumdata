{"TopicId":50533,"ForumId":34,"TopicTitle":"[1.8.x-1.12.x] Module Manager 4.2.3 (July 03th 2023) - Fireworks season","CreatedByName":"sarbian","CreatedById":57146,"CreatedDateTime":"2013-10-25T13:01:36Z","PageNum":19,"Articles":[{"CreatedByName":"ialdabaoth","CreatedById":57270,"CreatedDateTime":"2014-03-13T20:57:40Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Starwaster\u0022 data-cite=\u0022Starwaster\u0022\u003E\u003Cdiv\u003EHave you checked output_log.txt for errors when your cfg is applied? Or to see if something else is adding new engine modules in?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003E... I had two different versions of Module Manager installed.\u003C/p\u003E\u003Cp\u003E\u003Csup\u003EI\u0027ll just go sit over here now.\u003C/sup\u003E\u003C/p\u003E\n"},{"CreatedByName":"IronGremlin","CreatedById":77166,"CreatedDateTime":"2014-03-13T22:31:35Z","Content":"\n\u003Cp\u003EHey guys, the link in the OP doesn\u0027t seem to be functional, does anyone know where I could get a copy of MM 1.5.6 ?\u003C/p\u003E\n"},{"CreatedByName":"bagelbyheart","CreatedById":105712,"CreatedDateTime":"2014-03-13T22:40:09Z","Content":"\n\u003Cp\u003EI\u0027m seeing the same thing =\\\u003C/p\u003E\n"},{"CreatedByName":"Starwaster","CreatedById":71262,"CreatedDateTime":"2014-03-13T22:56:11Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022IronGremlin\u0022 data-cite=\u0022IronGremlin\u0022\u003E\u003Cdiv\u003EHey guys, the link in the OP doesn\u0027t seem to be functional, does anyone know where I could get a copy of MM 1.5.6 ?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENot functional or you get a security warning?\u003C/p\u003E\n"},{"CreatedByName":"bagelbyheart","CreatedById":105712,"CreatedDateTime":"2014-03-13T23:04:18Z","Content":"\n\u003Cp\u003ESecurity warning followed by not functional. Chrome reported \u0022Failed - No File\u0022\u003C/p\u003E\n"},{"CreatedByName":"IronGremlin","CreatedById":77166,"CreatedDateTime":"2014-03-13T23:08:51Z","Content":"\n\u003Cp\u003EBoth, actually\u003C/p\u003E\n"},{"CreatedByName":"NathanKell","CreatedById":75006,"CreatedDateTime":"2014-03-13T23:18:26Z","Content":"\n\u003Cp\u003ESarbian said elsewhere his site is down and he\u0027s scrambling to fix. For now you can get MM 1.5.6 from, say, the Real Fuels mod in my sig, or from the latest FAR.\u003C/p\u003E\n"},{"CreatedByName":"bagelbyheart","CreatedById":105712,"CreatedDateTime":"2014-03-13T23:23:23Z","Content":"\n\u003Cp\u003EYou are a saint sir!\u003C/p\u003E\n"},{"CreatedByName":"Tallinu","CreatedById":57810,"CreatedDateTime":"2014-03-17T06:47:00Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022heralo\u0022 data-cite=\u0022heralo\u0022\u003E\u003Cdiv\u003EI\u0027m trying to update a KAS config\u003Cp\u003E[...]\u003C/p\u003E\u003Cp\u003Eand this is my MM config:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E@PART[KAS_ContainerBay1]:Final{\u003Cbr\u003E\t!scale\u003Cbr\u003E\t!mesh\u003Cbr\u003E\t@rescaleFactor = 1\u003Cbr\u003E\t@node_stack_top = 0.0, -0.35, 0.0, 0.0, 1.0, 0.0, 0\u003Cbr\u003E\t@node_stack_bottom = 0.0, -0.4, 0.0, 0.0, 1.0, 0.0, 0\u003Cbr\u003E\t@node_attach = 0.0, -0.4, 0.0, 0.0, -1.0, 0.0\u003Cbr\u003E\tMODEL\u003Cbr\u003E\t{\u003Cbr\u003E\t\tmodel = KAS/Parts/containerBay1/containerBay1\u003Cbr\u003E\t\tscale = 0.5,0.5,0.5\u003Cbr\u003E\t}\t\t\u003Cbr\u003E\tMODULE\u003Cbr\u003E\t{\u003Cbr\u003E\t\tname = KASModuleGrab\t\u003Cbr\u003E\t\tevaPartPos = (0.0, 0.10, -0.15)\u003Cbr\u003E\t\tevaPartDir = (0,0,-1)\u003Cbr\u003E\t\tcustomGroundPos = true\u003Cbr\u003E\t\tdropPartPos = (0.0, 0.0, -0.55)\u003Cbr\u003E\t\tdropPartRot = (-10.0, 0.0, 0.0)\t\u003Cbr\u003E\t\tattachOnPart = True\u003Cbr\u003E\t\tattachOnEva = False\u003Cbr\u003E\t\tattachOnStatic = False\u003Cbr\u003E\t\tattachSendMsgOnly = False\t\t\t\u003Cbr\u003E\t}\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIt looks like you\u0027re trying to do what I just tried to do with the container storage rack, but I found that no matter what attach node I tried, it always sank halfway into whatever I tried to attach it to (part or terrain). Have you had any luck getting it to work?\u003C/p\u003E\n"},{"CreatedByName":"CaptRobau","CreatedById":41695,"CreatedDateTime":"2014-03-17T13:21:04Z","Content":"\n\u003Cp\u003EI\u0027m trying to change some things to the ion engine. Yet for some reason not everything is working correctly:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E@PART[ionEngine]\u003Cbr\u003E{\u003Cbr\u003E\t@category = Propulsion\u003Cbr\u003E\u003Cbr\u003E\t@MODULE[ModuleEngines]\u003Cbr\u003E\t{\u003Cbr\u003E\t\t@maxThrust = 1.25\u003Cbr\u003E\u003Cbr\u003E\t\t@PROPELLANT[ElectricCharge]\u003Cbr\u003E\t\t{\u003Cbr\u003E\t\t\t@ratio = 0.8\u003Cbr\u003E\t\t\tDrawGauge = true\u003Cbr\u003E\t\t}\u003Cbr\u003E\t}\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe category change works, but the engine stuff doesn\u0027t. What am I doing wrong?\u003C/p\u003E\n"},{"CreatedByName":"NathanKell","CreatedById":75006,"CreatedDateTime":"2014-03-17T15:18:19Z","Content":"\n\u003Cp\u003ECheck ksp.log, it will tell you. Maybe you\u0027re running Hot Rockets and so the engine module name was already changed?\u003C/p\u003E\n"},{"CreatedByName":"CaptRobau","CreatedById":41695,"CreatedDateTime":"2014-03-17T15:29:35Z","Content":"\n\u003Cp\u003EAh yes, I\u0027m running HotRockets. Makes sense now.\u003C/p\u003E\n"},{"CreatedByName":"KerbMav","CreatedById":70338,"CreatedDateTime":"2014-03-17T17:26:00Z","Content":"\n\u003Cp\u003EFrom where did I get a 1.5.7 version of this mod??\u003C/p\u003E\u003Cp\u003EOK, I know I got it from a different mod, but now I am confused that you are still at 1.5.6 here ...\u003C/p\u003E\u003Cp\u003EEdith tells me, it was DRE.\u003C/p\u003E\n"},{"CreatedByName":"heralo","CreatedById":102657,"CreatedDateTime":"2014-03-17T17:52:09Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Tallinu\u0022 data-cite=\u0022Tallinu\u0022\u003E\u003Cdiv\u003EIt looks like you\u0027re trying to do what I just tried to do with the container storage rack, but I found that no matter what attach node I tried, it always sank halfway into whatever I tried to attach it to (part or terrain). Have you had any luck getting it to work?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYes, I think so. I\u0027ve played with it in place the last few days and haven\u0027t noticed any issues. I can PM you the cfg when I get home from work if you want.\u003C/p\u003E\n"},{"CreatedByName":"KerbMav","CreatedById":70338,"CreatedDateTime":"2014-03-17T21:20:45Z","Content":"\n\u003Cp\u003EIf I am already using :Final to add some TechRequired entries, how can I make sure that everything I missed gets edited by this here:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E@PART[*]:HAS[~TechRequired[]]:Final\u003Cbr\u003E{\u003Cbr\u003E\tTechRequired=advScienceTech\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E?\u003C/p\u003E\n"},{"CreatedByName":"Starwaster","CreatedById":71262,"CreatedDateTime":"2014-03-18T10:10:02Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022KerbMav\u0022 data-cite=\u0022KerbMav\u0022\u003E\u003Cdiv\u003EIf I am already using :Final to add some TechRequired entries, how can I make sure that everything I missed gets edited by this here:\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E@PART[*]:HAS[~TechRequired[]]:Final\u003Cbr\u003E{\u003Cbr\u003E\tTechRequired=advScienceTech\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E?\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThis is what I use.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[*]:HAS[#module[Part],~TechRequired[]]:Final\u003Cbr\u003E{\u003Cbr\u003E\tTechRequired = advRocketry\u003Cbr\u003E\tentryCost = 1000\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EReally the same as what you have except that it only adds it to Parts. (probably some unnecessary weeding; \u0027Winglets\u0027 would get weeded out...)\u003C/p\u003E\u003Cp\u003EentryCost is superfluous... NOW. In the future it\u0027ll probably have a use.\u003C/p\u003E\n"},{"CreatedByName":"Crater","CreatedById":48907,"CreatedDateTime":"2014-03-18T13:06:42Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022KerbMav\u0022 data-cite=\u0022KerbMav\u0022\u003E\u003Cdiv\u003EIf I am already using :Final to add some TechRequired entries, how can I make sure that everything I missed gets edited by this here:\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E@PART[*]:HAS[~TechRequired[]]:Final\u003Cbr\u003E{\u003Cbr\u003E\tTechRequired=advScienceTech\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E?\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EMake sure that the config file with that in is alphabetically last, so stick it in a folder called \u0022GameData/ZZZZ_Final_Mods\u0022.\u003C/p\u003E\u003Cp\u003EAll of the configs are parsed in find-them order, then all the :Final ones, in the same order.\u003C/p\u003E\n"},{"CreatedByName":"Climberfx","CreatedById":57126,"CreatedDateTime":"2014-03-18T15:06:50Z","Content":"\n\u003Cp\u003EI love this mod. Thank you for your work done.\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"ialdabaoth","CreatedById":57270,"CreatedDateTime":"2014-03-20T21:48:10Z","Content":"\n\u003Cp\u003ESarbian: Node[Name, Tag] is useless, because almost no one uses \u0027tag\u0027, and if you don\u0027t have a tag, you CAN\u0027T pick anything but the first node.\u003C/p\u003E\u003Cp\u003EOriginally, it was supposed to work identically to value keys - i.e., Node[Name, index]\u003C/p\u003E\u003Cp\u003ESo you should be able to say MODULE[ModuleEnginesFX, 1] {\u003C/p\u003E\u003Cp\u003E}\u003C/p\u003E\u003Cp\u003EHere\u0027s a partial rewrite that fixes it:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        public static ConfigNode FindConfigNodeIn(ConfigNode src, string nodeType,\u003Cbr\u003E                                                   string nodeName = null, int index)\u003Cbr\u003E        {\u003Cbr\u003E#if DEBUG\u003Cbr\u003E\t\t\tif (nodeTag == null)\u003Cbr\u003E\t\t\t\tprint (\u0022Searching node for \u0022 \u002B nodeType \u002B \u0022[\u0022 \u002B nodeName \u002B \u0022]\u0022);\u003Cbr\u003E\t\t\telse\u003Cbr\u003E\t\t\t\tprint (\u0022Searching node for \u0022 \u002B nodeType \u002B \u0022[\u0022 \u002B nodeName \u002B \u0022,\u0022 \u002B nodeTag \u002B \u0022]\u0022);\u003Cbr\u003E#endif\u003Cbr\u003E            int found = 0;\u003Cbr\u003E            foreach (ConfigNode n in src.GetNodes(nodeType)) {\u003Cbr\u003E                if (nodeName == null \u0026amp;\u0026amp; nodeTag == null)\u003Cbr\u003E                    return n;\u003Cbr\u003E                if (n.HasValue(\u0022name\u0022) \u0026amp;\u0026amp; WildcardMatch(n.GetValue(\u0022name\u0022), nodeName)) {\u003Cbr\u003E                    if (found == index)\u003Cbr\u003E                    {\u003Cbr\u003E#if DEBUG\u003Cbr\u003E                    print (\u0022found node \u0022 \u002B found.ToString() \u002B \u0022!\u0022);\u003Cbr\u003E#endif\u003Cbr\u003E                        return n;\u003Cbr\u003E                    } else {\u003Cbr\u003E                        found\u002B\u002B;\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            return null;\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        public static ConfigNode ModifyNode(ConfigNode original, ConfigNode mod)\u003Cbr\u003E        {\u003Cbr\u003E            if (!IsSane(original) || !IsSane(mod)) {\u003Cbr\u003E                print(\u0022[ModuleManager] A node has an empty name. Skipping it. Original: \u0022 \u002B original.name);\u003Cbr\u003E                return original;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            ConfigNode newNode = original.CreateCopy();\u003Cbr\u003E\u003Cbr\u003E            foreach (ConfigNode.Value val in mod.values) {\u003Cbr\u003E                if (val.name[0] != \u0027@\u0027 \u0026amp;\u0026amp; val.name[0] != \u0027!\u0027 \u0026amp;\u0026amp; val.name[0] != \u0027%\u0027)\u003Cbr\u003E                    newNode.AddValue(val.name, val.value);\u003Cbr\u003E                else {\u003Cbr\u003E                    // Parsing: Format is @key = value or @key,index = value \u003Cbr\u003E                    string valName = val.name.Substring(1);\u003Cbr\u003E                    int index = 0;\u003Cbr\u003E                    if (valName.Contains(\u0022,\u0022)) {\u003Cbr\u003E                        int.TryParse(valName.Split(\u0027,\u0027)[1], out index);\u003Cbr\u003E                        valName = valName.Split(\u0027,\u0027)[0];\u003Cbr\u003E                    } // index is useless right now, but some day it might not be.\u003Cbr\u003E                    if (val.name[0] == \u0027@\u0027)\u003Cbr\u003E                        newNode.SetValue(valName, val.value, index);\u003Cbr\u003E                    else if (val.name[0] == \u0027!\u0027)\u003Cbr\u003E                        newNode.RemoveValues(valName);\u003Cbr\u003E                    else if (val.name[0] == \u0027%\u0027) {\u003Cbr\u003E                        newNode.RemoveValues(valName);\u003Cbr\u003E                        newNode.AddValue(valName, val.value);\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            foreach (ConfigNode subMod in mod.nodes) {\u003Cbr\u003E                subMod.name = RemoveWS(subMod.name);\u003Cbr\u003E                if (subMod.name[0] != \u0027@\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027!\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027%\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027$\u0027)\u003Cbr\u003E                    newNode.AddNode(subMod);\u003Cbr\u003E                else {\u003Cbr\u003E                    ConfigNode subNode;\u003Cbr\u003E                    //if (subMod.name[0] == \u0027@\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027%\u0027)\u003Cbr\u003E                    //    subNode = null;\u003Cbr\u003E\u003Cbr\u003E                    if (subMod.name.Contains(\u0022[\u0022)) {\u003Cbr\u003E                        // format @NODETYPE[Name] {...} or @NODETYPE[Name, index] {...} or ! instead of @\u003Cbr\u003E                        string nodeType = subMod.name.Substring(1).Split(\u0027[\u0027)[0];\u003Cbr\u003E                        string nodeName = subMod.name.Split(\u0027[\u0027)[1].Replace(\u0022]\u0022, \u0022\u0022);\u003Cbr\u003E                        int index = 0;\u003Cbr\u003E                        if (nodeName.Contains(\u0022,\u0022)) {\u003Cbr\u003E                            // format @NODETYPE[Name, index] {...} or ! instead of @\u003Cbr\u003E                            int.TryParse(nodeType.Split(\u0027,\u0027)[1], out index);\u003Cbr\u003E                            nodeName = nodeName.Split(\u0027,\u0027)[0];\u003Cbr\u003E                        }\u003Cbr\u003E                        subNode = FindConfigNodeIn(newNode, nodeType, nodeName, index);\u003Cbr\u003E                    } else {\u003Cbr\u003E                        // format @NODETYPE {...} or ! instead of @\u003Cbr\u003E                        string nodeType = subMod.name.Substring(1);\u003Cbr\u003E\u003Cbr\u003E                        // format @NODETYPE,N {...} or ! instead of @\u003Cbr\u003E                        // The problem with ! is that the index is messed up\u003Cbr\u003E                        // So the patch need to take that into account\u003Cbr\u003E                        // and lower the index for the next search\u003Cbr\u003E                        int index = 0;\u003Cbr\u003E                        if (nodeType.Contains(\u0022,\u0022)) {\u003Cbr\u003E                            int.TryParse(nodeType.Split(\u0027,\u0027)[1], out index);\u003Cbr\u003E                            nodeType = nodeType.Split(\u0027,\u0027)[0];\u003Cbr\u003E                        }\u003Cbr\u003E                        ConfigNode[] subNodes = newNode.GetNodes(nodeType);\u003Cbr\u003E                        if (subNodes.Length \u0026gt; index)\u003Cbr\u003E                            subNode = subNodes[index];\u003Cbr\u003E                        else\u003Cbr\u003E                            subNode = null;\u003Cbr\u003E                    }\u003Cbr\u003E                    if (subMod.name[0] == \u0027@\u0027) {\u003Cbr\u003E                        // find the original subnode to modify, modify it and add the modified.\u003Cbr\u003E                        if (subNode != null) {\u003Cbr\u003E                            ConfigNode newSubNode = ModifyNode(subNode, subMod);\u003Cbr\u003E                            newNode.nodes.Add(newSubNode);\u003Cbr\u003E                        } else\u003Cbr\u003E                            print(\u0022[ModuleManager] Could not find node to modify: \u0022 \u002B subMod.name);\u003Cbr\u003E                    }\u003Cbr\u003E                    if (subMod.name[0] == \u0027%\u0027) {\u003Cbr\u003E                        // if the original node exist add it\u003Cbr\u003E                        if (subNode != null) {\u003Cbr\u003E                            ConfigNode newSubNode = ModifyNode(subNode, subMod);\u003Cbr\u003E                            newNode.nodes.Add(newSubNode);\u003Cbr\u003E                        }\u003Cbr\u003E                        else { // if not add the mod node without the % in its name                            \u003Cbr\u003E                            // This part is messy. ialdabaoth is right, i need to rewrite.\u003Cbr\u003E                            string type;\u003Cbr\u003E                            string name;\u003Cbr\u003E                            if (subMod.name.Contains(\u0022[\u0022)) {\u003Cbr\u003E                                type = subMod.name.Substring(1).Split(\u0027[\u0027)[0];\u003Cbr\u003E                                name = subMod.name.Split(\u0027[\u0027)[1].Replace(\u0022]\u0022, \u0022\u0022);\u003Cbr\u003E                            }\u003Cbr\u003E                            else \u003Cbr\u003E                            {\u003Cbr\u003E                                type = subMod.name.Substring(1);\u003Cbr\u003E                                name = null;\u003Cbr\u003E                            }\u003Cbr\u003E\u003Cbr\u003E                            ConfigNode copy = new ConfigNode(type);\u003Cbr\u003E\u003Cbr\u003E                            if (name != null)\u003Cbr\u003E                                copy.AddValue(\u0022name\u0022, name);\u003Cbr\u003E\u003Cbr\u003E                            ConfigNode newSubNode = ModifyNode(copy, subMod);\u003Cbr\u003E                            newNode.nodes.Add(newSubNode);                            \u003Cbr\u003E                        }                            \u003Cbr\u003E                    }\u003Cbr\u003E                    if (subMod.name[0] == \u0027$\u0027)\u003Cbr\u003E                    {\u003Cbr\u003E                        // find the original subnode to copy, add the original, add the the modified copy.\u003Cbr\u003E                        if (subNode != null) {\u003Cbr\u003E                            newNode.nodes.Add(subNode);\u003Cbr\u003E                            ConfigNode newSubNode = ModifyNode(subNode, subMod);\u003Cbr\u003E                            newNode.nodes.Add(newSubNode);\u003Cbr\u003E                        }\u003Cbr\u003E                        else\u003Cbr\u003E                            print(\u0022[ModuleManager] Could not find node to copy: \u0022 \u002B subMod.name);\u003Cbr\u003E                    }\u003Cbr\u003E                    if (subNode != null)\u003Cbr\u003E                        newNode.nodes.Remove(subNode);\u003Cbr\u003E\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            return newNode;\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"ialdabaoth","CreatedById":57270,"CreatedDateTime":"2014-03-20T22:15:05Z","Content":"\n\u003Cp\u003EALSO: I can\u0027t test it right now, but the following should allow you to apply patches to ALL subnodes that wildcard-match, rather than merely the first:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E        public static ConfigNode ModifyNode(ConfigNode original, ConfigNode mod)\u003Cbr\u003E        {\u003Cbr\u003E            if (!IsSane(original) || !IsSane(mod)) {\u003Cbr\u003E                print(\u0022[ModuleManager] A node has an empty name. Skipping it. Original: \u0022 \u002B original.name);\u003Cbr\u003E                return original;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            ConfigNode newNode = original.CreateCopy();\u003Cbr\u003E\u003Cbr\u003E            foreach (ConfigNode.Value val in mod.values) {\u003Cbr\u003E                if (val.name[0] != \u0027@\u0027 \u0026amp;\u0026amp; val.name[0] != \u0027!\u0027 \u0026amp;\u0026amp; val.name[0] != \u0027%\u0027)\u003Cbr\u003E                    newNode.AddValue(val.name, val.value);\u003Cbr\u003E                else {\u003Cbr\u003E                    // Parsing: Format is @key = value or @key,index = value \u003Cbr\u003E                    string valName = val.name.Substring(1);\u003Cbr\u003E                    int index = 0;\u003Cbr\u003E                    if (valName.Contains(\u0022,\u0022)) {\u003Cbr\u003E                        int.TryParse(valName.Split(\u0027,\u0027)[1], out index);\u003Cbr\u003E                        valName = valName.Split(\u0027,\u0027)[0];\u003Cbr\u003E                    } // index is useless right now, but some day it might not be.\u003Cbr\u003E                    if (val.name[0] == \u0027@\u0027)\u003Cbr\u003E                        newNode.SetValue(valName, val.value, index);\u003Cbr\u003E                    else if (val.name[0] == \u0027!\u0027)\u003Cbr\u003E                        newNode.RemoveValues(valName);\u003Cbr\u003E                    else if (val.name[0] == \u0027%\u0027) {\u003Cbr\u003E                        newNode.RemoveValues(valName);\u003Cbr\u003E                        newNode.AddValue(valName, val.value);\u003Cbr\u003E                    }\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E            foreach (ConfigNode subMod in mod.nodes) {\u003Cbr\u003E                subMod.name = RemoveWS(subMod.name);\u003Cbr\u003E                if (subMod.name[0] != \u0027@\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027!\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027%\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027$\u0027)\u003Cbr\u003E                    newNode.AddNode(subMod);\u003Cbr\u003E                else {\u003Cbr\u003E                    ConfigNode subNode;\u003Cbr\u003E                    //if (subMod.name[0] == \u0027@\u0027 \u0026amp;\u0026amp; subMod.name[0] != \u0027%\u0027)\u003Cbr\u003E                    //    subNode = null;\u003Cbr\u003E                    string nodeType;\u003Cbr\u003E                    string nodeName;\u003Cbr\u003E                    string indexes = \u0022\u0022;\u003Cbr\u003E                    int index;\u003Cbr\u003E\u003Cbr\u003E                    if (subMod.name.Contains(\u0022[\u0022))\u003Cbr\u003E                    {\u003Cbr\u003E                        nodeType = subMod.name.Substring(1).Split(\u0027[\u0027)[0];\u003Cbr\u003E                        nodeName = subMod.name.Split(\u0027[\u0027)[1].Replace(\u0022]\u0022, \u0022\u0022);\u003Cbr\u003E                        indexes = \u0022\u0022;\u003Cbr\u003E                        index = 0;\u003Cbr\u003E\u003Cbr\u003E                        // format @NODETYPE[Name] {...} or @NODETYPE[Name], index {...} or ! instead of @\u003Cbr\u003E                        if (nodeName.Contains(\u0022,\u0022))\u003Cbr\u003E                        {\u003Cbr\u003E                            // format @NODETYPE[Name], index {...} or ! instead of @\u003Cbr\u003E                            nodeName = nodeName.Split(\u0027,\u0027)[0];\u003Cbr\u003E                            indexes = nodeType.Split(\u0027,\u0027)[1];\u003Cbr\u003E                        }\u003Cbr\u003E                    }\u003Cbr\u003E                    else\u003Cbr\u003E                    {\u003Cbr\u003E                        // format @NODETYPE {...} or ! instead of @\u003Cbr\u003E                        nodeType = subMod.name.Substring(1);\u003Cbr\u003E                        nodeName = null;\u003Cbr\u003E                        indexes = \u0022\u0022;\u003Cbr\u003E                        index = 0;\u003Cbr\u003E\u003Cbr\u003E                        // format @NODETYPE,N {...} or ! instead of @\u003Cbr\u003E                        // The problem with ! is that the index is messed up\u003Cbr\u003E                        // So the patch need to take that into account\u003Cbr\u003E                        // and lower the index for the next search\u003Cbr\u003E\u003Cbr\u003E                        if (nodeType.Contains(\u0022,\u0022))\u003Cbr\u003E                        {\u003Cbr\u003E                            nodeType = nodeType.Split(\u0027,\u0027)[0];\u003Cbr\u003E                            indexes = nodeType.Split(\u0027,\u0027);\u003Cbr\u003E                        }\u003Cbr\u003E                        ConfigNode[] subNodes = newNode.GetNodes(nodeType);\u003Cbr\u003E                        if (subNodes.Length \u0026gt; index)\u003Cbr\u003E                            subNode = subNodes[index];\u003Cbr\u003E                        else\u003Cbr\u003E                            subNode = null;\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    // an index of \u0027*\u0027 means apply to ALL subnodes that match\u003Cbr\u003E                    if (indexes == \u0022*\u0022 || indexes == \u0022\u0022)\u003Cbr\u003E                        index = 0;\u003Cbr\u003E                    else\u003Cbr\u003E                        int.TryParse(indexes, out index);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E                    bool moreToDo = true;\u003Cbr\u003E                    do\u003Cbr\u003E                    {\u003Cbr\u003E                        subNode = FindConfigNodeIn(newNode, nodeType, nodeName, index);\u003Cbr\u003E                        if (subNode != null)\u003Cbr\u003E                        {\u003Cbr\u003E                            if (subMod.name[0] == \u0027@\u0027)\u003Cbr\u003E                            {\u003Cbr\u003E                                // find the original subnode to modify, modify it and add the modified.\u003Cbr\u003E                                if (subNode != null)\u003Cbr\u003E                                {\u003Cbr\u003E                                    ConfigNode newSubNode = ModifyNode(subNode, subMod);\u003Cbr\u003E                                    newNode.nodes.Add(newSubNode);\u003Cbr\u003E                                }\u003Cbr\u003E                                else\u003Cbr\u003E                                    print(\u0022[ModuleManager] Could not find node to modify: \u0022 \u002B subMod.name);\u003Cbr\u003E                            }\u003Cbr\u003E                            if (subMod.name[0] == \u0027%\u0027)\u003Cbr\u003E                            {\u003Cbr\u003E                                // if the original node exist add it\u003Cbr\u003E                                if (subNode != null)\u003Cbr\u003E                                {\u003Cbr\u003E                                    ConfigNode newSubNode = ModifyNode(subNode, subMod);\u003Cbr\u003E                                    newNode.nodes.Add(newSubNode);\u003Cbr\u003E                                }\u003Cbr\u003E                                else\u003Cbr\u003E                                { // if not add the mod node without the % in its name                            \u003Cbr\u003E                                    // This part is messy. ialdabaoth is right, i need to rewrite.\u003Cbr\u003E                                    string type;\u003Cbr\u003E                                    string name;\u003Cbr\u003E                                    if (subMod.name.Contains(\u0022[\u0022))\u003Cbr\u003E                                    {\u003Cbr\u003E                                        type = subMod.name.Substring(1).Split(\u0027[\u0027)[0];\u003Cbr\u003E                                        name = subMod.name.Split(\u0027[\u0027)[1].Replace(\u0022]\u0022, \u0022\u0022);\u003Cbr\u003E                                    }\u003Cbr\u003E                                    else\u003Cbr\u003E                                    {\u003Cbr\u003E                                        type = subMod.name.Substring(1);\u003Cbr\u003E                                        name = null;\u003Cbr\u003E                                    }\u003Cbr\u003E\u003Cbr\u003E                                    ConfigNode copy = new ConfigNode(type);\u003Cbr\u003E\u003Cbr\u003E                                    if (name != null)\u003Cbr\u003E                                        copy.AddValue(\u0022name\u0022, name);\u003Cbr\u003E\u003Cbr\u003E                                    ConfigNode newSubNode = ModifyNode(copy, subMod);\u003Cbr\u003E                                    newNode.nodes.Add(newSubNode);\u003Cbr\u003E                                }\u003Cbr\u003E                            }\u003Cbr\u003E                            if (subMod.name[0] == \u0027$\u0027)\u003Cbr\u003E                            {\u003Cbr\u003E                                // find the original subnode to copy, add the original, add the the modified copy.\u003Cbr\u003E                                if (subNode != null)\u003Cbr\u003E                                {\u003Cbr\u003E                                    newNode.nodes.Add(subNode);\u003Cbr\u003E                                    ConfigNode newSubNode = ModifyNode(subNode, subMod);\u003Cbr\u003E                                    newNode.nodes.Add(newSubNode);\u003Cbr\u003E                                }\u003Cbr\u003E                                else\u003Cbr\u003E                                    print(\u0022[ModuleManager] Could not find node to copy: \u0022 \u002B subMod.name);\u003Cbr\u003E                            }\u003Cbr\u003E\u003Cbr\u003E                            // an index of \u0027*\u0027 means apply to ALL subnodes that match\u003Cbr\u003E                            if (indexes == \u0022*\u0022) \u003Cbr\u003E                                index\u002B\u002B;\u003Cbr\u003E                            else\u003Cbr\u003E                                moreToDo = false;\u003Cbr\u003E                        }\u003Cbr\u003E                        else\u003Cbr\u003E                        {\u003Cbr\u003E                            moreToDo = false;\u003Cbr\u003E                        }\u003Cbr\u003E                    } while (moreToDo);\u003Cbr\u003E\u003Cbr\u003E                    if (subNode != null)\u003Cbr\u003E                        newNode.nodes.Remove(subNode);\u003Cbr\u003E\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            return newNode;\u003Cbr\u003E        }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"ialdabaoth","CreatedById":57270,"CreatedDateTime":"2014-03-21T16:07:07Z","Content":"\n\u003Cp\u003EUPDATE! I just talked to sarbian; in his absence, I will be creating and releasing Module Manager 2.0.0\u003C/p\u003E\u003Cp\u003EI will do EVERYTHING I CAN not to break backwards compatibility, but no guarantees - there\u0027s a few cases where the current system does not provide an unambiguous configNode application sequence.\u003C/p\u003E\u003Cp\u003EHere is a preview of 2.0.0 syntax:\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:14px;\u0022\u003E\u003Cstrong\u003E1. Mod Definitions\u003C/strong\u003E\u003C/span\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003EMOD {\u003Cbr\u003E  name = MyMod \t\t\t\t// this is the name of your mod\u003Cbr\u003E  version = 23 \t\t\t\t// this is the version of your mod. It must be a single number, that increases whenever you release a new version.\u003Cbr\u003E  plugin = MyMod\\mymod.dll\u003Cbr\u003E  url = http://www.mymod.com/download\u003Cbr\u003E\u003Cbr\u003E  NEEDS { \t\t\t\t// a \u0027NEEDS\u0027 block defines a dependency \u003Cbr\u003E    name = NeededMod \t\t\t// i.e., ModManager should throw an error if the correct version of NeededMod isn\u0027t installed.\u003Cbr\u003E    min_version = 15\t\t\t// If NeededMod is installed, but the installed Version is 14 or lower, ModManager should throw an error.\u003Cbr\u003E\t\t\t\t\t// if min_version is blank, defaults to -1\u003Cbr\u003E    max_version = 9999\t\t\t// If NeededMod is installed, but the installed Version is 10000 or higher, ModManager should throw an error. \u003Cbr\u003E\t\t\t\t\t// if max_version is blank, defaults to a ridiculously large number (2 billion or so)\u003Cbr\u003E    error_message = MyMod version 23 requires NeededMod version 15 or higher. (Last tested version was 17). Please check $KSPFORUM:threads/75562-MyMod-Thread for details.\u003Cbr\u003E  }\u003Cbr\u003E\u003Cbr\u003E  CONFLICTS {\t\t\t\t// a \u0027CONFLICTS\u0027 block is the opposite of a \u0027NEEDS\u0027 block.\u003Cbr\u003E    name = BadMod \t\t\t// i.e., ModManager should throw an error if a conflicting version of BadMod is installed.\u003Cbr\u003E    min_version = 11\t\t\t// If BadMod is installed, but the installed Version is 10 or lower, ModManager should NOT throw an error.\u003Cbr\u003E\t\t\t\t\t// if min_version is blank, defaults to -1\u003Cbr\u003E    max_version = 13\t\t\t// If BadMod is installed, but the installed Version is 14 or higher, ModManager should NOT throw an error.\u003Cbr\u003E\t\t\t\t\t// if max_version is blank, defaults to a ridiculously large number (2 billion or so)\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EIf you do not include a Mod Definition with your mod, ModuleManager 2.0.0 WILL STILL WORK, but you (and other modders!) will not have access to any of the new fancy sequencing rules, or dependency checking. You\u0027ll only have access to the first-pass run and the :FINAL run.\u003C/p\u003E\u003Cp\u003EIf you DO include a Mod Definition, ModuleManager 2.0.0 will do two awesome things for you:\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:14px;\u0022\u003E\u003Cstrong\u003E2. Dependency and Conflict Checking\u003C/strong\u003E\u003C/span\u003E\u003C/p\u003E\u003Cp\u003EModuleManager 2.0 will check dependencies, by which I mean it will look for any other MOD nodes that match your NEEDS {} and CONFLICTS {} nodes, and throw up a warning to the user that they need to resolve any dependencies or conflicts indicated.\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:14px;\u0022\u003E\u003Cstrong\u003E3. Per-Mod Patch Sequencing\u003C/strong\u003E\u003C/span\u003E\u003C/p\u003E\u003Cp\u003EModuleManager 2.0 will create three new passes for each MOD node it finds, that happen after the first-pass but before :FINAL. These passes look like this:\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E:BEFORE[MyMod]\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EThe :BEFORE[MyMod] pass happens first, and happens once for each mod. You can specify it one of two ways:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:BEFORE[MyMod] // this config patch will ONLY be applied if any version of the MyMod mod is installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003Eif you require a specific version, you can do:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:BEFORE[MyMod,23] // this config patch will ONLY be applied if version 23 or greater of the MyMod mod is installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EAnd if you need versions of MULTIPLE mods, you can do:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:BEFORE[MyMod,23]:NEEDS[ModuleManager,200] // this config patch will ONLY be applied if version 23 or greater of the MyMod mod is installed, AND version 200 or greater of ModuleManager is installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:BEFORE[MyMod,23]:NEEDS[!Firespitter] // this config patch will ONLY be applied if version 23 or greater of the MyMod mod is installed, AND no version of Firespitter is installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E:FOR[MyMod]\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EThe :FOR[MyMod] pass happens next, and happens once for each mod. It uses the same syntax:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:FOR[MyMod] // this config patch will ONLY be applied any version of the MyMod mod is installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:FOR[MyMod,23] // this config patch will ONLY be applied if version 23 or greater of the MyMod mod is installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:FOR[MyMod,23]:NEEDS[ModuleManager,200]:NEEDS[!RealFuels,50] // this config patch will ONLY be applied if version 23 or greater of the MyMod mod is installed, AND version 200 or greater of ModuleManager is installed, AND version 50 or greater of RealFuels ISN\u0027T installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003E:AFTER[MyMod]\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EThe :AFTER[MyMod] pass happens next, and happens once for each mod. It uses the same syntax as above:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:AFTER[MyMod] // this config patch will ONLY be applied if any version of the MyMod mod is installed\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:AFTER[MyMod,23]:NEEDS[!ModuleManager] // this config patch will ONLY be applied if version 23 or greater of the MyMod mod is installed, AND no version of ModuleManager is installed. Good luck with that.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI\u0027ll continue to post here with progress.\u003C/p\u003E\n"},{"CreatedByName":"GavinZac","CreatedById":68719,"CreatedDateTime":"2014-03-21T16:54:07Z","Content":"\n\u003Cp\u003ELooks like a very exciting expansion! Looking forward to learning some new skills.\u003C/p\u003E\n"},{"CreatedByName":"sarbian","CreatedById":57146,"CreatedDateTime":"2014-03-21T17:34:45Z","Content":"\n\u003Cp\u003ELooks greats and it would solve a lot of the common problem when a lot of mods uses MM\u003C/p\u003E\u003Cp\u003EI have added the dev branch to my new Jenkins server. Anything pushed to dev will be compiled and made available here : \u003Ca href=\u0022http://ksp.sarbian.com/jenkins/job/ModuleManager%20Dev/\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://ksp.sarbian.com/jenkins/job/ModuleManager%20Dev/\u003C/a\u003E\u003C/p\u003E\n"},{"CreatedByName":"Arrowmaster","CreatedById":57556,"CreatedDateTime":"2014-03-22T22:06:25Z","Content":"\n\u003Cp\u003EWhile I like the additions of more passes to better handle multiple mods making changes to the same parts, I don\u0027t like the syntax and BEFORE, FOR, and AFTER names. I think its just trying to bandaid a broken method of only 2 passes by adding 3 more.\u003C/p\u003E\u003Cp\u003EWhat about a way to link to link each file with @NODE definitions in it to a MOD and and define interactions such as this cfg file must be loaded before/after any files linked to OTHERMOD if its installed. I feel like without a way to define interactions between mods the problem will resurface again as more complex configs are used. To keep things simpler make everything in the same file that uses the new format load at the same time. Does this make any sense how im trying to explain it?\u003C/p\u003E\u003Cp\u003EI have a question about the version selection logic in this.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022ialdabaoth\u0022 data-cite=\u0022ialdabaoth\u0022\u003E\u003Cdiv\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:FOR[MyMod,23]:NEEDS[ModuleManager,200]:NEEDS[!RealFuels,50] // this config patch will ONLY be applied if version 23 or greater of the MyMod mod is installed, AND version 200 or greater of ModuleManager is installed, AND version 50 or greater of RealFuels ISN\u0027T installed.\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIs there a way to say only load this if a version of MOD before X is installed or would that require something like this for only working on version 49 or lesser of RealFuels? Like this?\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:FOR[MyMod,23]:NEEDS[RealFuels]:NEEDS[!RealFuels,50]\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EWhy not just support comparison options with it defaulting to \u0026gt;= so something like this could be done? Make it support \u0026gt;= (default if none entered), \u0026gt;, =, \u0026lt;, and \u0026lt;=.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[some_part]:FOR[MyMod,23]:NEEDS[RealFuels,\u0026lt;50]\u003Cbr\u003E{\u003Cbr\u003E   // do stuff\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EHave you added in the abiltiy to use :HAS on subnodes? So we can select from multiple nodes without having to use the tags that nobody does or without knowing exactly which number references it. For example like this.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E@PART[*]\u003Cbr\u003E{\u003Cbr\u003E  @MODULE[foo]:HAS[#bar=baz]\u003Cbr\u003E  {\u003Cbr\u003E    // do stuff\u003Cbr\u003E  }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EAnd I think some people wanted the ability to use other operators in #bar=baz to so stuff like #mass\u0026lt;0.05.\u003C/p\u003E\n"},{"CreatedByName":"BudgetHedgehog\uFEFF","CreatedById":104112,"CreatedDateTime":"2014-03-23T15:50:50Z","Content":"\n\u003Cp\u003ELooking forward to 2.0.0!\u003C/p\u003E\u003Cp\u003EQuick question though: I want to move all RCS tanks to the Control tab, so I use the following\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E@PART[*]:HAS[@RESOURCE[MonoPropellant]]:Final\u003Cbr\u003E{\u003Cbr\u003E\t@category = Control\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EHowever, this moves all the command pods there as well. What syntax should I put that includes things with resource MonoPropellant but excludes ModuleCommand?\u003C/p\u003E\u003Cp\u003EEDIT: Am I right in thinking it would be \u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E@PART[*]:HAS[@RESOURCE[MonoPropellant]]:HAS[!MODULE[ModuleCommand]:Final\u003Cbr\u003E{\u003Cbr\u003E\t@category = Control\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E?\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-03-23T15:53:53Z\u0022 title=\u002203/23/2014 03:53  PM\u0022 data-short=\u002210 yr\u0022\u003EMarch 23, 2014\u003C/time\u003E by ObsessedWithKSP\u003C/strong\u003E\n\u003C/span\u003E\n"}]}