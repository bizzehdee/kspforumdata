{"TopicId":103963,"ForumId":36,"TopicTitle":"[WIP][1.9.x-1.12.x] Scatterer-atmospheric scattering (0.0838 - 14/08/2022) Scattering improvements, in-game atmo generation and multi-sun support","CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-04-12T08:37:35Z","PageNum":78,"Articles":[{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-17T23:42:22Z","Content":"\n[quote name=\u0027blackrack\u0027]Btw is your celestial object shadow shader functional in the newest EVE?[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nNope. Some of the stuff is there, but not enabled. I have to go a completely new route as many things wouldn\u0026#39;t work properly had I pursued the multi-projector route (eg. any transparent things like clouds wouldn\u0026#39;t be handled properly, scaled space shadows shake violently with camera movement, and multiple bodies obscuring the sun would result in multiple darkening passes being very unrealistic.) so I\u0026#39;m pursuing the single projector, multi-body shader for macro space, and an additional body material that handles multiple casts. I may turn this into a full scale lighting pass shader.\u003Cbr\u003E\n\u003Cbr\u003E\n[quote name=\u0027blackrack\u0027]And another question about projectors, how do you geenerate them from the clouds texture for the shadows?[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nOooh... a loaded question... basically, we take the vertex, the sun Direction, the body position and the cloud sphere radius, and use sphere collision math to determine at what distance a ray from that vertex would hit the cloud sphere. Then we take that, and get the cloud position with vertex\u002B(sunDir*distance) and from there, we use the body position to get the point of the sphere that resolves to. From there, we just plug that into our existing formula to fetch the texture. You can take a look in [url]https://github.com/rbray89/EnvironmentalVisualEnhancements/blob/master/ShaderLoader/Shaders/CloudShadow.shader[/url] to get a better peek.\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-17T23:59:25Z","Content":"\n[quote name=\u0027rbray89\u0027]Oooh... a loaded question... basically, we take the vertex, the sun Direction, the body position and the cloud sphere radius, and use sphere collision math to determine at what distance a ray from that vertex would hit the cloud sphere. Then we take that, and get the cloud position with vertex\u002B(sunDir*distance) and from there, we use the body position to get the point of the sphere that resolves to. From there, we just plug that into our existing formula to fetch the texture. You can take a look in [url]https://github.com/rbray89/EnvironmentalVisualEnhancements/blob/master/ShaderLoader/Shaders/CloudShadow.shader[/url] to get a better peek.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nThat seems nifty, in the end do you just look at the alpha value of the texture? Do the shadows have variable alpha depending on the clouds? I probably shouldn\u0026#39;t look at the code right now though as I\u0026#39;m way too tired to understand anything.\u003Cbr\u003E\n\u003Cbr\u003E\nAlso, I wanted to ask your opinion about logarithmic depth buffers. I\u0026#39;ve been meaning to implement a custom logarithmic depth buffer for use with the \u0022post-processing\u0022 shader to solve what I think are depth buffer inaccuracies that arise mostly in dx11 and OpenGL when looking at the water surface from the limit altitude where the PQS is disappearing, but also I think it causes a flickering (z-fighting?) effect in dx9.\u003Cbr\u003E\n\u003Cbr\u003E\nThere are a few resources on this, notably\u003Cbr\u003E\n\u003Cbr\u003E\n[URL=\u0022http://outerra.blogspot.fr/2009/08/logarithmic-z-buffer.html\u0022]http://outerra.blogspot.fr/2009/08/logarithmic-z-buffer.html[/URL]\u003Cbr\u003E\n\u003Cbr\u003E\n[URL=\u0022http://outerra.blogspot.fr/2013/07/logarithmic-depth-buffer-optimizations.html\u0022]http://outerra.blogspot.fr/2013/07/logarithmic-depth-buffer-optimizations.html[/URL]\u003Cbr\u003E\n\u003Cbr\u003E\nI haven\u0026#39;t gone too much in detail yet but it seems feasible, although I think reconstructing world position from this new depth buffer might be a bit more of a pain (it already was a pain for me to get working).\u003Cbr\u003E\n\u003Cbr\u003E\nI plan to just start from the provided unity depth shader and make changes to it, then use it as a replacement shader and obtain a depth buffer in a rendertexture. Thought it sounds straightforward, I know if too much matrix math gets involved I will lose my sanity.\u003Cbr\u003E\n\u003Cbr\u003E\n[quote name=\u0027Nhawks17\u0027]Fixed the black land but the sky is still black :([/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nOh well, no idea what to do now, as far as I know it should be ignoring the projectors now.\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-11-18T00:01:42Z\u0022 title=\u002211/18/2015 12:01  AM\u0022 data-short=\u00228 yr\u0022\u003ENovember 18, 2015\u003C/time\u003E by blackrack\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Manwith Noname","CreatedById":117203,"CreatedDateTime":"2015-11-18T00:11:50Z","Content":"\nGood news, hopefully.\u003Cbr\u003E\n\u003Cbr\u003E\nLatest EVE, Scatterer 0.0191 plus fix 3. It appears all the visual glitches are gone....at least for me. The only thing that remains is the atmo effect is lost when returning to space center from map view, which is presumably something to do with refreshing on scene change...though you two (Blackrack and rBray89) are far more qualified to be able to diagnose that.\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T00:14:45Z","Content":"\n[quote name=\u0027Manwith Noname\u0027]Good news, hopefully.\u003Cbr\u003E\n\u003Cbr\u003E\nLatest EVE, Scatterer 0.0191 plus fix 3. It appears all the visual glitches are gone....at least for me. The only thing that remains is the atmo effect is lost when returning to space center from map view, which is presumably something to do with refreshing on scene change...though you two (Blackrack and rBray89) are far more qualified to be able to diagnose that.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nThat is just a bug with the latest version that happens sometimes. Not important I\u0026#39;d say it\u0026#39;s just the KSC view, nothing game-breaking. However, I\u0026#39;m testing the fix myself right now, and it seems with scatterer only the sky still goes black randomly.\n"},{"CreatedByName":"Manwith Noname","CreatedById":117203,"CreatedDateTime":"2015-11-18T00:21:10Z","Content":"\nHmm, well, I never got a complete wipeout, just stripes and boxes.\u003Cbr\u003E\n\u003Cbr\u003E\nYeah, I appreciate it\u0026#39;s not major, particularly when I can just jump in the tracking station and back out again to get it back. It\u0026#39;s that white horizon that bugs me the most.\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T00:33:07Z","Content":"\n[quote name=\u0027blackrack\u0027]That seems nifty, in the end do you just look at the alpha value of the texture? Do the shadows have variable alpha depending on the clouds? I probably shouldn\u0026#39;t look at the code right now though as I\u0026#39;m way too tired to understand anything.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nClose... we first subtract the alpha off the color, then use the alpha to lerp between 1 and the color. It is then multiplied to the DstColor. This way, if the cloud was colored, we get a multiplicative effect that reflects the color passing through. We subtract the alpha to ensure that a fully opaque cloud is always opaque but if not some color should still show through (maybe we should use *(1-color.a) instead...) and then that value gets filtered once again by alpha to determine intensity.\u003Cbr\u003E\n[code]\u003Cbr\u003E\nBlend Zero SrcColor\u003Cbr\u003E\n...\u003Cbr\u003E\nfixed4 color = _Color * main.rgba * lerp(detail.rgba, 1, detailLevel);\u003Cbr\u003E\ncolor.rgb = saturate(color.rgb - color.a);\u003Cbr\u003E\ncolor.rgb = lerp(1, color.rgb, _ShadowFactor*color.a);\u003Cbr\u003E\nreturn lerp(1, color, shadowCheck);\u003Cbr\u003E\n[/code]\u003Cbr\u003E\n[quote name=\u0027blackrack\u0027]Also, I wanted to ask your opinion about logarithmic depth buffers. I\u0026#39;ve been meaning to implement a custom logarithmic depth buffer for use with the \u0022post-processing\u0022 shader to solve what I think are depth buffer inaccuracies that arise mostly in dx11 and OpenGL when looking at the water surface from the limit altitude where the PQS is disappearing, but also I think it causes a flickering (z-fighting?) effect in dx9.\u003Cbr\u003E\n\u003Cbr\u003E\nThere are a few resources on this, notably\u003Cbr\u003E\n\u003Cbr\u003E\n[URL=\u0022http://outerra.blogspot.fr/2009/08/logarithmic-z-buffer.html\u0022]http://outerra.blogspot.fr/2009/08/logarithmic-z-buffer.html[/URL]\u003Cbr\u003E\n\u003Cbr\u003E\n[URL=\u0022http://outerra.blogspot.fr/2013/07/logarithmic-depth-buffer-optimizations.html\u0022]http://outerra.blogspot.fr/2013/07/logarithmic-depth-buffer-optimizations.html[/URL]\u003Cbr\u003E\n\u003Cbr\u003E\nI haven\u0026#39;t gone too much in detail yet but it seems feasible, although I think reconstructing world position from this new depth buffer might be a bit more of a pain (it already was a pain for me to get working).\u003Cbr\u003E\n\u003Cbr\u003E\nI plan to just start from the provided unity depth shader and make changes to it, then use it as a replacement shader and obtain a depth buffer in a rendertexture. Thought it sounds straightforward, I know if too much matrix math gets involved I will lose my sanity.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nIf it is just water surface, than do what I was doing. I didn\u0026#39;t want to enable depth processing on the ocean.:\u003Cbr\u003E\n[code]\u003Cbr\u003E\n_OceanRadius (\u0022Ocean Radius\u0022, Float) = 63000\u003Cbr\u003E\n_PlanetOrigin (\u0022Sphere Center\u0022, Vector) = (0,0,0,1)\u003Cbr\u003E\n...\u003Cbr\u003E\nfloat _OceanRadius;\u003Cbr\u003E\nfloat3 _PlanetOrigin;\u003Cbr\u003E\n...\u003Cbr\u003E\n[vertex]\u003Cbr\u003E\no.L = _PlanetOrigin - _WorldSpaceCameraPos.xyz;\u003Cbr\u003E\n...\u003Cbr\u003E\n[surface]\u003Cbr\u003E\nhalf3 worldDir = normalize(IN.worldVert - _WorldSpaceCameraPos.xyz);\u003Cbr\u003E\nfloat tc = dot(IN.L, worldDir);\u003Cbr\u003E\nfloat d = sqrt(dot(IN.L,IN.L)-(tc*tc));\u003Cbr\u003E\nfloat3 norm = normalize(-IN.L);\u003Cbr\u003E\nfloat d2 = pow(d,2);\u003Cbr\u003E\nfloat td = sqrt(dot(IN.L,IN.L)-d2); \u003Cbr\u003E\n\u003Cbr\u003E\nfloat oceanRadius = _Scale*_OceanRadius;\u003Cbr\u003E\nhalf sphereCheck = step(d, oceanRadius)*step(0.0, tc);\u003Cbr\u003E\n\u003Cbr\u003E\nfloat tlc = sqrt((oceanRadius*oceanRadius)-d2);\u003Cbr\u003E\nfloat oceanSphereDist = lerp(depth, tc - tlc, sphereCheck);\u003Cbr\u003E\n\u003Cbr\u003E\ndepth = min(oceanSphereDist, depth);\u003Cbr\u003E\n[/code]\u003Cbr\u003E\n\u003Cbr\u003E\nThis will allow you to get the distance to the ocean if it is a \u0022hit\u0022 or depth in the \u0022miss\u0022 case. From there, you just take the min of the depth and the ocean dist. It allows you to get the VERY accurate distance to the ocean (floating point loss rather than depth buffer compression)\u003Cbr\u003E\n\u003Cbr\u003E\nI dreamed this up when thinking about how to go about doing stuff without using the depth buffer, and found that spherical collision is actually a very common math problem apparently. I\u0026#39;ve since used the same approach in many shaders. We are very lucky that things are perfect spheres in KSP.\u003Cbr\u003E\n\u003Cbr\u003E\n[COLOR=\u0022silver\u0022][SIZE=1]- - - Updated - - -[/SIZE][/COLOR]\u003Cbr\u003E\n\u003Cbr\u003E\nOh, and you shouldn\u0026#39;t have to use shaderreplacer any more! The newest KSP added the shader tags for RenderType.\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T00:33:43Z","Content":"\n[quote name=\u0027rbray89\u0027]Close... we first subtract the alpha off the color, then use the alpha to lerp between 1 and the color. It is then multiplied to the DstColor. This way, if the cloud was colored, we get a multiplicative effect that reflects the color passing through. We subtract the alpha to ensure that a fully opaque cloud is always opaque but if not some color should still show through (maybe we should use *(1-color.a) instead...) and then that value gets filtered once again by alpha to determine intensity.\u003Cbr\u003E\n[code]\u003Cbr\u003E\nBlend Zero SrcColor\u003Cbr\u003E\n...\u003Cbr\u003E\nfixed4 color = _Color * main.rgba * lerp(detail.rgba, 1, detailLevel);\u003Cbr\u003E\ncolor.rgb = saturate(color.rgb - color.a);\u003Cbr\u003E\ncolor.rgb = lerp(1, color.rgb, _ShadowFactor*color.a);\u003Cbr\u003E\nreturn lerp(1, color, shadowCheck);\u003Cbr\u003E\n[/code]\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\nIf it is just water surface, than do what I was doing. I didn\u0026#39;t want to enable depth processing on the ocean.:\u003Cbr\u003E\n[code]\u003Cbr\u003E\n_OceanRadius (\u0022Ocean Radius\u0022, Float) = 63000\u003Cbr\u003E\n_PlanetOrigin (\u0022Sphere Center\u0022, Vector) = (0,0,0,1)\u003Cbr\u003E\n...\u003Cbr\u003E\nfloat _OceanRadius;\u003Cbr\u003E\nfloat3 _PlanetOrigin;\u003Cbr\u003E\n...\u003Cbr\u003E\n[vertex]\u003Cbr\u003E\no.L = _PlanetOrigin - _WorldSpaceCameraPos.xyz;\u003Cbr\u003E\n...\u003Cbr\u003E\n[surface]\u003Cbr\u003E\nhalf3 worldDir = normalize(IN.worldVert - _WorldSpaceCameraPos.xyz);\u003Cbr\u003E\nfloat tc = dot(IN.L, worldDir);\u003Cbr\u003E\nfloat d = sqrt(dot(IN.L,IN.L)-(tc*tc));\u003Cbr\u003E\nfloat3 norm = normalize(-IN.L);\u003Cbr\u003E\nfloat d2 = pow(d,2);\u003Cbr\u003E\nfloat td = sqrt(dot(IN.L,IN.L)-d2); \u003Cbr\u003E\n\u003Cbr\u003E\nfloat oceanRadius = _Scale*_OceanRadius;\u003Cbr\u003E\nhalf sphereCheck = step(d, oceanRadius)*step(0.0, tc);\u003Cbr\u003E\n\u003Cbr\u003E\nfloat tlc = sqrt((oceanRadius*oceanRadius)-d2);\u003Cbr\u003E\nfloat oceanSphereDist = lerp(depth, tc - tlc, sphereCheck);\u003Cbr\u003E\n\u003Cbr\u003E\ndepth = min(oceanSphereDist, depth);\u003Cbr\u003E\n[/code]\u003Cbr\u003E\n\u003Cbr\u003E\nThis will allow you to get the distance to the ocean if it is a \u0022hit\u0022 or depth in the \u0022miss\u0022 case. From there, you just take the min of the depth and the ocean dist. It allows you to get the VERY accurate distance to the ocean (floating point loss rather than depth buffer compression)\u003Cbr\u003E\n\u003Cbr\u003E\nI dreamed this up when thinking about how to go about doing stuff without using the depth buffer, and found that spherical collision is actually a very common math problem apparently. I\u0026#39;ve since used the same approach in many shaders. We are very lucky that things are perfect spheres in KSP.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nWell it\u0026#39;s mostly the ocean, starts at 10 KMs up. But at higher altitudes other artifacts start appearing over the land so this won\u0026#39;t be enough. I noticed that forcing deferred rendering seems to get rid of all these artifacts but it causes many more issues with the rendering that I don\u0026#39;t feel like looking at. Do you know if deferred rendering uses some kind of higher precision depth buffer? Maybe 32bit for deferred vs 24bit for forward?\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\n[quote name=\u0027rbray89\u0027]\u003Cbr\u003E\nOh, and you shouldn\u0026#39;t have to use shaderreplacer any more! The newest KSP added the shader tags for RenderType.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nSo wait, how do I re-render everything so as to obtain a custom depth buffer without a replacement shader?\u003Cbr\u003E\n\u003Cbr\u003E\nEdited: I might still use your snippet for the ocean as I still get some kind of barrier around the horizon on oceans in OpenGL.\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-11-18T00:37:26Z\u0022 title=\u002211/18/2015 12:37  AM\u0022 data-short=\u00228 yr\u0022\u003ENovember 18, 2015\u003C/time\u003E by blackrack\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T00:37:28Z","Content":"\n[quote name=\u0027blackrack\u0027]Well it\u0026#39;s mostly the ocean, starts at 10 KMs up. But at higher altitudes other artifacts start appearing over the land so this won\u0026#39;t be enough. I noticed that forcing deferred rendering seems to get rid of all these artifacts but it causes many more issues with the rendering that I don\u0026#39;t feel like looking at. Do you know if deferred rendering uses some kind of higher precision depth buffer? Maybe 32bit for deferred vs 24bit for forward?[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nNot that I\u0026#39;m aware of.\u003Cbr\u003E\n\u003Cbr\u003E\nIn case you didn\u0026#39;t see:\u003Cbr\u003E\n\u003Cbr\u003E\nOh, and you shouldn\u0026#39;t have to use shaderreplacer any more! The newest KSP added the shader tags for RenderType.\u003Cbr\u003E\n\u003Cbr\u003E\n[COLOR=\u0022silver\u0022][SIZE=1]- - - Updated - - -[/SIZE][/COLOR]\u003Cbr\u003E\n\u003Cbr\u003E\n[quote name=\u0027blackrack\u0027]Well it\u0026#39;s mostly the ocean, starts at 10 KMs up. But at higher altitudes other artifacts start appearing over the land so this won\u0026#39;t be enough. I noticed that forcing deferred rendering seems to get rid of all these artifacts but it causes many more issues with the rendering that I don\u0026#39;t feel like looking at. Do you know if deferred rendering uses some kind of higher precision depth buffer? Maybe 32bit for deferred vs 24bit for forward?\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\nSo wait, how do I render this as to obtain a custom depth buffer without a replacement shader?[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nShaderReplacer being the entity that substitutes KSPs shader code with the modified code that adds the Shader Tags that they ommitted :)\u003Cbr\u003E\nEDIT: This guy: [url]https://github.com/LGhassen/Scatterer/blob/master/scatterer/ShaderReplacer.cs[/url]\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-11-18T00:39:30Z\u0022 title=\u002211/18/2015 12:39  AM\u0022 data-short=\u00228 yr\u0022\u003ENovember 18, 2015\u003C/time\u003E by rbray89\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T00:39:17Z","Content":"\n[quote name=\u0027rbray89\u0027]Not that I\u0026#39;m aware of.\u003Cbr\u003E\n\u003Cbr\u003E\nIn case you didn\u0026#39;t see:\u003Cbr\u003E\n\u003Cbr\u003E\nOh, and you shouldn\u0026#39;t have to use shaderreplacer any more! The newest KSP added the shader tags for RenderType.\u003Cbr\u003E\n\u003Cbr\u003E\n[COLOR=\u0022silver\u0022][SIZE=1]- - - Updated - - -[/SIZE][/COLOR]\u003Cbr\u003E\n\u003Cbr\u003E\nShaderReplacer being the entity that substitutes KSPs shader code with the modified code that adds the Shader Tags that they ommitted :)[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nBut deferred rendering definitely fixes all the artifacts which is weird.\u003Cbr\u003E\n\u003Cbr\u003E\nAh okay, I\u0026#39;m not talking about ShaderReplacer, but about using replacement shaders [URL=\u0022http://docs.unity3d.com/Manual/SL-ShaderReplacement.html\u0022]http://docs.unity3d.com/Manual/SL-ShaderReplacement.html[/URL] to re-render a scene and obtain a depth buffer for example.\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T00:42:34Z","Content":"\n[quote name=\u0027blackrack\u0027]Ah okay, I\u0026#39;m not talking about ShaderReplacer, but about using replacement shaders [URL=\u0022http://docs.unity3d.com/Manual/SL-ShaderReplacement.html\u0022]http://docs.unity3d.com/Manual/SL-ShaderReplacement.html[/URL] to re-render a scene and obtain a depth buffer for example.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nRight. I just wanted to mention that you can remove this entity and no longer have to worry about updating it going forward. \u003Cbr\u003E\n\u003Cbr\u003E\nAs a cool by-product, if you do make your own depth buffer you could use a camera with a huge clipping area and then you could use the near camera instead of the far camera for rendering and make much more dense atmo-rendering.\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T00:46:43Z","Content":"\n[quote name=\u0027rbray89\u0027]Right. I just wanted to mention that you can remove this entity and no longer have to worry about updating it going forward. \u003Cbr\u003E\n\u003Cbr\u003E\nAs a cool by-product, if you do make your own depth buffer you could use a camera with a huge clipping area and then you could use the near camera instead of the far camera for rendering and make much more dense atmo-rendering.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nThis is a cool idea, and I was thinking about doing this to simulate a really thick atmo on Eve, but for scatterer it wouldn\u0026#39;t work that well because the proland atmo is really rigid in many ways. ALso, won\u0026#39;t this make it render on top of the EVE clouds again?\u003Cbr\u003E\n\u003Cbr\u003E\nHowever I thought about making a custom shader based on the unity global fog shader to simulate dust or really dense fog on Eve.\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T00:54:25Z","Content":"\n[quote name=\u0027blackrack\u0027]This is a cool idea, and I was thinking about doing this to simulate a really thick atmo on Eve, but for scatterer it wouldn\u0026#39;t work that well because the proland atmo is really rigid in many ways. ALso, won\u0026#39;t this make it render on top of the EVE clouds again?\u003Cbr\u003E\n\u003Cbr\u003E\nHowever I thought about making a custom shader based on the unity global fog shader to simulate dust or really dense fog on Eve.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nYeah, but that would be where the idea of writing alpha could save us. \u003Cbr\u003E\n\u003Cbr\u003E\nMe too...\u003Cbr\u003E\n\u003Cbr\u003E\n[COLOR=\u0022silver\u0022][SIZE=1]- - - Updated - - -[/SIZE][/COLOR]\u003Cbr\u003E\n\u003Cbr\u003E\n[quote name=\u0027blackrack\u0027]But deferred rendering definitely fixes all the artifacts which is weird.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nOh, and I think that might be the case. I think that unity might actually render to two seperate buffers for depth and normal to achieve quality results, while you are reading from a depth\u002Bnormal map right?\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T00:58:18Z","Content":"\n[quote name=\u0027rbray89\u0027]Yeah, but that would be where the idea of writing alpha could save us. \u003Cbr\u003E\n\u003Cbr\u003E\nMe too...\u003Cbr\u003E\n\u003Cbr\u003E\n[COLOR=\u0022silver\u0022][SIZE=1]- - - Updated - - -[/SIZE][/COLOR]\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\nOh, and I think that might be the case. I think that unity might actually render to two seperate buffers for depth and normal to achieve quality results, while you are reading from a depth\u002Bnormal map right?[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nActually no, I\u0026#39;m using the depth only map that forward gives and it has artifacts compared to deferred.\u003Cbr\u003E\n\u003Cbr\u003E\nThe depthNormals map was a lot worse and I couldn\u0026#39;t even achieve the effects I wanted with the normals so I just got rid of it.\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T01:00:19Z","Content":"\n[quote name=\u0027blackrack\u0027]Actually no, I\u0026#39;m using the depth only map that forward gives and it has artifacts compared to deferred.\u003Cbr\u003E\n\u003Cbr\u003E\nThe depthNormals map was a lot worse and I couldn\u0026#39;t even achieve the effects I wanted with the normals so I just got rid of it.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nHmmm... Then I\u0026#39;m not sure. It is still probably producing a better depth buffer though.\n"},{"CreatedByName":"Manwith Noname","CreatedById":117203,"CreatedDateTime":"2015-11-18T01:00:56Z","Content":"\n[quote name=\u0027blackrack\u0027]However I thought about making a custom shader based on the unity global fog shader to simulate dust or really dense fog on Eve.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\n[quote name=\u0027rbray89\u0027]\u003Cbr\u003E\n\u003Cbr\u003E\nMe too...[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\n\u003Cbr\u003E\n[Insert Shia LeBeouf \u0022Do it\u0022 video]\u003Cbr\u003E\n\u003Cbr\u003E\n;p\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T01:24:42Z","Content":"\n[quote name=\u0027rbray89\u0027]Hmmm... Then I\u0026#39;m not sure. It is still probably producing a better depth buffer though.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nI\u0026#39;ve looked around a bit, it appears that when using forward, unity uses whichever depth buffer is default for the platform and hardware (32bit for dx9, 24bit for OpenGL) and when using deferred it uses replacement shaders to render a 32bit depth buffer for both. So this should work :cool:\u003Cbr\u003E\n\u003Cbr\u003E\nAnd although dx9 seems to have slight flickering at some altitudes it\u0026#39;s much better than the combined patterns and flickering OpenGL has. This will be a first step before I try a logarithmic depth buffer.\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T01:36:01Z","Content":"\n[quote name=\u0027blackrack\u0027]I\u0026#39;ve looked around a bit, it appears that when using forward, unity uses whichever depth buffer is default for the platform and hardware (32bit for dx9, 24bit for OpenGL) and when using deferred it uses replacement shaders to render a 32bit depth buffer for both. So this should work :cool:\u003Cbr\u003E\n\u003Cbr\u003E\nAnd although dx9 seems to have slight flickering at some altitudes it\u0026#39;s much better than the combined patterns and flickering OpenGL has. This will be a first step before I try a logarithmic depth buffer.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nAh that makes sense. I\u0026#39;d probably like a better depth buffer anyways and being able to send that off to all cameras rather than relying on them to have a unified buffer.\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T03:41:35Z","Content":"\nCustom depth buffer is working, all high altitude artifacts and moire patterns are gone. The barrier effect at the edge of the ocean remains but I already have an idea for that.\u003Cbr\u003E\n\u003Cbr\u003E\n[IMG]http://i.imgur.com/HjQX71H.jpg[/IMG]\u003Cbr\u003E\n\u003Cbr\u003E\nThe maximum depth allowed is actually 24bit. Turns out OpenGL was using 16bit by default which explains why it was so bad.\u003Cbr\u003E\n\u003Cbr\u003E\nNow to fix the ground to orbit transition.\u003Cbr\u003E\n\u003Cbr\u003E\nEdited: for those who want to try it: [URL=\u0022https://mega.nz/#!6JYDSKQJ!JoSWw_pr7wH1wBbknI3k7Nfl5xhRJ7tUcYCCcx3xHyA\u0022]ArtifactsFix.zip[/URL]\u003Cbr\u003E\n\u003Cbr\u003E\nI will probably add a few more features before making a complete new release/reupload to kerbalstuff.\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-11-18T03:47:03Z\u0022 title=\u002211/18/2015 03:47  AM\u0022 data-short=\u00228 yr\u0022\u003ENovember 18, 2015\u003C/time\u003E by blackrack\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"HafCoJoe","CreatedById":80363,"CreatedDateTime":"2015-11-18T03:47:21Z","Content":"\nGreat news man :). I\u0026#39;ve been a bit too busy to report lately (and right now the power is out :P). Great to hear you discovered the source!\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T03:56:38Z","Content":"\n[quote name=\u0027blackrack\u0027]Custom depth buffer is working, all high altitude artifacts and moire patterns are gone. The barrier effect at the edge of the ocean remains but I already have an idea for that.\u003Cbr\u003E\n\u003Cbr\u003E\n[url]http://i.imgur.com/HjQX71H.jpg[/url]\u003Cbr\u003E\n\u003Cbr\u003E\nThe maximum depth allowed is actually 24bit. Turns out OpenGL was using 16bit by default which explains why it was so bad.\u003Cbr\u003E\n\u003Cbr\u003E\nNow to fix the ground to orbit transition.\u003Cbr\u003E\n\u003Cbr\u003E\nEdited: for those who want to try it: [URL=\u0022https://mega.nz/#!6JYDSKQJ!JoSWw_pr7wH1wBbknI3k7Nfl5xhRJ7tUcYCCcx3xHyA\u0022]ArtifactsFix.zip[/URL]\u003Cbr\u003E\n\u003Cbr\u003E\nI will probably add a few more features before making a complete new release/reupload to kerbalstuff.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nSweet! What is involved with generating the new depth texture?\n"},{"CreatedByName":"blackrack","CreatedById":104258,"CreatedDateTime":"2015-11-18T04:09:37Z","Content":"\n[quote name=\u0027rbray89\u0027]Sweet! What is involved with generating the new depth texture?[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nIt\u0026#39;s actually pretty simple, using this as a replacement shader\u003Cbr\u003E\n\u003Cbr\u003E\n[CODE]\u003Cbr\u003E\nShader \u0022Custom/DepthTexture\u0022 {\u003Cbr\u003E\nSubShader {\u003Cbr\u003E\nTags { \u0022RenderType\u0022=\u0022Opaque\u0022 }\u003Cbr\u003E\nPass {\u003Cbr\u003E\nFog { Mode Off }\u003Cbr\u003E\nCGPROGRAM\u003Cbr\u003E\n\u003Cbr\u003E\n#pragma vertex vert\u003Cbr\u003E\n#pragma fragment frag\u003Cbr\u003E\n#include \u0022UnityCG.cginc\u0022\u003Cbr\u003E\n\u003Cbr\u003E\nstruct v2f {\u003Cbr\u003E\nfloat4 pos : SV_POSITION;\u003Cbr\u003E\nfloat2 depth : TEXCOORD0;\u003Cbr\u003E\n};\u003Cbr\u003E\n\u003Cbr\u003E\nv2f vert (appdata_base v) {\u003Cbr\u003E\nv2f o;\u003Cbr\u003E\no.pos = mul (UNITY_MATRIX_MVP, v.vertex);\u003Cbr\u003E\nUNITY_TRANSFER_DEPTH(o.depth);\u003Cbr\u003E\nreturn o;\u003Cbr\u003E\n}\u003Cbr\u003E\n\u003Cbr\u003E\nhalf4 frag(v2f i) : COLOR {\u003Cbr\u003E\nUNITY_OUTPUT_DEPTH(i.depth);\u003Cbr\u003E\n}\u003Cbr\u003E\nENDCG\u003Cbr\u003E\n}\u003Cbr\u003E\n}\u003Cbr\u003E\n}\u003Cbr\u003E\n\u003Cbr\u003E\n[/CODE]\u003Cbr\u003E\n\u003Cbr\u003E\nAnd then just creating a camera that renders the scene with this replacement shader to a rendertexture. This produces a regular (linear?) depth buffer but the rendertexture depth can be set manually when creating it. This seems to fix my OpenGL issues but dx9 still seems to have some flickering so I\u0026#39;ll probably experiment with the logarithmic depth buffer later on.\n"},{"CreatedByName":"rbray89","CreatedById":48847,"CreatedDateTime":"2015-11-18T04:24:10Z","Content":"\n[quote name=\u0027blackrack\u0027]It\u0026#39;s actually pretty simple, using this as a replacement shader\u003Cbr\u003E\n\u003Cbr\u003E\n[CODE]\u003Cbr\u003E\nShader \u0022Custom/DepthTexture\u0022 {\u003Cbr\u003E\nSubShader {\u003Cbr\u003E\nTags { \u0022RenderType\u0022=\u0022Opaque\u0022 }\u003Cbr\u003E\nPass {\u003Cbr\u003E\nFog { Mode Off }\u003Cbr\u003E\nCGPROGRAM\u003Cbr\u003E\n\u003Cbr\u003E\n#pragma vertex vert\u003Cbr\u003E\n#pragma fragment frag\u003Cbr\u003E\n#include \u0022UnityCG.cginc\u0022\u003Cbr\u003E\n\u003Cbr\u003E\nstruct v2f {\u003Cbr\u003E\nfloat4 pos : SV_POSITION;\u003Cbr\u003E\nfloat2 depth : TEXCOORD0;\u003Cbr\u003E\n};\u003Cbr\u003E\n\u003Cbr\u003E\nv2f vert (appdata_base v) {\u003Cbr\u003E\nv2f o;\u003Cbr\u003E\no.pos = mul (UNITY_MATRIX_MVP, v.vertex);\u003Cbr\u003E\nUNITY_TRANSFER_DEPTH(o.depth);\u003Cbr\u003E\nreturn o;\u003Cbr\u003E\n}\u003Cbr\u003E\n\u003Cbr\u003E\nhalf4 frag(v2f i) : COLOR {\u003Cbr\u003E\nUNITY_OUTPUT_DEPTH(i.depth);\u003Cbr\u003E\n}\u003Cbr\u003E\nENDCG\u003Cbr\u003E\n}\u003Cbr\u003E\n}\u003Cbr\u003E\n}\u003Cbr\u003E\n\u003Cbr\u003E\n[/CODE]\u003Cbr\u003E\n\u003Cbr\u003E\nAnd then just creating a camera that renders the scene with this replacement shader to a rendertexture. This produces a regular (linear?) depth buffer but the rendertexture depth can be set manually when creating it. This seems to fix my OpenGL issues but dx9 still seems to have some flickering so I\u0026#39;ll probably experiment with the logarithmic depth buffer later on.[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nVery cool!\n"},{"CreatedByName":"selfish_meme","CreatedById":125899,"CreatedDateTime":"2015-11-18T05:38:05Z","Content":"\n[IMG]http://i.imgur.com/vsRPpXB.png[/IMG]I am seeing a noticible lag now on scene changes before scatterer kicks in, it was always behind the scene load but now it\u0026#39;s more pronounced, no other effect of note. Linux 64bit, Intel with nvidia graphics and overidden hardware antialiasing. Happens for a second before physics kicks in. Glorius.\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-11-18T05:49:48Z\u0022 title=\u002211/18/2015 05:49  AM\u0022 data-short=\u00228 yr\u0022\u003ENovember 18, 2015\u003C/time\u003E by selfish_meme\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Manwith Noname","CreatedById":117203,"CreatedDateTime":"2015-11-18T05:57:50Z","Content":"\n[quote name=\u0027blackrack\u0027]\u003Cbr\u003E\nEdited: for those who want to try it: [URL=\u0022https://mega.nz/#!6JYDSKQJ!JoSWw_pr7wH1wBbknI3k7Nfl5xhRJ7tUcYCCcx3xHyA\u0022]ArtifactsFix.zip[/URL]\u003Cbr\u003E\n[/QUOTE]\u003Cbr\u003E\n\u003Cbr\u003E\nI think this just killed my framerate. Need to sleep so I haven\u0026#39;t had time to check everything. I had also just installed SCANsat so that could be adding to it, though no satellites were out mapping.\n"},{"CreatedByName":"selfish_meme","CreatedById":125899,"CreatedDateTime":"2015-11-18T06:15:21Z","Content":"\nNot sure if this view is because of scatterer or SVE, at 200km altitude I seem to be inside atmosphere, literally.\u003Cbr\u003E\n\u003Cbr\u003E\n[IMG]http://i.imgur.com/0EqUxkT.png[/IMG]\u003Cbr\u003E\n\u003Cbr\u003E\n[IMG]http://i.imgur.com/62NwusF.png[/IMG]\n"}]}