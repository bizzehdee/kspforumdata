{"TopicId":84921,"ForumId":29,"TopicTitle":"Prograde, and several other grades. :)","CreatedByName":"artwhaley","CreatedById":118388,"CreatedDateTime":"2014-09-18T22:26:10Z","PageNum":1,"Articles":[{"CreatedByName":"artwhaley","CreatedById":118388,"CreatedDateTime":"2014-09-18T22:26:10Z","Content":"\n\u003Cp\u003EI\u0027m trying to do something pretty basic, but it\u0027s confounding me... partly because there are about a dozen variables in the KSP API that sound like almost what I\u0027m looking for. \u003C/p\u003E\u003Cp\u003EI\u0027m trying to build indicators into my plugin that will help you point towards prograde, retrograde, normal, antinormal, and the next maneuver node. \u003C/p\u003E\u003Cp\u003EIdeally, what the user will see at the end of all my math are pitch and yaw numbers that relate where the nose of the ship is pointed to where they want to burn... so as you approach an ascending node during an intercept, the program would start showing you how many degrees you need to pitch and yaw to point anti-normal to match planes with your target, for example. Similarly, as you approach a maneuver node I\u0027d like pitch and yaw numbers that show the relationship of the control transform to the node... and as you plan a circularization I\u0027d like pitch and yaw numbers relative to prograde or retrograde, whether you\u0027ve got a maneuver node set or not.\u003C/p\u003E\u003Cp\u003EI\u0027ve grabbed the next maneuver node via : \u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003EMath.Sqrt(Math.Pow((vessel.patchedConicSolver.maneuverNodes[0].DeltaV.x),2)\u002BMath.Pow((vessel.patchedConicSolver.maneuverNodes[0].DeltaV.y),2)\u002BMath.Pow((vessel.patchedConicSolver.maneuverNodes[0].DeltaV.z),2)).ToString()  ; \u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E \u003C/p\u003E\u003Cp\u003EAnd it seems to come out relative to prograde - as in a prograde burn of 1000m/s will return 0,0,1000.\u003C/p\u003E\u003Cp\u003EBut I can\u0027t figure out how to figure out where the nose of my ship is pointing relative to prograde or the maneuver node. It seems like it should be pretty basic... but all of the variables I\u0027ve tried so far seem to return world coordinates... or just numbers that don\u0027t make sense in context at all. \u003C/p\u003E\u003Cp\u003EArt\u003C/p\u003E\n"},{"CreatedByName":"philotical","CreatedById":109390,"CreatedDateTime":"2014-09-19T08:22:11Z","Content":"\n\u003Cp\u003Ehave a look at this page (if you didn\u0027t allready)\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://wiki.unity3d.com/index.php?title=3d_Math_functions\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://wiki.unity3d.com/index.php?title=3d_Math_functions\u003C/a\u003E\u003C/p\u003E\u003Cp\u003Eif might give you an answer..\u003C/p\u003E\u003Cp\u003Ein general you must do two things\u003C/p\u003E\u003Cp\u003E1. find out the nose vector and the prograde vector\u003C/p\u003E\u003Cp\u003E2. calculate the angel between them\u003C/p\u003E\u003Cp\u003Ethe tricky part is to split that up in two relative to two planes so you get seperate values..\u003C/p\u003E\u003Cp\u003Eiirc the page above has a function to do that somewhere..\u003C/p\u003E\u003Cp\u003Enot sure if it still works - the page is a bit older..\u003C/p\u003E\n"},{"CreatedByName":"sarbian","CreatedById":57146,"CreatedDateTime":"2014-09-19T13:22:48Z","Content":"\n\u003Cp\u003Ewhat you need is \u003C/p\u003E\u003Cp\u003EburnV = vessel.patchedConicSolver.maneuverNodes[0].GetBurnVector(vessel.orbit) =\u0026gt; the burn direction in world coord\u003C/p\u003E\u003Cp\u003Evessel.GetTransform().up / vessel.GetTransform().right / vessel.GetTransform().forward get you your ship orienation in world coord ( KSP mix things up a bit to make things more fun. the up transform vector is the one that point to the front of the ship).\u003C/p\u003E\u003Cp\u003EThen you use Vector3d.Exclude to get the burn dir without the right / forward component. \u003C/p\u003E\u003Cp\u003EyawnComponent = Vector3d.Exclude(vessel.GetTransform().right, burnV )\u003C/p\u003E\u003Cp\u003EpitchComponent = Vector3d.Exclude(vessel.GetTransform().right, burnV )\u003C/p\u003E\u003Cp\u003Eyawn = Vector3d.Angle( yawnComponent , vessel.GetTransform().up)\u003C/p\u003E\u003Cp\u003Epitch= Vector3d.Angle( pitchComponent , vessel.GetTransform().up)\u003C/p\u003E\u003Cp\u003Eor you transform burnV in coord local to the ship and do you trig math\u003C/p\u003E\u003Cp\u003ElocalBurnV = vessel.GetTransform().InverseTransformDirection(burnV)\u003C/p\u003E\n"},{"CreatedByName":"artwhaley","CreatedById":118388,"CreatedDateTime":"2014-09-20T03:56:43Z","Content":"\n\u003Cp\u003EThank you so much for the help so far! You\u0027ve definitely got me mostly there!\u003C/p\u003E\u003Cp\u003EAfter a bit of trial and error with the various directions for this.vessel.GetTransform(), I\u0027ve got pointing at the maneuver node working with the following code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E Vector3 burnV = this.vessel.patchedConicSolver.maneuverNodes[0].GetBurnVector(this.vessel.orbit);\u003Cbr\u003E Vector3 yawnComponent = Vector3d.Exclude(vessel.GetTransform().forward, burnV);\u003Cbr\u003E Vector3 pitchComponent = Vector3d.Exclude(vessel.GetTransform().right, burnV);\u003Cbr\u003E double yawn = Vector3d.Angle(yawnComponent, vessel.GetTransform().up);\u003Cbr\u003E double pitch = Vector3d.Angle(pitchComponent, vessel.GetTransform().up);\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EAnd then I figured out how to relate it to Orbital Velocity to get prograde and retrograde.\u003C/p\u003E\u003Cp\u003E \u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E  Vector3 progradev = this.vessel.GetObtVelocity();\u003Cbr\u003E   Vector3 yawnComponent = Vector3d.Exclude(vessel.GetTransform().forward, progradev);\u003Cbr\u003E   Vector3 pitchComponent = Vector3d.Exclude(vessel.GetTransform().right, progradev);\u003Cbr\u003E   double yawn = Vector3d.Angle(yawnComponent, vessel.GetTransform().up);\u003Cbr\u003E   double pitch = Vector3d.Angle(pitchComponent, vessel.GetTransform().up);\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe only problem I\u0027m left with is that all of this is returning degrees between 0 and 180 without any signs... so the program can\u0027t tell if pitch is off by \u002B10 or -10 degrees. I\u0027d really like a way to relate the vessel transform to normal and antinormal... and to tell the difference between the two, but both of those are returning 90,90 in the second set of code there. Is there a way to get a value WITH sign?\u003C/p\u003E\n"},{"CreatedByName":"philotical","CreatedById":109390,"CreatedDateTime":"2014-09-20T04:48:05Z","Content":"\n\u003Cp\u003EWell, that\u0027s what I ment, those functions are on that list..\u003C/p\u003E\u003Cp\u003EI didn\u0027t test them, but at least they claim to do that\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022\u003E\u003Cdiv\u003E//Get the shortest distance between a point and a plane. \u003Cstrong\u003EThe output is signed so it holds information\u003C/strong\u003E\u003Cp\u003E\u003Cstrong\u003E //as to which side of the plane normal the point is.\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003E public static float SignedDistancePlanePoint(Vector3 planeNormal, Vector3 planePoint, Vector3 point){\u003C/p\u003E\u003Cp\u003E return Vector3.Dot(planeNormal, (point - planePoint));\u003C/p\u003E\u003Cp\u003E } \u003C/p\u003E\u003Cp\u003E //\u003Cstrong\u003EThis function calculates a signed (\u002B or - sign instead of being ambiguous) dot product.\u003C/strong\u003E It is basically used\u003C/p\u003E\u003Cp\u003E //to figure out whether a vector is positioned to the left or right of another vector. The way this is done is\u003C/p\u003E\u003Cp\u003E //by calculating a vector perpendicular to one of the vectors and using that as a reference. This is because\u003C/p\u003E\u003Cp\u003E //the result of a dot product only has signed information when an angle is transitioning between more or less\u003C/p\u003E\u003Cp\u003E //then 90 degrees.\u003C/p\u003E\u003Cp\u003E public static float SignedDotProduct(Vector3 vectorA, Vector3 vectorB, Vector3 normal){\u003C/p\u003E\u003Cp\u003E Vector3 perpVector;\u003C/p\u003E\u003Cp\u003E float dot;\u003C/p\u003E\u003Cp\u003E //Use the geometry object normal and one of the input vectors to calculate the perpendicular vector\u003C/p\u003E\u003Cp\u003E perpVector = Vector3.Cross(normal, vectorA);\u003C/p\u003E\u003Cp\u003E //Now calculate the dot product between the perpendicular vector (perpVector) and the other input vector\u003C/p\u003E\u003Cp\u003E dot = Vector3.Dot(perpVector, vectorB);\u003C/p\u003E\u003Cp\u003E return dot;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E public static float SignedVectorAngle(Vector3 referenceVector, Vector3 otherVector, Vector3 normal)\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E Vector3 perpVector;\u003C/p\u003E\u003Cp\u003E float angle;\u003C/p\u003E\u003Cp\u003E //Use the geometry object normal and one of the input vectors to calculate the perpendicular vector\u003C/p\u003E\u003Cp\u003E perpVector = Vector3.Cross(normal, referenceVector);\u003C/p\u003E\u003Cp\u003E //Now calculate the dot product between the perpendicular vector (perpVector) and the other input vector\u003C/p\u003E\u003Cp\u003E angle = Vector3.Angle(referenceVector, otherVector);\u003C/p\u003E\u003Cp\u003E angle *= Mathf.Sign(Vector3.Dot(perpVector, otherVector));\u003C/p\u003E\u003Cp\u003E return angle;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\n"},{"CreatedByName":"artwhaley","CreatedById":118388,"CreatedDateTime":"2014-09-23T01:17:35Z","Content":"\n\u003Cp\u003EI couldn\u0027t figure out how to get there from philotical\u0027s suggestions, though I\u0027m confident that a few years closer to my math classes I might have figured it out. \u003C/p\u003E\u003Cp\u003EWhat I did find was the signed angle routine in Mechjeb\u0027s math library. It gives the signed angle between two vectors, in reference to a third vector perpendicular to them. So I used Vector3.cross to generate a perpendicular vector. Initially the signs flipped at the 90 degree mark (so it would run from 0 to 90, then start going from -91 to -180) so I reversed the signs if the number is above 90 or below -90, and now it works just the way I want it to. For future reference - \u003C/p\u003E\u003Cp\u003E \u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E Vector3 burnV = this.vessel.patchedConicSolver.maneuverNodes[0].GetBurnVector(this.vessel.orbit);\u003Cbr\u003E                    Vector3 yawnComponent = Vector3d.Exclude(vessel.GetTransform().forward, burnV);\u003Cbr\u003E                    Vector3 crossp = Vector3.Cross(yawnComponent, vessel.GetTransform().right).normalized;\u003Cbr\u003E                    double yawn = AngleSigned(yawnComponent, vessel.GetTransform().up, crossp);\u003Cbr\u003E                    if (yawn \u0026gt; 90){\u003Cbr\u003E                        yawn = yawn * -1f;\u003Cbr\u003E                    } else if (yawn \u0026lt; -90){\u003Cbr\u003E                        yawn = yawn * -1f;\u003Cbr\u003E                    }\u003Cbr\u003E\u003Cbr\u003E                    Vector3 pitchComponent = Vector3d.Exclude(vessel.GetTransform().right, burnV);                    \\\u003Cbr\u003E                    crossp = Vector3.Cross(pitchComponent, vessel.GetTransform().forward).normalized;\u003Cbr\u003E                    double pitch = AngleSigned(pitchComponent, vessel.GetTransform().up, crossp);\u003Cbr\u003E                    if (pitch \u0026gt; 90){\u003Cbr\u003E                         pitch = pitch * -1f;\u003Cbr\u003E                    }  else if (pitch \u0026lt; -90){\u003Cbr\u003E                        pitch = pitch * -1f;\u003Cbr\u003E                    }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EEverything works just the way I want it to - 0,0 is prograde, 180,180 is retrograde, 90,-90 is antinormal and -90,90 is normal. \u003C/p\u003E\u003Cp\u003EThank you both for your help!\u003C/p\u003E\u003Cp\u003EArt\u003C/p\u003E\n"},{"CreatedByName":"philotical","CreatedById":109390,"CreatedDateTime":"2014-12-28T11:22:02Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022artwhaley\u0022 data-cite=\u0022artwhaley\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EEverything works just the way I want it to - 0,0 is prograde, 180,180 is retrograde, 90,-90 is antinormal and -90,90 is normal. \u003C/p\u003E\u003Cp\u003EArt\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003Ethis was exactly what I needed yesterday - thanks for sharing..\u003C/p\u003E\u003Cp\u003Eyou don\u0027t have by any chance the \u0022roll\u0022 version handy?\u003C/p\u003E\u003Cp\u003EI\u0027m still experimenting with what vectors to substitute - but my vector math is as low as it can be..\u003C/p\u003E\n"},{"CreatedByName":"JDP","CreatedById":30775,"CreatedDateTime":"2014-12-28T15:11:01Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022sarbian\u0022 data-cite=\u0022sarbian\u0022\u003E\u003Cdiv\u003E...vessel.GetTransform().up / vessel.GetTransform().right / vessel.GetTransform().forward get you your ship orienation in world coord ( KSP mix things up a bit to make things more fun. the up transform vector is the one that point to the front of the ship)....\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWouldn\u0027t he need vessel.ReferenceTransform? or does GetTransform() now return the correct transform in regard to which part you are controlling from (ie.: ReferenceTransform)?\u003C/p\u003E\n"},{"CreatedByName":"artwhaley","CreatedById":118388,"CreatedDateTime":"2014-12-28T15:32:20Z","Content":"\n\u003Cp\u003EPhilotical, roll relative to the body we\u0027re orbiting, or some other reference? \u003C/p\u003E\u003Cp\u003EAnd JDP, from recent fiddling with RPM I believe GetTransform is returning the correct, control from here aware, transform.\u003C/p\u003E\n"},{"CreatedByName":"philotical","CreatedById":109390,"CreatedDateTime":"2014-12-29T14:02:08Z","Content":"\n\u003Cp\u003Erelative to the body - right..\u003C/p\u003E\n"},{"CreatedByName":"stibbons","CreatedById":57865,"CreatedDateTime":"2015-11-04T14:58:06Z","Content":"\n\u003Cp\u003E\nThis thread was super helpful for me trying to figure out how to find pitch and yaw of various orbital vectors relative to my vessel heading. Thanks. \u003Cimg alt=\u0022:D\u0022 src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_cheesy.gif\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nOne problem though, is that calculating pitch and yaw independently means they are inaccurate when either of them have a magnitude greater than 90. For the prograde heading, the relative pitch and yaw come out as (0, 0) when the vessel is pointed prograde, but (180,180) when it\u0027s pointed retrograde. I\u0027d expect either (180,0) or (0, 180).\n\u003C/p\u003E\n\u003Cp\u003E\nThis is what I ended up writing. It seems to work well so far. It returns a yaw between -180 and 180, and a pitch between -90 and 90.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cdiv\u003E\n\u00A0\n\u003C/div\u003E\n\u003Cpre class=\u0022ipsCode prettyprint\u0022\u003E\n        private float[] getOffsetFromHeading(Vessel ActiveVessel, Vector3d targetVector)\n        {\n            Vector3d yawComponent = Vector3d.Exclude(ActiveVessel.GetTransform().forward, targetVector);\n            Vector3d yawCross = Vector3d.Cross(yawComponent, ActiveVessel.GetTransform().right);\n            float yaw = SignedVectorAngle(yawComponent, ActiveVessel.GetTransform().up, yawCross);\n\n            Vector3d pitchComponent = Vector3d.Exclude(ActiveVessel.GetTransform().right, targetVector);\n            Vector3d pitchCross = Vector3d.Cross(pitchComponent, ActiveVessel.GetTransform().forward);\n            float pitch = SignedVectorAngle(pitchComponent, ActiveVessel.GetTransform().up, pitchCross);\n\n            if (Math.Abs(yaw) \u0026gt; 90) {\n                yaw = -yaw;\n                // This condition makes sure progradePitch doesn\u0027t wrap from -x to 360-x\n                if (pitch \u0026gt; 0) {\n                    pitch = pitch - 180;\n                } else {\n                    pitch = pitch \u002B 180;\n                }\n            }\n            return new float[] {pitch, yaw};\n        }\n\n        private float SignedVectorAngle(Vector3d referenceVector, Vector3d otherVector, Vector3d normal)\n        {\n            Vector3d perpVector;\n            float angle;\n            //Use the geometry object normal and one of the input vectors to calculate the perpendicular vector\n            perpVector = Vector3d.Cross(normal, referenceVector);\n            //Now calculate the dot product between the perpendicular vector (perpVector) and the other input vector\n            angle = Vector3d.Angle(referenceVector, otherVector);\n            angle *= Mathf.Sign(Vector3d.Dot(perpVector, otherVector));\n\n            return angle;\n        }\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-12-01T07:49:08Z\u0022 title=\u002212/01/2015 07:49  AM\u0022 data-short=\u00228 yr\u0022\u003EDecember 1, 2015\u003C/time\u003E by stibbons\u003C/strong\u003E\n\u003Cbr\u003Eyay syntax highlighted code block\n\u003C/span\u003E\n"}]}