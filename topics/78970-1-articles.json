{"TopicId":78970,"ForumId":36,"TopicTitle":"64bit KSP - External library question","CreatedByName":"MeateaW","CreatedById":24950,"CreatedDateTime":"2014-07-22T10:37:56Z","PageNum":1,"Articles":[{"CreatedByName":"MeateaW","CreatedById":24950,"CreatedDateTime":"2014-07-22T10:37:56Z","Content":"\n\u003Cp\u003EHi All,\u003C/p\u003E\u003Cp\u003EI am fixing up a mod (for personal use - license doesn\u0027t let me distribute derivatives - but will contact the author if I get it going).\u003C/p\u003E\u003Cp\u003EThat mod imports some functions from a DLL, obviously it was a 32bit DLL in the past.\u003C/p\u003E\u003Cp\u003EIs there any way within the KSP API to detect if you are running 64 or 32bit?\u003C/p\u003E\u003Cp\u003EI obviously need to have some code that detects which mode I am in, and load the DLL that is appropriate.\u003C/p\u003E\u003Cp\u003EThanks!\u003C/p\u003E\u003Cp\u003EPS. \u003C/p\u003E\u003Cp\u003EI am a developer by trade, but have very little KSP modding experience (so don\u0027t know where to start to look for API documentation).\u003C/p\u003E\u003Cp\u003E(The mod I am refurbing is kerbcom avionics, which was last touched by its dev for ksp ~21.something, things have changed since then! - but yeah wont be releasing anything due to license - I may release diff files to allow the adventurous to compile their own version of my changes if I ever get it working, but tbh I wonder if even that is against the license - need to research first).\u003C/p\u003E\n"},{"CreatedByName":"Daid","CreatedById":32171,"CreatedDateTime":"2014-07-22T12:18:36Z","Content":"\n\u003Cp\u003EQuick google shows the following example:\u003C/p\u003E\u003Cp\u003Eif (System.IntPtr.Size == 8)\u003C/p\u003E\u003Cp\u003E{\u003C/p\u003E\u003Cp\u003E // 64-bit\u003C/p\u003E\u003Cp\u003E}\u003C/p\u003E\u003Cp\u003Eelse\u003C/p\u003E\u003Cp\u003E{\u003C/p\u003E\u003Cp\u003E // 32-bit\u003C/p\u003E\u003Cp\u003E}\u003C/p\u003E\u003Cp\u003EWhich makes sense to me. (didn\u0027t test it)\u003C/p\u003E\n"},{"CreatedByName":"MeateaW","CreatedById":24950,"CreatedDateTime":"2014-07-23T00:13:27Z","Content":"\n\u003Cp\u003EThanks Daid,\u003C/p\u003E\u003Cp\u003EI\u0027ll give it a shot.\u003C/p\u003E\n"},{"CreatedByName":"cpast","CreatedById":112846,"CreatedDateTime":"2014-07-23T00:17:01Z","Content":"\n\u003Cp\u003EWhy was the DLL obviously 32-bit before? What native code DLLs do plugins use?\u003C/p\u003E\n"},{"CreatedByName":"MeateaW","CreatedById":24950,"CreatedDateTime":"2014-07-25T06:46:28Z","Content":"\n\u003Cp\u003EIn this instance, the native code DLL was the Linear Programming solving library: \u0022Lpsolve\u0022. Used by Kerbal Avionics.\u003C/p\u003E\u003Cp\u003EWhen running KSP 64 bit it failed to load the DLL (the debugger indicated that it \u0022could not find DLL\u0022). \u003C/p\u003E\u003Cp\u003EProcess monitor indicated that it could indeed find the DLL (many \u0022Success\u0022 open-file events), however even after finding it it kept looking in other locations.\u003C/p\u003E\u003Cp\u003EOn a hunch I tried the code on KSP32 bit and it worked fine (all other things were the same).\u003C/p\u003E\u003Cp\u003ESo, I grabbed a 64 bit version of the DLL off the web, replaced it, and tried it again in 64bit and it worked.\u003C/p\u003E\u003Cp\u003ESo; there was no obvious \u0022this DLL is the wrong archictecture\u0022 message, however by a process of elimination I came to that conclusion. (and with something somewhat related to this code have effectively solved the problem).\u003C/p\u003E\u003Cp\u003EJust to explain how I solved it:\u003C/p\u003E\u003Cp\u003E(Note: this is not the only method, there are easier methods, and for my particular problem this method resulted in a LOT of extra code! - but it was all automated searches and replaces so wasn\u0027t as bad as it sounds).\u003C/p\u003E\u003Cp\u003ELets say you need to import a function from a library:\u003C/p\u003E\u003Cp\u003EYou would use something like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Epublic static class Library\u003Cbr\u003E{\u003Cbr\u003E  [DllImport(\u0022dllpath\\dllfile.dll\u0022, SetLastError=true)] \u003Cbr\u003E  public static extern bool add_column(int lp, double[] column);\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EAnd you would call that code like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E   void Function()\u003Cbr\u003E   {\u003Cbr\u003E     if (Library.add_column(intvalue, arrayofDouble))\u003Cbr\u003E           { /* Cheer! */ }\u003Cbr\u003E   }\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI wanted to ensure that whatever bit-version I needed was loaded, without changing any of my native calls.\u003C/p\u003E\u003Cp\u003ESo I don\u0027t change my calling-code, but I *do* change my library to the following:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Epublic static class Library\u003Cbr\u003E{\u003Cbr\u003E  [DllImport(\u0022dllpath\\dll_32bit.dll\u0022, SetLastError=true)] \u003Cbr\u003E  public static extern bool add_column_32(int lp, double[] column);\u003Cbr\u003E\u003Cbr\u003E  [DllImport(\u0022dllpath\\dll_64bit.dll\u0022, SetLastError=true)] \u003Cbr\u003E  public static extern bool add_column_64(int lp, double[] column);\u003Cbr\u003E\u003Cbr\u003E  public is64bit { get { return IntPtr.Size == 8; } }\u003Cbr\u003E\u003Cbr\u003E  public delegate bool add_column_delegate(int lp, double[] column);\u003Cbr\u003E\u003Cbr\u003E  public static add_column_delegate add_column { get { return is64bit? (add_column_delegate)add_column_64 : (add_column_delegate)add_column_32; } }\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI can guarantee this is not the \u0022simplest\u0022 way of doing it, but it is certainly *a* way of doing it.\u003C/p\u003E\u003Cp\u003EAlso; the internet when it saw this problem was similarly confused about why a 64bit application couldn\u0027t call a 32bit dll. (In fact most of the internets response was: \u0022Just call the 32bit version\u0022). However for whatever reason this did not work for the default compilation method of the ksp mod.\u003C/p\u003E\u003Cp\u003ENote:\u003C/p\u003E\u003Cp\u003EMy actual code was slightly more complex than this, but only because I had to split it over 3 files.\u003C/p\u003E\u003Cp\u003EEg:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003Epublic static class Library\u003Cbr\u003E{\u003Cbr\u003E   private is64bit { get { return IntPtr.Size == 8; } }\u003Cbr\u003E   public delegate bool add_column_delegate(int lp, double[] column);\u003Cbr\u003E   public static add_column_delegate add_column { get { return is64bit? (add_column_delegate)Library_64.add_column : (add_column_delegate)Library_32.add_column; } }\u003Cbr\u003E}\u003Cbr\u003Epublic static class Library_64\u003Cbr\u003E{\u003Cbr\u003E  private const string DLLPath = \u0022dllpath\\dll_64bit.dll\u0022;\u003Cbr\u003E\u003Cbr\u003E  [DllImport(DLLPath, SetLastError=true)] \u003Cbr\u003E  public static extern bool add_column(int lp, double[] column);\u003Cbr\u003E}\u003Cbr\u003E\u003Cbr\u003Epublic static class Library_32\u003Cbr\u003E{\u003Cbr\u003E  private const string DLLPath = \u0022dllpath\\dll_32bit.dll\u0022;\u003Cbr\u003E\u003Cbr\u003E  [DllImport(DLLPath, SetLastError=true)] \u003Cbr\u003E  public static extern bool add_column(int lp, double[] column);\u003Cbr\u003E}\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThe main reason for this, is the difference between the 32 and 64 bit import-classes, is precisely 2 lines. \u003C/p\u003E\u003Cp\u003EThe class Name, and the Constant-String variable.\u003C/p\u003E\u003Cp\u003EAgain; no guarantees this is the best way of doing this, just that it is *a* way of doing it.\u003C/p\u003E\n"}]}