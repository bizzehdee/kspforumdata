{"TopicId":90096,"ForumId":20,"TopicTitle":"Optimal Rocket Generator","CreatedByName":"MathigNihilcehk","CreatedById":81703,"CreatedDateTime":"2014-11-12T08:59:38Z","PageNum":1,"Articles":[{"CreatedByName":"MathigNihilcehk","CreatedById":81703,"CreatedDateTime":"2014-11-12T08:59:38Z","Content":"\n\u003Cp\u003EQuick background: I am a physics major, and math enthusiast. I found a web app on the forums (\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/threads/65011-WEB-0-25-KSP-Optimal-Rocket-Calculator-v1-15\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://forum.kerbalspaceprogram.com/threads/65011-WEB-0-25-KSP-Optimal-Rocket-Calculator-v1-15\u003C/a\u003E) that generates rocket designs. However, it requires enormous amounts of processor power and seems to miss some ideal solutions for generating rockets. (I tested 4500 2-stage, and 2 2250 stages (mass of 1st stage as payload of 2nd stage) and got different results) So, I am going to do an analysis of the problem \u0022How do I create a rocket generator\u0022. I believe my solution may be significantly superior to the existing app\u0027s solution(I love the app, but think I may have found a better solution), and I wanted to know what the community thought about it. My analysis will consider three engine types, and one type of fuel, but simple expansion can adapt to any number of engine types. Spoilers hide the derivation, and variable names.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003Edv= actual change in velocity\u003C/p\u003E\u003Cp\u003Eg = force of gravity on kerbin surface\u003C/p\u003E\u003Cp\u003EISP_i = ISP value of engine i\u003C/p\u003E\u003Cp\u003EISP = Overall ISP value\u003C/p\u003E\u003Cp\u003EP = payload mass\u003C/p\u003E\u003Cp\u003EE_i = engine i\u0027s mass(with coupler/branches factored in for simplicity)\u003C/p\u003E\u003Cp\u003EE = total mass for engines\u003C/p\u003E\u003Cp\u003EF = total mass of fuel\u003C/p\u003E\u003Cp\u003EC = total mass of empty fuel canisters\u003C/p\u003E\u003Cp\u003Ef = mass of smallest unit of fuel\u003C/p\u003E\u003Cp\u003Ec = mass of smallest unit of empty fuel canister\u003C/p\u003E\u003Cp\u003ET_i = Thrust of engine i\u003C/p\u003E\u003Cp\u003ET = total engine thrust\u003C/p\u003E\u003Cp\u003ETWR = actual thrust per weight ratio\u003C/p\u003E\u003Cp\u003EM = mass of entire rocket with fuel\u003C/p\u003E\u003Cp\u003Em = mass of entire rocket without fuel\u003C/p\u003E\u003Cp\u003Ek = number of fuel canisters\u003C/p\u003E\u003Cp\u003Ex,y,z = number of engines x,y, or z respectively\u003C/p\u003E\u003Cp\u003E_x,_y,_z = indicating \u0022of engine x, y, or z\u0022 respectively\u003C/p\u003E\u003Cp\u003EL = some finite lower limit for P/M we know ahead of time\u003C/p\u003E\u003Cp\u003ED = desired change in velocity\u003C/p\u003E\u003Cp\u003ETPR = desired thrust to weight ratio\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003Ex*E_x\u002By*E_y\u002Bz*E_z = E\u003C/p\u003E\u003Cp\u003Ex*T_x\u002By*T_y\u002Bz*T_z = T\u003C/p\u003E\u003Cp\u003ET/((x*T_x/ISP_x)\u002B(y*T_y/ISP_y)\u002B(z*T_z/ISP_z)) = ISP\u003C/p\u003E\u003Cp\u003Edv \u0026lt; g*ISP*ln(M/m)\u003C/p\u003E\u003Cp\u003ET/(g*M) = TWR\u003C/p\u003E\u003Cp\u003Ek*f=F\u003C/p\u003E\u003Cp\u003Ek*c=C\u003C/p\u003E\u003Cp\u003EM=P\u002BE\u002BC\u002BF\u003C/p\u003E\u003Cp\u003Em=P\u002BE\u002BC\u003C/p\u003E\u003Cp\u003EL \u0026lt; P/M (defined such that TPR = TWR is reasonable)\u003C/p\u003E\u003Cp\u003ETPR \u0026lt; TWR\u003C/p\u003E\u003Cp\u003ED \u0026lt; dv\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003EIn this system, I want to generate every reasonable \u0022guess\u0022 for an engine configuration, and then filter out every \u0022guess\u0022 that doesn\u0027t satisfy our desired thrust to weight and change in velocity conditions. I also want to sort for lowest mass, part count, and cost, so every \u0022guess\u0022 whose mass, part count, and cost are all higher than another engine should be eliminated as quickly as possible. This is what our lower limit is for. If some engine\u0027s payload/mass is lower than our limit, we can avoid guessing it. This turns out to be the case for all engine configurations with a specific engine count above a certain value. We then want to check against some equation that satisfies both TPR \u0026lt; TWR and D \u0026lt; dv. If an equation satisfies both of these, then we can finally check it\u0027s mass, part count, and cost to determine the best one.\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003EM \u0026lt; P/L\u003C/p\u003E\u003Cp\u003ET/(g*TWR) = M\u003C/p\u003E\u003Cp\u003ET/(g*TWR) \u0026lt; P/L\u003C/p\u003E\u003Cp\u003ET \u0026lt; g*TWR*P/L\u003C/p\u003E\u003Cp\u003ET \u0026lt; g*TPR*P/L (because we picked a low enough L)\u003C/p\u003E\u003Cp\u003Ex*T_x\u002By*T_y\u002Bz*T_z \u0026lt; g*TPR*P/L\u003C/p\u003E\u003Cp\u003E0 \u0026lt;= x \u0026lt; g*TPR*P/(L*T_x)\u003C/p\u003E\u003Cp\u003E0 \u0026lt;= y \u0026lt; g*TPR*P/(L*T_y)\u003C/p\u003E\u003Cp\u003E0 \u0026lt;= z \u0026lt; g*TPR*P/(L*T_z)\u003C/p\u003E\u003Cp\u003ESince x, y, and z are all integers, we now have a limited number of guesses to check. This number is x*y*z or...\u003C/p\u003E\u003Cp\u003E(g*TPR*P/L)^3*(1/T_x\u002B1/T_y\u002B1/T_z)\u003C/p\u003E\u003Cp\u003ESo the number of guesses increases exponentially as the payload, desired thrust to weight ratio, and number of engines increases and as thee limit decreases.\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003ED \u0026lt; dv\u003C/p\u003E\u003Cp\u003ED \u0026lt; g*ISP*ln(M/m)\u003C/p\u003E\u003Cp\u003ED \u0026lt; g*ISP*ln((P\u002BE\u002BC\u002BF)/(P\u002BE\u002BC))\u003C/p\u003E\u003Cp\u003ED \u0026lt; g*ISP*ln((P\u002BE\u002Bk*c\u002Bk*f)/(P\u002BE\u002Bk*c))\u003C/p\u003E\u003Cp\u003ED/(g*ISP) \u0026lt; ln((P\u002BE\u002Bk*c\u002Bk*f)/(P\u002BE\u002Bk*c))\u003C/p\u003E\u003Cp\u003Ee^(D/(g*ISP)) \u0026lt; (P\u002BE\u002Bk*c\u002Bk*f)/(P\u002BE\u002Bk*c)\u003C/p\u003E\u003Cp\u003Ee^(D/(g*ISP))*(P\u002BE\u002Bk*c) \u0026lt; (P\u002BE\u002Bk*c\u002Bk*f)\u003C/p\u003E\u003Cp\u003E(P\u002BE)*e^(D/(g*ISP))\u002Bk*c*e^(D/(g*ISP)) \u0026lt; (P\u002BE\u002Bk*c\u002Bk*f)\u003C/p\u003E\u003Cp\u003E(P\u002BE)*e^(D/(g*ISP)) \u0026lt; (P\u002BE\u002Bk*c\u002Bk*f) - k*c*e^(D/(g*ISP))\u003C/p\u003E\u003Cp\u003E(P\u002BE)*e^(D/(g*ISP))-(P\u002BE) \u0026lt; k*(c\u002Bf) - k*c*e^(D/(g*ISP))\u003C/p\u003E\u003Cp\u003E(P\u002BE)*e^(D/(g*ISP))-(P\u002BE) \u0026lt; k*((c\u002Bf) - c*e^(D/(g*ISP)))\u003C/p\u003E\u003Cp\u003E(P\u002BE)*(e^(D/(g*ISP))-1) \u0026lt; k*((c\u002Bf) - c*e^(D/(g*ISP)))\u003C/p\u003E\u003Cp\u003E(P\u002BE)*(e^(D/(g*ISP))-1)/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; k\u003C/p\u003E\u003Cp\u003ETPR \u0026lt; TWR\u003C/p\u003E\u003Cp\u003ETPR \u0026lt; T/(g*M)\u003C/p\u003E\u003Cp\u003ETPR \u0026lt; T/(g*(P\u002BE\u002BC\u002BF))\u003C/p\u003E\u003Cp\u003ETPR \u0026lt; T/(g*(P\u002BE\u002Bk*(c\u002Bf)))\u003C/p\u003E\u003Cp\u003E(g*(P\u002BE\u002Bk*(c\u002Bf))) \u0026lt; T/TPR\u003C/p\u003E\u003Cp\u003E(P\u002BE)\u002Bk*(c\u002Bf) \u0026lt; T/(TPR*g)\u003C/p\u003E\u003Cp\u003Ek*(c\u002Bf) \u0026lt; (T/(TPR*g)-(P\u002BE))\u003C/p\u003E\u003Cp\u003Ek \u0026lt; (T/(TPR*g)-(P\u002BE))/(c\u002Bf)\u003C/p\u003E\u003Cp\u003E(P\u002BE)*(e^(D/(g*ISP))-1)/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; k \u0026lt; (T/(TPR*g)-(P\u002BE))/(c\u002Bf)\u003C/p\u003E\u003Cp\u003E(P\u002BE)*(e^(D/(g*ISP))-1)/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; (T/(TPR*g)-(P\u002BE))/(c\u002Bf)\u003C/p\u003E\u003Cp\u003E-((c\u002Bf)-(c\u002Bf)*e^(D/(g*ISP)))/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; (T/(TPR*g)-(P\u002BE))/(P\u002BE)\u003C/p\u003E\u003Cp\u003E-((c\u002Bf)-c*e^(D/(g*ISP))-f*e^(D/(g*ISP)))/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; (T/(TPR*g)-(P\u002BE))/(P\u002BE)\u003C/p\u003E\u003Cp\u003E-1-(-f*e^(D/(g*ISP)))/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; (T/(TPR*g)-(P\u002BE))/(P\u002BE)\u003C/p\u003E\u003Cp\u003E(f*e^(D/(g*ISP)))/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; (T/(TPR*g)-(P\u002BE))/(P\u002BE)\u002B1\u003C/p\u003E\u003Cp\u003E(f*e^(D/(g*ISP)))/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; (T/(TPR*g)-(P\u002BE)\u002B(P\u002BE))/(P\u002BE)\u003C/p\u003E\u003Cp\u003E(f*e^(D/(g*ISP)))/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; (T/(TPR*g))/(P\u002BE)\u003C/p\u003E\u003Cp\u003E(f*e^(D/(g*ISP)))/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; T/(TPR*g*(P\u002BE))\u003C/p\u003E\u003Cp\u003Ef/((c\u002Bf)*e^(-D/(g*ISP))-c)\u0026lt;T/(TPR*g*(P\u002BE))\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003EWe can sort part count by adding up the parts, costs by adding up each part multiplied by it\u0027s cost, and mass similarly to cost. I will solve for mass, and skip the others for brevity. Since we want low mass, part count, and cost, we will want k to be minimal for each engine configuration. Thus, we can round up the k value for our k \u0026gt; ... expression.\u003C/p\u003E\u003Cp\u003E(P\u002BE)*(e^(D/(g*ISP))-1)/((c\u002Bf) - c*e^(D/(g*ISP))) \u0026lt; k\u003C/p\u003E\u003Cp\u003Ek optimal = roundup((P\u002BE)*(e^(D/(g*ISP))-1)/((c\u002Bf) - c*e^(D/(g*ISP))))\u003C/p\u003E\u003Cp\u003EM=P\u002BE\u002BC\u002BF\u003C/p\u003E\u003Cp\u003EM=P\u002BE\u002Bk*(c\u002Bf)\u003C/p\u003E\u003Cp\u003EM=P\u002BE\u002Broundup((P\u002BE)*(e^(D/(g*ISP))-1)/((c\u002Bf) - c*e^(D/(g*ISP))))*(c\u002Bf)\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote\u003E\u003Cp\u003ESo, assume we now have 2 stages. By guessing, dividing the delta V equally between the stages will give an optimal rocket. Then, we will calculate the first stage and plug in it\u0027s mass into our payload for the second stage. Since we are only calculating 1 equation for every set of engine configurations, and one more equation for each valid configuration, we can save time on displaying the actual rocket configurations until the scan is complete. Once complete, we can calculate the delta V, mass, etc. for the top few operations, as desired.\u003C/p\u003E\u003C/blockquote\u003E\u003Cp\u003EFinal Solution:\u003C/p\u003E\u003Cp\u003EConsider every possible set of x, y, and z(except 0,0,0) that satisfy\u003C/p\u003E\u003Cp\u003E0 \u0026lt;= x \u0026lt; g*TPR*P/(L*T_x)\u003C/p\u003E\u003Cp\u003E0 \u0026lt;= y \u0026lt; g*TPR*P/(L*T_y)\u003C/p\u003E\u003Cp\u003E0 \u0026lt;= z \u0026lt; g*TPR*P/(L*T_z)\u003C/p\u003E\u003Cp\u003Eand test if they satisfy f/((c\u002Bf)*e^(-D/(g*ISP))-c)\u0026lt;T/(TPR*g*(P\u002BE)). If so, sort by M=P\u002BE\u002Broundup((P\u002BE)*(e^(D/(g*ISP))-1)/((c\u002Bf) - c*e^(D/(g*ISP))))*(c\u002Bf) (for mass, cost and part count can be done similarly) and display the final solutions with the values for x, y, and z. Optionally calculate change in velocity, mass, and thrust to weight ratio and display for final solutions.\u003C/p\u003E\u003Cp\u003EConclusion: While I have yet to calculate the time per guess, I am assuming this would be a better method for generating rockets. At the very least it is one to consider, because the calculation time is not exponentially related to the stage count, but instead is proportional to it.\u003C/p\u003E\u003Cp\u003EQuestions: How do I find the time for testing each guess? Are there any errors in my calculations or reasoning? Did you enjoy reading this? Should I continue to pursue developing this method into a web-app or a download-able app? Should I move this to a new thread or location? Any other thoughts?\u003C/p\u003E\u003Cp\u003EThanks for reading!\u003C/p\u003E\n"},{"CreatedByName":"Pds314","CreatedById":70014,"CreatedDateTime":"2014-11-12T16:51:56Z","Content":"\n\u003Cp\u003EI guess I could probably write some simple mock-up Java code to do it. I\u0027m not sure I wanna try to maintain such an app, especially because manually entering in the Isps, thrusts, and masses of all those rockets, and the masses and sizes of all those tanks sounds difficult.\u003C/p\u003E\u003Cp\u003EThe main issue with your method is I have no clue what the maximal time complexity would be, but it looks pretty nasty if some of the numbers get very big. Is this sorting for each instance or just at the end, because if it is, remember that sorts are O(n*log(n)) complexity, at best.\u003C/p\u003E\u003Cp\u003EI do agree that the Optimal rocket calculator we have could use some work. Sometimes I\u0027ve had it run for half an hour and find something not even as good as I could make up out of thin air.\u003C/p\u003E\n"},{"CreatedByName":"MathigNihilcehk","CreatedById":81703,"CreatedDateTime":"2014-11-12T19:40:54Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Pds314\u0022 data-cite=\u0022Pds314\u0022\u003E\u003Cdiv\u003EThe main issue with your method is I have no clue what the maximal time complexity would be, but it looks pretty nasty if some of the numbers get very big. Is this sorting for each instance or just at the end, because if it is, remember that sorts are O(n*log(n)) complexity, at best.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIt would sort only rockets which meet the dV and TWR constraints. However, like the app, I\u0027d imagine limiting it to the top 20 or 10 working rockets would quicken the sorting process.\u003C/p\u003E\u003Cp\u003EA bigger concern might be the guess range as your number of rocket engines increases. The guess range I have is rather gross. I\u0027d imagine some sort of lower bound could be found(with another \u0022impossible\u0022 upper bound, maybe?), and first order corrections on the upper bound.\u003C/p\u003E\n"},{"CreatedByName":"madlemur","CreatedById":116597,"CreatedDateTime":"2014-11-12T19:44:46Z","Content":"\n\u003Cp\u003EWhat about thrust plates and using multiple small engines with larger tanks? That really opens up some new permutations...\u003C/p\u003E\n"},{"CreatedByName":"MathigNihilcehk","CreatedById":81703,"CreatedDateTime":"2014-11-12T19:57:08Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022madlemur\u0022 data-cite=\u0022madlemur\u0022\u003E\u003Cdiv\u003EWhat about thrust plates and using multiple small engines with larger tanks? That really opens up some new permutations...\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThrust plates are methods for stability, not for increasing thrust or change in velocity. This system would include any combination of allowed engines and tanks, but it would not handle large numbers of allowed engines easily.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-11-12T20:04:22Z\u0022 title=\u002211/12/2014 08:04  PM\u0022 data-short=\u00229 yr\u0022\u003ENovember 12, 2014\u003C/time\u003E by MathigNihilcehk\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Dilir","CreatedById":122948,"CreatedDateTime":"2014-11-12T20:09:41Z","Content":"\n\u003Cp\u003EI am working on something with matlab. Here is how i proceeded:\u003C/p\u003E\u003Cp\u003E- Build a 1 stage evaluation function. Imputs : minimum TWR (and later some engine size limitation). Output: optimization variable (IE mass or funds (currently mass), optimal engine as function of (dv, payload).\u003C/p\u003E\u003Cp\u003EThe function evaluates the best couple of \u0022engine \u002B fuel \u0022 that match the required dv and twr.\u003C/p\u003E\u003Cp\u003E- Set global criteria for mission : total dv, payload mass, specific requirement (dead weight winglets for the first 2000m/s, twr \u0026gt;1.2 at launch, etc).\u003C/p\u003E\u003Cp\u003E- Create a random set of rocket (a rocket is a sucession of dvi, sum(dvi)=total dv). Compute with previous function total mass\u003C/p\u003E\u003Cp\u003E- Use genetic algorythm to find near optimal values.\u003C/p\u003E\u003Cp\u003EI am testing this in a new career. Works pretty well so far (i can save a few kg but that\u0027s due to algo rounding). I have done mostly 2-stages rockets for now, but the algorythm was designed for more. Right now, with a very coarse time consuming programation, i have rougthly 1min computation time. (2min if i add all the engines from KW, Novapunch, AIES)\u003C/p\u003E\u003Cp\u003EConcerning thrust plats and multiple engine, i guess that if you want to incorporate them, you should just define that as a new engine. Oh, you can also eliminate some dominated engine (for example, LV-T45 is dominated by LV-T30 if you don\u0027t use gimbaling).\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-11-12T20:20:50Z\u0022 title=\u002211/12/2014 08:20  PM\u0022 data-short=\u00229 yr\u0022\u003ENovember 12, 2014\u003C/time\u003E by Dilir\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"MathigNihilcehk","CreatedById":81703,"CreatedDateTime":"2014-11-12T20:21:49Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Dilir\u0022 data-cite=\u0022Dilir\u0022\u003E\u003Cdiv\u003E- Create a random set of rocket (a rocket is a sucession of dvi, sum(dvi)=total dv). Compute with previous function total mass\u003Cp\u003E- Use genetic algorythm to find near optimal values.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ELOL... with those two lines you summarized your entire attempt at the solution. Care to elaborate a bit?\u003C/p\u003E\n"},{"CreatedByName":"Dilir","CreatedById":122948,"CreatedDateTime":"2014-11-12T20:29:21Z","Content":"\n\u003Cp\u003EGenetic, not generic :-). \u003C/p\u003E\u003Cp\u003EI am neither a programmer nor a specialist in optimization problem (my field is material science), so don\u0027t be too judging.\u003C/p\u003E\u003Cp\u003EThe idea is to create a random dv repartition for a population of rockets. They would be the parents. Then with the previous function you compute what is the mass of each of them. You then use genetic algorithm techniques (selection, crossing, mutation) to generate a child population. After a given number of generation, you look for the best individual in your population.\u003C/p\u003E\u003Cp\u003EOh, i also did an exhaustive search algorithm for 2 stages rocket, and the two give matching result. If you only have 2 or 3 stage, i would however suggest exhaustive over genetics, which is more suited to 3\u002B stages rockets.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-11-12T20:32:28Z\u0022 title=\u002211/12/2014 08:32  PM\u0022 data-short=\u00229 yr\u0022\u003ENovember 12, 2014\u003C/time\u003E by Dilir\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"madlemur","CreatedById":116597,"CreatedDateTime":"2014-11-12T20:35:42Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Dilir\u0022 data-cite=\u0022Dilir\u0022\u003E\u003Cdiv\u003EGenetic, not generic :-). \u003Cp\u003EI am neither a programmer nor a specialist in optimization problem (my field is material science), so don\u0027t be too judging.\u003C/p\u003E\u003Cp\u003EThe idea is to create a random dv repartition for a population of rockets. They would be the parents. Then with the previous function you compute what is the mass of each of them. You then use genetic algorithm techniques (selection, crossing, mutation) to generate a child population. After a given number of generation, you look for the best individual in your population.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EHeh... In Computer Science, genetic algorithms are self-rewriting algorithms, or more generally, the \u003Cem\u003Ealgorithms\u003C/em\u003E mutate, not the input/output (well, not directly). What you\u0027re doing is applying genetic theory in an iterative optimization algorithm.\u003C/p\u003E\u003Cp\u003EInteresting idea, though. Are you determining some ideal \u0022child\u0022 engine specs, then finding the closest match in the set of available engines?\u003C/p\u003E\n"},{"CreatedByName":"Dilir","CreatedById":122948,"CreatedDateTime":"2014-11-12T20:42:46Z","Content":"\n\u003Cp\u003EWell, we are talking optimization genetic algorythm, i don\u0027t know what computer scientist are calling genetic ^^. I can\u0027t take credit for the idea, it\u0027s well documented.\u003C/p\u003E\u003Cp\u003EI am not determining ideal child specs. I use my first function (only once per differents twr required, that\u0027s the trick) to generate two matrix. First give mass as a function of delta v and payload for single stage rocket, second give related optimal engine from those available.\u003C/p\u003E\u003Cp\u003EThen, a rocket is just defined by how you break your total DV. Each subset engine can be easily extracted from the matrix previously computed. This is still under testing and improvement and I will give more precise info when it will be a bit more polished.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-11-12T20:58:12Z\u0022 title=\u002211/12/2014 08:58  PM\u0022 data-short=\u00229 yr\u0022\u003ENovember 12, 2014\u003C/time\u003E by Dilir\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"MathigNihilcehk","CreatedById":81703,"CreatedDateTime":"2014-11-12T21:19:07Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Dilir\u0022 data-cite=\u0022Dilir\u0022\u003E\u003Cdiv\u003EWell, we are talking optimization genetic algorythm, i don\u0027t know what computer scientist are calling genetic ^^. I can\u0027t take credit for the idea, it\u0027s well documented.\u003Cp\u003EI am not determining ideal child specs. I use my first function (only once per differents twr required, that\u0027s the trick) to generate two matrix. First give mass as a function of delta v and payload for single stage rocket, second give related optimal engine from those available.\u003C/p\u003E\u003Cp\u003EThen, a rocket is just defined by how you break your total DV. Each subset engine can be easily extracted from the matrix previously computed. This is still under testing and improvement and I will give more precise info when it will be a bit more polished.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EStill having trouble figuring out what you are doing... So, you generate a matrix that will look like\u003C/p\u003E\u003Cp\u003E[table=width: 500, class: grid]\u003C/p\u003E\u003Cp\u003E[tr]\u003C/p\u003E\u003Cp\u003E [td]m(dV,P)_x_1y_1z_1[/td]\u003C/p\u003E\u003Cp\u003E [td]x_1[/td]\u003C/p\u003E\u003Cp\u003E [td]y_1[/td]\u003C/p\u003E\u003Cp\u003E [td]z_1[/td]\u003C/p\u003E\u003Cp\u003E[/tr]\u003C/p\u003E\u003Cp\u003E[tr]\u003C/p\u003E\u003Cp\u003E [td]m(dV,P)_x_2y_2z_2[/td]\u003C/p\u003E\u003Cp\u003E [td]x_2[/td]\u003C/p\u003E\u003Cp\u003E [td]y_2[/td]\u003C/p\u003E\u003Cp\u003E [td]z_2[/td]\u003C/p\u003E\u003Cp\u003E[/tr]\u003C/p\u003E\u003Cp\u003E[tr]\u003C/p\u003E\u003Cp\u003E [td]m(dV,P)_x_iy_iz_i[/td]\u003C/p\u003E\u003Cp\u003E [td]x_i[/td]\u003C/p\u003E\u003Cp\u003E [td]y_i[/td]\u003C/p\u003E\u003Cp\u003E [td]z_i[/td]\u003C/p\u003E\u003Cp\u003E[/tr]\u003C/p\u003E\u003Cp\u003E[/table]\u003C/p\u003E\u003Cp\u003EThen you search for the minimum mass given a certain P and dV and display the appropriate x, y, and z?\u003C/p\u003E\u003Cp\u003EOn another note entirely, I found a way to optimize my guesses. I just plug in my limit condition into a for-loop to scan for valid guesses, then immediately test the dv and TWR followed by comparing with the optimal set and resorting it, if needed.\u003C/p\u003E\u003Cp\u003EAnd... since someone replied fairly quickly, I\u0027ll set up a working model in Matlab, before transporting to C# (I\u0027m thinking Unity for GUI would work best, unless anyone has a better idea). After-all, who can say what the best model is, until the model is put to the test.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-11-12T21:21:19Z\u0022 title=\u002211/12/2014 09:21  PM\u0022 data-short=\u00229 yr\u0022\u003ENovember 12, 2014\u003C/time\u003E by MathigNihilcehk\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Dilir","CreatedById":122948,"CreatedDateTime":"2014-11-12T21:35:12Z","Content":"\n\u003Cp\u003EOk, here is what i do\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EFunction 1 (1 stage optimization)\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EImputs : required TWR, required size\u003C/p\u003E\u003Cp\u003EHarcoded : all engine specs (for now, i only use vacuum isp).\u003C/p\u003E\u003Cp\u003ECode\u003C/p\u003E\u003Cp\u003EStep 1: discretize dv and payload to n and m values\u003C/p\u003E\u003Cp\u003EStep 2: create two n*m matrix. First will contain best engine for each (dv,m) couple, second required fuel for that engine.\u003C/p\u003E\u003Cp\u003EStep 3: for each (dv,m), for each engine, compute the required mass to get dv. Store best (engine, mass) into dv,m point of storages matrix.\u003C/p\u003E\u003Cp\u003ERetrun the two n*m matrix. \u003C/p\u003E\u003Cp\u003EObviously, this function is quite time consuming. But, as we hard store the result for a large number of dv and mass, it only need to be run once per required TWR in rocket design.\u003C/p\u003E\u003Cp\u003E\u003Cstrong\u003EFunction 2: main algo\u003C/strong\u003E\u003C/p\u003E\u003Cp\u003EStep 1: create N rockets (a rocket is a partition of dV).\u003C/p\u003E\u003Cp\u003EStep 2: evalutate mass of rockets using function 1.\u003C/p\u003E\u003Cp\u003EStep 3: select (with mass), cross and mutate the rockets. This is the genetic part. The idea is to use \u0022good\u0027 parents to produce next generation. Good but not necessarely best allows better coverage of the optimization space and to avoid local minimas.\u003C/p\u003E\u003Cp\u003EStep 4: iterate until convergence.\u003C/p\u003E\u003Cp\u003E Step 5: keep best individual. Dv of each stage is given by definition of my rocket, corresponding engines are computed using function 1.\u003C/p\u003E\u003Cp\u003EI am going to bed now, but could discuss that furthermore tomorrow.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-11-12T21:38:13Z\u0022 title=\u002211/12/2014 09:38  PM\u0022 data-short=\u00229 yr\u0022\u003ENovember 12, 2014\u003C/time\u003E by Dilir\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"madlemur","CreatedById":116597,"CreatedDateTime":"2014-11-12T21:40:21Z","Content":"\n\u003Cp\u003EOK... Tell me more about Function 2, Step 3... How are you crossing and mutating the rockets? What variables (chromosomes) are you using?\u003C/p\u003E\n"},{"CreatedByName":"Dilir","CreatedById":122948,"CreatedDateTime":"2014-11-12T21:54:52Z","Content":"\n\u003Cp\u003EYou got the tricky part right. I am really open to new ideas here, as it\u0027s my first go at theses algos.\u003C/p\u003E\u003Cp\u003EMutating is for most of the case transfering some dv from one stage to the next or previous one. Sometimes, it\u0027s adding or removing an engine. Crossing is chosing a cutoff delta-v and take the upper part of rocket 1 and lower part of rocket 2.\u003C/p\u003E\u003Cp\u003EI got the idea of using these algo from 1 phd and 1 paper found here:\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022https://etd.auburn.edu/bitstream/handle/10415/837/BAYLEY_DOUGLAS_5.pdf?sequence=1\u0022 rel=\u0022external nofollow\u0022\u003Ehttps://etd.auburn.edu/bitstream/handle/10415/837/BAYLEY_DOUGLAS_5.pdf?sequence=1\u003C/a\u003E\u003C/p\u003E\u003Cp\u003Eand here\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022http://strategic.mit.edu/spacelogistics/pdf/AIAA-2006-1720-231.pdf\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://strategic.mit.edu/spacelogistics/pdf/AIAA-2006-1720-231.pdf\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EAnd now i\u0027m really going to sleep!\u003C/p\u003E\n"},{"CreatedByName":"MathigNihilcehk","CreatedById":81703,"CreatedDateTime":"2014-11-12T23:55:09Z","Content":"\n\u003Cp\u003ERegarding the Genetic Algorithm paper(I\u0027ll have to read more into it, in the future, it is quite interesting), I\u0027ve learned that it basically takes a number of random valid inputs, and then breeds them together and checks the offspring for better or worse engine design. It takes the best sets and continually breeds them until one solution is found. However, this solution is not guaranteed to be the global maximum or minimum as stated in the paper \u0022However, finding this global optimum is not guaranteed.\u0022 page 11, paragraph 2. IE: some rocket components could be lost for reasons completely unrelated to their value (ie, the rocket they were in failed as a whole). This is avoided if a large enough sample size is used, but the larger the sample size, the more generations will need to be checked, and computational time is exponentially related to sample size. As the second paper explains, the optimization is partly random, as in page 9 paragraph 2 \u0022This is a result of the randomness inherent in a heuristic optimization algorithm, and suggests that more computation is necessary to give confidence with the results.\u0022\u003C/p\u003E\u003Cp\u003EWhile this may lead to an optimization function that generates good rockets that qualify our constraints in a short period of time, it may either miss better rockets, or eat up more computational time than desired. In contrast, my method takes more of a thorough approach and scans every rocket within a range of valid rockets. A finite range can be picked to include the most optimal rocket, and thus the best rocket can be found given enough time.\u003C/p\u003E\n"},{"CreatedByName":"Dilir","CreatedById":122948,"CreatedDateTime":"2014-11-13T07:28:21Z","Content":"\n\u003Cp\u003EThe global idea is good.\u003C/p\u003E\u003Cp\u003EHowever, keeping only the best set for offspring, while it allows faster convergence, often causes to fal into a local minimal. By keeping some \u0022less good\u0022 individual, you ensure better genetics diversity at the price of computation time.\u003C/p\u003E\u003Cp\u003EI am not sure of the complexity of my algo. It\u0027s roughly number of individuals * number of generation to convergence, but i don\u0027t know how the latter relates to the former.\u003C/p\u003E\u003Cp\u003EI agree with you that for high complexity (3\u002B stages) rocket, if you limit the numer of generation, you might only get \u0022goods rockets\u0022 and not the absolute minima.\u003C/p\u003E\u003Cp\u003EThis is a tradoff, because for n stage, exhaustive search is, assuming you divide your rocket in 1000 dv units, (n-1) among 1000 which is roughly 1000^(n-1)/(n-1)!\u003C/p\u003E\u003Cp\u003EAnyway, genetic search was something fun i wanted to try out (because i never used it before) and seemed to be interesting for the problem i am trying to adress. I do not say it is the best solution, and I would be happy to discuss with you about other algos.\u003C/p\u003E\n"}]}