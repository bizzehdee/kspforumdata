{"TopicId":206633,"ForumId":20,"TopicTitle":"I made a kOS quadcopter script (WIP). Can someone help me finish it?","CreatedByName":"MAFman","CreatedById":101780,"CreatedDateTime":"2022-01-27T14:56:41Z","PageNum":1,"Articles":[{"CreatedByName":"MAFman","CreatedById":101780,"CreatedDateTime":"2022-01-27T14:56:41Z","Content":"\n\u003Cp\u003E\nI\u0027m trying to make a quadcopter that\u0027s actually flyable intuitively, and to that end I\u0027m developing a kOS script to control it. I\u0027m using the Breaking Ground rotors and controlling them using their max RPM fields. Here\u0027s the code:\u00A0\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode\u0022\u003E// Fly-by-wire for a quadcopter\n\n// Declare variables representing the four motors, which are tagged\nset frontLeft to ship:partsTagged(\u0022front left\u0022)[0].\nset frontRight to ship:partsTagged(\u0022front right\u0022)[0].\nset rearLeft to ship:partsTagged(\u0022rear left\u0022)[0].\nset rearRight to ship:partsTagged(\u0022rear right\u0022)[0].\n\n// Use setField(rpmLimit)\nset frontLeftThrottle to frontLeft:getModule(\u0022ModuleRoboticServoRotor\u0022).\nset frontRightThrottle to frontRight:getModule(\u0022ModuleRoboticServoRotor\u0022).\nset rearLeftThrottle to rearLeft:getModule(\u0022ModuleRoboticServoRotor\u0022).\nset rearRightThrottle to rearRight:getModule(\u0022ModuleRoboticServoRotor\u0022).\n\nset motors to list(\u0022frontLeft\u0022, \u0022frontRight\u0022, \u0022rearLeft\u0022, \u0022rearRight\u0022).\n\nfunction throttleMotor {\n  parameter motor, throt. // throt is a float between 0 and 1\n  if motor = \u0022frontLeft\u0022 {\n    frontLeftThrottle:setField(throt * 460).\n  }\n  else if motor = \u0022frontRight\u0022 {\n    frontRightThrottle:setField(throt * 460).\n  }\n  else if motor = \u0022rearLeft\u0022 {\n    rearLeftThrottle:setField(throt * 460).\n  }\n  else if motor = \u0022rearRight\u0022 {\n    rearRightThrottle:setField(throt * 460).\n  }\n  else { // Catch-all, this should never happen\n    print(\u0022Error: invalid motor!\u0022).\n  }\n}\n\nfunction calcMotorSpeed {\n  // Make the speed of each motor proportional to the main throttle plus the input from steering\n  set rotorSpeed to 230 * pilotMainThrottle.\n  set speedOffset to rotorSpeed * 0.25.\n\n  // Pitch: If negative, front rotors slow down and rear rotors speed up\n  //        If positive, front rotors speed up and rear rotors slow down\n  //        This happens until the measured pitch is \u002B/- 15 degrees,\n  //        at which point the four motors briefly change speed to stop the pitch\n  //        If zero, reverse pitch until forward speed is zero\n  set pitchOutput to list(0, 0, 0, 0).\n  if pilotPitch = -1 {\n    set pitchOutput[0] to -speedOffset.\n    set pitchOutput[1] to -speedOffset.\n    set pitchOutput[2] to speedOffset.\n    set pitchOutput[3] to speedOffset.\n  }\n  else if pilotPitch = 1 {\n      set pitchOutput[0] to speedOffset.\n      set pitchOutput[1] to speedOffset.\n      set pitchOutput[2] to -speedOffset.\n      set pitchOutput[3] to -speedOffset.\n    }\n  else {\n    // Reverse outputs until measured forward speed is zero, then set all input offsets to 0.\n  }\n\n  // Yaw: If negative, front left and rear right rotors speed up, and rear left and front right rotors slow down\n  //      If positive, front right and rear left rotors speed up, and rear right and front left rotors slow down\n  //      If zero, set all rotors to equal speed.\n  set yawOutput to list(0, 0, 0, 0).\n  if pilotYaw = -1 {\n    set pitchOutput[0] to -speedOffset.\n    set pitchOutput[2] to -speedOffset.\n    set pitchOutput[1] to speedOffset.\n    set pitchOutput[3] to speedOffset.\n  }\n  else if pilotYaw = 1 {\n      set yawOutput[0] to speedOffset.\n      set yawOutput[2] to speedOffset.\n      set yawOutput[1] to -speedOffset.\n      set yawOutput[3] to -speedOffset.\n    }\n  else {\n    set yawOutput[0] to 0.\n    set yawOutput[1] to 0.\n    set yawOutput[2] to 0.\n    set yawOutput[3] to 0.\n  }\n\n  // Roll: If positive, left rotors speed up and right rotors slow down\n  //       If negative, left rotors slow down and right rotors speed up\n  //       This happens until the measured roll is \u002B/- 15 degrees,\n  //       at which point the rotors briefly change speed to stop the roll\n  //       If zero, reverse roll until lateral speed is zero\n  set rollOutput to list(0, 0, 0, 0).\n  if pilotRoll = -1 {\n    set rollOutput[0] to -speedOffset.\n    set rollOutput[2] to -speedOffset.\n    set rollOutput[1] to speedOffset.\n    set rollOutput[3] to speedOffset.\n  }\n  else if pilotPitch = 1 {\n      set rollOutput[0] to speedOffset.\n      set rollOutput[2] to speedOffset.\n      set rollOutput[1] to -speedOffset.\n      set rollOutput[3] to -speedOffset.\n    }\n  else {\n    // Reverse outputs until measured forward speed is zero, then set all input offsets to 0.\n  }\n\n  // Total: Sum all inputs and that\u0027s the final output.\n  set totalOutput to list(0, 0, 0, 0).\n  for element in pitchOutput {\n    set totalOutput[element] to pitchOutput[element] \u002B yawOutput[element] \u002B rollOutput[element] \u002B rotorSpeed.\n  }\n  for m in motors {\n    throttleMotor(m, totalOutput[indexOf(m)]).\n  }\n}\u003C/pre\u003E\n\u003Cp\u003E\nI have yet to implement the auto-leveling, which I have no idea how to do. How do real drones pull it off?\n\u003C/p\u003E\n"},{"CreatedByName":"Snark","CreatedById":125662,"CreatedDateTime":"2022-01-27T20:33:10Z","Content":"\n\u003Cp\u003E\nMoving to Add-on Discussions.\n\u003C/p\u003E\n"}]}