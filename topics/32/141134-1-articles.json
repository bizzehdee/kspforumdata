{"TopicId":141134,"ForumId":32,"TopicTitle":"[1.1.2][kOS] Air drag calculation attempt","CreatedByName":"schedar","CreatedById":164417,"CreatedDateTime":"2016-06-03T17:43:34Z","PageNum":1,"Articles":[{"CreatedByName":"schedar","CreatedById":164417,"CreatedDateTime":"2016-06-03T17:43:34Z","Content":"\n\u003Cp\u003E\nHi,\n\u003C/p\u003E\n\u003Cp\u003E\nSo because there is no real answer so far on how to do a perfect ascend I did an attempt to calculate Air drag in kOS as a first step to finding method for perfect ascend. Basically I just assumed that:\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022gif.latex?PotentialAcceleration%20-%20Ai\u0022 src=\u0022https://latex.codecogs.com/gif.latex?PotentialAcceleration%20-%20AirDragAcceleration%20%3D%20RealAcceleration\u0022 title=\u0022This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\nwhere\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022gif.latex?PotentialAcceleration%20%3D%20\u0022 src=\u0022https://latex.codecogs.com/gif.latex?PotentialAcceleration%20%3D%20ThrustAcceleration%20-%20GravitionalForceAcceleration\u0022 title=\u0022This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg alt=\u0022gif.latex?RealAcceleration%3D%5Cfrac%7B%\u0022 src=\u0022https://latex.codecogs.com/gif.latex?RealAcceleration%3D%5Cfrac%7B%5CDelta%20V%7D%7B%5CDelta%20T%7D\u0022 title=\u0022This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program.\u0022\u003E\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nSo basically if we knew Potential and Real acceleration we could calculate AirDragAcceleration. We could see then if drag resistance is to high.\n\u003C/p\u003E\n\u003Cp\u003E\nBelow is a script in kOS that wil show thrust force (Ft), and accelerations Ar(real), Ap(potential) and Ad (drag). Be aware that it will calculate properly only when you are ascending in the atmosphere. Also turning your rocket will probably make readings inaccurate (I\u0027m working on it). It\u0027s not going to be 100% correct but i think it\u0027s good start.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nBTW. I\u0027m using SSRSS mod that\u0027s why it\u0027s using Earth. You can use Kerbin if you don\u0027t have this mod.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cimg class=\u0022ipsImage\u0022 src=\u0022http://s33.postimg.org/v05ob9xnj/Untitled.png\u0022 alt=\u0022Untitled.png\u0022\u003E\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003ECLEARSCREEN.\u003Cbr\u003E\n//Standard Earth Gravity Acceleration\u003Cbr\u003E\nset c_Earth_G0 to (earth:mass*constant:g/earth:radius^2).\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003Euntil false {\u003Cbr\u003E\n//Calculate actual thrust\u003Cbr\u003E\n\u00A0\u00A0 \u00A0LIST engines in l_Engines.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set v_Ft to 0.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0FOR eng IN l_Engines {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0IF eng:IGNITION set v_Ft to v_Ft \u002B eng:THRUST.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0//Thrust force Ft in kN\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022Ft:\u0022\u002Bround(v_Ft,2) at(50,2).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n//Earth gravitional acceleration with altitude\u003Cbr\u003E\nset v_Earth_Gh to c_Earth_G0*(earth:radius/(earth:radius\u002Bship:altitude))^2.\u003Cbr\u003E\n//Earth gravitional force with altitude\u003Cbr\u003E\nset v_Earth_Fg to ship:mass*v_Earth_Gh.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003E//Potential acceleration without air drag on Earth\u003Cbr\u003E\nset v_Earth_Ap to (v_Ft-v_Earth_Fg)/ship:mass.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022Ap:\u0022\u002Bround(v_Earth_Ap,2) at(50,5).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n//Calculate dV and dT\u003Cbr\u003E\nset T_temp to sessiontime.\u003Cbr\u003E\nset V_temp_vector to SHIP:VELOCITY:SURFACE.\u003Cbr\u003E\nwait 0.1.\u003Cbr\u003E\nset delta_T to sessiontime - T_temp.\u003Cbr\u003E\nset delta_V_vector to SHIP:VELOCITY:SURFACE - V_temp_vector.\u003Cbr\u003E\nset delta_V_vector_mag to delta_V_vector:MAG.\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003E//Real acceleration\u003Cbr\u003E\n//in direction of velocity\u003Cbr\u003E\nset v_Ar to delta_V_vector_mag/delta_T.\u003Cbr\u003E\nprint \u0022Ar:\u0022\u002Bround(v_Ar,2) at(50,4).\u003C/span\u003E\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022font-family:\u0027courier new\u0027, courier, monospace;\u0022\u003E//Airdrag Ad = Ap - Ar\u003Cbr\u003E\nSet v_Earth_Ad to v_Earth_Ap - v_Ar.\u003Cbr\u003E\nprint \u0022Ad:\u0022\u002Bround(v_Earth_Ad,2) at(50,6).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n}\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nLet me know what you think.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-06-03T17:54:32Z\u0022 title=\u002206/03/2016 05:54  PM\u0022 data-short=\u00228 yr\u0022\u003EJune 3, 2016\u003C/time\u003E by schedar\u003C/strong\u003E\n\u003Cbr\u003Escreenshot\n\u003C/span\u003E\n"},{"CreatedByName":"Adelaar","CreatedById":150794,"CreatedDateTime":"2016-06-05T22:16:05Z","Content":"\n\u003Cp\u003E\nA few questions... The first is; why don\u0027t you tap into the datastream of KSP itself, rather than to resort to calculations rond by a script. I\u0027m no modder, but I do know how to visualize the drag by turning on the Aero GUI via Alt-F12.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nSecondly, why use drag for an optimal ascentprofile, drag isn\u0027t the only factor, the slingshot effect is too...\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nAlso, why not Mechjeb? I don\u0027t use it myself \u00A0but it does provide ascentprofile.\n\u003C/p\u003E\n"},{"CreatedByName":"stenole","CreatedById":144084,"CreatedDateTime":"2016-06-05T23:30:48Z","Content":"\n\u003Cp\u003E\nYour reasoning is correct, but I would try to keep things as vectors to make sure you\u0027re not adding errors into your calculations. Vectors will\u00A0make your code cleaner because a lot of the variables that you extract in kOS will already be vectors and you have access to simple vector functions.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022color:rgb(39,42,52);font-family:\u0027courier new\u0027, courier, monospace;font-size:14px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:22.4px;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;float:none;background-color:rgb(250,250,250);\u0022\u003E\u0022set v_Earth_Ap to (v_Ft-v_Earth_Fg)/ship:mass.\u003C/span\u003E \u0022\n\u003C/p\u003E\n\u003Cp\u003E\nThis line of code assumes that your thrust is always pointing opposite of gravity which means it will be incorrect if your rocket is not going straight up. If you had thrust and gravity as vectors instead of scalar numbers\u00A0this would make it easier to apply newton\u0027s 2nd law of motion.\n\u003C/p\u003E\n\u003Cp\u003E\nIf you intend to use scalars and keep gravity going in the -1 direction, be aware that the angular speed (horizontal speed) will affect the\u00A0gravity value because you are in a rotating reference frame; Think Centripetal force\n\u003C/p\u003E\n"},{"CreatedByName":"schedar","CreatedById":164417,"CreatedDateTime":"2016-06-15T17:31:14Z","Content":"\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222618131\u0022 data-ipsquote-contentid=\u0022141134\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221465164965\u0022 data-ipsquote-userid=\u0022150794\u0022 data-ipsquote-username=\u0022Adelaar\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nOn 6/6/2016 at 0:16 AM, Adelaar said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nA few questions... The first is; why don\u0027t you tap into the datastream of KSP itself, rather than to resort to calculations rond by a script. I\u0027m no modder, but I do know how to visualize the drag by turning on the Aero GUI via Alt-F12.\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nSecondly, why use drag for an optimal ascentprofile, drag isn\u0027t the only factor, the slingshot effect is too...\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nAlso, why not Mechjeb? I don\u0027t use it myself \u00A0but it does provide ascentprofile.\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nThe idea is to use kOS instead of Mechjeb in order to have full control over vessel during ascent.\n\u003C/p\u003E\n\u003Cp\u003E\nDrag is of course one of the elements I want to use as a parameter when ascending. I want to keep it optimal especially in lower parts of the atmosphere.\n\u003C/p\u003E\n\u003Cp\u003E\nI\u0027d love to extract the air drag numbers from datastream of KSP but I don\u0027t know how.\n\u003C/p\u003E\n\u003Cblockquote class=\u0022ipsQuote\u0022 data-ipsquote=\u0022\u0022 data-ipsquote-contentapp=\u0022forums\u0022 data-ipsquote-contentclass=\u0022forums_Topic\u0022 data-ipsquote-contentcommentid=\u00222618233\u0022 data-ipsquote-contentid=\u0022141134\u0022 data-ipsquote-contenttype=\u0022forums\u0022 data-ipsquote-timestamp=\u00221465169448\u0022 data-ipsquote-userid=\u0022144084\u0022 data-ipsquote-username=\u0022stenole\u0022\u003E\n\u003Cdiv class=\u0022ipsQuote_citation\u0022\u003E\nOn 6/6/2016 at 1:30 AM, stenole said:\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsQuote_contents\u0022\u003E\n\u003Cp\u003E\nYour reasoning is correct, but I would try to keep things as vectors to make sure you\u0027re not adding errors into your calculations. Vectors will\u00A0make your code cleaner because a lot of the variables that you extract in kOS will already be vectors and you have access to simple vector functions.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cspan style=\u0022color:rgb(39,42,52);font-family:\u0027courier new\u0027, courier, monospace;font-size:14px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:22.4px;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;float:none;background-color:rgb(250,250,250);\u0022\u003E\u0022set v_Earth_Ap to (v_Ft-v_Earth_Fg)/ship:mass.\u003C/span\u003E \u0022\n\u003C/p\u003E\n\u003Cp\u003E\nThis line of code assumes that your thrust is always pointing opposite of gravity which means it will be incorrect if your rocket is not going straight up. If you had thrust and gravity as vectors instead of scalar numbers\u00A0this would make it easier to apply newton\u0027s 2nd law of motion.\n\u003C/p\u003E\n\u003Cp\u003E\nIf you intend to use scalars and keep gravity going in the -1 direction, be aware that the angular speed (horizontal speed) will affect the\u00A0gravity value because you are in a rotating reference frame; Think Centripetal force\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/blockquote\u003E\n\u003Cp\u003E\nYes, you are very correct about this. I simply got lost in all those vectors, directions and rotations in kOS so I started simply with scalars and added some vectors where I could. Well it was my first attempt.\n\u003C/p\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-03T17:48:02Z","Content":"\n\u003Cp\u003E\nThose equations will only work if you\u0027re going straight up, because gravity only acts in one direction whilst the thrust and drag can be in any.\u00A0 Pretty useless for actual ascents.\n\u003C/p\u003E\n\u003Cp\u003E\nA more effective equation for drag is 1/2 *q *Cd *A, where:\n\u003C/p\u003E\n\u003Cul\u003E\u003Cli\u003E\nq = dynamic pressure\n\u003C/li\u003E\n\u003Cli\u003E\nCd = coefficient of drag\n\u003C/li\u003E\n\u003Cli\u003E\nA = surface area\n\u003C/li\u003E\n\u003C/ul\u003E\u003Cp\u003E\n(from \u003Ca href=\u0022https://www.reddit.com/r/Kos/comments/1mmotv/how_to_determine_atmospheric_drag_on_your_craft/\u0022 rel=\u0022external nofollow\u0022\u003Ehere\u003C/a\u003E)\n\u003C/p\u003E\n\u003Cp\u003E\nThe problem is we don\u0027t know (A *Cd) anymore in 1.0 without doing experiments.\u00A0 Cd is based on the \u0027drag boxes\u0027 you may have heard about, and no one knows how to calculate them yet AFAIK.\n\u003C/p\u003E\n\u003Cp\u003E\nGeneral dimensions of the ship aren\u0027t even available in kOS for some inexplicable reason. A is just frontal surface area, though, so width^2 in the editor.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-07-09T04:44:52Z\u0022 title=\u002207/09/2016 04:44  AM\u0022 data-short=\u00228 yr\u0022\u003EJuly 9, 2016\u003C/time\u003E by surge\u003C/strong\u003E\n\u003Cbr\u003Eequation was wrong\n\u003C/span\u003E\n"},{"CreatedByName":"surge","CreatedById":136150,"CreatedDateTime":"2016-07-09T04:56:02Z","Content":"\n\u003Cp\u003E\nIf you want ascent guidance try the following (xnode just does the maneuvre node).\n\u003C/p\u003E\n\u003Cp\u003E\nThe key seems to be vectored thrust pitch-over angle/altitude at 0-lift start, not drag... you can make nearly any rocket get into space with this by adjusting that value. Some of my more \u0027pointy\u0027 rockets use poang as low as 50, but if you\u0027re trying to launch a draggy, horrible pile of junk, you may need as much as 85-80. And even then it probably wont get into orbit - it\u0027s just not possible.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nparameter talt, tinc, poang.\u003Cbr\u003E\n// Target Altitude, Target Inclination, Pitchover Angle\n\u003C/p\u003E\n\u003Cp\u003E\nclearscreen.\u003Cbr\u003E\nprint \u0022== Launch Ascent Guidance System (LAGS) ==\u0022.\n\u003C/p\u003E\n\u003Cp\u003E\nset talt to talt *1000. // target orbital perigee\u003Cbr\u003E\nset safetyspeed to 50. // speed at which safety turn ends.\u003Cbr\u003E\nset safestart to 20. // Altitude at which safety turn starts.\u003Cbr\u003E\nset pitchhold to 10. // halt zero-lift turn at this pitch\u003Cbr\u003E\nset debugmode to true.\n\u003C/p\u003E\n\u003Cp\u003E\nset critq to 15. // maxQ Not implemented yet.\u003Cbr\u003E\n// fudge factor - how \u0027pointy\u0027 rocket is\u003Cbr\u003E\nset dragf to 0.4. // Not implemented yet\n\u003C/p\u003E\n\u003Cp\u003E\n// ===END CONFIG OPTIONS===\n\u003C/p\u003E\n\u003Cp\u003E\n// release controls early in case we get interrupted.\u003Cbr\u003E\nSET SHIP:CONTROL:PILOTMAINTHROTTLE TO 0.\n\u003C/p\u003E\n\u003Cp\u003E\nlock LAc to 90 -vang(up:vector, ship:velocity:surface).\u003Cbr\u003E\nlock dynp to SHIP:DYNAMICPRESSURE *constant:AtmToKPa.\n\u003C/p\u003E\n\u003Cp\u003E\nfunction printscreen {\u003Cbr\u003E\n// were going to use a 15 line screen total.\u003Cbr\u003E\n// Debug messages start on line 20\u003Cbr\u003E\nprint \u0022 \u0022 at(0,1).\u003Cbr\u003E\nprint \u0022Target altitude: \u0022 \u002Bround(talt/1000, 1) \u002B\u0022km\u00A0\u00A0 \u0022 at(0,2).\u003Cbr\u003E\nprint \u0022Target inclination: \u0022 \u002Bround(tinc, 1) \u002B\u0022o\u00A0\u00A0 \u0022 at(25,2).\u003Cbr\u003E\n// Vector start, Vector end\u003Cbr\u003E\n// Launch mass, \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003Etwr\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003Cbr\u003E\nprint \u0022Apogee: \u0022 \u002Bround(SHIP:OBT:APOAPSIS/1000,1) \u002B\u0022km\u00A0\u00A0\u00A0\u00A0 \u0022at(0,6).\u003Cbr\u003E\nprint \u0022Perigee: \u0022 \u002Bround(SHIP:OBT:PERIAPSIS/1000,1) \u002B\u0022km\u00A0\u00A0\u00A0 \u0022at(25,6).\u003Cbr\u003E\nprint \u0022Time to apogee: \u0022 \u002Bround(ETA:APOAPSIS) \u002B\u0022s\u00A0\u00A0 \u0022at(0,7).\u003Cbr\u003E\nprint \u0022Ecc: \u0022 \u002Bround(SHIP:OBT:ECCENTRICITY,2) \u002B\u0022\u00A0\u00A0 \u0022 at(0,8).\u003Cbr\u003E\nprint \u0022Inc: \u0022 \u002Bround(SHIP:OBT:INCLINATION,2)\u00A0 \u002B\u0022\u00A0\u00A0 \u0022 at(25,8).\u003Cbr\u003E\nprint \u0022Dynamic pressure: \u0022 \u002Bround(dynp, 2) \u002B\u0022/\u0022 \u002Bround(critq, 2)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u002B\u0022kPa\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,9).\u003Cbr\u003E\nprint \u0022Flight path angle: \u0022 \u002Bround(LAc, 1) \u002B\u0022\u00A0\u00A0 \u0022 at(0,10).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,11).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,12).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,13).\u003Cbr\u003E\nprint \u0022 \u0022 at(0,14).\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nwait 0.5.\u003Cbr\u003E\nprintscreen().\u003Cbr\u003E\nprint \u0022STATUS: calculating...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\n\u003C/p\u003E\n\u003Cp\u003E\nfunction clamped {\u003Cbr\u003E\n// returns stage number of clamps any\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local stagecmp to STAGE:number.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local highclamp to -1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if SHIP:STATUS \u0026lt;\u0026gt; \u0022PRELAUNCH\u0022 and SHIP:STATUS \u0026lt;\u0026gt; \u0022LANDED\u0022\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return -1.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local clamps to ship:partsnamed(\u0022launchClamp1\u0022).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0for c in clamps {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (c:stage \u0026gt; highclamp) set highclamp to c:stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return highclamp.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nset coremotors to list().\u003Cbr\u003E\nset boostmotors to list().\u003Cbr\u003E\nfunction detect_motors {\u003Cbr\u003E\n// parse and sort motors in current stage into\u003Cbr\u003E\n// globals coremotors and boostmotors\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local el to list().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0list engines in el.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set coremotors to list().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set boostmotors to list().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local stagehigh to STAGE:number.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local stagelow to clamped().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (SHIP:STATUS = \u0022PRELAUNCH\u0022) and (stagelow = -1) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set stagelow to stagehigh -1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0} else if (stagelow = -1)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set stagelow to stagehigh.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0for e in el {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// we have to detect if stage above has launch\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// clamps AND if we are in launch ready state\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (e:stage \u0026gt;= stagelow) and (e:stage \u0026lt;= stagehigh)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// Check if the engine is\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// on centre stack.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (e:tag = \u0022boostMotor\u0022) {\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0boostmotors:add(e).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0} else {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// everything else should be cores.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0coremotors:add(e).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return coremotors:LENGTH \u002Bboostmotors:LENGTH.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nfunction setcorethrottle {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter lvl.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0for e in coremotors {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set e:THRUSTLIMIT to lvl *100.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nfunction getcorethrottle {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (coremotors:length = 0) return 0.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return coremotors[0]:THRUSTLIMIT /100.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nfunction getctwr {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// returns current \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003ETWR\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// *sigh* :MAXTHRUST doesnt work unless the engine is\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// staged. This SHOULD return the \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003ETWR\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E upon launch, so\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// we only have to calculate it once.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local gf to (SHIP:BODY:MU\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0/(SHIP:BODY:RADIUS \u002BSHIP:ALTITUDE)^2).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local thrust to 0.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0list engines in el.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0for e in el\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if e:IGNITION set thrust to thrust \u002Be:THRUST.\n\u003C/p\u003E\n\u003Cp\u003E\n//\u00A0\u00A0 \u00A0return SHIP:AVAILABLETHRUST /(SHIP:MASS*gf).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return thrust /(SHIP:MASS*gf).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nfunction inc2hdg {\u003Cbr\u003E\n// does the wierd maths when converting from an orbital inclination\u003Cbr\u003E\n// to a heading to fly for it.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter inc.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set rt to 180 -inc -90.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (rt \u0026lt; 0) set rt to 180 -rt.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return rt.\u003Cbr\u003E\n}\u003Cbr\u003E\nset thdg to inc2hdg(tinc).\n\u003C/p\u003E\n\u003Cp\u003E\nset east to up *R(0, -90, 0).\u003Cbr\u003E\nfunction getvhdg {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local r1 to vcrs(up:vector,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ship:velocity:orbit):normalized.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local vhdg to vang(r1, east:vector).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (r1:y) \u0026gt; 0.0 set vhdg to 360 -vhdg.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return vhdg.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nset laststage to STAGE:NUMBER.\u003Cbr\u003E\nfunction stagectl {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if not STAGE:READY return false.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if THROTTLE \u0026lt;= 0 return false.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// detect_motors() takes long and only needs to be\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// called once after staging has finished\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (laststage \u0026lt;\u0026gt; STAGE:NUMBER) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0detect_motors().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set laststage to STAGE:NUMBER.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return false.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// also check for no motors\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (coremotors:length = 0) and (boostmotors:length = 0){\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0lock throttle to 1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return true.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0for e in boostmotors {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (e:maxthrust \u0026lt;= 0) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0lock throttle to 1.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return true.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0if (coremotors:length \u0026gt; 0) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// check that boost motors are gone.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0// but still need to do the fuel check thing.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (boostmotors:length = 0) setcorethrottle(1).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0local corethrust to 0.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0for e in coremotors {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0set corethrust to corethrust \u002Be:maxthrust.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0if (corethrust = 0) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0stage.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0return true.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return false.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\nfunction hdgerr {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// Calculates the heading offset for the given orbital\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// inclination.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0parameter targethdg.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// ffs. SHIP:OBT:INCLINATION doesnt do negatives?\u003Cbr\u003E\n\u00A0\u00A0 \u00A0set shipinc to SHIP:OBT:INCLINATION.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0local shiphdg to getvhdg().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0if (shiphdg \u0026gt; 90 and shiphdg \u0026lt; 270) set shipinc to -shipinc.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0return targethdg -inc2hdg(shipinc).\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\ndetect_motors().\u003Cbr\u003E\nif boostmotors:LENGTH = 0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022WARNING NO BOOST MOTORS DETECTED!\u0022 at (0,14).\u003Cbr\u003E\n//\u00A0\u00A0 \u00A0exit.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n//\u003Cbr\u003E\n// ===GUIDANCE CALCULATION===\u003Cbr\u003E\n//\n\u003C/p\u003E\n\u003Cp\u003E\nset poalt to SHIP:BODY:ATM:HEIGHT/7.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\n// FIXME: This needs to settle faster.\u003Cbr\u003E\nSET thpid to PIDLOOP(0.1, 0.8, 0.15, 0, 1).\u003Cbr\u003E\nset thpid:setpoint to 0.0.\n\u003C/p\u003E\n\u003Cp\u003E\nSET pchpid to PIDLOOP(0.5, 0.05, 0.5, 0, 20).\u003Cbr\u003E\nset pchpid:setpoint to 15.\n\u003C/p\u003E\n\u003Cp\u003E\n//set STEERINGMANAGER:PITCHPID:KD to 0.5.\u003Cbr\u003E\n//set STEERINGMANAGER:YAWPID:KD to 0.5.\n\u003C/p\u003E\n\u003Cp\u003E\nFROM {local countdown is 5.}\u003Cbr\u003E\nUNTIL countdown = 0 STEP {SET countdown to countdown - 1.} DO {\u003Cbr\u003E\n\u00A0\u00A0\u00A0 PRINT \u0022STATUS: pre-launch... T-\u0022\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u002B countdown \u002B\u0022s\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\n\u00A0\u00A0\u00A0 WAIT 1.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: Launch...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock throttle to 1.\u003Cbr\u003E\nlock steering to up.\u003Cbr\u003E\n// Since engine:MAXTHRUST is broken, we have to actually fire\u003Cbr\u003E\n// up the engines (possibly launch if no clamps) to get a value.\u003Cbr\u003E\nset launchtwr to 0.\u003Cbr\u003E\nset sa to SHIP:ALTITUDE -SHIP:GEOPOSITION:TERRAINHEIGHT.\u003Cbr\u003E\nuntil SHIP:ALTITUDE -SHIP:GEOPOSITION:TERRAINHEIGHT-sa \u0026gt; safestart {\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0set launchtwr to getctwr().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local dTWR to getctwr() -1.3.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0setcorethrottle(thpid:update(TIME:SECONDS*10, dTWR)).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022Launch \u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003E\u003Cabbr title=\u0022Thrust-to-weight ratio\u0022\u003ETWR\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E: \u0022 \u002Bround(launchtwr, 2) \u002B\u0022\u00A0\u00A0\u00A0\u00A0 \u0022 at(25,3).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0print \u0022Launch Mass: \u0022 \u002Bround(SHIP:MASS, 2) \u002B\u0022\u00A0\u00A0\u00A0 \u0022 at(0,3).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.1.\u003Cbr\u003E\n}\u003Cbr\u003E\nunset sa.\u003Cbr\u003E\n//set poang to 90-(-100*(1/dragf*0.2)*(launchtwr -1.8)).\u003Cbr\u003E\nprint \u0022Zero-lift start: \u0022 \u002Bround(poalt) \u002B\u0022m\u00A0\u00A0 \u0022 at(0,4).\u003Cbr\u003E\nprint \u0022Vectoring angle: \u0022 \u002Bround(poang, 1) \u002B\u0022o\u00A0\u00A0\u00A0 \u0022at(25,4).\u003Cbr\u003E\nunset startalt.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: safety turn...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock steering to heading(thdg, 85).\u003Cbr\u003E\nset \u003Cabbr title=\u0022Reaction Control System\u0022\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003Ercs\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E to true.\u003Cbr\u003E\nuntil (SHIP:VELOCITY:SURFACE:MAG \u0026gt;= safetyspeed) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: vector guidance...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock pitcherr to SHIP:ALTITUDE *(90-poang)/poalt.\u003Cbr\u003E\nlock steering to heading(thdg, 90 -pitcherr).\u003Cbr\u003E\nuntil (SHIP:ALTITUDE \u0026gt; poalt)\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: zero-lift turn...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock steering to heading(thdg, LAc).\u003Cbr\u003E\n// FIXME: do throttle control\u003Cbr\u003E\nlock steering to heading(thdg \u002Bhdgerr(thdg), LAc).\u003Cbr\u003E\nuntil (LAc \u0026lt;= pitchhold) or (SHIP:APOAPSIS \u0026gt;= talt) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: pitch hold...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nlock steering to heading(thdg \u002Bhdgerr(thdg), pitchhold).\u003Cbr\u003E\nuntil (SHIP:ALTITUDE \u0026gt;= SHIP:BODY:ATM:HEIGHT) {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0stagectl().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0lock throttle to thpid:update(TIME:SECONDS,\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0SHIP:APOAPSIS -talt).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0local pitchang to pchpid:update(TIME:SECONDS*10, LAc).\u003Cbr\u003E\n\u00A0\u00A0 \u00A0lock steering to heading(thdg \u002Bhdgerr(thdg), pitchang).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0printscreen().\u003Cbr\u003E\n\u00A0\u00A0 \u00A0wait 0.5.\u003Cbr\u003E\n}\u003Cbr\u003E\nlock throttle to 0.\u003Cbr\u003E\nunlock steering.\u003Cbr\u003E\nunlock LAc.\u003Cbr\u003E\nunlock dynp.\u003Cbr\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003E\u003Cabbr title=\u0022Reaction Control System\u0022\u003ERCS\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E off.\n\u003C/p\u003E\n\u003Cp\u003E\n\u003Cbr\u003E\nprint \u0022STATUS: Orbital Insertion...\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\u003Cbr\u003E\nset apR to APOAPSIS \u002BBODY:RADIUS.\u003Cbr\u003E\nset \u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E to sqrt(BODY:MU /apR)\u003Cbr\u003E\n\u00A0\u00A0 \u00A0-sqrt(BODY:MU* (2/apR -1/OBT:SEMIMAJORAXIS)).\u003Cbr\u003E\nset circNode to node(TIME:SECONDS \u002BETA:APOAPSIS, 0, 0, \u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003E\u003Cabbr title=\u0022Delta-V\u0022\u003EdV\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E\u003C/abbr\u003E).\u003Cbr\u003E\nadd circNode.\u003Cbr\u003E\n// we could check the node is correct by comparing\u003Cbr\u003E\n// circNode:ORBIT:APOAPSIS and circNode:ORBIT:PERIAPSIS\u003Cbr\u003E\n// to make sure they are a) nearly equal, and b) close to talt\n\u003C/p\u003E\n\u003Cp\u003E\nrun xnode(1, 0).\u003Cbr\u003E\nprint \u0022STATUS: Program ended.\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0 \u0022 at(0,20).\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222016-07-09T05:08:57Z\u0022 title=\u002207/09/2016 05:08  AM\u0022 data-short=\u00228 yr\u0022\u003EJuly 9, 2016\u003C/time\u003E by surge\u003C/strong\u003E\n\u003C/span\u003E\n"}]}