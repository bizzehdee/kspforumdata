{"TopicId":69016,"ForumId":55,"TopicTitle":"Memory Swapping","CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-11T18:34:19Z","PageNum":1,"Articles":[{"CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-11T18:34:19Z","Content":"\n\u003Cp\u003EWay too many years ago I used to be a programmer on z80 and 6502. Now I\u0027m at the age where I probably have forgotton more than most people know. (Including where I put my glasses)\u003C/p\u003E\u003Cp\u003EAnyway before I start to ramble about dead relatives and the weather, I\u0027d like to pose a suggestion.\u003C/p\u003E\u003Cp\u003EWhen we were programming, we had the age old problem of not enough RAM.\u003C/p\u003E\u003Cp\u003ESo we would swap memory in and out from the hard drive.\u003C/p\u003E\u003Cp\u003EImagine if you will a KSP which doesn\u0027t load any parts at all. Except for the catalogue of parts.\u003C/p\u003E\u003Cp\u003EThe catalogue will show you all the parts you currently have access to. The ones you have researched. It will even tell you if, and how many of a given part you have in memory.\u003C/p\u003E\u003Cp\u003EThese parts are not held in the computers memory until you call for one of them and put it on a ship.\u003C/p\u003E\u003Cp\u003EOnce it is in the real world (as virtual as it may be) then it is kept in memory. Until such a time as that part no longer exists as a part in in real world. Then its memory is usable by another part.\u003C/p\u003E\u003Cp\u003ENo matter how many of an individual part you would have in the world, you would only need one part file/texture etc. in memory at any one time. You wouldn\u0027t need to have every item from every installed mod in memory at once.\u003C/p\u003E\u003Cp\u003EYou may have to have an array for tweakables and current state of each occurrence of the part but the rest of your hundreds of parts are not loaded until needed.\u003C/p\u003E\u003Cp\u003EWhen you install a mod, you would add it to the catalogue. The catalogue could be HUGE and accessible in game. You wouldn\u0027t even need to keep the whole catalogue in memory at the same time. Just the page you are looking at. This would open up options of really checking out a part before adding it to a ship. Full spec. sheet, 3D rotatable zoomable preview. Or just click and grab it and fit it as you do now. Nice to have options.\u003C/p\u003E\u003Cp\u003ENow I\u0027m curious... You see memory has been a problem since modding for the game began. (well, shortly thereafter) what I\u0027m curious about is whether it\u0027s 8 bit, 16,32, or even 64 bit. the same techniques are still good.\u003C/p\u003E\u003Cp\u003EWhy haven\u0027t they been implemented?\u003C/p\u003E\n"},{"CreatedByName":"coolitic","CreatedById":79738,"CreatedDateTime":"2014-04-11T18:37:32Z","Content":"\n\u003Cp\u003EDude, do you know how horrible gameplay would be? We would get major hitching and stuttering every time new parts come in and go.\u003C/p\u003E\u003Cp\u003EThe only solution is 64 bit, which will supposedly come with unity 5.\u003C/p\u003E\n"},{"CreatedByName":"sal_vager","CreatedById":16426,"CreatedDateTime":"2014-04-11T18:48:28Z","Content":"\n\u003Cp\u003EMuch of KSP is actually Unity code, so the Squad developers are having to put up with the optimisations or lack thereof in that code, things such as graphics, I/O, sound, even the physics.\u003C/p\u003E\u003Cp\u003EAlso game assets are much larger than they were in the days of the Spectrum or Commodore, though I seem to remember many early home computers used cassette tape, small capacity floppy disks and if you were very lucky, erasable programmable ROMS.\u003C/p\u003E\u003Cp\u003EThis means that they had to hold everything in memory, and aggressive optimisation was a requirement not a luxury.\u003C/p\u003E\u003Cp\u003EThis doesn\u0027t mean that such methods are defunct today, but they are very different, in the past we\u0027d use assembler, low level languages and many tricks to get everything into RAM, though the simplicity of the games back then helped, even Frontier, possibly one of the most ambitious games of the early IBM compatible PC\u0027s came on two floppy disks.\u003C/p\u003E\u003Cp\u003EThese days we\u0027d have to use different methods such as generating game assets on the fly, CPU\u0027s are powerful enough now to allow this, we could load assets from the hard disk when needed but this would be and is slow for many games, which is why we see loading screens in other titles.\u003C/p\u003E\u003Cp\u003EEverything has gotten bigger, this is the real problem, graphics are at higher resolutions, sound at higher bitrates, code is more complex and the hardware that runs it is so powerful that old school optimisations aren\u0027t needed as much.\u003C/p\u003E\n"},{"CreatedByName":"Kasuha","CreatedById":81781,"CreatedDateTime":"2014-04-11T18:51:08Z","Content":"\n\u003Cp\u003EMemory mapped files are feature which allows a 32-bit program to allocate/access way more storage than what fits into 32 bits address. If the system has enough RAM, it can even hold these files in file cache, enabling reasonably fast access to data stored this way. The problem is, it is a lot of work to do it well and if there is promise that Unity will become 64-bit eventually, it may be not worth the effort.\u003C/p\u003E\n"},{"CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-11T18:54:31Z","Content":"\n\u003Cp\u003EParts would only change in memory in the Design section of the game. In that particular area the slowest part of the computer is the user.\u003C/p\u003E\u003Cp\u003EIn space all the parts for a ship would be in memory from launch and until such parts were no longer required in memory.\u003C/p\u003E\u003Cp\u003EThere would be no difference to the amount of hitching and stuttering than there is right now. In fact the opposite might well be true.\u003C/p\u003E\u003Cp\u003EThere is no such promise and memory swapping would solve the problem now.\u003C/p\u003E\n"},{"CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-11T19:12:23Z","Content":"\n\u003Cp\u003EOnce the hard disk was in use, memory swapping came to the fore. Random access filing.\u003C/p\u003E\u003Cp\u003EAs for loading screens that wouldn\u0027t be a problem as parts would be loaded on a click by click basis and the user would barely be aware of the loading process.\u003C/p\u003E\u003Cp\u003EI spent a lot of my time on computers a little bigger than the Spectrum. Such as the Kray xmp. We still used memory swapping in many applications.\u003C/p\u003E\u003Cp\u003EFiles are bigger. Storage is bigger computers are faster. It all evens out in the end.\u003C/p\u003E\n"},{"CreatedByName":"Nuke","CreatedById":10883,"CreatedDateTime":"2014-04-11T19:16:45Z","Content":"\n\u003Cp\u003Eyou could probibly stream in and out the higher resolution mip levels based on texture usage (preferably in another thread). after all textures are the lions share of memory usage, the rest of the data is negligible. you do have to keep everything in memory, so if you suddenly need to draw something, you can without needing to wait. but you dont need to keep it all in memory, just what you need when you have an unexpected need to draw something.\u003C/p\u003E\u003Cp\u003Efor example your ship might only use a tiny fraction of the parts available to you. so you can reduce the maps for those unused parts down to a really low mip level, like 64x64 so that you have memory for other tasks. now lets say you rendezvous with another ship with completely different set of parts. you dont have to wait for the engine to load any textures, just use the low res textures instead, and load the high res versions during approach, and once loaded you can start drawing those textures in full detail (which in most cases is going to be while the ship is still smaller than the target box) without a hickup while this happens.\u003C/p\u003E\n"},{"CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-11T19:20:42Z","Content":"\n\u003Cp\u003EOh , by the way... \u0022Kray\u0022 with a K was a pet name. Sometimes we called it the Kraken. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003EIt only had 16 megs of memory but it was effectively 32 bit.\u003C/p\u003E\n"},{"CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-11T19:24:26Z","Content":"\n\u003Cp\u003EYou clearly either didn\u0027t read what I wrote or didn\u0027t understand it.\u003C/p\u003E\n"},{"CreatedByName":"plausse","CreatedById":64331,"CreatedDateTime":"2014-04-11T19:28:36Z","Content":"\n\u003Cp\u003EMy understanding of programming is limited. So am my walking skills, but my stumbling on the other hand... Is impeccable. So I happen to stumble across this:\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/threads/73236-WIP-Loading-textures-only-as-required\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://forum.kerbalspaceprogram.com/threads/73236-WIP-Loading-textures-only-as-required\u003C/a\u003E\u003C/p\u003E\n"},{"CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-11T19:39:25Z","Content":"\n\u003Cp\u003EThat\u0027s on the right track. But imagine if you will, using for example the B9 Mod or KW or many others with lots of parts.\u003C/p\u003E\u003Cp\u003EHave you ever played a game and used ALL of the parts from a pack so that somewhere in kerbal space there was an instance of one of those parts?\u003C/p\u003E\u003Cp\u003EDo you cherry pick parts from mods because of how much memory the parts that you will never or hardly use will take up?\u003C/p\u003E\u003Cp\u003EUsing the system I have in mind. Every part made will be accessible. Of course it will still be possible to use up all of the available memory by building lots of part intensive ships but you will have had so much more fun by the time that happens.\u003C/p\u003E\n"},{"CreatedByName":"Nuke","CreatedById":10883,"CreatedDateTime":"2014-04-11T20:48:03Z","Content":"\n\u003Cp\u003Eorders of magnitude.\u003C/p\u003E\u003Cp\u003Ecfgs (a few k)\u003C/p\u003E\u003Cp\u003Emodels (tens to hundreds of k)\u003C/p\u003E\u003Cp\u003Etextures (a few megs)\u003C/p\u003E\u003Cp\u003Ething about textures is you can down sample them fairly quickly (or preoptimize them in a compressed format with pre-generated mip maps but i wont go there for simplicity, thats another discussion entirely). the formula for texture memory usage is w*h*bpp. for technical reasons power of 2 textures are preferred. 24bpp is common for 3 channel uncompressed bitmaps (dxt1 can do 4bpp, but again thats a different discussion). a 24-bit 1024^2 texture has mip levels of the following sizes:\u003C/p\u003E\u003Cp\u003E1024 - 3072k\u003C/p\u003E\u003Cp\u003E512 - 768k\u003C/p\u003E\u003Cp\u003E256 - 192k\u003C/p\u003E\u003Cp\u003E128 - 48k\u003C/p\u003E\u003Cp\u003E64 - 12k\u003C/p\u003E\u003Cp\u003E32 - 3k\u003C/p\u003E\u003Cp\u003E...\u003C/p\u003E\u003Cp\u003Eas you can see just dropping a couple mip levels shaves a lot off of your texture size. so if the textures to all your unused parts dropped down to the 32^2 level, you free up a lot of memory. if you track your texture usage stats internally, load higher resolution versions of textures that are used a lot, unload high resolution content that is not used at all. since texture usage changes based on gameplay, you need to keep on the ball to optimise texture quality vs usage while meeting a memory usage target. you can do this in another thread for best results. \u003C/p\u003E\u003Cp\u003Etextures are usually passed by reference, because there is too much data to move around. thing about references, they can be changed quickly. so you can load new data-\u0026gt;change the reference-\u0026gt;unload old data. to do this on another thread you just need spin locks on those references, so you can only change them when they aren\u0027t being used (if they are buffer em up and try again on the next loop of the texture management thread).\u003C/p\u003E\n"},{"CreatedByName":"Daveroski","CreatedById":93896,"CreatedDateTime":"2014-04-12T09:06:48Z","Content":"\n\u003Cp\u003EUsed in conjunction with memory swapping parts in used in the universe, I can see how this would enable the user to have considerably more unique parts available for use in the universe than memory swapping could alone.\u003C/p\u003E\u003Cp\u003EAs a standalone feature, it would greatly increase the number of parts available in the universe at one time. But you would still have possibly many hundreds of parts in memory that are not being used anywhere in the universe at all.\u003C/p\u003E\u003Cp\u003EHaving to access the drive while in an active scene in the universe is something we would strive to avoid. Loading textures for a part-heavy scene in the middle of a maneuver would likely cause an unwanted jerk in the scene as the larger texture files load.\u003C/p\u003E\n"},{"CreatedByName":"Nuke","CreatedById":10883,"CreatedDateTime":"2014-04-12T09:54:24Z","Content":"\n\u003Cp\u003Ethats why you do it on a different thread. if you did it on the same thread you would need to spend a lot of time waiting for data. do it right and the game wont even know that there is another thread moving pixels around. you might get some bus contention on the pci-e interface, since textures being streamed in need to be moved to the video card pretty quickly. the best time to do this is while physics is being handled, when rendering is not being done pci-e traffic should be virtually non-existant. whenever you have a race condition the rule of thumb would be the main thread goes first. the texture loader doesn\u0027t need to operate in near real time like the main thread.\u003C/p\u003E\u003Cp\u003Ethe other big rule is that you must always have something to draw when something unexpected happens. last thing you want is to have to load a gig of textures when two spacecraft with different sets of parts meet. so a bare minimum of data needs to stay in memory so that the object can be drawn when it needs to. higher definition textures can load over the course of several frames, which is a blink of the eye for the player. but you can still draw with the low res data until that happens. that way you never have to wait for the hard drive (in the main thread).\u003C/p\u003E\u003Cp\u003Eas for the memory cost: most squad models are under 100k and a 64^2 (a good minimum) texture would be 12k. thats certainly much less compared to the 512^2 textures @ 768k by themselves (times hundreds of parts). you are not going to save all the memory, but you stand to reduce your memory usage a lot.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-04-12T10:11:19Z\u0022 title=\u002204/12/2014 10:11  AM\u0022 data-short=\u002210 yr\u0022\u003EApril 12, 2014\u003C/time\u003E by Nuke\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"John FX","CreatedById":59415,"CreatedDateTime":"2014-04-12T18:55:59Z","Content":"\n\u003Cp\u003EIt could work the way Mun does now. You get closer to Mun in warp and come out of warp at periapsis and while rendering, Mun is procedurally generated until it gets to full beauty.\u003C/p\u003E\u003Cp\u003EDo something like that with textures so you don\u0060t get the big, system stopping texture loading session. Maybe a tiny placeholder texture is loaded first quickly so there is \u0060something to render\u0060 then the game engine carries on, the player plays the game, and the rest of the textures are loaded in the background. The tiny placeholders could even be used if lack of memory is about to cause a crash...\u003C/p\u003E\u003Cp\u003EEDIT : It would be nice for something like that to happen now. A prediction that an object will be closer than 2.5km in a few real world seconds triggers a preload of everything that will be needed when the craft has to be rendered and physics applied in a way that does not impact performance any more than rendering the object. Obviously the player could cause this to not happen but that will be the less common situation by a few orders and you could just unload.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-04-12T19:00:26Z\u0022 title=\u002204/12/2014 07:00  PM\u0022 data-short=\u002210 yr\u0022\u003EApril 12, 2014\u003C/time\u003E by John FX\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Slouch","CreatedById":97348,"CreatedDateTime":"2014-04-14T12:07:34Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Daveroski\u0022 data-cite=\u0022Daveroski\u0022\u003E\u003Cdiv\u003EOf course it will still be possible to use up all of the available memory by building lots of part intensive ships but you will have had so much more fun by the time that happens.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003ENow you\u0027ve handed memory management to the user. One click too many and their game crashes.\u003C/p\u003E\u003Cp\u003EIt\u0027s one thing to expect a user to know: Too many mods -\u0026gt; Game doesn\u0027t work.\u003C/p\u003E\u003Cp\u003EIts another expect them to know: Too many mods -\u0026gt; Game doesn\u0027t work \u003Cem\u003Eif\u003C/em\u003E I select an arbitrary set of parts. I.E *add part*, *add part*, *add part*, *add part*, *\u003Cstrong\u003ECrash\u003C/strong\u003E* \u003C/p\u003E\u003Cp\u003EOR \u003C/p\u003E\u003Cp\u003E*add part*, *add part*, *add part*, *add part*,*add part*, *add part*, *add part*, *add part*,*add part*, *add part*, *add part*, *add part*, *\u003Cstrong\u003ECrash\u003C/strong\u003E*.\u003C/p\u003E\u003Cp\u003EThe unless the user works out which mods they\u0027re currently using and the memory requirements of each of those mods is they won\u0027t know when their game will fail.\u003C/p\u003E\u003Cp\u003EAlso on the fly memory management is low level and a ball-ache. It\u0027s likely to cause plenty of bugs and shift error prevention to the user at run time.\u003C/p\u003E\n"},{"CreatedByName":"John FX","CreatedById":59415,"CreatedDateTime":"2014-04-14T12:35:20Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Slouch\u0022 data-cite=\u0022Slouch\u0022\u003E\u003Cdiv\u003ENow you\u0027ve handed memory management to the user. One click too many and their game crashes.\u003Cp\u003EIt\u0027s one thing to expect a user to know: Too many mods -\u0026gt; Game doesn\u0027t work.\u003C/p\u003E\u003Cp\u003EIts another expect them to know: Too many mods -\u0026gt; Game doesn\u0027t work \u003Cem\u003Eif\u003C/em\u003E I select an arbitrary set of parts. I.E *add part*, *add part*, *add part*, *add part*, *\u003Cstrong\u003ECrash\u003C/strong\u003E* \u003C/p\u003E\u003Cp\u003EOR \u003C/p\u003E\u003Cp\u003E*add part*, *add part*, *add part*, *add part*,*add part*, *add part*, *add part*, *add part*,*add part*, *add part*, *add part*, *add part*, *\u003Cstrong\u003ECrash\u003C/strong\u003E*.\u003C/p\u003E\u003Cp\u003EThe unless the user works out which mods they\u0027re currently using and the memory requirements of each of those mods is they won\u0027t know when their game will fail.\u003C/p\u003E\u003Cp\u003EAlso on the fly memory management is low level and a ball-ache. It\u0027s likely to cause plenty of bugs and shift error prevention to the user at run time.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EWhich is exactly why I suggested small fast placeholder textures which are only replaced by larger ones if there is enough RAM, avoiding making the user handle memory management. If they want too many parts and textures the quality of the textures is adjusted to match the available memory. Texture swapping is much easier than low level memory management and let\u0060s face it, textures are the biggest memory hog AFAIK.\u003C/p\u003E\u003Cp\u003EThen your available memory is not a fixed amount of parts or textures.\u003C/p\u003E\n"},{"CreatedByName":"Guest","CreatedById":-1,"CreatedDateTime":"2014-04-14T12:35:46Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Slouch\u0022 data-cite=\u0022Slouch\u0022\u003E\u003Cdiv\u003E\u003Cp\u003EThe unless the user works out which mods they\u0027re currently using and the memory requirements of each of those mods is they won\u0027t know when their game will fail.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EHow is this different from what we have now? Someone posts \u0022 Game crashes on startup.\u0022 almost every single day.\u003C/p\u003E\n"},{"CreatedByName":"Slouch","CreatedById":97348,"CreatedDateTime":"2014-04-15T08:36:42Z","Content":"\n\u003Cp\u003EThe difference is the game \u003Cstrong\u003Ewill\u003C/strong\u003E crash if too many mods are installed and the game \u003Cstrong\u003Emay\u003C/strong\u003E crash (on an arbitrary click).\u003C/p\u003E\u003Cp\u003E@JohnFX Texture management sounds better but swapping out textures biased on available RAM sounds like it could lead to plenty of errors down the line. The devs are great and all, but they are only human (AFAIK). Also how would texture swapping work if you played on the low graphics settings? \u003C/p\u003E\u003Cp\u003EAlthough if I saw an example of it being done well elsewhere then that sounds awesome.\u003C/p\u003E\n"}]}