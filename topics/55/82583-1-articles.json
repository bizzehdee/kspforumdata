{"TopicId":82583,"ForumId":55,"TopicTitle":"QUESTION: Reference Frame dev-question (KSP krakensbane approach for high velocities)","CreatedByName":"JoergZdarsky","CreatedById":106276,"CreatedDateTime":"2014-08-23T08:53:03Z","PageNum":1,"Articles":[{"CreatedByName":"JoergZdarsky","CreatedById":106276,"CreatedDateTime":"2014-08-23T08:53:03Z","Content":"\n\u003Cp\u003EHi,\u003C/p\u003E\u003Cp\u003EI have a question about the implementation of the reference frame in KSP (the krakensbane approach for high velocities). \u003C/p\u003E\u003Cp\u003EThere is a blog entry by HarevesteR where my question would have fi to (altough its an older entry), anyway somehow I am not able to add comments there.\u003C/p\u003E\u003Cp\u003E\u003Ca href=\u0022https://forum.kerbalspaceprogram.com/entries/12-Krakensbane\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://forum.kerbalspaceprogram.com/entries/12-Krakensbane\u003C/a\u003E\u003C/p\u003E\u003Cp\u003ESo I hope to find an anser here.\u003C/p\u003E\u003Cp\u003EI am implementing a space game in Unity3D (just for the fun/hobby, spacegame using \u0022real\u0022 distances, procedural planets (still a long road to go) and oculus rift support). I of course meet the same issues like in KSP,\u003C/p\u003E\u003Cp\u003Etherefor I also implemented a floating origin approach for the camera position to get rid of the floating point precision issue which works fine. After adding a number of asteroids in a believable distance and starting to fly by, I noticed a need another solution for velocities, as the common speeds for the unity physics engine are not enough for universe distances. So I looked at KSP presentation at Unite 2013 trying to understand how they did it. \u003C/p\u003E\u003Cp\u003EBasically I think I understood the approach. If the ridigbody where the camera is applied to (so basically the spaceship) reaches a certain speed, the velocity vector3 is copied to a, say, \u0022referenceframe\u0022 script (which is similar to the floating origin script) with a separate vector3 velocity value. At the same time the velocity is copied, the velocity of the ridigbody (spaceship) is set to zero again. This separate vector3 value is used to, when other than (0,0,0), reposition all objects around the spaceship (which has now zero velocity and is \u0022not moving\u0022) each frame. So similar to floating origin, just for velocities.\u003C/p\u003E\u003Cp\u003EThis works, however you notice some stuttering when the script moves the objects. So I wonder if this is exactly KSPs approach or if they did something different?? Hopefully anyone knows.\u003C/p\u003E\u003Cp\u003EBelow is my script. One optimization might be to group the asteroids into one gameobject so that not 400 asteroid gameobjects have to be moved separately by the script, but only one gameobject. Hopefully this increases performance, however any other hint, or how KSP did this, would be very much appreciated!\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E// ReferenceFrameBylayer.cs\u003Cbr\u003E// Written by Joerg Zdarsky\u003Cbr\u003E// 23 August 2014\u003Cbr\u003Eusing UnityEngine;\u003Cbr\u003Eusing System.Collections;\u003Cbr\u003E\u003Cbr\u003E/* Reference Frame Script\u003Cbr\u003E * Contents\u003Cbr\u003E * 1 Description\u003Cbr\u003E * 2 Usage\u003Cbr\u003E * 3 Notes\u003Cbr\u003E * 4 C# - ReferenceFrameByLayer.cs\u003Cbr\u003E * Description\u003Cbr\u003E * This script translates all objects in the world to keep objects moving around an object that has\u003Cbr\u003E * velocity zero. Similar approach to floating origin, just for velocities\u003Cbr\u003E * Usage\u003Cbr\u003E * Attach this script to the gameobject that moves around \u0027threshold\u0027 determines the distance at which mass object translation occurs, \u003Cbr\u003E * this is not a light-weight operation so less frequent movement is better. \u003Cbr\u003E * Notes\u003Cbr\u003E * Make sure your other camera controls are in Update() and not LateUpdate() otherwise they could clash.\u003Cbr\u003E */\u003Cbr\u003E[RequireComponent(typeof(GameObject))]\u003Cbr\u003Epublic class ReferenceFrameByLayer : MonoBehaviour\u003Cbr\u003E{\u003Cbr\u003E\tpublic float threshold = 27777.78f; // =100.000km/h, treshhold is meters per second (as provided by rigidbody.velocity.magnitude)\u003Cbr\u003E\tpublic Vector3 referenceFrameVelocity = new Vector3(0,0,0);\u003Cbr\u003E\tpublic string layer;\u003Cbr\u003E\tpublic GameObject parentGameObject;\u003Cbr\u003E\u003Cbr\u003E    void LateUpdate()\u003Cbr\u003E    {\u003Cbr\u003E        Vector3 gameObjectVelocity = gameObject.rigidbody.velocity;\u003Cbr\u003E\t\tfloat gameObjectMagnitude = gameObjectVelocity.magnitude;\u003Cbr\u003E\t\tVector3 gameObjectAbsoluteVelocity = gameObjectVelocity \u002B referenceFrameVelocity;\u003Cbr\u003E\t\tfloat gameObjectAbsoluteMagnitude = gameObjectAbsoluteVelocity.magnitude;\u003Cbr\u003E\u003Cbr\u003E\t\t// Check if velocity needs to be added to reference framce\u003Cbr\u003E\t\tif (gameObjectMagnitude \u0026gt; threshold) {\u003Cbr\u003E\t\t\tthis.referenceFrameVelocity \u002B= gameObjectVelocity;\u003Cbr\u003E\t\t\tgameObject.rigidbody.velocity = new Vector3(0,0,0);\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\t// Check if velocity needs to be returned to the gameobject\u003Cbr\u003E\t\telse if (gameObjectAbsoluteMagnitude \u0026lt; threshold \u0026amp;\u0026amp; referenceFrameVelocity.magnitude \u0026gt;= threshold) {\u003Cbr\u003E\t\t\tgameObject.rigidbody.velocity \u002B= this.referenceFrameVelocity;\u003Cbr\u003E\t\t\tthis.referenceFrameVelocity = new Vector3(0,0,0);\u003Cbr\u003E\t\t}\u003Cbr\u003E\u003Cbr\u003E                // Moves objects (not-light-weight)\u003Cbr\u003E\t\tif (referenceFrameVelocity != new Vector3 (0, 0, 0)) {\u003Cbr\u003E\t\t\tObject[] objects = FindObjectsOfType(typeof(Transform));\u003Cbr\u003E\t\t\tforeach(Object o in objects)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tTransform t = (Transform)o;\u003Cbr\u003E\u003Cbr\u003E\t\t\t\tif (t.gameObject.layer == LayerMask.NameToLayer(layer))\u003Cbr\u003E\t\t\t\t{\u003Cbr\u003E\t\t\t\t\tt.position -= this.referenceFrameVelocity*Time.deltaTime;\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t}\u003Cbr\u003E\u003Cbr\u003E\t\t\tobjects = FindObjectsOfType(typeof(ParticleEmitter));\u003Cbr\u003E\t\t\tforeach (Object o in objects)\u003Cbr\u003E\t\t\t{\u003Cbr\u003E\t\t\t\tParticleEmitter pe = (ParticleEmitter)o;\u003Cbr\u003E\t\t\t\tParticle[] emitterParticles = pe.particles;\u003Cbr\u003E\t\t\t\tfor(int i = 0; i \u0026lt; emitterParticles.Length; \u002B\u002Bi)\u003Cbr\u003E\t\t\t\t{\u003Cbr\u003E\t\t\t\t\temitterParticles[i].position -= this.referenceFrameVelocity;\u003Cbr\u003E\t\t\t\t}\u003Cbr\u003E\t\t\t\tpe.particles = emitterParticles;\u003Cbr\u003E\t\t\t}\u003Cbr\u003E    \t}\u003Cbr\u003E\t}\u003Cbr\u003E}\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"}]}