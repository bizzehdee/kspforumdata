{"TopicId":154554,"ForumId":29,"TopicTitle":"[ANSWERED] Detecting Animation duration","CreatedByName":"Warezcrawler","CreatedById":145377,"CreatedDateTime":"2017-01-05T21:00:16Z","PageNum":1,"Articles":[{"CreatedByName":"Warezcrawler","CreatedById":145377,"CreatedDateTime":"2017-01-05T21:00:16Z","Content":"\n\u003Cp\u003E\nI created a MultiModeConverter module, which enables switching converter setup instead of having multiple converters or multiple converter module in a single converter that can run simultaneously.\n\u003C/p\u003E\n\u003Cp\u003E\nNow I\u0027ve run into an issue. The module seems to work just fine most of the time, but I ran into an issue when the converter has the \u0022ModuleAnimationGroup\u0022. I cloned and modified the Karbonite \u0022KA-2500 Particle Collector\u0022, which has this animation, and each time it is activated, it automatically activates all converters at the same time....\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003E\tMODULE\n\t{\n\t\tname = ModuleAnimationGroup\n\t\tdeployAnimationName = Deploy\n\t\tactiveAnimationName = \n\t\tmoduleType = Collector\n\t}\u003C/span\u003E\u003C/pre\u003E\n\u003Cdiv class=\u0022ipsSpoiler\u0022 data-ipsspoiler=\u0022\u0022\u003E\n\u003Cdiv class=\u0022ipsSpoiler_header\u0022\u003E\n\u003Cspan\u003ESpoiler\u003C/span\u003E\n\u003C/div\u003E\n\u003Cdiv class=\u0022ipsSpoiler_contents\u0022\u003E\n\u003Cp\u003E\nPART:NEEDS[UmbraSpaceIndustries]\u003Cbr\u003E\n{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// --- general parameters ---\u003Cbr\u003E\n\u00A0\u00A0 \u00A0name = GT_ParticleCollector_250\u003Cbr\u003E\n\u00A0\u00A0 \u00A0module = Part\u003Cbr\u003E\n\u00A0\u00A0 \u00A0author = Warezcrawler\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// --- asset parameters ---\u003Cbr\u003E\n\u00A0\u00A0 \u00A0MODEL\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0model = UmbraSpaceIndustries/Karbonite/Assets/RamScoop\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0scale = 1.07,1.07,1.07\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0rescaleFactor = 1\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// --- node definitions ---\u003Cbr\u003E\n\u00A0\u00A0 \u00A0node_stack_bottom = 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 2\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// --- editor parameters ---\u003Cbr\u003E\n\u00A0\u00A0 \u00A0TechRequired = fuelSystems\u003Cbr\u003E\n\u00A0\u00A0 \u00A0entryCost = 16000\u003Cbr\u003E\n\u00A0\u00A0 \u00A0cost = 150000\u003Cbr\u003E\n\u00A0\u00A0 \u00A0category = Utility\u003Cbr\u003E\n\u00A0\u00A0 \u00A0subcategory = 0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0title = GT Particle Collector 2.5m\u003Cbr\u003E\n\u00A0\u00A0 \u00A0manufacturer = Guybrush Threepwood Industries\u003Cbr\u003E\n\u00A0\u00A0 \u00A0description = After repeatedly having to clear all kinds of gunk out of this air intake, our engineers modified it\u0027s design to selectively filter out airborne Karbonite particles. \u00A0This version will work on the edge of planetary atmospheres.\u003Cbr\u003E\n\u00A0\u00A0 \u00A0// attachment rules: stack, srfAttach, allowStack, allowSrfAttach, allowCollision\u003Cbr\u003E\n\u00A0\u00A0 \u00A0attachRules = 1,0,0,0,0\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\u00A0 \u00A0// --- standard part parameters ---\u003Cbr\u003E\n\u00A0\u00A0 \u00A0mass = 1\u003Cbr\u003E\n\u00A0\u00A0 \u00A0dragModelType = default\u003Cbr\u003E\n\u00A0\u00A0 \u00A0maximum_drag = 0.2\u003Cbr\u003E\n\u00A0\u00A0 \u00A0minimum_drag = 0.3\u003Cbr\u003E\n\u00A0\u00A0 \u00A0angularDrag = 2\u003Cbr\u003E\n\u00A0\u00A0 \u00A0crashTolerance = 6\u003Cbr\u003E\n\u00A0\u00A0 \u00A0breakingForce = 250\u003Cbr\u003E\n\u00A0\u00A0 \u00A0breakingTorque = 250\u003Cbr\u003E\n\u00A0\u00A0 \u00A0maxTemp = 2900\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\u003Cstrong\u003E\u00A0\u00A0 \u00A0MODULE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0name = GTI_MultiModeConverter\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0availableInFlight = true\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0availableInEditor = true\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0useModuleAnimationGroup = true\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003C/strong\u003E\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0MODULE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 name = ModuleResourceConverter\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 tag = Karbonite\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 ConverterName = Karbonite\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 StartActionName = Start Karbonite Collector\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 StopActionName = Stop Karbonite Collector\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 INPUT_RESOURCE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ResourceName = ElectricCharge\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0Ratio = 80\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 OUTPUT_RESOURCE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ResourceName = Karbonite\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0Ratio = 0.8\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DumpExcess = false\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0MODULE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 name = ModuleResourceConverter\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 tag = DarkGoo\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 ConverterName = Dark Goo\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 StartActionName = Start Dark Goo Collector\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 StopActionName = Stop Dark Goo Collector\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 INPUT_RESOURCE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ResourceName = ElectricCharge\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0Ratio = 100\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 OUTPUT_RESOURCE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ResourceName = DarkGoo\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0Ratio = 0.001\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DumpExcess = false\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0MODULE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 name = ModuleResourceConverter\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 tag = Dust\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 ConverterName = Dust\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 StartActionName = Start Dust Collector\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 StopActionName = Stop Dust Collector\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 INPUT_RESOURCE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ResourceName = ElectricCharge\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0Ratio = 10\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 OUTPUT_RESOURCE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 {\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0ResourceName = Dust\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0Ratio = 0.1\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0DumpExcess = false\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0 }\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u003Cbr\u003E\u003Cstrong\u003E\u00A0\u00A0 \u00A0MODULE\u003Cbr\u003E\n\u00A0\u00A0 \u00A0{\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0name = ModuleAnimationGroup\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0deployAnimationName = Deploy\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0activeAnimationName =\u00A0\u003Cbr\u003E\n\u00A0\u00A0 \u00A0\u00A0\u00A0 \u00A0moduleType = Collector\u003Cbr\u003E\n\u00A0\u00A0 \u00A0}\u003C/strong\u003E\u003Cbr\u003E\n}\n\u003C/p\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cp\u003E\nSo my questions are.\n\u003C/p\u003E\n\u003Col\u003E\u003Cli\u003E\nHow do I in my plugin disable the behavior of \u0022activating all the converters\u0022 when deploying the part - if this is at all possible....\n\u003C/li\u003E\n\u003Cli\u003E\nalternatively how do I detect if the animation is finished, then I can invoke my oversteering after that, and regain control.\n\u003C/li\u003E\n\u003Cli\u003E\nalternatively how do I detect how long the animation takes (which seem to be the basis of invoking this change), then I can invoke my oversteering after that, and regain control.\n\u003C/li\u003E\n\u003C/ol\u003E\u003Cp\u003E\nalternative 2\u002B3 are not optimal, but acceptable. Maybe there is an alternative I haven\u0027t considered yet?\n\u003C/p\u003E\n\u003Cp\u003E\nCurrently I have hardcoded my plugin to update 2 sec after the module is activate (hence after animation finishes), it works, but is not pretty.\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222017-01-06T20:24:22Z\u0022 title=\u002201/06/2017 08:24  PM\u0022 data-short=\u00227 yr\u0022\u003EJanuary 6, 2017\u003C/time\u003E by Warezcrawler\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Diazo","CreatedById":81549,"CreatedDateTime":"2017-01-05T21:20:30Z","Content":"\n\u003Cp\u003E\nThis is all going to revolve around the Animation Time value. If there is also an Animate State enum like ModuleDeployableSolarPanel.deployState, that would probably also work.\n\u003C/p\u003E\n\u003Cp\u003E\nWhen ModuleAnimateGeneric.animTime =0f, animation is at it\u0027s \u0022beginning\u0022 state, so in this case the converters are fully retracted.\n\u003C/p\u003E\n\u003Cp\u003E\nWhen it\u0027s 1f, they are fully deployed.\n\u003C/p\u003E\n\u003Cp\u003E\nAny other value between those two means the converter is actively deploying/retracting and the animation is playing.\n\u003C/p\u003E\n\u003Cp\u003E\nSo:\n\u003C/p\u003E\n\u003Cp\u003E\n1) Check .animTime ==0f or 1f, otherwise lock your code out.\n\u003C/p\u003E\n\u003Cp\u003E\n2) .animTime = 1f, animation finished playing.\n\u003C/p\u003E\n\u003Cp\u003E\n3) No clue, never looked at that. Not sure it\u0027s available as all ModuleAnimateGeneric does is tell the animation made in Blender to stop/start/reverse, I don\u0027t know how much information of the animation itself it exposes.\n\u003C/p\u003E\n\u003Cp\u003E\nD.\n\u003C/p\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222017-01-05T21:20:59Z\u0022 title=\u002201/05/2017 09:20  PM\u0022 data-short=\u00227 yr\u0022\u003EJanuary 5, 2017\u003C/time\u003E by Diazo\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"DMagic","CreatedById":57416,"CreatedDateTime":"2017-01-05T21:49:26Z","Content":"\n\u003Cp\u003E\nYou need to find the actual Unity Animation component being played by\u00A0the ModuleAnimationGroup. And if it isn\u0027t accessible you should be able to manually retrieve it from the part using animation name specified:\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003EAnimation anim = part.FindModelAnimators(\u0022Animation Name\u0022)[0];\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\n\u00A0\n\u003C/p\u003E\n\u003Cp\u003E\nThen you can use all of the properties of that animation (length, normalized time, isplaying, etc...) to figure out what\u0027s going on.\n\u003C/p\u003E\n\u003Cp\u003E\nAs for disabling ModuleAnimationGroup\u0027s activating of things when it finishes the animation, that might not be possible, since that is one of the primary purposes of the module (what it\u0027s actually doing is activating all of the Part Modules on that same part that implement\u00A0IAnimatedModule).\n\u003C/p\u003E\n"},{"CreatedByName":"Warezcrawler","CreatedById":145377,"CreatedDateTime":"2017-01-06T20:24:05Z","Content":"\n\u003Cp\u003E\n\u003Ca contenteditable=\u0022false\u0022 data-ipshover=\u0022\u0022 data-ipshover-target=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/81549-diazo/\u0026amp;do=hovercard\u0022 data-mentionid=\u002281549\u0022 href=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/81549-diazo/\u0022 rel=\u0022\u0022\u003E@Diazo\u003C/a\u003E\u00A0and \u003Ca contenteditable=\u0022false\u0022 data-ipshover=\u0022\u0022 data-ipshover-target=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/57416-dmagic/\u0026amp;do=hovercard\u0022 data-mentionid=\u002257416\u0022 href=\u0022https://forum.kerbalspaceprogram.com/index.php?/profile/57416-dmagic/\u0022 rel=\u0022\u0022\u003E@DMagic\u003C/a\u003E\u00A0Thanks for your advice! After a lot of messing around I think I got it to work. I ended up going about it like DMagic suggested.\n\u003C/p\u003E\n\u003Cp\u003E\nI anybody out there needs the answer, I\u0027ll try and sum it up.\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003E//Initializing the objects\nMAG = part.FindModuleImplementing\u003C/span\u003E\u003Cspan class=\u0022tag\u0022\u003E\u0026lt;ModuleAnimationGroup\u0026gt;\u003C/span\u003E\u003Cspan class=\u0022pln\u0022\u003E();\t\t\t//Finding the ModuleAnimationGroup\nAnim = part.FindModelAnimator(MAG.deployAnimationName);\t\t\t\t//Finding the Animation\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nthen in my event I use invoke to make sure I check when the animation is finished\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003E//Getting the lenght of the animation. I add 0.1 to get on the other side of the animation.\ntry { AnimLength = Anim.clip.length \u002B 0.1f; } catch { AnimLength = 1f; }\t\t//I\u0027m unsure if it might in some cases not exist, so I use a try statement\n\n//Then I invoke my update of the converter modules when it is expected to be finished\nInvoke(\u0022ModuleAnimationGroupEventInvoke\u0022, AnimLength);\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nI have my invoke call itself until the animation is finished with a very small interval.\n\u003C/p\u003E\n\u003Cpre class=\u0022ipsCode prettyprint lang-html prettyprinted\u0022\u003E\n\u003Cspan class=\u0022pln\u0022\u003E        private void ModuleAnimationGroupEventInvoke()\n        {\n\t\t\t//Here I use the \u0022.isPlaying\u0022 boolean of the animation to check if it is finished, and ready to be updated\n            if (Anim.isPlaying == false)\n            {\n                Debug.Log(\u0022\u0027ModuleAnimationGroupEventInvoke\u0027: not deployed\u0022);\n                updateConverter(silentUpdate: true);\n\n                //reset invoke counter\n                _InvokeCounter = 0;\n            }\n            else\n            {\n                //If no ready, I recall the invoke shortly again until update could be performed\n                if (_InvokeCounter \u0026lt; 60) { Invoke(\u0022ModuleAnimationGroupEventInvoke\u0022, 0.01f); _InvokeCounter\u002B\u002B; } else { _InvokeCounter = 0; }\n            }\n        }\u003C/span\u003E\u003C/pre\u003E\n\u003Cp\u003E\nIn this way I was able to take control over the converter modules, even with the \u0022ModuleAnimationGroup\u0022 module present. It\u0027s not absolutely pretty, but it works. My invoke usually don\u0027t reinvoke so far.\n\u003C/p\u003E\n"}]}