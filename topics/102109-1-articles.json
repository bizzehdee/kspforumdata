{"TopicId":102109,"ForumId":34,"TopicTitle":"[kOS 0.16.2 Script] Nav Tools","CreatedByName":"TDW","CreatedById":120346,"CreatedDateTime":"2015-03-17T00:16:25Z","PageNum":1,"Articles":[{"CreatedByName":"TDW","CreatedById":120346,"CreatedDateTime":"2015-03-17T00:16:25Z","Content":"**kOS Nav Tools**\n\n![uc?export=view\u0026id=0B2X2pcwft9VdS0V1THlXX2FmUkE](https://drive.google.com/uc?export=view\u0026id=0B2X2pcwft9VdS0V1THlXX2FmUkE)\n\n**Download from** [**Github**](https://github.com/TDW89/KOS-nav-tools/releases/tag/v1.1)\n\n[**Licence**](https://github.com/TDW89/KOS-nav-tools/blob/master/LICENSE)\n\n**UPDATE: These scripts are now being maintained as part of the** [**KSLib.**](https://github.com/KSP-KOS/KSLib)\n\nI thought I would release these, I may add to them as time goes on or I need others.\n\nNot only is this not a stand-alone mod, YOU NEED kOS TO RUN THESE,but they are not intended as stand-alone scripts either. They are intended as equations to be called from within other scripts to aid with more complex surface(or near surface) navigation.\n\nAs this stands there are 4 scripts that use great circle equations to give a variety of results.\n\n **What does this do?**\n\n First off these scripts don\u0027t do a lot on their own. They are intended to be a tool/equation set for script writers to call from within their own scripts (although there is nothing stopping you just running them if you want).\n\n These scripts make use of Great Circle equations, which I am about to do a rubbish job of explaining. A Great Circle is the circle created by on the surface of a sphere by any plane that passes through it\u0027s centre. The equator is on example of this as are the lines of longitude around the earth.\n\n For more information google is your friend :-P\n\n This is useful because these circles are the most direct rout between any two points on the surface of a sphere (in this case a planet or moon).\n\n **How to use**\n\n All of these scripts need to be run with their arguments (commented in each script). They each return the variable \u0060result\u0060 and the only other variables they use are declared parameters. This is done to minimise conflicts with other scripts.\n\n Tip: When flying a plane using body:radius\u002Bship:altitude will give you a more accurate result for scripts that ask for a radius.\n\n**Scripts**\n\n\u003E \n\u003E  Similar to an inclined orbit the bearing you are travelling on will change when using great circles. This equation will give you the initial bearing along the great circle path from point 1 to point 2.\n\u003E \n\u003E  Not overly useful when run once but by repeatedly running this with your current position as point 1 you will get a continuously updating bearing along the shortest path to point 2.\n\u003E \n\u003E Declare\n\u003E \n\u003E p1 - point 1\n\u003E \n\u003E p2 - point 2\n\u003E \n\u003E Output\n\u003E \n\u003E  result - the bearing.\n\u003E \n\u003E \n\n\u003E \n\u003E  This will tell you the geo-position of a point along a great circle path given a starting position, distance and initial bearing. It can be used for checking the layout of terrain up ahead using:\n\u003E \n\u003E  \n\u003E \n\u003E RUN gs\\_destination(ship:geoposition,(-1)\\*ship:bearing,1000,body:radius).\n\u003E \n\u003E \n\u003E     \n\u003E \n\u003E \n\u003E \n\u003E \n\u003E  to give you the latlng() position of a point 1km ahead of you and letting you query it for terrain height. So no more crashing into that cliff because you can only track changes in terrain as you pass over it.\n\u003E \n\u003E Declare\n\u003E \n\u003E P1 - starting point\n\u003E \n\u003E b - initial bearing\n\u003E \n\u003E d - distance travelled\n\u003E \n\u003E radius - radius of the sphere you are travelling over (either body:radius or body:radius\u002Bship:altitude).\n\u003E \n\u003E Output\n\u003E \n\u003E result - the point you will end up at (by travelling in a strait line from p1 for d with an initial bearing of ![B)](//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_cool.png)\n\u003E \n\u003E resultLat - the latitude of the point.\n\u003E \n\u003E resultLng - the longitude of the point.\n\u003E \n\u003E \n\n\u003E \n\u003E  kOS lets you query the distance to a latlng() position at the moment but it gives you the separation of the points in 3d space so if you ask for the distance to a point directly opposite you on Kerbin it will give tell you the distance is Kerbins diameter. This will give you the surface distance between 2 points. So will tell you the distance is half Kerbins circumference. This is useful if you want to know how far you will actually have to go and how long it will take you at your current surface speed.\n\u003E \n\u003E  It can also be used between a 2 arbitrary points not just your vessel\u0027s position and another so for lists of way-points you could use something like:\n\u003E \n\u003E  \n\u003E \n\u003E SET current To ship:geoposition.  \n\u003E  SET distance TO 0.  \n\u003E  FOR point IN waypoints {  \n\u003E  RUN gs\\_distance(current,point,body:radius).  \n\u003E  SET distance TO distance \u002B result.  \n\u003E  SET current TO point.  \n\u003E  }.  \n\u003E  PRINT distance.\n\u003E \n\u003E \n\u003E     \n\u003E \n\u003E \n\u003E \n\u003E \n\u003E  to give the distance total distance of your current rout.\n\u003E \n\u003E Declare\n\u003E \n\u003E p1 - point 1\n\u003E \n\u003E p2 - point 2\n\u003E \n\u003E radius - radius of the sphere you are travelling over (either body:radius or body:radius\u002Bship:altitude).\n\u003E \n\u003E Output\n\u003E \n\u003E result - the distance (in meters) between point 1 and 2.\n\u003E \n\u003E \n\n\u003E \n\u003E  Gives you the midpoint between point 1 and 2 along a great circle path. This is not as obviously useful as the others but I needed it for something I am working on so threw it in as well.\n\u003E \n\u003E Declare\n\u003E \n\u003E  p1 - point 1\n\u003E \n\u003E p2 - point 2\n\u003E \n\u003E Output\n\u003E \n\u003E result - mid point (as a geoposition).\n\u003E \n\u003E \n\n\u003E \n\u003E  This is for tweaking geopositions manually. It places an arrow at the declared latlng and then allows you to move it around using action groups. (The action groups are set up with the intention that they are mapped to the number pad).\n\u003E \n\u003E  0 - exits the script.\n\u003E \n\u003E  2 - moves the arrow south.\n\u003E \n\u003E  3 - multiplies the movement by 0.1 (eg m -\u003E cm -\u003E mm).\n\u003E \n\u003E  4 - moves west.\n\u003E \n\u003E  5 - logs the position to a file.\n\u003E \n\u003E  6 - moves east.\n\u003E \n\u003E  8 - moves north.\n\u003E \n\u003E  9 - multiplies the movement by 10 (eg mm -\u003E cm -\u003E m).\n\u003E \n\u003E  NOTE: While changing to map view will increase the size of the arrows. Action groups don\u00C3\u00A2\u00E2\u201A\u00AC\u00E2\u201E\u00A2t work so you cant move it.\n\u003E \n\u003E \n\n\u003E \n\u003E  This gives the slope of a point and its bearing by sampling 4 points around it in a diamond shape.\n\u003E \n\u003E  By declaring a bearing (otherwise just use 0) you can get the components of the slope along that bearing and at right angles to it. Also by declaring the incline as 1 it will give you a bearing up the slope and -1 will give you down the slope.\n\u003E \n\u003E  By combining this with \u0060gs_destination.ks\u0060 it is possible to have the script follow the slope up or down hill to find the flat landing location either at the top of the hill or at the bottom of a gully. (This is not necessarily the closest flat area but it is relatively easy to find by script).\n\u003E \n\u003E Declare\n\u003E \n\u003E p1 - point to sample.\n\u003E \n\u003E bearing - for specifying a direction of travel across point\n\u003E \n\u003E separation - the distance of the sample points from p1.\n\u003E \n\u003E incline - for specifying whether you want the bearing of the uphill(1) slope or the downhill(-1).\n\u003E \n\u003E Output\n\u003E \n\u003E resultSlope - the angle of the slope in degrees (eg 0 is flat 90 is vertical)\n\u003E \n\u003E resultBearing - the bearing up or down the slope (depending on declared incline)\n\u003E \n\u003E resultAproach - the slope in your direction of travel.\n\u003E \n\u003E resultTangent - the slope across your direction of travel (if high could cause you to roll over).\n\u003E \n\u003E \n\n\u003E \n\u003E  This works the same way as \u0060nav_slope_quad.ks\u0060 except that it speeds up the calculation by using 3 points. The one you declared and 2 others 45deg either side of the declared bearing.\n\u003E \n\u003E  This if the other script lags too mutch try this one. It is faster but the centre of the sample area is not the point you gave it but just past it.\n\u003E \n\u003E Declare\n\u003E \n\u003E p1 - point to sample.\n\u003E \n\u003E bearing - for specifying a direction of travel across point\n\u003E \n\u003E separation - the distance of the sample points from p1.\n\u003E \n\u003E incline - for specifying whether you want the bearing of the uphill(1) slope or the downhill(-1).\n\u003E \n\u003E Output\n\u003E \n\u003E resultSlope - the angle of the slope in degrees (eg 0 is flat 90 is vertical)\n\u003E \n\u003E resultBearing - the bearing up or down the slope (depending on declared incline)\n\u003E \n\u003E resultAproach - the slope in your direction of travel.\n\u003E \n\u003E resultTangent - the slope across your direction of travel (if high could cause you to roll over).\n\u003E \n\u003E \n\n\u003E \n\u003E  This was me playing around. It doesn\u00C3\u00A2\u00E2\u201A\u00AC\u00E2\u201E\u00A2t do anything useful automation wise but. It shows the relative height of the terrain in front of you as you fly around.\n\u003E \n\u003E ![uc?export=view\u0026id=0B2X2pcwft9VdQ1N5Q0tNX1JPWTg](https://drive.google.com/uc?export=view\u0026id=0B2X2pcwft9VdQ1N5Q0tNX1JPWTg)\n\u003E \n\u003E \n\n **Creds**\n\n Nivekk for creating kOS and Erendrake and Steve Mading for maintaining and advancing it to where it is today.\n\n I should also like to add that the equations are from this site:\n\n [http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html)\n\n Which contains implementations of these equations in various other languages, and although I haven\u00C3\u00A2\u00E2\u201A\u00AC\u00E2\u201E\u00A2t copied any of the script itself it has been an invaluable resource for the base equations.\n\n**Edited \u003Ctime datetime=\u00222015-08-06T13:49:25Z\u0022 title=\u002208/06/2015 01:49  PM\u0022 data-short=\u00228 yr\u0022\u003EAugust 6, 2015\u003C/time\u003E by TDW**\n  \nScript updates"},{"CreatedByName":"nismobg","CreatedById":83892,"CreatedDateTime":"2015-03-17T00:35:40Z","Content":"\u002B1 for clever terminal !"},{"CreatedByName":"Drew Kerman","CreatedById":103177,"CreatedDateTime":"2015-03-17T02:28:22Z","Content":"this is great, have a plane I\u0027ve been wanting to fly from KSC out to the badlands and it would serve wonderfully to be able to fly that along a great circle route. Will def put this to use to give me a constant bearing along my flight!"},{"CreatedByName":"TDW","CreatedById":120346,"CreatedDateTime":"2015-03-24T00:38:59Z","Content":"Scripts updated.\n\n [h=3]Added[/h] New scripts for slope \u0026 fine tuning geopositions (just encase you want to try and land on the flag pole).\n\n [h=3]Changed[/h] Reconfigured most of the great circle calcs to move repeat calculations to a variable. This means they use more variable names but should run faster. (all added variables are in the format result....)"}]}