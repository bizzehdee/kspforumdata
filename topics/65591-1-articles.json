{"TopicId":65591,"ForumId":29,"TopicTitle":"NaN Orbit when using custom PartModule","CreatedByName":"MrHappyFace","CreatedById":76365,"CreatedDateTime":"2014-03-12T20:43:48Z","PageNum":1,"Articles":[{"CreatedByName":"MrHappyFace","CreatedById":76365,"CreatedDateTime":"2014-03-12T20:43:48Z","Content":"\n\u003Cp\u003EWhenver I try to use a custom PartModule, physics doesnt load and the DebugLog keeps spitting out errors saying that my orbit is NaN.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E\u003Cbr\u003E//KSPFields\u003Cbr\u003E       public class ModuleUFO : PartModule\u003Cbr\u003E       {\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public float GravitationalConstant;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public string resourceName;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public string electricResourceName;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public double kerbalConsuption;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public float maxThrust;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public float translationMaxThrust;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public float afterBurnerThrustMultiplier;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public float afterBurnerResourceMultiplier;\u003Cbr\u003E        [KSPField]\u003Cbr\u003E        public int powerPerAbduction;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        //KSPField GUI crappers\u003Cbr\u003E        [KSPField(guiName = \u0022Hovering: \u0022)]\u003Cbr\u003E        public bool hovering = false;\u003Cbr\u003E        [KSPField(guiName = \u0022After-Burner active: \u0022)]\u003Cbr\u003E        public bool afterBurner = false;\u003Cbr\u003E        [KSPField(guiName = \u0022Flight Mode: \u0022)]\u003Cbr\u003E        public string flightMode = \u0022Surface\u0022;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        //Regular fields\u003Cbr\u003E        LineRenderer deathRenderer = null;\u003Cbr\u003E\u003Cbr\u003E        public override void OnStart(StartState state)\u003Cbr\u003E        {\u003Cbr\u003E            base.OnStart(state);\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            if(part.gameObject.transform.FindChild(\u0022Light\u0022).gameObject.GetComponent\u0026lt;LineRenderer\u0026gt;() != null)\u003Cbr\u003E            {\u003Cbr\u003E                deathRenderer = part.gameObject.transform.FindChild(\u0022Light\u0022).gameObject.AddComponent\u0026lt;LineRenderer\u0026gt;();\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E                deathRenderer = part.gameObject.transform.FindChild(\u0022Light\u0022).gameObject.GetComponent\u0026lt;LineRenderer\u0026gt;();\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            deathRenderer.renderer.enabled = false;\u003Cbr\u003E            maxThrust *= 1000;\u003Cbr\u003E            translationMaxThrust *= 1000;\u003Cbr\u003E        }\u003Cbr\u003E        public override void OnFixedUpdate()\u003Cbr\u003E        {\u003Cbr\u003E            base.OnFixedUpdate();\u003Cbr\u003E\u003Cbr\u003E            float throttle = vessel.ctrlState.mainThrottle;\u003Cbr\u003E            double resourceRequest = kerbalConsuption;\u003Cbr\u003E            Vector3 thrustDirection = new Vector3(0f, 1f, 0f);\u003Cbr\u003E\u003Cbr\u003E            //hovering stuff\u003Cbr\u003E            if(hovering)\u003Cbr\u003E            {\u003Cbr\u003E                float vesselmass = vessel.GetTotalMass();\u003Cbr\u003E                float gravity = (float)vessel.mainBody.GeeASL;\u003Cbr\u003E                float thrust = vesselmass * gravity * GravitationalConstant;\u003Cbr\u003E                float realThrust = Mathf.Clamp(thrust, 0f, maxThrust);\u003Cbr\u003E                throttle = realThrust / maxThrust;\u003Cbr\u003E                resourceRequest *= throttle;\u003Cbr\u003E            }\u003Cbr\u003E            //space mode stuff\u003Cbr\u003E            if(flightMode == \u0022Space\u0022)\u003Cbr\u003E            {\u003Cbr\u003E                thrustDirection = new Vector3(1f, 0f, 0f);\u003Cbr\u003E                resourceRequest *= throttle;\u003Cbr\u003E            }\u003Cbr\u003E            if(flightMode == \u0022Surface\u0022)\u003Cbr\u003E            {\u003Cbr\u003E                var axisX = GameSettings.AXIS_TRANSLATE_X;\u003Cbr\u003E                var axisZ = GameSettings.AXIS_TRANSLATE_Z;\u003Cbr\u003E                var axisY = GameSettings.AXIS_TRANSLATE_Y;\u003Cbr\u003E                float directionX = axisX.GetAxis();\u003Cbr\u003E                float directionZ = axisZ.GetAxis();\u003Cbr\u003E                float directionY = axisY.GetAxis();\u003Cbr\u003E                float multiplier = 1f;\u003Cbr\u003E                float abMultiplier = 1f;\u003Cbr\u003E                if(afterBurner)\u003Cbr\u003E                {\u003Cbr\u003E                    multiplier = afterBurnerThrustMultiplier;\u003Cbr\u003E                    abMultiplier = afterBurnerResourceMultiplier;\u003Cbr\u003E                }\u003Cbr\u003E                resourceRequest \u002B= 0.125 * directionX * kerbalConsuption * abMultiplier;\u003Cbr\u003E                resourceRequest \u002B= 0.125 * directionZ * kerbalConsuption * abMultiplier;\u003Cbr\u003E                resourceRequest \u002B= 0.125 * directionY * kerbalConsuption * abMultiplier;\u003Cbr\u003E                part.rigidbody.AddRelativeForce(new Vector3(directionX * multiplier, directionY, directionZ * multiplier));\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            part.RequestResource(resourceName, resourceRequest * Time.deltaTime);\u003Cbr\u003E            part.RequestResource(electricResourceName, -0.1 * Time.deltaTime);\u003Cbr\u003E            part.rigidbody.AddRelativeForce(thrustDirection * maxThrust * throttle);\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E        [KSPEvent(guiName = \u0022Toggle Afterburner\u0022)]\u003Cbr\u003E        public void ToggleAfterburner()\u003Cbr\u003E        {\u003Cbr\u003E            afterBurner = !afterBurner;\u003Cbr\u003E        }\u003Cbr\u003E        [KSPEvent(guiName = \u0022Toggle Hover\u0022)]\u003Cbr\u003E        public void ToggleHover()\u003Cbr\u003E        {\u003Cbr\u003E            hovering = !hovering;\u003Cbr\u003E        }\u003Cbr\u003E        [KSPEvent(guiName = \u0022Toggle Flight Mode\u0022)]\u003Cbr\u003E        public void ToggleFlightMode()\u003Cbr\u003E        {\u003Cbr\u003E            if(flightMode == \u0022Surface\u0022)\u003Cbr\u003E                flightMode = \u0022Space\u0022;\u003Cbr\u003E            else\u003Cbr\u003E                flightMode = \u0022Surface\u0022;\u003Cbr\u003E        }\u003Cbr\u003E        [KSPEvent(guiName = \u0022Abduct\u0022)]\u003Cbr\u003E        public void Abduct()\u003Cbr\u003E        {\u003Cbr\u003E            LineRenderer deathRenderer = part.gameObject.transform.FindChild(\u0022Light\u0022).gameObject.GetComponent\u0026lt;LineRenderer\u0026gt;();\u003Cbr\u003E            Color abductColor = new Color(0f, 0.859f, 0.27f, 1f);\u003Cbr\u003E            Vector3 AbductPos = part.gameObject.transform.FindChild(\u0022Light\u0022).position;\u003Cbr\u003E            var Objs = Physics.OverlapSphere(AbductPos, 50);\u003Cbr\u003E            KerbalEVA victim = null;\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            foreach(Collider c in Objs)\u003Cbr\u003E            {\u003Cbr\u003E                if(c.gameObject.GetComponent\u0026lt;KerbalEVA\u0026gt;() != null)\u003Cbr\u003E                {\u003Cbr\u003E                    victim = c.gameObject.GetComponent\u0026lt;KerbalEVA\u0026gt;();\u003Cbr\u003E                    break;\u003Cbr\u003E                }\u003Cbr\u003E            }\u003Cbr\u003E            if(victim == null)\u003Cbr\u003E            {\u003Cbr\u003E                ScreenMessages.PostScreenMessage(new ScreenMessage(\u0022No victims found in the vicinity\u0022, 4f, ScreenMessageStyle.UPPER_CENTER), false);\u003Cbr\u003E                return;\u003Cbr\u003E            }\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            part.RequestResource(electricResourceName, (double)powerPerAbduction);\u003Cbr\u003E            deathRenderer.renderer.enabled = true;\u003Cbr\u003E            deathRenderer.SetWidth(6f, 10f);\u003Cbr\u003E            deathRenderer.SetColors(abductColor, abductColor);\u003Cbr\u003E            deathRenderer.SetPosition(0, AbductPos);\u003Cbr\u003E            deathRenderer.SetPosition(1, victim.gameObject.transform.position);\u003Cbr\u003E            Invoke(\u0022killAbductee\u0022, 0.5f);\u003Cbr\u003E            Invoke(\u0022cancelRay\u0022, 0.3f);\u003Cbr\u003E        }\u003Cbr\u003E        public void killAbductee(KerbalEVA victim)\u003Cbr\u003E        {\u003Cbr\u003E            victim.part.explosionPotential = 100;\u003Cbr\u003E            victim.part.explode();\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003E            foreach(var crew in victim.part.protoModuleCrew)\u003Cbr\u003E            {\u003Cbr\u003E                crew.Die();\u003Cbr\u003E                crew.rosterStatus = ProtoCrewMember.RosterStatus.MISSING;\u003Cbr\u003E                crew.StartRespawnPeriod(7200);\u003Cbr\u003E                part.RequestResource(resourceName, -1);\u003Cbr\u003E            }\u003Cbr\u003E        }\u003Cbr\u003E        public void cancelRay()\u003Cbr\u003E        {\u003Cbr\u003E            deathRenderer.renderer.enabled = false;\u003Cbr\u003E        }\u003Cbr\u003E        }\u003Cbr\u003E\u003Cbr\u003E\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_sad.gif\u0022 alt=\u0022:(\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"MOARdV","CreatedById":60950,"CreatedDateTime":"2014-03-12T22:48:42Z","Content":"\n\u003Cp\u003EI don\u0027t know for sure why you\u0027re getting NaN for the orbit, but there are a few things in that code that don\u0027t look right at a casual glance based on this code in isolation (since I don\u0027t know what part you\u0027re attaching the module to, or what\u0027s in the config file):\u003C/p\u003E\u003Cp\u003EYou\u0027re not verifying that the \u0022Light\u0022 transform exists in your part.\u003C/p\u003E\u003Cp\u003EYou are dereferencing a null object in OnStart if the GetComponent call returns null.\u003C/p\u003E\u003Cp\u003EYou don\u0027t have defaults for any of the KSPField values, and you don\u0027t set them anywhere, so they could be 0 for all I know (which can lead to a divide by zero in at least one spot I see).\u003C/p\u003E\u003Cp\u003EIt also looks like you\u0027re querying the deathRenderer in Abduct, even though you notionally got it already in OnStart.\u003C/p\u003E\u003Cp\u003EHave you printed out the values you\u0027re actually adding in part.rigidbody.AddRelativeForce during OnFixedUpdate to see if they\u0027re reasonable?\u003C/p\u003E\n"},{"CreatedByName":"RSF77","CreatedById":88474,"CreatedDateTime":"2014-03-16T02:43:14Z","Content":"\n\u003Cp\u003EI have no idea what the problem is, I just wanted to say that\u0027s hilarious.\u003C/p\u003E\n"},{"CreatedByName":"stupid_chris","CreatedById":62017,"CreatedDateTime":"2014-03-16T19:07:30Z","Content":"\n\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E            if(part.gameObject.transform.FindChild(\u0022Light\u0022).gameObject.GetComponent\u0026lt;LineRenderer\u0026gt;() != null)\u003Cbr\u003E            {\u003Cbr\u003E                deathRenderer = part.gameObject.transform.FindChild(\u0022Light\u0022).gameObject.AddComponent\u0026lt;LineRenderer\u0026gt;();\u003Cbr\u003E            }\u003Cbr\u003E            else\u003Cbr\u003E                deathRenderer = part.gameObject.transform.FindChild(\u0022Light\u0022).gameObject.GetComponent\u0026lt;LineRenderer\u0026gt;();\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003ELets transform that to pseudo code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003E if Part has non null LineRenderer\u003Cbr\u003E    Add LineRenderer to Part\u003Cbr\u003Eelse\u003Cbr\u003E    Get LineRenderer in Part\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI think the problem just became obvious.\u003C/p\u003E\u003Cp\u003EAlso: you don\u0027t need to go through gameObject to get the part transform. this.part.transform.FindChild(\u0022Light\u0022) will do just alright.\u003C/p\u003E\n"}]}