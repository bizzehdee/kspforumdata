{"TopicId":78481,"ForumId":29,"TopicTitle":"Fixing TT\u0026#039;s wheels for 0.24","CreatedByName":"Jakey4150","CreatedById":84226,"CreatedDateTime":"2014-07-19T18:45:00Z","PageNum":1,"Articles":[{"CreatedByName":"Jakey4150","CreatedById":84226,"CreatedDateTime":"2014-07-19T18:45:00Z","Content":"\n\u003Cp\u003ESince 0.19, I have been fixing his wheels and making them work, but since 0.24, they worked once and seems like ksp edited the script and broke it. Has for the part.cfg, its up to date but the plugin is broken I think. Here it is. Anything not correct in this ?? And then, how I convert the .cs into a .dll? (traditional format change)??\u003C/p\u003E\u003Cp\u003EThese are the wheels \u003Ca href=\u0022http://i11.photobucket.com/albums/a180/manmuppet/screenshot62-1.png\u0022 rel=\u0022external nofollow\u0022\u003Ehttp://i11.photobucket.com/albums/a180/manmuppet/screenshot62-1.png\u003C/a\u003E\u003C/p\u003E\u003Cp\u003EThe name of the plugin is TTModularWheel.dll\u003C/p\u003E\u003Cp\u003Eusing System;\u003C/p\u003E\u003Cp\u003Eusing System.Collections.Generic;\u003C/p\u003E\u003Cp\u003Eusing System.Linq;\u003C/p\u003E\u003Cp\u003Eusing System.Text;\u003C/p\u003E\u003Cp\u003Eusing UnityEngine;\u003C/p\u003E\u003Cp\u003Epublic class TTModularWheel : PartModule\u003C/p\u003E\u003Cp\u003E{\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float steerFalloff = 0.25f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float maxMotorTorque = 15f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float maxBrakeTorque = 15f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float rollingResistance = 0.5f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float maxSteer = 45f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public Vector3 wheelRotationAxis = new Vector3 (0,0,1);\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float rotationFactor = (6/180);\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float contactDisplace = 0.075f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float brakepercentadd = 0.03f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float brakepercentsub = 0.12f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float slidefactor = 10f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float slidepower = 0.9f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float velslidefactor = 0.05f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float smokestart = 5f;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public bool isDeployable = false;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public string retractAnimation = \u0022Retract\u0022;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public float spring = 0f;\u003C/p\u003E\u003Cp\u003E [KSPField(isPersistant = true)]\u003C/p\u003E\u003Cp\u003E bool isDeployed = true;\u003C/p\u003E\u003Cp\u003E bool isActive = false;\u003C/p\u003E\u003Cp\u003E [KSPField(isPersistant = true)]\u003C/p\u003E\u003Cp\u003E bool throttlemode = false;\u003C/p\u003E\u003Cp\u003E [KSPField]\u003C/p\u003E\u003Cp\u003E public bool yforwardtrueorxfalse = true;\u003C/p\u003E\u003Cp\u003E //slightly borrowedcode\u003C/p\u003E\u003Cp\u003E protected Animation anim\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E get { return part.FindModelAnimators(retractAnimation)[0]; }\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E //\u003C/p\u003E\u003Cp\u003E Transform steeringTransform;\u003C/p\u003E\u003Cp\u003E Transform suspensionTransform;\u003C/p\u003E\u003Cp\u003E Transform wheelModel;\u003C/p\u003E\u003Cp\u003E Transform Bounder;\u003C/p\u003E\u003Cp\u003E Transform rotatingLever;\u003C/p\u003E\u003Cp\u003E //Transform wheelc;\u003C/p\u003E\u003Cp\u003E WheelCollider wheelc;\u003C/p\u003E\u003Cp\u003E Vector3 driveAt;\u003C/p\u003E\u003Cp\u003E //BoxCollider Bounderbox;\u003C/p\u003E\u003Cp\u003E //Animation s;\u003C/p\u003E\u003Cp\u003E //List\u0026lt;Animation\u0026gt; s = new List\u0026lt;Animation\u0026gt;();\u003C/p\u003E\u003Cp\u003E GameObject skidSmoke;\u003C/p\u003E\u003Cp\u003E [KSPField(isPersistant = true)]\u003C/p\u003E\u003Cp\u003E bool brakesOn = false;\u003C/p\u003E\u003Cp\u003E float motor;\u003C/p\u003E\u003Cp\u003E float steer;\u003C/p\u003E\u003Cp\u003E float csteer;\u003C/p\u003E\u003Cp\u003E float fixedangle;\u003C/p\u003E\u003Cp\u003E float vel;\u003C/p\u003E\u003Cp\u003E float speed = 1f;\u003C/p\u003E\u003Cp\u003E float BrakeTorquePercent = 0f;\u003C/p\u003E\u003Cp\u003E float driveDirection = 1f;\u003C/p\u003E\u003Cp\u003E //Vector3 direction;\u003C/p\u003E\u003Cp\u003E //float mSpeed;\u003C/p\u003E\u003Cp\u003E bool Debugtoggle;\u003C/p\u003E\u003Cp\u003E bool editorstate = false;\u003C/p\u003E\u003Cp\u003E [KSPEvent(guiActive = true, guiName = \u0022DEBUGTOGGLE\u0022, guiActiveUnfocused = false, unfocusedRange = 0)]\u003C/p\u003E\u003Cp\u003E public void Toggle2 ()\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E Debugtoggle = !Debugtoggle;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E // Throttle switching GUI / Action groups\u003C/p\u003E\u003Cp\u003E [KSPEvent(guiActive = true, guiName = \u0022Change Throttlemode\u0022, guiActiveUnfocused = false, unfocusedRange = 0)]\u003C/p\u003E\u003Cp\u003E public void Togglethrottle ()\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E throttlemode = !throttlemode;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E [KSPAction(\u0022Change Throttlemode\u0022)]\u003C/p\u003E\u003Cp\u003E public void Togglethrottle2(KSPActionParam Param)\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E throttlemode = !throttlemode;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E [KSPField(guiActive = true, guiName = \u0022Mode = \u0022)]\u003C/p\u003E\u003Cp\u003E public string throttlemodeout = \u0022Rover Mode\u0022;\u003C/p\u003E\u003Cp\u003E [KSPEvent(guiActive = true, guiName = \u0022Gear up/down\u0022, guiActiveUnfocused = false, unfocusedRange = 0)]\u003C/p\u003E\u003Cp\u003E public void GearGui ()\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E AnimGear();\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E [KSPAction(\u0022Gear\u0022, KSPActionGroup.Gear)]\u003C/p\u003E\u003Cp\u003E public void Gear(KSPActionParam param)\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E AnimGear();\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E [KSPAction(\u0022Brakes\u0022, KSPActionGroup.Brakes)]\u003C/p\u003E\u003Cp\u003E public void Brake (KSPActionParam param)\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E if (param.type == KSPActionType.Activate) {\u003C/p\u003E\u003Cp\u003E brakesOn = true;\u003C/p\u003E\u003Cp\u003E /*if (BrakeTorquePercent \u0026lt; 1f)\u003C/p\u003E\u003Cp\u003E BrakeTorquePercent = BrakeTorquePercent \u002B brakepercentadd;\u003C/p\u003E\u003Cp\u003E else\u003C/p\u003E\u003Cp\u003E BrakeTorquePercent = 1f;\u003C/p\u003E\u003Cp\u003E wheelc.brakeTorque = maxBrakeTorque * BrakeTorquePercent;*/\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022Applying Percent Brakes : \u0022 \u002B BrakeTorquePercent);\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E brakesOn = false;\u003C/p\u003E\u003Cp\u003E //wheelc.brakeTorque = maxBrakeTorque * BrakeTorquePercent;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E public void AnimGear ()\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E if (isDeployable == true)\u003C/p\u003E\u003Cp\u003E if (isDeployed == true) {\u003C/p\u003E\u003Cp\u003E isDeployed = false;\u003C/p\u003E\u003Cp\u003E foreach (AnimationState s in anim)\u003C/p\u003E\u003Cp\u003E s.speed = speed;\u003C/p\u003E\u003Cp\u003E anim.Play (retractAnimation,PlayMode.StopAll);\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E isDeployed = true;\u003C/p\u003E\u003Cp\u003E foreach (AnimationState s in anim){\u003C/p\u003E\u003Cp\u003E s.speed = -speed;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E anim.Play (retractAnimation,PlayMode.StopAll);\u003C/p\u003E\u003Cp\u003E foreach (AnimationState s in anim){\u003C/p\u003E\u003Cp\u003E if (s.normalizedTime == 0){ \u003C/p\u003E\u003Cp\u003E s.normalizedTime = 1;\u003C/p\u003E\u003Cp\u003E //Debug.Log (\u0022setting normalizedTime to 1...\u0022);\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E //Debug.Log (\u0022normalizedtime = \u0022 \u002B s.normalizedTime);\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E public override void OnStart (StartState state)\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E steeringTransform = part.FindModelTransform (\u0022steeringAxis\u0022);\u003C/p\u003E\u003Cp\u003E wheelModel = part.FindModelTransform (\u0022Wheel\u0022);\u003C/p\u003E\u003Cp\u003E suspensionTransform = part.FindModelTransform (\u0022suspensionParent\u0022);\u003C/p\u003E\u003Cp\u003E Bounder = part.FindModelTransform (\u0022Bounds\u0022);\u003C/p\u003E\u003Cp\u003E rotatingLever = part.FindModelTransform (\u0022rotatingLever1\u0022);\u003C/p\u003E\u003Cp\u003E //wheelc = part.FindModelTransform(\u0022Wheel\u0022);\u003C/p\u003E\u003Cp\u003E wheelc = part.FindModelComponent\u0026lt;WheelCollider\u0026gt; ();\u003C/p\u003E\u003Cp\u003E //s = (part.FindModelAnimators(retractAnimation));\u003C/p\u003E\u003Cp\u003E //Bounderbox = Bounder.GetComponent\u0026lt;BoxCollider\u0026gt; ();\u003C/p\u003E\u003Cp\u003E //Bounderbox.enabled = false;\u003C/p\u003E\u003Cp\u003E Destroy (Bounder.gameObject.collider);\u003C/p\u003E\u003Cp\u003E //This part is for setting up particles\u003C/p\u003E\u003Cp\u003E if (state != StartState.Editor) {\u003C/p\u003E\u003Cp\u003E skidSmoke = (GameObject)GameObject.Instantiate (UnityEngine.Resources.Load (\u0022Effects/fx_smokeTrail_light\u0022));\u003C/p\u003E\u003Cp\u003E skidSmoke.transform.parent = suspensionTransform;\u003C/p\u003E\u003Cp\u003E skidSmoke.transform.position = wheelc.transform.position;\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.emit = false;\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.localVelocity = Vector3.zero;\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.useWorldSpace = true;\u003C/p\u003E\u003Cp\u003E JointSpring wheelspring;\u003C/p\u003E\u003Cp\u003E wheelspring = wheelc.suspensionSpring;\u003C/p\u003E\u003Cp\u003E if (spring != 0f){\u003C/p\u003E\u003Cp\u003E wheelspring.spring = spring;\u003C/p\u003E\u003Cp\u003E wheelc.suspensionSpring = wheelspring;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E if (isDeployed == false) {\u003C/p\u003E\u003Cp\u003E anim.Play (retractAnimation, PlayMode.StopAll);\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022Persistant shows gear retracted, retracting animation\u0022);\u003C/p\u003E\u003Cp\u003E foreach (AnimationState s in anim)\u003C/p\u003E\u003Cp\u003E s.normalizedTime = 1;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E editorstate = false;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E editorstate = true;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E wheelc.enabled = true;\u003C/p\u003E\u003Cp\u003E // make sure wheels are at full suspension extension in the VAB/SPH\u003C/p\u003E\u003Cp\u003E suspensionTransform.position = wheelc.transform.position - (wheelc.transform.up * (wheelc.suspensionDistance \u002B contactDisplace));\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E // fix180 is for converting 0 to 360 degree range to -180 to 180 degree range.\u003C/p\u003E\u003Cp\u003E float fix180(float angle)\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E if (angle \u0026gt; 180f) {\u003C/p\u003E\u003Cp\u003E fixedangle = angle - 360f;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E fixedangle = angle;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E return fixedangle;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E public void FixedUpdate ()\u003C/p\u003E\u003Cp\u003E {\u003C/p\u003E\u003Cp\u003E /*// is the animation at the start? if it is, work. if it aint, don\u0027t.\u003C/p\u003E\u003Cp\u003E foreach (AnimationState s in anim) {\u003C/p\u003E\u003Cp\u003E if (s.normalizedTime == 0) {\u003C/p\u003E\u003Cp\u003E isDeployed = true;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E isDeployed = false;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E */\u003C/p\u003E\u003Cp\u003E if (HighLogic.LoadedSceneIsEditor == false) {\u003C/p\u003E\u003Cp\u003E if (this.vessel.isActiveVessel == false)\u003C/p\u003E\u003Cp\u003E isActive = false;\u003C/p\u003E\u003Cp\u003E else\u003C/p\u003E\u003Cp\u003E isActive = true;\u003C/p\u003E\u003Cp\u003E if (yforwardtrueorxfalse == true) {\u003C/p\u003E\u003Cp\u003E driveAt = part.transform.InverseTransformDirection (vessel.transform.forward \u002B vessel.transform.up);\u003C/p\u003E\u003Cp\u003E if (driveAt.y \u0026gt; 0)\u003C/p\u003E\u003Cp\u003E driveDirection = 1f;\u003C/p\u003E\u003Cp\u003E else\u003C/p\u003E\u003Cp\u003E driveDirection = -1f;\u003C/p\u003E\u003Cp\u003E if (Debugtoggle == true)\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022driveAt.y = \u0022 \u002B driveAt.y);\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E driveAt = part.transform.InverseTransformDirection (vessel.transform.forward \u002B vessel.transform.up);\u003C/p\u003E\u003Cp\u003E if (driveAt.x \u0026gt; 0)\u003C/p\u003E\u003Cp\u003E driveDirection = 1f;\u003C/p\u003E\u003Cp\u003E else\u003C/p\u003E\u003Cp\u003E driveDirection = -1f;\u003C/p\u003E\u003Cp\u003E if (Debugtoggle == true)\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022driveAt.x = \u0022 \u002B driveAt.x);\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E if (isActive == true) {\u003C/p\u003E\u003Cp\u003E if (isDeployed == true) {\u003C/p\u003E\u003Cp\u003E vel = (float)this.vessel.srf_velocity.magnitude;\u003C/p\u003E\u003Cp\u003E //Debug.Log (\u0022velocity readout : \u0022 \u002B vel);\u003C/p\u003E\u003Cp\u003E steer = (float)(-FlightInputHandler.state.wheelSteer * maxSteer / (1f \u002B (vel * steerFalloff)));\u003C/p\u003E\u003Cp\u003E //select the appropiate mode for driving the motor\u003C/p\u003E\u003Cp\u003E if (throttlemode == false) {\u003C/p\u003E\u003Cp\u003E motor = (float)(FlightInputHandler.state.wheelThrottle);\u003C/p\u003E\u003Cp\u003E throttlemodeout = \u0022Rover Mode\u0022;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E motor = (float)(FlightInputHandler.state.mainThrottle);\u003C/p\u003E\u003Cp\u003E throttlemodeout = \u0022Throttle Mode\u0022;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E Vector3 partposition = part.transform.InverseTransformPoint (vessel.transform.position);\u003C/p\u003E\u003Cp\u003E Vector3 CoMposition = part.transform.InverseTransformPoint (vessel.CoM);\u003C/p\u003E\u003Cp\u003E if (Debugtoggle == true)\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022PP = \u0022 \u002B partposition \u002B \u0022 COMP = \u0022 \u002B CoMposition);\u003C/p\u003E\u003Cp\u003E if (yforwardtrueorxfalse == true)\u003C/p\u003E\u003Cp\u003E if (CoMposition.y * driveDirection \u0026gt; 0)\u003C/p\u003E\u003Cp\u003E steer = -steer;\u003C/p\u003E\u003Cp\u003E if (yforwardtrueorxfalse == false)\u003C/p\u003E\u003Cp\u003E if (CoMposition.x * driveDirection \u0026gt; 0)\u003C/p\u003E\u003Cp\u003E steer = -steer;\u003C/p\u003E\u003Cp\u003E // not deployed or active? then don\u0027t steer or drive.\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E motor = 0f;\u003C/p\u003E\u003Cp\u003E steer = 0f;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E csteer = steeringTransform.localEulerAngles.y;\u003C/p\u003E\u003Cp\u003E csteer = fix180 (csteer);\u003C/p\u003E\u003Cp\u003E //rediculously basic smoothing command\u003C/p\u003E\u003Cp\u003E steer = (steer \u002B csteer) / 2;\u003C/p\u003E\u003Cp\u003E // set the steering angle and wheel torque\u003C/p\u003E\u003Cp\u003E steeringTransform.localEulerAngles = new Vector3 (0, steer, 0);\u003C/p\u003E\u003Cp\u003E wheelc.motorTorque = (float)(motor * maxMotorTorque * driveDirection);\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E //Old Brakes applying code using GetKey\u003C/p\u003E\u003Cp\u003E /*if (Input.GetKey (KeyCode.\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_cool.png\u0022 alt=\u0022B)\u0022\u003E == true) {\u003C/p\u003E\u003Cp\u003E wheelc.brakeTorque = maxBrakeTorque;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E wheelc.brakeTorque = 0f;\u003C/p\u003E\u003Cp\u003E }*/\u003C/p\u003E\u003Cp\u003E if (brakesOn == true) {\u003C/p\u003E\u003Cp\u003E if (BrakeTorquePercent \u0026lt; 1f)\u003C/p\u003E\u003Cp\u003E BrakeTorquePercent = BrakeTorquePercent \u002B brakepercentadd;\u003C/p\u003E\u003Cp\u003E if (BrakeTorquePercent \u0026gt; 1f)\u003C/p\u003E\u003Cp\u003E BrakeTorquePercent = 1f;\u003C/p\u003E\u003Cp\u003E if (Debugtoggle == true)\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022Applying Percent Brakes : \u0022 \u002B BrakeTorquePercent);\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E if (BrakeTorquePercent \u0026gt; 0f)\u003C/p\u003E\u003Cp\u003E BrakeTorquePercent = BrakeTorquePercent - brakepercentsub;\u003C/p\u003E\u003Cp\u003E if (BrakeTorquePercent \u0026lt; 0f)\u003C/p\u003E\u003Cp\u003E BrakeTorquePercent = 0f;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E if ((maxBrakeTorque * BrakeTorquePercent) \u0026gt; rollingResistance)\u003C/p\u003E\u003Cp\u003E wheelc.brakeTorque = maxBrakeTorque * BrakeTorquePercent;\u003C/p\u003E\u003Cp\u003E else\u003C/p\u003E\u003Cp\u003E if (vessel.srf_velocity.magnitude \u0026lt; 0.1)\u003C/p\u003E\u003Cp\u003E wheelc.brakeTorque = rollingResistance;\u003C/p\u003E\u003Cp\u003E //Debug.Log (KSPActionGroup.Brakes);\u003C/p\u003E\u003Cp\u003E //Debug.Log (Input.GetKey(KeyCode.\u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_cool.png\u0022 alt=\u0022B)\u0022\u003E);\u003C/p\u003E\u003Cp\u003E //var hit : Physics.RaycastHit;\u003C/p\u003E\u003Cp\u003E /*\u003C/p\u003E\u003Cp\u003E float susdist = wheelc.radius \u002B wheelc.suspensionDistance;\u003C/p\u003E\u003Cp\u003E RaycastHit hit = new RaycastHit ();\u003C/p\u003E\u003Cp\u003E if (Physics.Raycast (wheelc.transform.position, -transform.up, out hit, susdist)) {\u003C/p\u003E\u003Cp\u003E suspensionTransform.position = hit.point \u002B (this.part.transform.up * wheelc.radius);\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E suspensionTransform.position = wheelc.transform.position - (this.part.transform.up * wheelc.suspensionDistance);\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E */\u003C/p\u003E\u003Cp\u003E /*\u003C/p\u003E\u003Cp\u003E WheelHit whit = new WheelHit ();\u003C/p\u003E\u003Cp\u003E if (wheelc.GetGroundHit (out whit)) {\u003C/p\u003E\u003Cp\u003E suspensionTransform.position = whit.point \u002B (this.part.transform.up * wheelc.radius);\u003C/p\u003E\u003Cp\u003E if (whit.forwardSlip \u002B whit.sidewaysSlip \u0026gt; 0.9) {\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022skidding at \u0022 \u002B whit.forwardSlip \u002B \u0022 by \u0022 \u002B whit.sidewaysSlip);\u003C/p\u003E\u003Cp\u003E skidSmoke.transform.position = whit.point;\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.emit = true;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.emit = false;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E suspensionTransform.position = wheelc.transform.position - (this.part.transform.up * wheelc.suspensionDistance);\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.emit = false;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E */\u003C/p\u003E\u003Cp\u003E wheelModel.RotateAroundLocal (wheelRotationAxis, wheelc.rpm * rotationFactor * Time.deltaTime);\u003C/p\u003E\u003Cp\u003E WheelHit whit = new WheelHit ();\u003C/p\u003E\u003Cp\u003E RaycastHit hit = new RaycastHit ();\u003C/p\u003E\u003Cp\u003E if (wheelc.GetGroundHit (out whit)) {\u003C/p\u003E\u003Cp\u003E Physics.Raycast (wheelc.transform.position, -wheelc.transform.up, out hit);\u003C/p\u003E\u003Cp\u003E Vector3 hitlag = (whit.point - hit.point);\u003C/p\u003E\u003Cp\u003E if (Debugtoggle == true)\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022Lagging \u0022 \u002B hitlag.magnitude \u002B \u0022 Deltatime \u0022 \u002B Time.deltaTime);\u003C/p\u003E\u003Cp\u003E whit.point = whit.point \u002B vessel.srf_velocity*Time.deltaTime;\u003C/p\u003E\u003Cp\u003E hitlag = (whit.point - hit.point);\u003C/p\u003E\u003Cp\u003E if (Debugtoggle == true){\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022Lagging \u0022 \u002B hitlag.magnitude \u002B \u0022velocity = \u0022 \u002B vessel.srf_velocity*Time.deltaTime);\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E whit.point = wheelc.transform.InverseTransformPoint (whit.point);\u003C/p\u003E\u003Cp\u003E whit.point = wheelc.transform.TransformPoint (0, whit.point.y \u002B contactDisplace, 0);\u003C/p\u003E\u003Cp\u003E suspensionTransform.position = whit.point \u002B (wheelc.transform.up * wheelc.radius);\u003C/p\u003E\u003Cp\u003E if (Math.Abs (whit.forwardSlip) \u002B Math.Abs (whit.sidewaysSlip) \u0026gt; smokestart) {\u003C/p\u003E\u003Cp\u003E skidSmoke.transform.position = whit.point;\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.emit = true;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.emit = false;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E WheelFrictionCurve sf = wheelc.sidewaysFriction;\u003C/p\u003E\u003Cp\u003E WheelFrictionCurve ff = wheelc.forwardFriction;\u003C/p\u003E\u003Cp\u003E Vector3 gee = FlightGlobals.getGeeForceAtPosition (transform.position);\u003C/p\u003E\u003Cp\u003E //sf.stiffness = (0.1f/(1f\u002B(wheelc.rpm/50f)));\u003C/p\u003E\u003Cp\u003E //sf.stiffness = (1f/(10f * (1f\u002B((float)vessel.srf_velocity.magnitude*velslidefactor)\u002Bslidefactor*(Math.Abs(whit.sidewaysSlip)\u002BMath.Abs(whit.forwardSlip)))));\u003C/p\u003E\u003Cp\u003E //sf.stiffness = (1f/(10f * (1f\u002B((float)vessel.srf_velocity.magnitude*velslidefactor)*slidefactor*(Math.Abs(whit.sidewaysSlip)\u002BMath.Abs(whit.forwardSlip)))));\u003C/p\u003E\u003Cp\u003E //sf.stiffness = (1f/(10f * (1f\u002B((float)vessel.srf_velocity.magnitude*velslidefactor)*slidefactor*(float)Math.Pow ((Math.Abs(whit.sidewaysSlip)\u002BMath.Abs(whit.forwardSlip)),0.5f))));\u003C/p\u003E\u003Cp\u003E sf.stiffness = (TimeWarp.CurrentRate / (10f \u002B (slidefactor * (float)Math.Pow ((Math.Abs (whit.sidewaysSlip) \u002B 0f * Math.Abs (whit.forwardSlip)), slidepower))));\u003C/p\u003E\u003Cp\u003E ff.stiffness = (TimeWarp.CurrentRate / (7.5f * (1 \u002B Math.Abs (whit.forwardSlip))));\u003C/p\u003E\u003Cp\u003E if (Debugtoggle == true) {\u003C/p\u003E\u003Cp\u003E //Debug.Log (\u0022gee \u0022 \u002B gee.magnitude);\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022partvel \u0022 \u002B vessel.srf_velocity.magnitude);\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022skidding at \u0022 \u002B Math.Abs (whit.forwardSlip) \u002B \u0022 by \u0022 \u002B Math.Abs (whit.sidewaysSlip));\u003C/p\u003E\u003Cp\u003E Debug.Log (sf.stiffness);\u003C/p\u003E\u003Cp\u003E Debug.Log (ff.stiffness);\u003C/p\u003E\u003Cp\u003E Debug.Log (\u0022timewarp : \u0022 \u002B TimeWarp.CurrentRate);\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E wheelc.sidewaysFriction = sf;\u003C/p\u003E\u003Cp\u003E wheelc.forwardFriction = ff;\u003C/p\u003E\u003Cp\u003E } else {\u003C/p\u003E\u003Cp\u003E suspensionTransform.position = wheelc.transform.position - (wheelc.transform.up * (wheelc.suspensionDistance \u002B contactDisplace));\u003C/p\u003E\u003Cp\u003E skidSmoke.particleEmitter.emit = false;\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E //deal with rotating levers\u003C/p\u003E\u003Cp\u003E if (rotatingLever) {\u003C/p\u003E\u003Cp\u003E //rotatingLever.LookAt (rotatingLever.position \u002B wheelc.transform.right, Vector3.Normalize (wheelModel.position - rotatingLever.position));\u003C/p\u003E\u003Cp\u003E //rotatingLever.LookAt (wheelc.transform, transform.TransformPoint (new Vector3(1,0,0)));\u003C/p\u003E\u003Cp\u003E //rotatingLever.localRotation = Quaternion.LookRotation (wheelModel.position, rotatingLever.position \u002B rotatingLever.TransformDirection (1,0,0));\u003C/p\u003E\u003Cp\u003E rotatingLever.LookAt ((rotatingLever.position \u002B part.transform.TransformDirection (1, 0, 0)), Vector3.Normalize (wheelModel.position - rotatingLever.position));\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E }\u003C/p\u003E\u003Cp\u003E}\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222014-07-19T22:01:57Z\u0022 title=\u002207/19/2014 10:01  PM\u0022 data-short=\u00229 yr\u0022\u003EJuly 19, 2014\u003C/time\u003E by Jakey4150\u003C/strong\u003E\n\u003C/span\u003E\n"}]}