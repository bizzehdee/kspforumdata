{"TopicId":114421,"ForumId":44,"TopicTitle":"Quantum Mechanics: Einstein vs. Bell","CreatedByName":"arkie87","CreatedById":103434,"CreatedDateTime":"2015-06-28T06:41:46Z","PageNum":1,"Articles":[{"CreatedByName":"arkie87","CreatedById":103434,"CreatedDateTime":"2015-06-28T06:41:46Z","Content":"\n\u003Cp\u003ESo I am reading \u0022Fabric of the Cosmos\u0022 by Brian Greene (highly recommend btw), and he is discussing the debate between Einstein et. al. and Bell regarding whether or not elementary particles have properties before we observe them or not.\u003C/p\u003E\u003Cp\u003EHe then describes an experiment Bell proposed to determine who is correct. The idea is to take two entangled particles, and have one group measure it\u0027s spin with respect to a random axis and another group measure the spin of the other in a random axis. Einstein believed that both particles had predetermined spins in each of the primary coordinate axes. Due to probability, Bell posited that if Einstein was right, the probability that the two groups observed the same spin direction would be larger than 50%.\u003C/p\u003E\u003Cp\u003EBell, on the other hand, believed that the spin that the particle has in a particular axis is not decided until you measure it, and due to some logic not expressly described in the book, the probability that the two groups would observe the same spin should be 50% (or less, presumably).\u003C/p\u003E\u003Cp\u003EThis didnt make sense to me (it didnt seem like the probability would be any different), so I wrote a matlab program to test it, and I am right.\u003C/p\u003E\u003Cp\u003EThis leads me to believe that I am misunderstanding something.\u003C/p\u003E\u003Cp\u003EAnyone familiar with this and want to venture a guess where I am going wrong?\u003C/p\u003E\u003Cp\u003EBelow is my Matlab code:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Efunction QuantumMechanics\u003Cbr\u003Eclc\u003Cbr\u003Eclear all\u003Cbr\u003Eclose all\u003Cbr\u003E\u003Cbr\u003Efor i=1:100000\u003Cbr\u003E    bell(i)=BellSim;\u003Cbr\u003Eend\u003Cbr\u003EBell=mean(bell(not(isnan(bell))))\u003Cbr\u003E\u003Cbr\u003E\u003Cbr\u003Efor i=1:100000\u003Cbr\u003E    epr(i)=EPRSim;\u003Cbr\u003Eend\u003Cbr\u003EEPR=mean(epr(not(isnan(epr))))\u003Cbr\u003E\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003Efunction p=EPRSim\u003Cbr\u003Ex=[BinaryRand,BinaryRand,BinaryRand];\u003Cbr\u003Ea=TrinaryRand;\u003Cbr\u003Eb=TrinaryRand;\u003Cbr\u003Ea=x(a);\u003Cbr\u003Eb=x(;\u003Cbr\u003Eif a==b\u003Cbr\u003E    p=1;\u003Cbr\u003Eelse\u003Cbr\u003E    p=0;\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003Efunction p=BellSim\u003Cbr\u003E\u003Cbr\u003Ea=TrinaryRand;\u003Cbr\u003Eb=TrinaryRand;\u003Cbr\u003E\u003Cbr\u003Eif a==b\u003Cbr\u003E    p=1;\u003Cbr\u003Eelse\u003Cbr\u003E    a=BinaryRand;\u003Cbr\u003E    b=BinaryRand;\u003Cbr\u003E    if a==b\u003Cbr\u003E        p=1;\u003Cbr\u003E    else\u003Cbr\u003E        p=0;\u003Cbr\u003E    end\u003Cbr\u003Eend\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003Efunction n=TrinaryRand\u003Cbr\u003En=3*rand(1);n=ceil(n);\u003Cbr\u003Eend\u003Cbr\u003E\u003Cbr\u003Efunction r=BinaryRand\u003Cbr\u003Er=rand(1)-0.5; r=sign(r);\u003Cbr\u003Eend\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\n"},{"CreatedByName":"Steel","CreatedById":49317,"CreatedDateTime":"2015-06-28T13:55:56Z","Content":"\n\u003Cp\u003EThe issue here is you\u0027re trying to look at it from a purely probabilistic viewpoint, in which case there will be no difference. The test is a physical one, as the difference in probabilities is caused by the physical properties of the system, not mathematics.\u003C/p\u003E\u003Cp\u003ETo actually test whether there is a difference you need two entangled particles, which you cannot, unfortunately, program in MATLAB (or at least I can\u0027t) \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003Cp\u003E(And of course there\u0027s the other issue that random numbers in computers are not truly random, but let\u0027s not get into that!)\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-06-28T14:01:28Z\u0022 title=\u002206/28/2015 02:01  PM\u0022 data-short=\u00229 yr\u0022\u003EJune 28, 2015\u003C/time\u003E by Steel\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-06-28T14:12:29Z","Content":"\n\u003Cp\u003EFirst of all, it\u0027s not about probabilities, but rather correlation. You need correlation as a function of the angle between the two bases. While both classical and quantum measurements predict the same probabilities, they predict totally different correlations between the two measurements. Because both measurements have zero mean and unit deviations, correlation is just Corr(X,Y) = E[XY] for two measurements X and Y.\u003C/p\u003E\u003Cp\u003EBut more fundamentally, you do not seem to understand how the entanglement works.\u003C/p\u003E\u003Cp\u003ELets start with a classical theory. Suppose that spin axis makes angle \u00C3\u017D\u00C2\u00B8 with your measurement axis. Classical measurement tells you that you will measure spin Sign(Cos(\u00C3\u017D\u00C2\u00B8)). That still gives you 50/50 odds if you don\u0027t know \u00C3\u017D\u00C2\u00B8, but if you do know \u00C3\u017D\u00C2\u00B8, then it\u0027s a fixed quantity. Lets look at it backwards. Suppose you did make a measurement, and you did measure spin \u002B1. What is \u00C3\u017D\u00C2\u00B8? Well, you don\u0027t know, but you can say for sure that it\u0027s between -90\u00C3\u201A\u00C2\u00B0 and 90\u00C3\u201A\u00C2\u00B0, because these are the only values of \u00C3\u017D\u00C2\u00B8 that give you positive Cos(\u00C3\u017D\u00C2\u00B8). So now, lets say you have a duplicate of that spin with exactly opposite angle (\u00C3\u017D\u00C2\u00B8\u002B\u00C3\u00E2\u201A\u00AC). Naturally, if you measured \u002B1 on the first, you\u0027d measure -1 on this one. But suppose, you measured this one in a different basis, say, at some angle \u00C3\u017D\u00C2\u00A6 to first measurement. What are the odds that you measure -1 now? Well, it depends on what \u00C3\u017D\u00C2\u00B8 was. But if \u00C3\u017D\u00C2\u00A6 is small, almost any \u00C3\u017D\u00C2\u00B8 will give you -1, and if \u00C3\u017D\u00C2\u00A6 is close to 180\u00C3\u201A\u00C2\u00B0, almost any \u00C3\u017D\u00C2\u00B8 will give you \u002B1. And therein lies the correlation.\u003C/p\u003E\u003Cp\u003ESo here is a rough outline of what your classical computation should be.\u003C/p\u003E\u003Cp\u003E1) Generate a list or random angles \u00C3\u017D\u00C2\u00B8.\u003C/p\u003E\u003Cp\u003E2) Generate a list of Sign(Cos(\u00C3\u017D\u00C2\u00B8)), call this list X.\u003C/p\u003E\u003Cp\u003E3) Generate a list of Sign(Cos(\u00C3\u017D\u00C2\u00B8 \u002B \u00C3\u017D\u00C2\u00A6)) for a bunch of values of \u00C3\u017D\u00C2\u00A6 from 0\u00C3\u201A\u00C2\u00B0 to 360\u00C3\u201A\u00C2\u00B0, call that Y.\u003C/p\u003E\u003Cp\u003E4) Compute correlation as Sum(X(i)Y(i)) / N, where N is the number of \u00C3\u017D\u00C2\u00A6 values you used.\u003C/p\u003E\u003Cp\u003E5) Plot the correlation as a function of \u00C3\u017D\u00C2\u00A6. You should see something that\u0027s straight line rising from -1 to 1 from 0\u00C3\u201A\u00C2\u00B0 to 180\u00C3\u201A\u00C2\u00B0, and then falls back again from 180\u00C3\u201A\u00C2\u00B0 to 360\u00C3\u201A\u00C2\u00B0.\u003C/p\u003E\u003Cp\u003ENow, quantum measurements are much more complicated conceptually, but almost as easy to evaluate. I won\u0027t walk you through the entire logic, but just what\u0027s relevant to simulation. From perspective of the simulation, it doesn\u0027t really matter what the initial state was, other than that it was entangled. As soon as you measure first particle, entanglement tells us state of the other. So you can seed first measurement, X, with random values. You can use the same X as classical result, for example. The important bit is that you use that to compute measurements on Y.\u003C/p\u003E\u003Cp\u003ESo, suppose you measured \u002B1 on the first particle. Just like in the classical case, you know that second particle has -1 in the same basis. But what are your odds of measuring -1 in the basis rotated by \u00C3\u017D\u00C2\u00A6? Well, it\u0027s \u0026lt;-1|Exp(iS\u003Csub\u003Ex\u003C/sub\u003E \u00C3\u017D\u00C2\u00A6/2)|-1\u0026gt;\u00C3\u201A\u00C2\u00B2 = Cos(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2. Likewise, probability of getting \u002B1 is Sin(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2. Note that Cos(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2 \u002B Sin(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2 = 1, because total probability needs to be 1. And so you have your rough algorithm.\u003C/p\u003E\u003Cp\u003E1) Generate a random list of \u002B1/-1 values X, or just use the X from classical case.\u003C/p\u003E\u003Cp\u003E2) For each value X, generate corresponding Y by generating a random value r between 0 and 1, then have Y = X if r \u0026gt; Cos(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2 and have Y = -X otherwise. Note that you need to do this once for each \u00C3\u017D\u00C2\u00A6.\u003C/p\u003E\u003Cp\u003E3) Compute correlation as above.\u003C/p\u003E\u003Cp\u003E4) Plot correlation as function of \u00C3\u017D\u00C2\u00A6. This time, you should see something that looks like a Cos curve.\u003C/p\u003E\u003Cp\u003E@Steel, it\u0027s very easy to program entangled particles in Matlab if you know QM and a bit of linear algebra. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\n"},{"CreatedByName":"arkie87","CreatedById":103434,"CreatedDateTime":"2015-06-28T15:30:51Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Steel\u0022 data-cite=\u0022Steel\u0022\u003E\u003Cdiv\u003EThe issue here is you\u0027re trying to look at it from a purely probabilistic viewpoint, in which case there will be no difference. The test is a physical one, as the difference in probabilities is caused by the physical properties of the system, not mathematics.\u003Cp\u003ETo actually test whether there is a difference you need two entangled particles, which you cannot, unfortunately, program in MATLAB (or at least I can\u0027t) \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EIt is still unclear to me why I need two entangled particles, and cannot model the behavior statistically in Matlab... can you elaborate?\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022Steel\u0022 data-cite=\u0022Steel\u0022\u003E\u003Cdiv\u003E\u003Cp\u003E(And of course there\u0027s the other issue that random numbers in computers are not truly random, but let\u0027s not get into that!)\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYes, i am aware of that \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_tongue2.gif\u0022 alt=\u0022:sticktongue:\u0022\u003E but both probabilities are pretty close to expected value (i.e. 2/3)...\u003C/p\u003E\u003Cp\u003E\u003Cspan style=\u0022font-size:8px;\u0022\u003E\u003Cspan style=\u0022color:#C0C0C0;\u0022\u003E- - - Updated - - -\u003C/span\u003E\u003C/span\u003E\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EFirst of all, it\u0027s not about probabilities, but rather correlation. You need correlation as a function of the angle between the two bases. While both classical and quantum measurements predict the same probabilities, they predict totally different correlations between the two measurements. Because both measurements have zero mean and unit deviations, correlation is just Corr(X,Y) = E[XY] for two measurements X and Y.\u003Cp\u003EBut more fundamentally, you do not seem to understand how the entanglement works.\u003C/p\u003E\u003Cp\u003ELets start with a classical theory. Suppose that spin axis makes angle \u00C3\u017D\u00C2\u00B8 with your measurement axis. Classical measurement tells you that you will measure spin Sign(Cos(\u00C3\u017D\u00C2\u00B8)). That still gives you 50/50 odds if you don\u0027t know \u00C3\u017D\u00C2\u00B8, but if you do know \u00C3\u017D\u00C2\u00B8, then it\u0027s a fixed quantity. Lets look at it backwards. Suppose you did make a measurement, and you did measure spin \u002B1. What is \u00C3\u017D\u00C2\u00B8? Well, you don\u0027t know, but you can say for sure that it\u0027s between -90\u00C3\u201A\u00C2\u00B0 and 90\u00C3\u201A\u00C2\u00B0, because these are the only values of \u00C3\u017D\u00C2\u00B8 that give you positive Cos(\u00C3\u017D\u00C2\u00B8). So now, lets say you have a duplicate of that spin with exactly opposite angle (\u00C3\u017D\u00C2\u00B8\u002B\u00C3\u00E2\u201A\u00AC). Naturally, if you measured \u002B1 on the first, you\u0027d measure -1 on this one. But suppose, you measured this one in a different basis, say, at some angle \u00C3\u017D\u00C2\u00A6 to first measurement. What are the odds that you measure -1 now? Well, it depends on what \u00C3\u017D\u00C2\u00B8 was. But if \u00C3\u017D\u00C2\u00A6 is small, almost any \u00C3\u017D\u00C2\u00B8 will give you -1, and if \u00C3\u017D\u00C2\u00A6 is close to 180\u00C3\u201A\u00C2\u00B0, almost any \u00C3\u017D\u00C2\u00B8 will give you \u002B1. And therein lies the correlation.\u003C/p\u003E\u003Cp\u003ESo here is a rough outline of what your classical computation should be.\u003C/p\u003E\u003Cp\u003E1) Generate a list or random angles \u00C3\u017D\u00C2\u00B8.\u003C/p\u003E\u003Cp\u003E2) Generate a list of Sign(Cos(\u00C3\u017D\u00C2\u00B8)), call this list X.\u003C/p\u003E\u003Cp\u003E3) Generate a list of Sign(Cos(\u00C3\u017D\u00C2\u00B8 \u002B \u00C3\u017D\u00C2\u00A6)) for a bunch of values of \u00C3\u017D\u00C2\u00A6 from 0\u00C3\u201A\u00C2\u00B0 to 360\u00C3\u201A\u00C2\u00B0, call that Y.\u003C/p\u003E\u003Cp\u003E4) Compute correlation as Sum(X(i)Y(i)) / N, where N is the number of \u00C3\u017D\u00C2\u00A6 values you used.\u003C/p\u003E\u003Cp\u003E5) Plot the correlation as a function of \u00C3\u017D\u00C2\u00A6. You should see something that\u0027s straight line rising from -1 to 1 from 0\u00C3\u201A\u00C2\u00B0 to 180\u00C3\u201A\u00C2\u00B0, and then falls back again from 180\u00C3\u201A\u00C2\u00B0 to 360\u00C3\u201A\u00C2\u00B0.\u003C/p\u003E\u003Cp\u003ENow, quantum measurements are much more complicated conceptually, but almost as easy to evaluate. I won\u0027t walk you through the entire logic, but just what\u0027s relevant to simulation. From perspective of the simulation, it doesn\u0027t really matter what the initial state was, other than that it was entangled. As soon as you measure first particle, entanglement tells us state of the other. So you can seed first measurement, X, with random values. You can use the same X as classical result, for example. The important bit is that you use that to compute measurements on Y.\u003C/p\u003E\u003Cp\u003ESo, suppose you measured \u002B1 on the first particle. Just like in the classical case, you know that second particle has -1 in the same basis. But what are your odds of measuring -1 in the basis rotated by \u00C3\u017D\u00C2\u00A6? Well, it\u0027s \u0026lt;-1|Exp(iS\u003Csub\u003Ex\u003C/sub\u003E \u00C3\u017D\u00C2\u00A6/2)|-1\u0026gt;\u00C3\u201A\u00C2\u00B2 = Cos(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2. Likewise, probability of getting \u002B1 is Sin(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2. Note that Cos(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2 \u002B Sin(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2 = 1, because total probability needs to be 1. And so you have your rough algorithm.\u003C/p\u003E\u003Cp\u003E1) Generate a random list of \u002B1/-1 values X, or just use the X from classical case.\u003C/p\u003E\u003Cp\u003E2) For each value X, generate corresponding Y by generating a random value r between 0 and 1, then have Y = X if r \u0026gt; Cos(\u00C3\u017D\u00C2\u00A6/2)\u00C3\u201A\u00C2\u00B2 and have Y = -X otherwise. Note that you need to do this once for each \u00C3\u017D\u00C2\u00A6.\u003C/p\u003E\u003Cp\u003E3) Compute correlation as above.\u003C/p\u003E\u003Cp\u003E4) Plot correlation as function of \u00C3\u017D\u00C2\u00A6. This time, you should see something that looks like a Cos curve.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThank you for your detailed response! I have a few questions:\u003C/p\u003E\u003Cp\u003E(1) I assume by \u0022classical\u0022 computation you mean ignoring QM and assuming Einstein et. al. are correct. For this case, in step 4, what are we computing exactly. It seems like Corr = sum(X(i)*Y(i))/N for i=1:N, which should just give you one value, not a value for each i value, i.e. Corr =/= Corr(i)?\u003C/p\u003E\u003Cp\u003E(2) I\u0027m confused why the algorithm for QM is fundamentally different than for classical. In step two, where is the list of phi\u0027s generated? Why is Y=X if r \u0026gt; cos(phi/2)^2? \u003C/p\u003E\u003Cp\u003EIt seems maybe the book over-simplified (not surprisingly). The book says we measure randomly in 1 of 3 axes, but you are saying we measure a random, continuous (not discrete) shift from the other angle, which changes the logic in my code.\u003C/p\u003E\u003Cp\u003EI will try to make sense of this and work it out in Matlab. Thanks again!\u003C/p\u003E\n"},{"CreatedByName":"K^2","CreatedById":57710,"CreatedDateTime":"2015-06-28T21:32:31Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022arkie87\u0022 data-cite=\u0022arkie87\u0022\u003E\u003Cdiv\u003E(1) I assume by \u0022classical\u0022 computation you mean ignoring QM and assuming Einstein et. al. are correct. For this case, in step 4, what are we computing exactly. It seems like Corr = sum(X(i)*Y(i))/N for i=1:N, which should just give you one value, not a value for each i value, i.e. Corr =/= Corr(i)?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYes, it\u0027s just one number. But it\u0027s a different number for every angle \u00C3\u017D\u00C2\u00A6.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022arkie87\u0022 data-cite=\u0022arkie87\u0022\u003E\u003Cdiv\u003E(2) I\u0027m confused why the algorithm for QM is fundamentally different than for classical. In step two, where is the list of phi\u0027s generated?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EYou just generate a list of \u00C3\u017D\u00C2\u00A6 to plot results against, same as a bove. In Matlab, you can just do phi = 0:0.1:2*pi; Likewise, you can generate all thetas in one go as theta = 2*pi*rand(1000,1); That will give you 1,000 random initial orientations. So then your code for computing a list of classical correlations might look something like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ec = zeros(length(phi));\u003Cbr\u003Efor j = 1:length(phi)\u003Cbr\u003E\ty = sign(cos(theta .\u002B phi(j)) .\u002B pi);\u003Cbr\u003E\tc(j) = mean(x .* y);\u003Cbr\u003Eend\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis assumes that x, theta, and phi are already computed, of course. The \u002Bpi bit is just there to account for the fact that two particles are exactly opposite in direction.\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022arkie87\u0022 data-cite=\u0022arkie87\u0022\u003E\u003Cdiv\u003EWhy is Y=X if r \u0026gt; cos(phi/2)^2?\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EJust a shortcut for the odds of it being same or opposite sign. You can do this in Matlab in one ligne.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ey = x.*(sign(rand(1,1000).-(cos(phi(i)/2)^2)));\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022arkie87\u0022 data-cite=\u0022arkie87\u0022\u003E\u003Cdiv\u003EIt seems maybe the book over-simplified (not surprisingly). The book says we measure randomly in 1 of 3 axes, but you are saying we measure a random, continuous (not discrete) shift from the other angle, which changes the logic in my code.\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EI\u0027d bet your book describes an actual experiment done with optical excitations. They are relatively inexpensive to set up in a lab, but they have some limitations. Like, it\u0027s hard to do rotations by arbitrary angles. So instead, it likely uses a discrete set of angles, and \u0022random axis\u0022 means one of the few very specific ones randomly selected.\u003C/p\u003E\u003Cp\u003EWhat I describe above is a more general case. It\u0027s possible to make this into an actual experiment, but it\u0027s a more complicated one to cary out. You have to get creative with NMR spectrometer to do measurements in arbitrary bases. But I\u0027ve seen it done. Not sure if anyone has actually carried out this exact experiment, though. On the flip side, it\u0027s much more straight forward conceptually. So I\u0027d start by simulating and understanding what\u0027s going on with this one. And then moving on to ones that are easier to set up in the lab, but harder to understand.\u003C/p\u003E\n\u003Cspan class=\u0022ipsType_reset ipsType_medium ipsType_light\u0022 data-excludequote=\u0022\u0022\u003E\n\u003Cstrong\u003EEdited \u003Ctime datetime=\u00222015-06-28T21:45:24Z\u0022 title=\u002206/28/2015 09:45  PM\u0022 data-short=\u00229 yr\u0022\u003EJune 28, 2015\u003C/time\u003E by K^2\u003C/strong\u003E\n\u003C/span\u003E\n"},{"CreatedByName":"Fuzzy Dunlop","CreatedById":27329,"CreatedDateTime":"2015-06-28T23:43:37Z","Content":"\n\u003Cp\u003EFor anyone looking for a slightly less involved introduction to this topic: \u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003E\n\u003C/p\u003E\u003Cdiv class=\u0022ipsEmbeddedVideo\u0022 contenteditable=\u0022false\u0022\u003E\u003Cdiv\u003E\u003Ciframe width=\u0022480\u0022 height=\u0022270\u0022 src=\u0022https://www.youtube.com/embed/ZuvK-od647c?feature=oembed\u0022 frameborder=\u00220\u0022 allowfullscreen=\u0022true\u0022\u003E\u003C/iframe\u003E\u003C/div\u003E\u003C/div\u003E\n"},{"CreatedByName":"arkie87","CreatedById":103434,"CreatedDateTime":"2015-06-29T03:28:11Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003EYes, it\u0027s just one number. But it\u0027s a different number for every angle \u00C3\u017D\u00C2\u00A6.\u003Cp\u003EYou just generate a list of \u00C3\u017D\u00C2\u00A6 to plot results against, same as a bove. In Matlab, you can just do phi = 0:0.1:2*pi; Likewise, you can generate all thetas in one go as theta = 2*pi*rand(1000,1); That will give you 1,000 random initial orientations. So then your code for computing a list of classical correlations might look something like this:\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ec = zeros(length(phi));\u003Cbr\u003Efor j = 1:length(phi)\u003Cbr\u003E\ty = sign(cos(theta .\u002B phi(j)) .\u002B pi);\u003Cbr\u003E\tc(j) = mean(x .* y);\u003Cbr\u003Eend\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EThis assumes that x, theta, and phi are already computed, of course. The \u002Bpi bit is just there to account for the fact that two particles are exactly opposite in direction.\u003C/p\u003E\u003Cp\u003EJust a shortcut for the odds of it being same or opposite sign. You can do this in Matlab in one ligne.\u003C/p\u003E\u003Cp\u003E\u003C/p\u003E\u003Cdiv\u003E\u003C/div\u003E\u003Cpre class=\u0022ipsCode\u0022\u003Ey = x.*(sign(rand(1,1000).-(cos(phi(i)/2)^2)));\u003C/pre\u003E\u003Cp\u003E\u003C/p\u003E\u003Cp\u003EI\u0027d bet your book describes an actual experiment done with optical excitations. They are relatively inexpensive to set up in a lab, but they have some limitations. Like, it\u0027s hard to do rotations by arbitrary angles. So instead, it likely uses a discrete set of angles, and \u0022random axis\u0022 means one of the few very specific ones randomly selected.\u003C/p\u003E\u003Cp\u003EWhat I describe above is a more general case. It\u0027s possible to make this into an actual experiment, but it\u0027s a more complicated one to cary out. You have to get creative with NMR spectrometer to do measurements in arbitrary bases. But I\u0027ve seen it done. Not sure if anyone has actually carried out this exact experiment, though. On the flip side, it\u0027s much more straight forward conceptually. So I\u0027d start by simulating and understanding what\u0027s going on with this one. And then moving on to ones that are easier to set up in the lab, but harder to understand.\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThanks for the help! Will review later (I read it quickly and it seems to make sense now).\u003C/p\u003E\u003Cp\u003EI would give you rep, but apparently, i\u0027ve given it to you recently already...\u003C/p\u003E\n"},{"CreatedByName":"PB666","CreatedById":107380,"CreatedDateTime":"2015-06-29T11:51:32Z","Content":"\n\u003Cblockquote data-ipsquote=\u0022\u0022 class=\u0022ipsQuote\u0022 data-ipsquote-username=\u0022K^2\u0022 data-cite=\u0022K^2\u0022\u003E\u003Cdiv\u003E\u003Cp\u003E@Steel, it\u0027s very easy to program entangled particles in Matlab if you know QM and a bit of linear algebra. \u003Cimg src=\u0022//kerbal-forum-uploads.s3.us-west-2.amazonaws.com/emoticons/default_k_smiley.gif\u0022 alt=\u0022:)\u0022\u003E\u003C/p\u003E\u003C/div\u003E\u003C/blockquote\u003E\u003Cp\u003EThis follows the basic form of a Monte Carlo analysis with three independent random variables. \u003C/p\u003E\u003Cp\u003ERandom number generator 1 creates the theta of the spin\u003C/p\u003E\u003Cp\u003ERandom number generator 2 creates the theta of observer 1 (this should accurate be composed of an X,Y,Z axis)\u003C/p\u003E\u003Cp\u003ERandom number generator 3 creates the theta of observer 2 (this should accurate be composed of an X,Y,Z axis)\u003C/p\u003E\u003Cp\u003ECalculate the delta vector between observer 1 and 2\u003C/p\u003E\n"}]}